<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 72px;
}
.code-line {
  margin: 0;
  height: 1em;
  counter-increment: line;

  position: absolute;
  padding: 0 0.3em 0.3em 0.3em;
  display: inherit;
  width: 100%;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

.code-text-container {
  position: relative;
  height: 1em;
  padding: 0.3em 0;
}

.cover-indicator {
  display: flex;
  width: 100%;
  position: absolute;
  justify-content: end;
  height: 1em;
  align-items: center;
  padding: 0 0.3em 0.3em 0.3em;
}

.cover-indicator.check-cover::after {
  content: "\2713";
  font-weight: bold;
  background-color: var(--green);
  height: 1em;
}

.cover-indicator.no-cover::after {
  content: "\2716";
  font-weight: bold;
  background-color: var(--red);
  height: 1em;
}

.stat-line-hit {
  max-width: 48px;
  overflow: hidden;
  font-weight: bold;
  margin-right: 4px;
  background-color: var(--green);
  position: relative;
  top: 0.1em;
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","capture.rs"],"content":"use std::collections::{HashMap, HashSet};\nuse std::fs;\nuse std::path::Path;\nuse std::sync::Arc;\n\nuse crate::prompt::{collect_variables, PromptOptions};\nuse mdvault_core::captures::{CaptureRepoError, CaptureRepository, CaptureSpec};\nuse mdvault_core::config::loader::{default_config_path, ConfigLoader};\nuse mdvault_core::config::types::ResolvedConfig;\nuse mdvault_core::frontmatter::{apply_ops, parse, serialize};\nuse mdvault_core::macros::MacroRepository;\nuse mdvault_core::markdown_ast::{MarkdownAstError, MarkdownEditor, SectionMatch};\nuse mdvault_core::scripting::{run_on_update_hook, NoteContext, VaultContext};\nuse mdvault_core::templates::engine::render_string as engine_render_string;\nuse mdvault_core::templates::repository::TemplateRepository;\nuse mdvault_core::types::{TypeRegistry, TypedefRepository};\n\nuse chrono::Local;\nuse regex::Regex;\n\n/// Built-in variables that are automatically provided\nconst BUILTIN_VARS: \u0026[\u0026str] = \u0026[\n    \"date\",\n    \"time\",\n    \"datetime\",\n    \"vault_root\",\n    \"templates_dir\",\n    \"captures_dir\",\n    \"macros_dir\",\n];\n\npub fn run_list(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv capture --list\");\n            eprintln!(\"{e}\");\n            if config.is_none() {\n                eprintln!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    let repo = match CaptureRepository::new(\u0026cfg.captures_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv capture --list\");\n            eprintln!(\"{e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let captures = repo.list_all();\n    if captures.is_empty() {\n        println!(\"(no captures found)\");\n        return;\n    }\n\n    for info in captures {\n        // Try to load the capture to get its variables\n        match repo.get_by_name(\u0026info.logical_name) {\n            Ok(loaded) =\u003e {\n                let user_vars = extract_user_variables(\u0026loaded.spec);\n                if user_vars.is_empty() {\n                    println!(\"{}\", info.logical_name);\n                } else {\n                    let vars_str = user_vars.join(\", \");\n                    println!(\"{}  [{}]\", info.logical_name, vars_str);\n                }\n            }\n            Err(_) =\u003e {\n                // If we can't load it, just show the name\n                println!(\"{}  (error loading)\", info.logical_name);\n            }\n        }\n    }\n    println!(\"-- {} captures --\", captures.len());\n}\n\n/// Extract user-defined variables from a capture spec (excludes built-ins)\nfn extract_user_variables(spec: \u0026CaptureSpec) -\u003e Vec\u003cString\u003e {\n    let re = Regex::new(r\"\\{\\{([a-zA-Z0-9_]+)\\}\\}\").unwrap();\n    let builtin: HashSet\u003c\u0026str\u003e = BUILTIN_VARS.iter().copied().collect();\n\n    let mut vars = HashSet::new();\n\n    // Extract from content (if present)\n    if let Some(content) = \u0026spec.content {\n        for cap in re.captures_iter(content) {\n            let var = cap.get(1).unwrap().as_str();\n            if !builtin.contains(var) {\n                vars.insert(var.to_string());\n            }\n        }\n    }\n\n    // Extract from target file path\n    for cap in re.captures_iter(\u0026spec.target.file) {\n        let var = cap.get(1).unwrap().as_str();\n        if !builtin.contains(var) {\n            vars.insert(var.to_string());\n        }\n    }\n\n    // Extract from section (if present)\n    if let Some(section) = \u0026spec.target.section {\n        for cap in re.captures_iter(section) {\n            let var = cap.get(1).unwrap().as_str();\n            if !builtin.contains(var) {\n                vars.insert(var.to_string());\n            }\n        }\n    }\n\n    let mut sorted: Vec\u003c_\u003e = vars.into_iter().collect();\n    sorted.sort();\n    sorted\n}\n\npub fn run(\n    config: Option\u003c\u0026Path\u003e,\n    profile: Option\u003c\u0026str\u003e,\n    capture_name: \u0026str,\n    vars: \u0026[(String, String)],\n    batch: bool,\n) {\n    // 1. Load config\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv capture\");\n            eprintln!(\"{e}\");\n            if config.is_none() {\n                eprintln!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    // 2. Load capture repository\n    let repo = match CaptureRepository::new(\u0026cfg.captures_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv capture\");\n            eprintln!(\"{e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // 3. Get capture spec\n    let loaded = match repo.get_by_name(capture_name) {\n        Ok(c) =\u003e c,\n        Err(e) =\u003e match e {\n            CaptureRepoError::NotFound(name) =\u003e {\n                eprintln!(\"Capture not found: {name}\");\n                eprintln!(\"Available captures:\");\n                for c in repo.list_all() {\n                    eprintln!(\"  - {}\", c.logical_name);\n                }\n                std::process::exit(1);\n            }\n            other =\u003e {\n                eprintln!(\"Failed to load capture: {other}\");\n                std::process::exit(1);\n            }\n        },\n    };\n\n    // 4. Build render context\n    let base_ctx = build_capture_context(\u0026cfg);\n\n    // Convert provided vars to HashMap\n    let provided_vars: HashMap\u003cString, String\u003e = vars.iter().cloned().collect();\n\n    // Build content string for variable extraction (combine all templated fields)\n    let mut content_for_vars = String::new();\n    if let Some(content) = \u0026loaded.spec.content {\n        content_for_vars.push_str(content);\n    }\n    content_for_vars.push_str(\u0026loaded.spec.target.file);\n    if let Some(section) = \u0026loaded.spec.target.section {\n        content_for_vars.push_str(section);\n    }\n\n    // Collect variables (prompt for missing ones if interactive)\n    let vars_map = loaded.spec.vars.as_ref();\n    let prompt_options = PromptOptions { batch_mode: batch };\n\n    let collected = match collect_variables(\n        vars_map,\n        \u0026content_for_vars,\n        \u0026provided_vars,\n        \u0026base_ctx,\n        \u0026prompt_options,\n    ) {\n        Ok(c) =\u003e c,\n        Err(e) =\u003e {\n            eprintln!(\"Error: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Merge collected variables into context\n    let mut ctx = base_ctx;\n    for (k, v) in collected.values {\n        ctx.insert(k, v);\n    }\n\n    // 5. Render target file path\n    let target_file_raw = render_string(\u0026loaded.spec.target.file, \u0026ctx);\n    let target_file = resolve_target_path(\u0026cfg.vault_root, \u0026target_file_raw);\n\n    // 6. Read existing file or create if missing\n    let existing_content = match fs::read_to_string(\u0026target_file) {\n        Ok(content) =\u003e content,\n        Err(e)\n            if e.kind() == std::io::ErrorKind::NotFound\n                \u0026\u0026 loaded.spec.target.create_if_missing =\u003e\n        {\n            // Create the file with minimal structure\n            let content =\n                create_minimal_note(\u0026ctx, loaded.spec.target.section.as_deref());\n\n            // Ensure parent directory exists\n            if let Some(parent) = target_file.parent() {\n                if let Err(e) = fs::create_dir_all(parent) {\n                    eprintln!(\"Failed to create directory {}: {e}\", parent.display());\n                    std::process::exit(1);\n                }\n            }\n\n            // Write the new file\n            if let Err(e) = fs::write(\u0026target_file, \u0026content) {\n                eprintln!(\"Failed to create target file {}: {e}\", target_file.display());\n                std::process::exit(1);\n            }\n\n            println!(\"Created: {}\", target_file.display());\n            content\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Failed to read target file {}: {e}\", target_file.display());\n            eprintln!(\"Hint: The target file must exist before capturing to it.\");\n            eprintln!(\n                \"      Use 'create_if_missing: true' in the capture spec to auto-create.\"\n            );\n            std::process::exit(1);\n        }\n    };\n\n    // 7. Execute capture (frontmatter + content insertion)\n    let (result_content, section_info) =\n        match execute_capture_operations(\u0026existing_content, \u0026loaded.spec, \u0026ctx) {\n            Ok(r) =\u003e r,\n            Err(e) =\u003e {\n                eprintln!(\"{e}\");\n                std::process::exit(1);\n            }\n        };\n\n    // 8. Write back to file\n    if let Err(e) = fs::write(\u0026target_file, \u0026result_content) {\n        eprintln!(\"Failed to write to {}: {e}\", target_file.display());\n        std::process::exit(1);\n    }\n\n    // 9. Run on_update hook if defined for this note type\n    run_on_update_hook_if_needed(\u0026cfg, \u0026target_file, \u0026result_content);\n\n    println!(\"OK   mdv capture\");\n    println!(\"capture: {}\", capture_name);\n    println!(\"target:  {}\", target_file.display());\n    if let Some((title, level)) = section_info {\n        println!(\"section: {} (level {})\", title, level);\n    }\n    if loaded.spec.frontmatter.is_some() {\n        println!(\"frontmatter: modified\");\n    }\n}\n\n/// Run on_update hook for the target note if its type has one defined.\nfn run_on_update_hook_if_needed(cfg: \u0026ResolvedConfig, target_file: \u0026Path, content: \u0026str) {\n    // Parse frontmatter to get note type\n    let parsed = match parse(content) {\n        Ok(p) =\u003e p,\n        Err(_) =\u003e return, // Can't parse, skip hook\n    };\n\n    // Get note type from frontmatter\n    let note_type = parsed\n        .frontmatter\n        .as_ref()\n        .and_then(|fm| fm.fields.get(\"type\"))\n        .and_then(|v| match v {\n            serde_yaml::Value::String(s) =\u003e Some(s.as_str()),\n            _ =\u003e None,\n        })\n        .unwrap_or(\"none\");\n\n    // Skip if no type or \"none\" type\n    if note_type == \"none\" {\n        return;\n    }\n\n    // Load type definitions\n    let typedef_repo = match TypedefRepository::new(\u0026cfg.typedefs_dir) {\n        Ok(r) =\u003e r,\n        Err(_) =\u003e return, // Can't load types, skip hook\n    };\n\n    let registry = match TypeRegistry::from_repository(\u0026typedef_repo) {\n        Ok(r) =\u003e r,\n        Err(_) =\u003e return,\n    };\n\n    // Get type definition\n    let typedef = match registry.get(note_type) {\n        Some(td) =\u003e td,\n        None =\u003e return, // No definition for this type\n    };\n\n    // Skip if no on_update hook\n    if !typedef.has_on_update_hook {\n        return;\n    }\n\n    // Build note context\n    let frontmatter = parsed\n        .frontmatter\n        .as_ref()\n        .map(|fm| {\n            let mut map = serde_yaml::Mapping::new();\n            for (k, v) in \u0026fm.fields {\n                map.insert(serde_yaml::Value::String(k.clone()), v.clone());\n            }\n            serde_yaml::Value::Mapping(map)\n        })\n        .unwrap_or(serde_yaml::Value::Mapping(serde_yaml::Mapping::new()));\n\n    let note_ctx = NoteContext {\n        path: target_file.to_path_buf(),\n        note_type: note_type.to_string(),\n        frontmatter,\n        content: content.to_string(),\n    };\n\n    // Build vault context (with repositories for vault operations)\n    // Note: We don't need full repositories for the hook - we just need the registry\n    // Use ok() to convert Result to Option and skip if loading fails\n    let capture_repo = CaptureRepository::new(\u0026cfg.captures_dir).ok();\n    let template_repo = TemplateRepository::new(\u0026cfg.templates_dir).ok();\n    let macro_repo = MacroRepository::new(\u0026cfg.macros_dir).ok();\n\n    // If any required repository is missing, skip the hook\n    let (capture_repo, template_repo, macro_repo) =\n        match (capture_repo, template_repo, macro_repo) {\n            (Some(c), Some(t), Some(m)) =\u003e (c, t, m),\n            _ =\u003e return, // Can't create vault context without all repos\n        };\n\n    let vault_ctx = VaultContext::from_arcs(\n        Arc::new(cfg.clone()),\n        Arc::new(template_repo),\n        Arc::new(capture_repo),\n        Arc::new(macro_repo),\n        Arc::new(registry),\n    );\n\n    // Run the hook\n    match run_on_update_hook(\u0026typedef, \u0026note_ctx, vault_ctx) {\n        Ok(result) =\u003e {\n            if result.modified {\n                // Build updated document\n                let mut updated_parsed = parsed;\n\n                if let Some(serde_yaml::Value::Mapping(map)) = result.frontmatter {\n                    let mut fields = HashMap::new();\n                    for (k, v) in map {\n                        if let serde_yaml::Value::String(key) = k {\n                            fields.insert(key, v);\n                        }\n                    }\n                    updated_parsed.frontmatter =\n                        Some(mdvault_core::frontmatter::Frontmatter { fields });\n                }\n\n                if let Some(new_content) = result.content {\n                    updated_parsed.body = new_content;\n                }\n\n                // Write back\n                let final_content = serialize(\u0026updated_parsed);\n                if let Err(e) = fs::write(target_file, \u0026final_content) {\n                    eprintln!(\"Warning: Failed to apply on_update hook changes: {e}\");\n                }\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Warning: on_update hook failed: {e}\");\n        }\n    }\n}\n\n/// Execute capture operations: frontmatter modification and/or content insertion.\n/// Returns the modified content and optional section info (title, level).\nfn execute_capture_operations(\n    existing_content: \u0026str,\n    spec: \u0026CaptureSpec,\n    ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(String, Option\u003c(String, u8)\u003e), String\u003e {\n    // Parse frontmatter from existing content first\n    let mut parsed = parse(existing_content)\n        .map_err(|e| format!(\"Failed to parse frontmatter: {e}\"))?;\n    let mut section_info = None;\n\n    // Apply frontmatter operations if specified\n    if let Some(fm_ops) = \u0026spec.frontmatter {\n        parsed = apply_ops(parsed, fm_ops, ctx)\n            .map_err(|e| format!(\"Failed to apply frontmatter ops: {e}\"))?;\n    }\n\n    // Insert content if specified - operate on body only to preserve frontmatter\n    if let Some(content_template) = \u0026spec.content {\n        let section = spec.target.section.as_ref().ok_or_else(|| {\n            \"Capture has content but no target section specified\".to_string()\n        })?;\n\n        let rendered_content = render_string(content_template, ctx);\n        let section_match = SectionMatch::new(section);\n        let position = spec.target.position.clone().into();\n\n        let result = MarkdownEditor::insert_into_section(\n            \u0026parsed.body,\n            \u0026section_match,\n            \u0026rendered_content,\n            position,\n        )\n        .map_err(|e| match \u0026e {\n            MarkdownAstError::SectionNotFound(s) =\u003e {\n                let headings = MarkdownEditor::find_headings(\u0026parsed.body);\n                let mut msg = format!(\"Section not found: '{s}'\\nAvailable sections:\\n\");\n                for h in headings {\n                    msg.push_str(\u0026format!(\"  - {} (level {})\\n\", h.title, h.level));\n                }\n                msg\n            }\n            MarkdownAstError::EmptyDocument =\u003e \"Target file is empty\".to_string(),\n            MarkdownAstError::RenderError(msg) =\u003e format!(\"Markdown render error: {msg}\"),\n        })?;\n\n        section_info = Some((result.matched_heading.title, result.matched_heading.level));\n        parsed.body = result.content;\n    }\n\n    // Serialize the document (frontmatter + body)\n    let final_content = serialize(\u0026parsed);\n    Ok((final_content, section_info))\n}\n\nfn build_capture_context(cfg: \u0026ResolvedConfig) -\u003e HashMap\u003cString, String\u003e {\n    let mut ctx = HashMap::new();\n\n    // Date/time\n    let now = Local::now();\n    ctx.insert(\"date\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"time\".into(), now.format(\"%H:%M\").to_string());\n    ctx.insert(\"datetime\".into(), now.to_rfc3339());\n\n    // Config paths\n    ctx.insert(\"vault_root\".into(), cfg.vault_root.to_string_lossy().to_string());\n    ctx.insert(\"templates_dir\".into(), cfg.templates_dir.to_string_lossy().to_string());\n    ctx.insert(\"captures_dir\".into(), cfg.captures_dir.to_string_lossy().to_string());\n    ctx.insert(\"macros_dir\".into(), cfg.macros_dir.to_string_lossy().to_string());\n\n    ctx\n}\n\nfn render_string(template: \u0026str, ctx: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    // Use the engine's render_string which supports date math expressions\n    engine_render_string(template, ctx).unwrap_or_else(|_| template.to_string())\n}\n\nfn resolve_target_path(vault_root: \u0026Path, target: \u0026str) -\u003e std::path::PathBuf {\n    let path = std::path::Path::new(target);\n    if path.is_absolute() {\n        path.to_path_buf()\n    } else {\n        vault_root.join(path)\n    }\n}\n\n/// Create a minimal note structure for auto-created files.\nfn create_minimal_note(vars: \u0026HashMap\u003cString, String\u003e, section: Option\u003c\u0026str\u003e) -\u003e String {\n    let date = vars.get(\"date\").map(|s| s.as_str()).unwrap_or(\"unknown\");\n    let title = vars.get(\"title\").map(|s| s.as_str()).unwrap_or(date);\n\n    let mut content = format!(\"---\\ntype: daily\\ndate: {}\\n---\\n\\n# {}\\n\", date, title);\n\n    // Add the target section if specified\n    if let Some(section_name) = section {\n        content.push_str(\u0026format!(\"\\n## {}\\n\", section_name));\n    }\n\n    content\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":7}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":9}},{"line":65,"address":[],"length":0,"stats":{"Line":7}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":83,"address":[],"length":0,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":18}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":13}},{"line":91,"address":[],"length":0,"stats":{"Line":16}},{"line":92,"address":[],"length":0,"stats":{"Line":11}},{"line":93,"address":[],"length":0,"stats":{"Line":9}},{"line":99,"address":[],"length":0,"stats":{"Line":9}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":9}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":15}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":14}},{"line":129,"address":[],"length":0,"stats":{"Line":42}},{"line":130,"address":[],"length":0,"stats":{"Line":28}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":28}},{"line":143,"address":[],"length":0,"stats":{"Line":28}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":41}},{"line":153,"address":[],"length":0,"stats":{"Line":26}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":39}},{"line":174,"address":[],"length":0,"stats":{"Line":78}},{"line":177,"address":[],"length":0,"stats":{"Line":26}},{"line":178,"address":[],"length":0,"stats":{"Line":29}},{"line":179,"address":[],"length":0,"stats":{"Line":16}},{"line":181,"address":[],"length":0,"stats":{"Line":39}},{"line":182,"address":[],"length":0,"stats":{"Line":29}},{"line":183,"address":[],"length":0,"stats":{"Line":16}},{"line":187,"address":[],"length":0,"stats":{"Line":39}},{"line":188,"address":[],"length":0,"stats":{"Line":26}},{"line":190,"address":[],"length":0,"stats":{"Line":39}},{"line":191,"address":[],"length":0,"stats":{"Line":26}},{"line":192,"address":[],"length":0,"stats":{"Line":26}},{"line":193,"address":[],"length":0,"stats":{"Line":26}},{"line":194,"address":[],"length":0,"stats":{"Line":13}},{"line":195,"address":[],"length":0,"stats":{"Line":13}},{"line":197,"address":[],"length":0,"stats":{"Line":26}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":26}},{"line":206,"address":[],"length":0,"stats":{"Line":53}},{"line":207,"address":[],"length":0,"stats":{"Line":30}},{"line":211,"address":[],"length":0,"stats":{"Line":52}},{"line":212,"address":[],"length":0,"stats":{"Line":52}},{"line":215,"address":[],"length":0,"stats":{"Line":38}},{"line":216,"address":[],"length":0,"stats":{"Line":24}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":3}},{"line":244,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":22}},{"line":254,"address":[],"length":0,"stats":{"Line":36}},{"line":255,"address":[],"length":0,"stats":{"Line":22}},{"line":256,"address":[],"length":0,"stats":{"Line":1}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":22}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":44}},{"line":271,"address":[],"length":0,"stats":{"Line":22}},{"line":272,"address":[],"length":0,"stats":{"Line":22}},{"line":273,"address":[],"length":0,"stats":{"Line":33}},{"line":274,"address":[],"length":0,"stats":{"Line":29}},{"line":275,"address":[],"length":0,"stats":{"Line":6}},{"line":277,"address":[],"length":0,"stats":{"Line":28}},{"line":278,"address":[],"length":0,"stats":{"Line":6}},{"line":283,"address":[],"length":0,"stats":{"Line":11}},{"line":285,"address":[],"length":0,"stats":{"Line":22}},{"line":286,"address":[],"length":0,"stats":{"Line":22}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":22}},{"line":292,"address":[],"length":0,"stats":{"Line":11}},{"line":294,"address":[],"length":0,"stats":{"Line":29}},{"line":295,"address":[],"length":0,"stats":{"Line":11}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":11}},{"line":303,"address":[],"length":0,"stats":{"Line":11}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":12}},{"line":413,"address":[],"length":0,"stats":{"Line":36}},{"line":414,"address":[],"length":0,"stats":{"Line":12}},{"line":415,"address":[],"length":0,"stats":{"Line":24}},{"line":418,"address":[],"length":0,"stats":{"Line":18}},{"line":419,"address":[],"length":0,"stats":{"Line":30}},{"line":420,"address":[],"length":0,"stats":{"Line":6}},{"line":424,"address":[],"length":0,"stats":{"Line":19}},{"line":425,"address":[],"length":0,"stats":{"Line":28}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":28}},{"line":430,"address":[],"length":0,"stats":{"Line":21}},{"line":431,"address":[],"length":0,"stats":{"Line":28}},{"line":434,"address":[],"length":0,"stats":{"Line":7}},{"line":435,"address":[],"length":0,"stats":{"Line":7}},{"line":436,"address":[],"length":0,"stats":{"Line":7}},{"line":437,"address":[],"length":0,"stats":{"Line":7}},{"line":439,"address":[],"length":0,"stats":{"Line":8}},{"line":440,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":3}},{"line":442,"address":[],"length":0,"stats":{"Line":3}},{"line":443,"address":[],"length":0,"stats":{"Line":7}},{"line":444,"address":[],"length":0,"stats":{"Line":6}},{"line":446,"address":[],"length":0,"stats":{"Line":1}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":12}},{"line":453,"address":[],"length":0,"stats":{"Line":12}},{"line":457,"address":[],"length":0,"stats":{"Line":33}},{"line":458,"address":[],"length":0,"stats":{"Line":11}},{"line":461,"address":[],"length":0,"stats":{"Line":13}},{"line":462,"address":[],"length":0,"stats":{"Line":26}},{"line":465,"address":[],"length":0,"stats":{"Line":26}},{"line":466,"address":[],"length":0,"stats":{"Line":91}},{"line":467,"address":[],"length":0,"stats":{"Line":91}},{"line":468,"address":[],"length":0,"stats":{"Line":78}},{"line":471,"address":[],"length":0,"stats":{"Line":78}},{"line":472,"address":[],"length":0,"stats":{"Line":78}},{"line":473,"address":[],"length":0,"stats":{"Line":78}},{"line":474,"address":[],"length":0,"stats":{"Line":78}},{"line":476,"address":[],"length":0,"stats":{"Line":13}},{"line":479,"address":[],"length":0,"stats":{"Line":20}},{"line":481,"address":[],"length":0,"stats":{"Line":80}},{"line":484,"address":[],"length":0,"stats":{"Line":13}},{"line":485,"address":[],"length":0,"stats":{"Line":39}},{"line":486,"address":[],"length":0,"stats":{"Line":26}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":39}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}}],"covered":144,"coverable":261},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","doctor.rs"],"content":"use mdvault_core::config::loader::{default_config_path, ConfigLoader};\nuse std::path::Path;\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e) {\n    match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e {\n            println!(\"OK   mdv doctor\");\n            println!(\n                \"path: {}\",\n                config\n                    .map(|p| p.display().to_string())\n                    .unwrap_or_else(|| default_config_path().display().to_string())\n            );\n            println!(\"profile: {}\", rc.active_profile);\n            println!(\"vault_root: {}\", rc.vault_root.display());\n            println!(\"templates_dir: {}\", rc.templates_dir.display());\n            println!(\"captures_dir: {}\", rc.captures_dir.display());\n            println!(\"macros_dir: {}\", rc.macros_dir.display());\n            println!(\"security.allow_shell: {}\", rc.security.allow_shell);\n            println!(\"security.allow_http:  {}\", rc.security.allow_http);\n        }\n        Err(e) =\u003e {\n            println!(\"FAIL mdv doctor\");\n            println!(\"{e}\");\n            if config.is_none() {\n                println!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":4}},{"line":5,"address":[],"length":0,"stats":{"Line":8}},{"line":6,"address":[],"length":0,"stats":{"Line":3}},{"line":7,"address":[],"length":0,"stats":{"Line":6}},{"line":8,"address":[],"length":0,"stats":{"Line":3}},{"line":9,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":11,"address":[],"length":0,"stats":{"Line":7}},{"line":12,"address":[],"length":0,"stats":{"Line":5}},{"line":14,"address":[],"length":0,"stats":{"Line":6}},{"line":15,"address":[],"length":0,"stats":{"Line":9}},{"line":16,"address":[],"length":0,"stats":{"Line":9}},{"line":17,"address":[],"length":0,"stats":{"Line":9}},{"line":18,"address":[],"length":0,"stats":{"Line":9}},{"line":19,"address":[],"length":0,"stats":{"Line":6}},{"line":20,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":1}}],"covered":22,"coverable":22},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","links.rs"],"content":"//! Links command implementation.\n\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::IndexDb;\n\nuse super::output::{print_links_json, print_links_quiet, print_links_table, LinkOutput};\nuse crate::{LinksArgs, OutputFormat};\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: LinksArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Normalize the note path (strip leading ./)\n    let note_path = normalize_path(\u0026args.note);\n\n    // Look up the note\n    let note = match db.get_note_by_path(Path::new(\u0026note_path)) {\n        Ok(Some(n)) =\u003e n,\n        Ok(None) =\u003e {\n            eprintln!(\"Note not found in index: {}\", note_path);\n            eprintln!(\"Hint: Check the path or run 'mdv reindex'.\");\n            std::process::exit(1);\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Error looking up note: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    let note_id = note.id.expect(\"indexed note should have ID\");\n\n    // Determine what to show (both shown by default)\n    let show_backlinks = args.backlinks || !args.outlinks;\n    let show_outlinks = args.outlinks || !args.backlinks;\n\n    // Resolve output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Get and display backlinks\n    if show_backlinks {\n        match db.get_backlinks(note_id) {\n            Ok(links) =\u003e {\n                let outputs: Vec\u003cLinkOutput\u003e = links\n                    .iter()\n                    .map(|l| {\n                        // Look up source note path\n                        let source_path = db\n                            .get_note_by_id(l.source_id)\n                            .ok()\n                            .flatten()\n                            .map(|n| n.path.to_string_lossy().to_string());\n                        LinkOutput::from_link(l, source_path.as_deref())\n                    })\n                    .collect();\n\n                if show_outlinks \u0026\u0026 !matches!(format, OutputFormat::Json) {\n                    println!(\"=== Backlinks (notes linking to {}) ===\", note_path);\n                    println!();\n                }\n                match format {\n                    OutputFormat::Table =\u003e print_links_table(\u0026outputs, \"backlinks\"),\n                    OutputFormat::Json =\u003e print_links_json(\u0026outputs),\n                    OutputFormat::Quiet =\u003e print_links_quiet(\u0026outputs, true),\n                }\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Error getting backlinks: {}\", e);\n                std::process::exit(1);\n            }\n        }\n    }\n\n    // Get and display outgoing links\n    if show_outlinks {\n        match db.get_outgoing_links(note_id) {\n            Ok(links) =\u003e {\n                let outputs: Vec\u003cLinkOutput\u003e = links\n                    .iter()\n                    .map(|l| LinkOutput::from_link(l, Some(\u0026note_path)))\n                    .collect();\n\n                if show_backlinks \u0026\u0026 !matches!(format, OutputFormat::Json) {\n                    println!();\n                    println!(\"=== Outgoing links (notes {} links to) ===\", note_path);\n                    println!();\n                }\n                match format {\n                    OutputFormat::Table =\u003e print_links_table(\u0026outputs, \"outgoing links\"),\n                    OutputFormat::Json =\u003e print_links_json(\u0026outputs),\n                    OutputFormat::Quiet =\u003e print_links_quiet(\u0026outputs, false),\n                }\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Error getting outgoing links: {}\", e);\n                std::process::exit(1);\n            }\n        }\n    }\n}\n\n/// Normalize note path by removing leading ./.\nfn normalize_path(path: \u0026str) -\u003e String {\n    path.strip_prefix(\"./\").unwrap_or(path).to_string()\n}\n\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":71},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","list.rs"],"content":"//! List command implementation.\n\nuse std::path::Path;\n\nuse chrono::{DateTime, NaiveDate, NaiveTime, Utc};\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{IndexDb, NoteQuery};\nuse mdvault_core::vars::try_evaluate_date_expr;\n\nuse super::output::{print_notes_json, print_notes_quiet, print_notes_table};\nuse crate::{ListArgs, OutputFormat};\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: ListArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Build query\n    let query = NoteQuery {\n        note_type: args.r#type.map(|t| t.into()),\n        path_prefix: None,\n        modified_after: parse_date_arg(\u0026args.modified_after, \"modified-after\"),\n        modified_before: parse_date_arg(\u0026args.modified_before, \"modified-before\"),\n        limit: args.limit,\n        offset: None,\n    };\n\n    // Execute query\n    let notes = match db.query_notes(\u0026query) {\n        Ok(notes) =\u003e notes,\n        Err(e) =\u003e {\n            eprintln!(\"Error querying notes: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Determine output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Output results\n    match format {\n        OutputFormat::Table =\u003e print_notes_table(\u0026notes),\n        OutputFormat::Json =\u003e print_notes_json(\u0026notes),\n        OutputFormat::Quiet =\u003e print_notes_quiet(\u0026notes),\n    }\n}\n\n/// Parse a date argument, supporting both YYYY-MM-DD and date math expressions.\nfn parse_date_arg(arg: \u0026Option\u003cString\u003e, name: \u0026str) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n    let s = arg.as_ref()?;\n\n    // Try date math expression first (e.g., \"today - 7d\")\n    if let Some(result) = try_evaluate_date_expr(s) {\n        if let Ok(date) = NaiveDate::parse_from_str(\u0026result, \"%Y-%m-%d\") {\n            let datetime = date.and_time(NaiveTime::from_hms_opt(0, 0, 0).unwrap());\n            return Some(DateTime::from_naive_utc_and_offset(datetime, Utc));\n        }\n    }\n\n    // Try ISO date (YYYY-MM-DD)\n    if let Ok(date) = NaiveDate::parse_from_str(s, \"%Y-%m-%d\") {\n        let datetime = date.and_time(NaiveTime::from_hms_opt(0, 0, 0).unwrap());\n        return Some(DateTime::from_naive_utc_and_offset(datetime, Utc));\n    }\n\n    // Try ISO datetime (YYYY-MM-DDTHH:MM:SS)\n    if let Ok(dt) = DateTime::parse_from_rfc3339(s) {\n        return Some(dt.with_timezone(\u0026Utc));\n    }\n\n    eprintln!(\n        \"Warning: Could not parse --{} '{}'. Expected YYYY-MM-DD or date expression.\",\n        name, s\n    );\n    None\n}\n\n/// Resolve the output format from flags.\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","list_templates.rs"],"content":"use mdvault_core::config::loader::{default_config_path, ConfigLoader};\nuse mdvault_core::templates::discovery::discover_templates;\nuse std::path::Path;\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e) {\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            println!(\"FAIL mdv list-templates\");\n            println!(\"{e}\");\n            if config.is_none() {\n                println!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    match discover_templates(\u0026rc.templates_dir) {\n        Ok(list) =\u003e {\n            if list.is_empty() {\n                println!(\"(no templates found)\");\n                return;\n            }\n            for t in \u0026list {\n                println!(\"{}\", t.logical_name);\n            }\n            println!(\"-- {} templates --\", list.len());\n        }\n        Err(e) =\u003e {\n            println!(\"FAIL mdv list-templates\");\n            println!(\"{e}\");\n            std::process::exit(1);\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":1}},{"line":6,"address":[],"length":0,"stats":{"Line":3}},{"line":7,"address":[],"length":0,"stats":{"Line":2}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":7}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":9,"coverable":21},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","macro_cmd.rs"],"content":"//! Macro command implementation.\n\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse std::process::Command;\n\nuse crate::prompt::{collect_variables, PromptOptions};\nuse mdvault_core::captures::CaptureRepository;\nuse mdvault_core::config::loader::{default_config_path, ConfigLoader};\nuse mdvault_core::config::types::ResolvedConfig;\nuse mdvault_core::frontmatter::{apply_ops, parse, serialize};\nuse mdvault_core::macros::{\n    get_shell_commands, requires_trust, run_macro, CaptureStep, MacroRepoError,\n    MacroRepository, MacroRunError, MacroSpec, RunContext, RunOptions, ShellStep,\n    StepExecutor, StepResult, TemplateStep,\n};\nuse mdvault_core::markdown_ast::{MarkdownEditor, SectionMatch};\nuse mdvault_core::templates::discovery::TemplateInfo;\nuse mdvault_core::templates::engine::{\n    build_minimal_context, render_string, resolve_template_output_path,\n};\nuse mdvault_core::templates::repository::TemplateRepository;\n\nuse chrono::Local;\n\n/// List available macros.\npub fn run_list(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv macro --list\");\n            eprintln!(\"{e}\");\n            if config.is_none() {\n                eprintln!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    let repo = match MacroRepository::new(\u0026cfg.macros_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv macro --list\");\n            eprintln!(\"{e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let macros = repo.list_all();\n    if macros.is_empty() {\n        println!(\"(no macros found)\");\n        return;\n    }\n\n    for info in macros {\n        match repo.get_by_name(\u0026info.logical_name) {\n            Ok(loaded) =\u003e {\n                let trust_marker =\n                    if requires_trust(\u0026loaded.spec) { \" [requires --trust]\" } else { \"\" };\n                let desc = if loaded.spec.description.is_empty() {\n                    String::new()\n                } else {\n                    format!(\" - {}\", loaded.spec.description)\n                };\n                println!(\n                    \"{}  ({} steps){trust_marker}{desc}\",\n                    info.logical_name,\n                    loaded.spec.steps.len()\n                );\n            }\n            Err(_) =\u003e {\n                println!(\"{}  (error loading)\", info.logical_name);\n            }\n        }\n    }\n    println!(\"-- {} macros --\", macros.len());\n}\n\n/// Run a macro.\npub fn run(\n    config: Option\u003c\u0026Path\u003e,\n    profile: Option\u003c\u0026str\u003e,\n    macro_name: \u0026str,\n    vars: \u0026[(String, String)],\n    batch: bool,\n    trust: bool,\n) {\n    // 1. Load config\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv macro\");\n            eprintln!(\"{e}\");\n            if config.is_none() {\n                eprintln!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    // 2. Load macro repository\n    let repo = match MacroRepository::new(\u0026cfg.macros_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv macro\");\n            eprintln!(\"{e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // 3. Get macro spec\n    let loaded = match repo.get_by_name(macro_name) {\n        Ok(m) =\u003e m,\n        Err(e) =\u003e match e {\n            MacroRepoError::NotFound(name) =\u003e {\n                eprintln!(\"Macro not found: {name}\");\n                eprintln!(\"Available macros:\");\n                for m in repo.list_all() {\n                    eprintln!(\"  - {}\", m.logical_name);\n                }\n                std::process::exit(1);\n            }\n            other =\u003e {\n                eprintln!(\"Failed to load macro: {other}\");\n                std::process::exit(1);\n            }\n        },\n    };\n\n    // 4. Check trust requirements\n    if requires_trust(\u0026loaded.spec) \u0026\u0026 !trust {\n        eprintln!(\n            \"Error: This macro contains shell commands that require the --trust flag.\"\n        );\n        eprintln!(\"Shell commands:\");\n        for cmd in get_shell_commands(\u0026loaded.spec) {\n            eprintln!(\"  $ {cmd}\");\n        }\n        eprintln!(\"\\nRun with --trust to allow shell execution.\");\n        std::process::exit(1);\n    }\n\n    // 5. Build base context\n    let base_ctx = build_macro_context(\u0026cfg);\n\n    // Convert provided vars to HashMap\n    let provided_vars: HashMap\u003cString, String\u003e = vars.iter().cloned().collect();\n\n    // Build content string for variable extraction from macro vars\n    let content_for_vars = build_vars_content(\u0026loaded.spec);\n\n    // Collect variables (prompt for missing ones if interactive)\n    let vars_map = loaded.spec.vars.as_ref();\n    let prompt_options = PromptOptions { batch_mode: batch };\n\n    let collected = match collect_variables(\n        vars_map,\n        \u0026content_for_vars,\n        \u0026provided_vars,\n        \u0026base_ctx,\n        \u0026prompt_options,\n    ) {\n        Ok(c) =\u003e c,\n        Err(e) =\u003e {\n            eprintln!(\"Error: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Merge collected variables into context\n    let mut ctx_vars = base_ctx;\n    for (k, v) in collected.values {\n        ctx_vars.insert(k, v);\n    }\n\n    // 6. Create executor with loaded repositories\n    let template_repo = match TemplateRepository::new(\u0026cfg.templates_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load templates: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let capture_repo = match CaptureRepository::new(\u0026cfg.captures_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load captures: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let executor = CliStepExecutor { config: cfg.clone(), template_repo, capture_repo };\n\n    // 7. Create run context and options\n    let run_options = RunOptions {\n        trust,\n        allow_shell: cfg.security.allow_shell || trust,\n        dry_run: false,\n    };\n\n    let run_ctx = RunContext::new(ctx_vars, run_options);\n\n    // 8. Run the macro\n    let result = run_macro(\u0026loaded, \u0026executor, run_ctx);\n\n    // 9. Print results\n    if result.success {\n        println!(\"OK   mdv macro\");\n        println!(\"macro: {}\", macro_name);\n        println!(\"steps: {} completed\", result.step_results.len());\n        for (i, step_result) in result.step_results.iter().enumerate() {\n            let status = if step_result.success { \"OK\" } else { \"FAIL\" };\n            println!(\"  [{status}] Step {}: {}\", i + 1, step_result.message);\n        }\n    } else {\n        eprintln!(\"FAIL mdv macro\");\n        eprintln!(\"macro: {}\", macro_name);\n        for (i, step_result) in result.step_results.iter().enumerate() {\n            let status = if step_result.success { \"OK\" } else { \"FAIL\" };\n            eprintln!(\"  [{status}] Step {}: {}\", i + 1, step_result.message);\n        }\n        std::process::exit(1);\n    }\n}\n\n/// Build content string for variable extraction from macro spec.\nfn build_vars_content(spec: \u0026MacroSpec) -\u003e String {\n    let mut content = String::new();\n\n    // Add macro-level vars\n    if let Some(vars) = \u0026spec.vars {\n        for (name, spec) in vars {\n            content.push_str(\u0026format!(\"{{{{{name}}}}}\"));\n            if let Some(default) = spec.default() {\n                content.push_str(default);\n            }\n        }\n    }\n\n    // Add vars from step overrides\n    for step in \u0026spec.steps {\n        match step {\n            mdvault_core::macros::MacroStep::Template(t) =\u003e {\n                for v in t.vars_with.values() {\n                    content.push_str(v);\n                }\n                if let Some(output) = \u0026t.output {\n                    content.push_str(output);\n                }\n            }\n            mdvault_core::macros::MacroStep::Capture(c) =\u003e {\n                for v in c.vars_with.values() {\n                    content.push_str(v);\n                }\n            }\n            mdvault_core::macros::MacroStep::Shell(s) =\u003e {\n                content.push_str(\u0026s.shell);\n            }\n        }\n    }\n\n    content\n}\n\nfn build_macro_context(cfg: \u0026ResolvedConfig) -\u003e HashMap\u003cString, String\u003e {\n    let mut ctx = HashMap::new();\n\n    // Date/time\n    let now = Local::now();\n    ctx.insert(\"date\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"time\".into(), now.format(\"%H:%M\").to_string());\n    ctx.insert(\"datetime\".into(), now.to_rfc3339());\n    ctx.insert(\"today\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"now\".into(), now.to_rfc3339());\n\n    // Config paths\n    ctx.insert(\"vault_root\".into(), cfg.vault_root.to_string_lossy().to_string());\n    ctx.insert(\"templates_dir\".into(), cfg.templates_dir.to_string_lossy().to_string());\n    ctx.insert(\"captures_dir\".into(), cfg.captures_dir.to_string_lossy().to_string());\n    ctx.insert(\"macros_dir\".into(), cfg.macros_dir.to_string_lossy().to_string());\n\n    ctx\n}\n\n/// CLI step executor that uses template and capture repositories.\nstruct CliStepExecutor {\n    config: ResolvedConfig,\n    template_repo: TemplateRepository,\n    capture_repo: CaptureRepository,\n}\n\nimpl StepExecutor for CliStepExecutor {\n    fn execute_template(\n        \u0026self,\n        step: \u0026TemplateStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        let step_vars = ctx.with_step_vars(\u0026step.vars_with);\n\n        // Load template\n        let loaded = self\n            .template_repo\n            .get_by_name(\u0026step.template)\n            .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n        // Build template info\n        let info = TemplateInfo {\n            logical_name: loaded.logical_name.clone(),\n            path: loaded.path.clone(),\n        };\n\n        // Resolve output path\n        let output_path = if let Some(ref output) = step.output {\n            let rendered = render_string(output, \u0026step_vars)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n            self.config.vault_root.join(\u0026rendered)\n        } else {\n            let minimal_ctx = build_minimal_context(\u0026self.config, \u0026info);\n            let mut merged_ctx = minimal_ctx;\n            for (k, v) in \u0026step_vars {\n                merged_ctx.insert(k.clone(), v.clone());\n            }\n            resolve_template_output_path(\u0026loaded, \u0026self.config, \u0026merged_ctx)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?\n                .ok_or_else(|| {\n                    MacroRunError::TemplateError(\n                        \"Template has no output path and none specified in macro\"\n                            .to_string(),\n                    )\n                })?\n        };\n\n        // Check if file exists\n        if output_path.exists() {\n            return Err(MacroRunError::TemplateError(format!(\n                \"File already exists: {}\",\n                output_path.display()\n            )));\n        }\n\n        // Render template\n        let rendered = render_string(\u0026loaded.body, \u0026step_vars)\n            .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n        // Create parent directories\n        if let Some(parent) = output_path.parent() {\n            fs::create_dir_all(parent)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n        }\n\n        // Write file\n        fs::write(\u0026output_path, \u0026rendered)\n            .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n        Ok(StepResult {\n            step_index: 0, // Will be set by runner\n            success: true,\n            message: format!(\"Created {}\", output_path.display()),\n            output_path: Some(output_path),\n        })\n    }\n\n    fn execute_capture(\n        \u0026self,\n        step: \u0026CaptureStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        let step_vars = ctx.with_step_vars(\u0026step.vars_with);\n\n        // Load capture\n        let loaded = self\n            .capture_repo\n            .get_by_name(\u0026step.capture)\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n        // Render target file path\n        let target_file_raw = render_string(\u0026loaded.spec.target.file, \u0026step_vars)\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n        let target_file = if Path::new(\u0026target_file_raw).is_absolute() {\n            PathBuf::from(\u0026target_file_raw)\n        } else {\n            self.config.vault_root.join(\u0026target_file_raw)\n        };\n\n        // Read existing file\n        let existing_content = fs::read_to_string(\u0026target_file).map_err(|e| {\n            MacroRunError::CaptureError(format!(\n                \"Failed to read {}: {e}\",\n                target_file.display()\n            ))\n        })?;\n\n        // Parse frontmatter\n        let mut parsed = parse(\u0026existing_content)\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n        // Apply frontmatter operations\n        if let Some(fm_ops) = \u0026loaded.spec.frontmatter {\n            parsed = apply_ops(parsed, fm_ops, \u0026step_vars)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n        }\n\n        // Insert content if specified\n        if let Some(content_template) = \u0026loaded.spec.content {\n            let section = loaded.spec.target.section.as_ref().ok_or_else(|| {\n                MacroRunError::CaptureError(\n                    \"Capture has content but no target section\".to_string(),\n                )\n            })?;\n\n            let rendered_content = render_string(content_template, \u0026step_vars)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n            let section_match = SectionMatch::new(section);\n            let position = loaded.spec.target.position.clone().into();\n\n            let result = MarkdownEditor::insert_into_section(\n                \u0026parsed.body,\n                \u0026section_match,\n                \u0026rendered_content,\n                position,\n            )\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n            parsed.body = result.content;\n        }\n\n        // Serialize and write\n        let final_content = serialize(\u0026parsed);\n        fs::write(\u0026target_file, \u0026final_content)\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n        Ok(StepResult {\n            step_index: 0,\n            success: true,\n            message: format!(\"Updated {}\", target_file.display()),\n            output_path: Some(target_file),\n        })\n    }\n\n    fn execute_shell(\n        \u0026self,\n        step: \u0026ShellStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        let rendered_cmd = render_string(\u0026step.shell, \u0026ctx.vars)\n            .map_err(|e| MacroRunError::ShellError(e.to_string()))?;\n\n        // Execute the command\n        let output = Command::new(\"sh\")\n            .arg(\"-c\")\n            .arg(\u0026rendered_cmd)\n            .current_dir(\u0026self.config.vault_root)\n            .output()\n            .map_err(|e| MacroRunError::ShellError(e.to_string()))?;\n\n        if output.status.success() {\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Executed: {rendered_cmd}\"),\n                output_path: None,\n            })\n        } else {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            Err(MacroRunError::ShellError(format!(\n                \"Command failed: {rendered_cmd}\\n{stderr}\"\n            )))\n        }\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":10}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":60,"address":[],"length":0,"stats":{"Line":12}},{"line":61,"address":[],"length":0,"stats":{"Line":12}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":8}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":8}},{"line":81,"address":[],"length":0,"stats":{"Line":7}},{"line":90,"address":[],"length":0,"stats":{"Line":21}},{"line":91,"address":[],"length":0,"stats":{"Line":14}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":14}},{"line":104,"address":[],"length":0,"stats":{"Line":14}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":20}},{"line":114,"address":[],"length":0,"stats":{"Line":12}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":13}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":15}},{"line":148,"address":[],"length":0,"stats":{"Line":30}},{"line":151,"address":[],"length":0,"stats":{"Line":15}},{"line":154,"address":[],"length":0,"stats":{"Line":15}},{"line":155,"address":[],"length":0,"stats":{"Line":10}},{"line":157,"address":[],"length":0,"stats":{"Line":15}},{"line":158,"address":[],"length":0,"stats":{"Line":10}},{"line":159,"address":[],"length":0,"stats":{"Line":10}},{"line":160,"address":[],"length":0,"stats":{"Line":10}},{"line":161,"address":[],"length":0,"stats":{"Line":5}},{"line":162,"address":[],"length":0,"stats":{"Line":5}},{"line":164,"address":[],"length":0,"stats":{"Line":10}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":10}},{"line":173,"address":[],"length":0,"stats":{"Line":29}},{"line":174,"address":[],"length":0,"stats":{"Line":18}},{"line":178,"address":[],"length":0,"stats":{"Line":10}},{"line":179,"address":[],"length":0,"stats":{"Line":10}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":10}},{"line":187,"address":[],"length":0,"stats":{"Line":10}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":20}},{"line":199,"address":[],"length":0,"stats":{"Line":10}},{"line":203,"address":[],"length":0,"stats":{"Line":20}},{"line":206,"address":[],"length":0,"stats":{"Line":25}},{"line":209,"address":[],"length":0,"stats":{"Line":5}},{"line":210,"address":[],"length":0,"stats":{"Line":10}},{"line":211,"address":[],"length":0,"stats":{"Line":10}},{"line":212,"address":[],"length":0,"stats":{"Line":20}},{"line":213,"address":[],"length":0,"stats":{"Line":22}},{"line":214,"address":[],"length":0,"stats":{"Line":18}},{"line":215,"address":[],"length":0,"stats":{"Line":18}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":5}},{"line":230,"address":[],"length":0,"stats":{"Line":10}},{"line":233,"address":[],"length":0,"stats":{"Line":10}},{"line":234,"address":[],"length":0,"stats":{"Line":23}},{"line":235,"address":[],"length":0,"stats":{"Line":18}},{"line":236,"address":[],"length":0,"stats":{"Line":8}},{"line":237,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":17}},{"line":244,"address":[],"length":0,"stats":{"Line":6}},{"line":245,"address":[],"length":0,"stats":{"Line":4}},{"line":246,"address":[],"length":0,"stats":{"Line":10}},{"line":247,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":5}},{"line":267,"address":[],"length":0,"stats":{"Line":5}},{"line":268,"address":[],"length":0,"stats":{"Line":10}},{"line":271,"address":[],"length":0,"stats":{"Line":10}},{"line":272,"address":[],"length":0,"stats":{"Line":35}},{"line":273,"address":[],"length":0,"stats":{"Line":35}},{"line":274,"address":[],"length":0,"stats":{"Line":30}},{"line":275,"address":[],"length":0,"stats":{"Line":35}},{"line":276,"address":[],"length":0,"stats":{"Line":30}},{"line":279,"address":[],"length":0,"stats":{"Line":30}},{"line":280,"address":[],"length":0,"stats":{"Line":30}},{"line":281,"address":[],"length":0,"stats":{"Line":30}},{"line":282,"address":[],"length":0,"stats":{"Line":30}},{"line":284,"address":[],"length":0,"stats":{"Line":5}},{"line":295,"address":[],"length":0,"stats":{"Line":4}},{"line":300,"address":[],"length":0,"stats":{"Line":16}},{"line":303,"address":[],"length":0,"stats":{"Line":8}},{"line":304,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":8}},{"line":306,"address":[],"length":0,"stats":{"Line":4}},{"line":310,"address":[],"length":0,"stats":{"Line":12}},{"line":311,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":8}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":16}},{"line":321,"address":[],"length":0,"stats":{"Line":8}},{"line":322,"address":[],"length":0,"stats":{"Line":172}},{"line":323,"address":[],"length":0,"stats":{"Line":210}},{"line":325,"address":[],"length":0,"stats":{"Line":16}},{"line":326,"address":[],"length":0,"stats":{"Line":4}},{"line":327,"address":[],"length":0,"stats":{"Line":4}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":4}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":16}},{"line":345,"address":[],"length":0,"stats":{"Line":4}},{"line":348,"address":[],"length":0,"stats":{"Line":8}},{"line":349,"address":[],"length":0,"stats":{"Line":8}},{"line":350,"address":[],"length":0,"stats":{"Line":4}},{"line":354,"address":[],"length":0,"stats":{"Line":12}},{"line":355,"address":[],"length":0,"stats":{"Line":4}},{"line":357,"address":[],"length":0,"stats":{"Line":4}},{"line":358,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":4}},{"line":360,"address":[],"length":0,"stats":{"Line":12}},{"line":361,"address":[],"length":0,"stats":{"Line":4}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":370,"address":[],"length":0,"stats":{"Line":8}},{"line":373,"address":[],"length":0,"stats":{"Line":4}},{"line":374,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":4}},{"line":376,"address":[],"length":0,"stats":{"Line":2}},{"line":379,"address":[],"length":0,"stats":{"Line":8}},{"line":380,"address":[],"length":0,"stats":{"Line":2}},{"line":381,"address":[],"length":0,"stats":{"Line":6}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":4}},{"line":388,"address":[],"length":0,"stats":{"Line":8}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":6}},{"line":397,"address":[],"length":0,"stats":{"Line":2}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":4}},{"line":407,"address":[],"length":0,"stats":{"Line":8}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":8}},{"line":414,"address":[],"length":0,"stats":{"Line":2}},{"line":415,"address":[],"length":0,"stats":{"Line":6}},{"line":416,"address":[],"length":0,"stats":{"Line":8}},{"line":419,"address":[],"length":0,"stats":{"Line":2}},{"line":420,"address":[],"length":0,"stats":{"Line":2}},{"line":421,"address":[],"length":0,"stats":{"Line":2}},{"line":422,"address":[],"length":0,"stats":{"Line":2}},{"line":424,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":4}},{"line":430,"address":[],"length":0,"stats":{"Line":6}},{"line":431,"address":[],"length":0,"stats":{"Line":6}},{"line":432,"address":[],"length":0,"stats":{"Line":2}},{"line":434,"address":[],"length":0,"stats":{"Line":2}},{"line":435,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":6}},{"line":438,"address":[],"length":0,"stats":{"Line":2}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}}],"covered":163,"coverable":242},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","mod.rs"],"content":"pub mod capture;\npub mod doctor;\npub mod links;\npub mod list;\npub mod list_templates;\npub mod macro_cmd;\npub mod new;\npub mod orphans;\npub mod output;\npub mod project;\npub mod reindex;\npub mod rename;\npub mod search;\npub mod stale;\npub mod task;\npub mod validate;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","new.rs"],"content":"use crate::prompt::{prompt_for_field, CollectedVars, PromptOptions};\nuse crate::NewArgs;\nuse dialoguer::{theme::ColorfulTheme, Editor, Input, Select};\nuse mdvault_core::captures::CaptureRepository;\nuse mdvault_core::config::loader::{default_config_path, ConfigLoader};\nuse mdvault_core::config::types::ResolvedConfig;\nuse mdvault_core::frontmatter::parse as parse_frontmatter;\nuse mdvault_core::ids::{generate_project_id, generate_task_id};\nuse mdvault_core::index::{IndexBuilder, IndexDb, NoteQuery, NoteType};\nuse mdvault_core::macros::MacroRepository;\nuse mdvault_core::scripting::{\n    run_on_create_hook, HookResult, NoteContext, VaultContext,\n};\nuse mdvault_core::templates::discovery::TemplateInfo;\nuse mdvault_core::templates::engine::{\n    build_minimal_context, render, render_string, resolve_template_output_path,\n};\nuse mdvault_core::templates::repository::{TemplateRepoError, TemplateRepository};\nuse mdvault_core::types::{\n    discovery::load_typedef_from_file, generate_scaffolding, get_missing_required_fields,\n    TypeDefinition, TypeRegistry, TypedefRepository,\n};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n/// Core metadata that must be preserved in notes regardless of template/hook modifications.\n/// These fields are managed by mdvault and should not be removed or overwritten by user code.\n#[derive(Debug, Clone, Default)]\nstruct CoreMetadata {\n    /// Note type (project, task, etc.)\n    note_type: Option\u003cString\u003e,\n    /// Title of the note\n    title: Option\u003cString\u003e,\n    /// Project ID (for projects)\n    project_id: Option\u003cString\u003e,\n    /// Task ID (for tasks)\n    task_id: Option\u003cString\u003e,\n    /// Task counter (for projects)\n    task_counter: Option\u003cu32\u003e,\n    /// Parent project (for tasks)\n    project: Option\u003cString\u003e,\n}\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: NewArgs) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            println!(\"FAIL mdv new\");\n            println!(\"{e}\");\n            if config.is_none() {\n                println!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    // Decide between template mode and type-based scaffolding\n    if let Some(ref template_name) = args.template {\n        // Template mode (existing behavior)\n        run_template_mode(\u0026cfg, template_name, \u0026args);\n    } else if let Some(ref type_name) = args.note_type {\n        // Type-based scaffolding mode\n        run_scaffolding_mode(\u0026cfg, type_name, \u0026args);\n    } else {\n        eprintln!(\"Error: either provide a type name or use --template\");\n        eprintln!(\"Usage: mdv new \u003ctype\u003e [title] [--var field=value]\");\n        eprintln!(\"       mdv new --template \u003cname\u003e [--var key=value]\");\n        std::process::exit(1);\n    }\n}\n\n/// Run template-based note creation (existing behavior).\nfn run_template_mode(cfg: \u0026ResolvedConfig, template_name: \u0026str, args: \u0026NewArgs) {\n    let repo = match TemplateRepository::new(\u0026cfg.templates_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            println!(\"FAIL mdv new\");\n            println!(\"{e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let loaded = match repo.get_by_name(template_name) {\n        Ok(t) =\u003e t,\n        Err(e) =\u003e match e {\n            TemplateRepoError::NotFound(name) =\u003e {\n                eprintln!(\"Template not found: {name}\");\n                std::process::exit(1);\n            }\n            other =\u003e {\n                eprintln!(\"Failed to load template: {other}\");\n                std::process::exit(1);\n            }\n        },\n    };\n\n    // Build TemplateInfo for context building\n    let info = TemplateInfo {\n        logical_name: loaded.logical_name.clone(),\n        path: loaded.path.clone(),\n    };\n\n    // Check if template links to a Lua script\n    let lua_typedef: Option\u003cTypeDefinition\u003e =\n        loaded.frontmatter.as_ref().and_then(|fm| fm.lua.as_ref()).and_then(|lua_path| {\n            // Resolve lua path relative to typedefs directory\n            let lua_file = cfg.typedefs_dir.join(lua_path);\n            match load_typedef_from_file(\u0026lua_file) {\n                Ok(td) =\u003e Some(td),\n                Err(e) =\u003e {\n                    eprintln!(\"Warning: failed to load Lua script '{}': {}\", lua_path, e);\n                    None\n                }\n            }\n        });\n\n    // Convert provided vars to HashMap\n    let mut provided_vars: HashMap\u003cString, String\u003e = args.vars.iter().cloned().collect();\n\n    // Handle title: In template mode, the first positional arg (note_type) is actually the title\n    // since --template replaces the type name. Also check args.title for completeness.\n    let title = args.title.clone().or_else(|| args.note_type.clone());\n    if let Some(ref t) = title {\n        provided_vars.entry(\"title\".to_string()).or_insert(t.clone());\n    }\n\n    // For task templates: show project picker if project not already provided\n    if template_name == \"task\" \u0026\u0026 !provided_vars.contains_key(\"project\") \u0026\u0026 !args.batch {\n        if let Some(project) = prompt_project_selection(cfg) {\n            provided_vars.insert(\"project\".to_string(), project);\n        }\n    }\n\n    // Build minimal context for variable resolution\n    let minimal_ctx = build_minimal_context(cfg, \u0026info);\n\n    // Collect variables using Lua schema prompts\n    let prompt_options = PromptOptions { batch_mode: args.batch };\n\n    let collected = if let Some(ref typedef) = lua_typedef {\n        // Use Lua schema for prompting - fields with `prompt` set will be prompted\n        match collect_schema_variables(typedef, \u0026provided_vars, \u0026prompt_options) {\n            Ok(c) =\u003e c,\n            Err(e) =\u003e {\n                eprintln!(\"Error: {e}\");\n                std::process::exit(1);\n            }\n        }\n    } else {\n        // No Lua script - just use provided vars directly\n        CollectedVars {\n            values: provided_vars.clone(),\n            prompted: Vec::new(),\n            defaulted: Vec::new(),\n        }\n    };\n\n    // Merge collected variables into context\n    let mut ctx = minimal_ctx;\n    for (k, v) in collected.values {\n        ctx.insert(k, v);\n    }\n\n    // Resolve output path: CLI arg \u003e template frontmatter \u003e Lua typedef output\n    let output_path = if let Some(ref out) = args.output {\n        out.clone()\n    } else {\n        // Try to get from template frontmatter first\n        match resolve_template_output_path(\u0026loaded, cfg, \u0026ctx) {\n            Ok(Some(path)) =\u003e path,\n            Ok(None) =\u003e {\n                // Fall back to Lua typedef output if available\n                if let Some(ref typedef) = lua_typedef {\n                    if let Some(ref output_template) = typedef.output {\n                        // Render the output template with current context\n                        match render_output_path(output_template, cfg, \u0026ctx) {\n                            Ok(path) =\u003e path,\n                            Err(e) =\u003e {\n                                eprintln!(\"Failed to resolve Lua output path: {e}\");\n                                std::process::exit(1);\n                            }\n                        }\n                    } else {\n                        eprintln!(\n                            \"Error: --output is required (neither template nor Lua script has output)\"\n                        );\n                        std::process::exit(1);\n                    }\n                } else {\n                    eprintln!(\n                        \"Error: --output is required (template has no output in frontmatter)\"\n                    );\n                    std::process::exit(1);\n                }\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Failed to resolve output path: {e}\");\n                std::process::exit(1);\n            }\n        }\n    };\n\n    // Update context with output info\n    let output_abs = if output_path.is_absolute() {\n        output_path.clone()\n    } else {\n        std::env::current_dir()\n            .unwrap_or_else(|_| std::path::PathBuf::from(\".\"))\n            .join(\u0026output_path)\n    };\n    ctx.insert(\"output_path\".to_string(), output_abs.to_string_lossy().to_string());\n    if let Some(name) = output_abs.file_name().and_then(|s| s.to_str()) {\n        ctx.insert(\"output_filename\".to_string(), name.to_string());\n    }\n    if let Some(parent) = output_abs.parent() {\n        ctx.insert(\"output_dir\".to_string(), parent.to_string_lossy().to_string());\n    }\n\n    if output_path.exists() {\n        eprintln!(\n            \"Refusing to overwrite existing file: {} (add --force later if needed)\",\n            output_path.display()\n        );\n        std::process::exit(1);\n    }\n\n    let rendered = match render(\u0026loaded, \u0026ctx) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to render template: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    if let Some(parent) = output_path.parent() {\n        if let Err(e) = fs::create_dir_all(parent) {\n            eprintln!(\"Failed to create parent directory {}: {e}\", parent.display());\n            std::process::exit(1);\n        }\n    }\n\n    if let Err(e) = fs::write(\u0026output_path, \u0026rendered) {\n        eprintln!(\"Failed to write output file {}: {e}\", output_path.display());\n        std::process::exit(1);\n    }\n\n    // Execute on_create hook if type definition exists\n    match run_on_create_hook_if_exists(cfg, \u0026output_path, \u0026rendered) {\n        Ok(hook_result) =\u003e {\n            if hook_result.modified {\n                if let Err(e) =\n                    apply_hook_modifications(\u0026output_path, \u0026rendered, \u0026hook_result)\n                {\n                    eprintln!(\n                        \"Warning: failed to apply on_create hook modifications: {e}\"\n                    );\n                }\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Warning: on_create hook failed: {e}\");\n        }\n    }\n\n    // Log to daily note for tasks and projects\n    // Note: In template mode, we don't auto-generate IDs (user should use scaffolding mode for that)\n    // But we still log to daily with whatever ID might be in the context\n    if template_name == \"task\" || template_name == \"project\" {\n        let title = ctx.get(\"title\").cloned().unwrap_or_else(|| \"Untitled\".to_string());\n        let note_id = ctx\n            .get(\"task-id\")\n            .or_else(|| ctx.get(\"project-id\"))\n            .cloned()\n            .unwrap_or_default();\n        log_to_daily(cfg, template_name, \u0026title, \u0026note_id, \u0026output_path);\n\n        // Force reindex so the new note appears in queries\n        reindex_vault(cfg);\n    }\n\n    println!(\"OK   mdv new\");\n    println!(\"template: {}\", template_name);\n    println!(\"output:   {}\", output_path.display());\n}\n\n/// Run type-based scaffolding mode.\nfn run_scaffolding_mode(cfg: \u0026ResolvedConfig, type_name: \u0026str, args: \u0026NewArgs) {\n    // Load type registry\n    let typedef_repo = match TypedefRepository::new(\u0026cfg.typedefs_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load type definitions: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let type_registry = match TypeRegistry::from_repository(\u0026typedef_repo) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to build type registry: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Check if type is known\n    if !type_registry.is_known_type(type_name) {\n        eprintln!(\"Unknown type: {type_name}\");\n        eprintln!(\"Available types:\");\n        for t in type_registry.list_all_types() {\n            eprintln!(\"  {t}\");\n        }\n        std::process::exit(1);\n    }\n\n    // Get type definition (may be None for built-in types without Lua override)\n    let typedef = type_registry.get(type_name);\n\n    // Check if there's a matching template\n    let template_repo = TemplateRepository::new(\u0026cfg.templates_dir).ok();\n    let loaded_template =\n        template_repo.as_ref().and_then(|repo| repo.get_by_name(type_name).ok());\n\n    // For non-project/task types with templates, delegate to template mode\n    // For projects and tasks, we ALWAYS use scaffolding mode to ensure proper ID generation\n    if loaded_template.is_some() \u0026\u0026 type_name != \"project\" \u0026\u0026 type_name != \"task\" {\n        run_template_mode(cfg, type_name, args);\n        return;\n    }\n\n    // Get title (required for scaffolding)\n    let title = match \u0026args.title {\n        Some(t) =\u003e t.clone(),\n        None =\u003e {\n            if args.batch {\n                eprintln!(\"Error: title is required in batch mode\");\n                eprintln!(\"Usage: mdv new {type_name} \\\"Title\\\"\");\n                std::process::exit(1);\n            }\n            // Prompt for title\n            match prompt_for_field(\"title\", \"Note title\", None, true) {\n                Ok(t) =\u003e t,\n                Err(e) =\u003e {\n                    eprintln!(\"Error: {e}\");\n                    std::process::exit(1);\n                }\n            }\n        }\n    };\n\n    // Collect vars from command line\n    let mut vars: HashMap\u003cString, String\u003e = args.vars.iter().cloned().collect();\n\n    // Handle project creation with ID generation\n    let (output_path, note_id) = if type_name == \"project\" {\n        // Compute default project ID from title\n        let computed_id = generate_project_id(\u0026title);\n\n        // Prompt for project ID with computed value as default (unless batch mode)\n        let project_id = if args.batch {\n            computed_id\n        } else {\n            match prompt_for_field(\n                \"project-id\",\n                \"Project ID (3-letter code)\",\n                Some(\u0026computed_id),\n                true,\n            ) {\n                Ok(id) if !id.is_empty() =\u003e id.to_uppercase(),\n                Ok(_) =\u003e computed_id, // Empty input uses computed default\n                Err(e) =\u003e {\n                    eprintln!(\"Error: {e}\");\n                    std::process::exit(1);\n                }\n            }\n        };\n\n        vars.insert(\"project-id\".to_string(), project_id.clone());\n        vars.insert(\"task_counter\".to_string(), \"0\".to_string());\n        vars.insert(\"title\".to_string(), title.clone());\n\n        let path = if let Some(ref out) = args.output {\n            out.clone()\n        } else if let Some(ref td) = typedef {\n            // Use Lua typedef's output template if available\n            if let Some(ref output_template) = td.output {\n                match render_output_path(output_template, cfg, \u0026vars) {\n                    Ok(p) =\u003e p,\n                    Err(e) =\u003e {\n                        eprintln!(\"Warning: failed to render Lua output path: {e}\");\n                        // Fall back to default\n                        cfg.vault_root\n                            .join(format!(\"Projects/{}/{}.md\", project_id, project_id))\n                    }\n                }\n            } else {\n                // No output template in Lua, use default\n                cfg.vault_root.join(format!(\"Projects/{}/{}.md\", project_id, project_id))\n            }\n        } else {\n            // No typedef, use default\n            cfg.vault_root.join(format!(\"Projects/{}/{}.md\", project_id, project_id))\n        };\n        (path, project_id)\n    } else if type_name == \"task\" {\n        // For tasks: prompt for project selection if not already provided\n        let project_folder = if let Some(proj) = vars.get(\"project\").cloned() {\n            proj\n        } else if !args.batch {\n            match prompt_project_selection(cfg) {\n                Some(proj) =\u003e {\n                    vars.insert(\"project\".to_string(), proj.clone());\n                    proj\n                }\n                None =\u003e \"inbox\".to_string(),\n            }\n        } else {\n            \"inbox\".to_string()\n        };\n\n        // Add title to vars for output path rendering\n        vars.insert(\"title\".to_string(), title.clone());\n\n        // Get project info and generate task ID\n        let (task_id, output_path) = if project_folder == \"inbox\" {\n            // Inbox tasks get a simple incremental ID\n            let task_id = generate_inbox_task_id(cfg);\n            vars.insert(\"task-id\".to_string(), task_id.clone());\n            let path = if let Some(ref out) = args.output {\n                out.clone()\n            } else if let Some(ref td) = typedef {\n                // Use Lua typedef's output template if available\n                if let Some(ref output_template) = td.output {\n                    match render_output_path(output_template, cfg, \u0026vars) {\n                        Ok(p) =\u003e p,\n                        Err(e) =\u003e {\n                            eprintln!(\"Warning: failed to render Lua output path: {e}\");\n                            cfg.vault_root.join(format!(\"Inbox/{}.md\", task_id))\n                        }\n                    }\n                } else {\n                    cfg.vault_root.join(format!(\"Inbox/{}.md\", task_id))\n                }\n            } else {\n                cfg.vault_root.join(format!(\"Inbox/{}.md\", task_id))\n            };\n            (task_id, path)\n        } else {\n            // Get project's task counter and increment it\n            match get_and_increment_project_counter(cfg, \u0026project_folder) {\n                Ok((project_id, counter)) =\u003e {\n                    let task_id = generate_task_id(\u0026project_id, counter);\n                    vars.insert(\"task-id\".to_string(), task_id.clone());\n                    vars.insert(\"project-id\".to_string(), project_id.clone());\n                    let path = if let Some(ref out) = args.output {\n                        out.clone()\n                    } else if let Some(ref td) = typedef {\n                        // Use Lua typedef's output template if available\n                        if let Some(ref output_template) = td.output {\n                            match render_output_path(output_template, cfg, \u0026vars) {\n                                Ok(p) =\u003e p,\n                                Err(e) =\u003e {\n                                    eprintln!(\n                                        \"Warning: failed to render Lua output path: {e}\"\n                                    );\n                                    cfg.vault_root.join(format!(\n                                        \"Projects/{}/Tasks/{}.md\",\n                                        project_folder, task_id\n                                    ))\n                                }\n                            }\n                        } else {\n                            cfg.vault_root.join(format!(\n                                \"Projects/{}/Tasks/{}.md\",\n                                project_folder, task_id\n                            ))\n                        }\n                    } else {\n                        cfg.vault_root.join(format!(\n                            \"Projects/{}/Tasks/{}.md\",\n                            project_folder, task_id\n                        ))\n                    };\n                    (task_id, path)\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"Warning: could not get project info: {e}\");\n                    // Fall back to inbox-style ID\n                    let task_id = generate_inbox_task_id(cfg);\n                    vars.insert(\"task-id\".to_string(), task_id.clone());\n                    let path = if let Some(ref td) = typedef {\n                        if let Some(ref output_template) = td.output {\n                            match render_output_path(output_template, cfg, \u0026vars) {\n                                Ok(p) =\u003e p,\n                                Err(_) =\u003e cfg.vault_root.join(format!(\n                                    \"Projects/{}/Tasks/{}.md\",\n                                    project_folder, task_id\n                                )),\n                            }\n                        } else {\n                            cfg.vault_root.join(format!(\n                                \"Projects/{}/Tasks/{}.md\",\n                                project_folder, task_id\n                            ))\n                        }\n                    } else {\n                        cfg.vault_root.join(format!(\n                            \"Projects/{}/Tasks/{}.md\",\n                            project_folder, task_id\n                        ))\n                    };\n                    (task_id, path)\n                }\n            }\n        };\n        (output_path, task_id)\n    } else {\n        // Other types use default output path\n        let path = if let Some(ref out) = args.output {\n            out.clone()\n        } else {\n            cfg.vault_root.join(format!(\"{}s/{}.md\", type_name, slugify(\u0026title)))\n        };\n        (path, String::new())\n    };\n\n    // Build core metadata for projects and tasks\n    // This will be used to ensure these fields survive template/hook modifications\n    let core_metadata = if type_name == \"project\" {\n        CoreMetadata {\n            note_type: Some(\"project\".to_string()),\n            title: Some(title.clone()),\n            project_id: vars.get(\"project-id\").cloned(),\n            task_counter: Some(0),\n            ..Default::default()\n        }\n    } else if type_name == \"task\" {\n        CoreMetadata {\n            note_type: Some(\"task\".to_string()),\n            title: Some(title.clone()),\n            task_id: vars.get(\"task-id\").cloned(),\n            project: vars.get(\"project\").cloned(),\n            ..Default::default()\n        }\n    } else {\n        CoreMetadata::default()\n    };\n\n    // Prompt for missing required fields\n    if let Some(ref td) = typedef {\n        let missing = get_missing_required_fields(td, \u0026vars);\n\n        if !missing.is_empty() {\n            if args.batch {\n                eprintln!(\"Error: missing required fields:\");\n                for (field, schema) in \u0026missing {\n                    let type_hint = schema\n                        .field_type\n                        .map(|t| t.to_string())\n                        .unwrap_or_else(|| \"string\".to_string());\n                    eprintln!(\"  {} ({})\", field, type_hint);\n                }\n                std::process::exit(1);\n            }\n\n            // Prompt for each missing field\n            for (field, schema) in missing {\n                let type_hint = schema\n                    .field_type\n                    .map(|t| t.to_string())\n                    .unwrap_or_else(|| \"string\".to_string());\n\n                let prompt = if let Some(ref desc) = schema.description {\n                    format!(\"{} ({})\", desc, type_hint)\n                } else {\n                    format!(\"{} ({})\", field, type_hint)\n                };\n\n                // For enums, show available values\n                let enum_hint = schema.enum_values.as_ref().map(|v| v.join(\"/\"));\n\n                match prompt_for_field(field, \u0026prompt, enum_hint.as_deref(), true) {\n                    Ok(value) =\u003e {\n                        vars.insert(field.clone(), value);\n                    }\n                    Err(e) =\u003e {\n                        eprintln!(\"Error: {e}\");\n                        std::process::exit(1);\n                    }\n                }\n            }\n        }\n    }\n\n    if output_path.exists() {\n        eprintln!(\"Refusing to overwrite existing file: {}\", output_path.display());\n        std::process::exit(1);\n    }\n\n    // Generate content - use template if available, otherwise scaffolding\n    // For projects/tasks, we'll ensure core metadata is preserved either way\n    let content = if let Some(ref loaded) = loaded_template {\n        // Build context for template rendering\n        let info = TemplateInfo {\n            logical_name: loaded.logical_name.clone(),\n            path: loaded.path.clone(),\n        };\n        let mut ctx = build_minimal_context(cfg, \u0026info);\n\n        // Add all vars to context\n        ctx.insert(\"title\".to_string(), title.clone());\n        for (k, v) in \u0026vars {\n            ctx.insert(k.clone(), v.clone());\n        }\n\n        // Update context with output info\n        ctx.insert(\"output_path\".to_string(), output_path.to_string_lossy().to_string());\n        if let Some(name) = output_path.file_name().and_then(|s| s.to_str()) {\n            ctx.insert(\"output_filename\".to_string(), name.to_string());\n        }\n\n        // Render template\n        match render(loaded, \u0026ctx) {\n            Ok(rendered) =\u003e rendered,\n            Err(e) =\u003e {\n                eprintln!(\"Failed to render template: {e}\");\n                eprintln!(\"Falling back to scaffolding...\");\n                generate_scaffolding(type_name, typedef.as_deref(), \u0026title, \u0026vars)\n            }\n        }\n    } else {\n        generate_scaffolding(type_name, typedef.as_deref(), \u0026title, \u0026vars)\n    };\n\n    // Apply core metadata immediately after content generation (before writing)\n    // This ensures template output has the required fields\n    let content = if type_name == \"project\" || type_name == \"task\" {\n        match ensure_core_metadata(\u0026content, \u0026core_metadata) {\n            Ok(fixed) =\u003e fixed,\n            Err(e) =\u003e {\n                eprintln!(\"Warning: failed to apply core metadata: {e}\");\n                content\n            }\n        }\n    } else {\n        content\n    };\n\n    // Create parent directories\n    if let Some(parent) = output_path.parent() {\n        if let Err(e) = fs::create_dir_all(parent) {\n            eprintln!(\"Failed to create parent directory {}: {e}\", parent.display());\n            std::process::exit(1);\n        }\n    }\n\n    // Write file\n    if let Err(e) = fs::write(\u0026output_path, \u0026content) {\n        eprintln!(\"Failed to write output file {}: {e}\", output_path.display());\n        std::process::exit(1);\n    }\n\n    // Execute on_create hook if defined\n    match run_on_create_hook_if_exists(cfg, \u0026output_path, \u0026content) {\n        Ok(hook_result) =\u003e {\n            if hook_result.modified {\n                if let Err(e) =\n                    apply_hook_modifications(\u0026output_path, \u0026content, \u0026hook_result)\n                {\n                    eprintln!(\n                        \"Warning: failed to apply on_create hook modifications: {e}\"\n                    );\n                }\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Warning: on_create hook failed: {e}\");\n        }\n    }\n\n    // Ensure core metadata is preserved after template/hook modifications\n    // This guarantees that projects have project-id and tasks have task-id\n    if type_name == \"project\" || type_name == \"task\" {\n        match fs::read_to_string(\u0026output_path) {\n            Ok(current_content) =\u003e {\n                match ensure_core_metadata(\u0026current_content, \u0026core_metadata) {\n                    Ok(fixed_content) =\u003e {\n                        if let Err(e) = fs::write(\u0026output_path, fixed_content) {\n                            eprintln!(\"Warning: failed to write core metadata: {e}\");\n                        }\n                    }\n                    Err(e) =\u003e {\n                        eprintln!(\"Warning: failed to ensure core metadata: {e}\");\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Warning: failed to read file for metadata check: {e}\");\n            }\n        }\n    }\n\n    // Log to daily note for tasks and projects\n    if type_name == \"task\" || type_name == \"project\" {\n        log_to_daily(cfg, type_name, \u0026title, \u0026note_id, \u0026output_path);\n    }\n\n    // Force reindex so the new note appears in queries\n    reindex_vault(cfg);\n\n    println!(\"OK   mdv new\");\n    println!(\"type:   {}\", type_name);\n    if !note_id.is_empty() {\n        println!(\"id:     {}\", note_id);\n    }\n    println!(\"output: {}\", output_path.display());\n}\n\n/// Slugify a string for use in paths.\nfn slugify(s: \u0026str) -\u003e String {\n    let mut result = String::with_capacity(s.len());\n    for c in s.chars() {\n        if c.is_ascii_alphanumeric() {\n            result.push(c.to_ascii_lowercase());\n        } else if (c == ' ' || c == '_' || c == '-') \u0026\u0026 !result.ends_with('-') {\n            result.push('-');\n        }\n    }\n    result.trim_matches('-').to_string()\n}\n\n/// Ensure core metadata fields are present in the note content.\n///\n/// This function is called after template rendering and hook execution to guarantee\n/// that required fields managed by mdvault are not removed or corrupted by user code.\n/// Templates and hooks can ADD fields but cannot REMOVE core fields.\nfn ensure_core_metadata(content: \u0026str, core: \u0026CoreMetadata) -\u003e Result\u003cString, String\u003e {\n    let parsed = parse_frontmatter(content).map_err(|e| e.to_string())?;\n\n    // Start with existing frontmatter or create new\n    let mut fields: HashMap\u003cString, serde_yaml::Value\u003e =\n        if let Some(fm) = parsed.frontmatter { fm.fields } else { HashMap::new() };\n\n    // Inject/overwrite core fields - these are authoritative from Rust\n    if let Some(ref t) = core.note_type {\n        fields.insert(\"type\".to_string(), serde_yaml::Value::String(t.clone()));\n    }\n\n    if let Some(ref t) = core.title {\n        fields.insert(\"title\".to_string(), serde_yaml::Value::String(t.clone()));\n    }\n\n    if let Some(ref id) = core.project_id {\n        fields.insert(\"project-id\".to_string(), serde_yaml::Value::String(id.clone()));\n    }\n\n    if let Some(ref id) = core.task_id {\n        fields.insert(\"task-id\".to_string(), serde_yaml::Value::String(id.clone()));\n    }\n\n    if let Some(counter) = core.task_counter {\n        fields.insert(\n            \"task_counter\".to_string(),\n            serde_yaml::Value::Number(serde_yaml::Number::from(counter)),\n        );\n    }\n\n    if let Some(ref proj) = core.project {\n        fields.insert(\"project\".to_string(), serde_yaml::Value::String(proj.clone()));\n    }\n\n    // Rebuild the document\n    let mut mapping = serde_yaml::Mapping::new();\n    for (k, v) in fields {\n        mapping.insert(serde_yaml::Value::String(k), v);\n    }\n\n    let yaml_str = serde_yaml::to_string(\u0026serde_yaml::Value::Mapping(mapping))\n        .map_err(|e| e.to_string())?;\n\n    Ok(format!(\"---\\n{}---\\n{}\", yaml_str, parsed.body))\n}\n\n/// Generate a task ID for inbox tasks (no project).\nfn generate_inbox_task_id(cfg: \u0026ResolvedConfig) -\u003e String {\n    let inbox_path = cfg.vault_root.join(\"Inbox\");\n    let mut max_counter = 0u32;\n\n    if inbox_path.exists() {\n        if let Ok(entries) = fs::read_dir(\u0026inbox_path) {\n            for entry in entries.filter_map(|e| e.ok()) {\n                let name = entry.file_name();\n                let name_str = name.to_string_lossy();\n                // Parse INB-XXX pattern\n                if name_str.starts_with(\"INB-\") {\n                    if let Some(num_str) =\n                        name_str.strip_prefix(\"INB-\").and_then(|s| s.strip_suffix(\".md\"))\n                    {\n                        if let Ok(n) = num_str.parse::\u003cu32\u003e() {\n                            max_counter = max_counter.max(n);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    generate_task_id(\"INB\", max_counter + 1)\n}\n\n/// Get project's ID and increment its task counter.\n/// Returns (project_id, new_counter) on success.\nfn get_and_increment_project_counter(\n    cfg: \u0026ResolvedConfig,\n    project_folder: \u0026str,\n) -\u003e Result\u003c(String, u32), String\u003e {\n    // Find the project file - try both \u003cfolder\u003e/\u003cfolder\u003e.md and \u003cfolder\u003e.md patterns\n    let project_path = find_project_file(cfg, project_folder)?;\n\n    // Read and parse the project file\n    let content = fs::read_to_string(\u0026project_path)\n        .map_err(|e| format!(\"Failed to read project file: {e}\"))?;\n\n    let parsed = parse_frontmatter(\u0026content)\n        .map_err(|e| format!(\"Failed to parse project frontmatter: {e}\"))?;\n\n    let fm = parsed.frontmatter.ok_or(\"Project has no frontmatter\")?;\n\n    // Get project-id\n    let project_id = fm\n        .fields\n        .get(\"project-id\")\n        .and_then(|v| match v {\n            serde_yaml::Value::String(s) =\u003e Some(s.clone()),\n            _ =\u003e None,\n        })\n        .unwrap_or_else(|| generate_project_id(project_folder));\n\n    // Get current task counter\n    let current_counter = fm\n        .fields\n        .get(\"task_counter\")\n        .and_then(|v| match v {\n            serde_yaml::Value::Number(n) =\u003e n.as_u64().map(|n| n as u32),\n            serde_yaml::Value::String(s) =\u003e s.parse::\u003cu32\u003e().ok(),\n            _ =\u003e None,\n        })\n        .unwrap_or(0);\n\n    let new_counter = current_counter + 1;\n\n    // Update the project file with new counter\n    let mut new_fm = fm.fields.clone();\n    new_fm.insert(\n        \"task_counter\".to_string(),\n        serde_yaml::Value::Number(serde_yaml::Number::from(new_counter)),\n    );\n\n    // Rebuild the document\n    let mut mapping = serde_yaml::Mapping::new();\n    for (k, v) in new_fm {\n        mapping.insert(serde_yaml::Value::String(k), v);\n    }\n    let yaml_str = serde_yaml::to_string(\u0026serde_yaml::Value::Mapping(mapping))\n        .map_err(|e| format!(\"Failed to serialize frontmatter: {e}\"))?;\n\n    let new_content = format!(\"---\\n{}---\\n{}\", yaml_str, parsed.body);\n\n    fs::write(\u0026project_path, new_content)\n        .map_err(|e| format!(\"Failed to update project file: {e}\"))?;\n\n    Ok((project_id, new_counter))\n}\n\n/// Find the project file for a given project folder name.\nfn find_project_file(\n    cfg: \u0026ResolvedConfig,\n    project_folder: \u0026str,\n) -\u003e Result\u003cPathBuf, String\u003e {\n    // Try Projects/\u003cfolder\u003e/\u003cfolder\u003e.md\n    let path1 =\n        cfg.vault_root.join(format!(\"Projects/{}/{}.md\", project_folder, project_folder));\n    if path1.exists() {\n        return Ok(path1);\n    }\n\n    // Try Projects/\u003cfolder\u003e.md\n    let path2 = cfg.vault_root.join(format!(\"Projects/{}.md\", project_folder));\n    if path2.exists() {\n        return Ok(path2);\n    }\n\n    // Try scanning the Projects/\u003cfolder\u003e/ directory for any .md file\n    let folder_path = cfg.vault_root.join(format!(\"Projects/{}\", project_folder));\n    if folder_path.is_dir() {\n        if let Ok(entries) = fs::read_dir(\u0026folder_path) {\n            for entry in entries.filter_map(|e| e.ok()) {\n                let path = entry.path();\n                if path.extension().map(|e| e == \"md\").unwrap_or(false) {\n                    // Check if it's a project file (not in Tasks subdirectory)\n                    if !path.to_string_lossy().contains(\"/Tasks/\") {\n                        return Ok(path);\n                    }\n                }\n            }\n        }\n    }\n\n    Err(format!(\"Project file not found for: {}\", project_folder))\n}\n\n/// Force a vault reindex to include newly created notes.\nfn reindex_vault(cfg: \u0026ResolvedConfig) {\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n\n    // Ensure index directory exists\n    if let Some(parent) = index_path.parent() {\n        let _ = fs::create_dir_all(parent);\n    }\n\n    // Open the database and run incremental reindex\n    match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e {\n            let builder = IndexBuilder::new(\u0026db, \u0026cfg.vault_root);\n            if let Err(e) = builder.incremental_reindex(None) {\n                eprintln!(\"Warning: reindex failed: {e}\");\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Warning: could not open index for reindex: {e}\");\n        }\n    }\n}\n\n/// Extract note type from rendered content's frontmatter.\nfn extract_note_type(content: \u0026str) -\u003e Option\u003cString\u003e {\n    let parsed = parse_frontmatter(content).ok()?;\n    let fm = parsed.frontmatter?;\n\n    if let Some(serde_yaml::Value::String(t)) = fm.fields.get(\"type\") {\n        return Some(t.clone());\n    }\n    None\n}\n\n/// Run on_create hook if the note type has one defined.\n/// Returns the HookResult which may contain modifications to apply.\nfn run_on_create_hook_if_exists(\n    cfg: \u0026ResolvedConfig,\n    output_path: \u0026Path,\n    content: \u0026str,\n) -\u003e Result\u003cHookResult, String\u003e {\n    // Extract note type from frontmatter\n    let note_type = match extract_note_type(content) {\n        Some(t) =\u003e t,\n        None =\u003e {\n            return Ok(HookResult { modified: false, frontmatter: None, content: None })\n        }\n    };\n\n    // Load type registry\n    let typedef_repo =\n        TypedefRepository::new(\u0026cfg.typedefs_dir).map_err(|e| e.to_string())?;\n    let type_registry =\n        TypeRegistry::from_repository(\u0026typedef_repo).map_err(|e| e.to_string())?;\n\n    // Check if type has on_create hook\n    let typedef = match type_registry.get(\u0026note_type) {\n        Some(td) if td.has_on_create_hook =\u003e td,\n        _ =\u003e return Ok(HookResult { modified: false, frontmatter: None, content: None }),\n    };\n\n    // Load all repositories for VaultContext\n    let template_repo =\n        TemplateRepository::new(\u0026cfg.templates_dir).map_err(|e| e.to_string())?;\n    let capture_repo =\n        CaptureRepository::new(\u0026cfg.captures_dir).map_err(|e| e.to_string())?;\n    let macro_repo = MacroRepository::new(\u0026cfg.macros_dir).map_err(|e| e.to_string())?;\n\n    // Build VaultContext\n    let vault_ctx = VaultContext::new(\n        cfg.clone(),\n        template_repo,\n        capture_repo,\n        macro_repo,\n        type_registry,\n    );\n\n    // Parse frontmatter for NoteContext\n    let parsed = parse_frontmatter(content).map_err(|e| e.to_string())?;\n\n    // Convert Frontmatter to serde_yaml::Value\n    let frontmatter = match parsed.frontmatter {\n        Some(fm) =\u003e {\n            let mut mapping = serde_yaml::Mapping::new();\n            for (k, v) in fm.fields {\n                mapping.insert(serde_yaml::Value::String(k), v);\n            }\n            serde_yaml::Value::Mapping(mapping)\n        }\n        None =\u003e serde_yaml::Value::Null,\n    };\n\n    // Build NoteContext\n    let note_ctx = NoteContext::new(\n        output_path.to_path_buf(),\n        note_type,\n        frontmatter,\n        content.to_string(),\n    );\n\n    // Run the hook and return its result\n    run_on_create_hook(\u0026typedef, \u0026note_ctx, vault_ctx).map_err(|e| e.to_string())\n}\n\n/// Apply hook modifications to the output file.\nfn apply_hook_modifications(\n    output_path: \u0026Path,\n    original_content: \u0026str,\n    hook_result: \u0026HookResult,\n) -\u003e Result\u003c(), String\u003e {\n    if !hook_result.modified {\n        return Ok(());\n    }\n\n    // Parse original content to get structure\n    let original_parsed =\n        parse_frontmatter(original_content).map_err(|e| e.to_string())?;\n\n    // Determine final frontmatter\n    let final_frontmatter = if let Some(ref new_fm) = hook_result.frontmatter {\n        new_fm.clone()\n    } else if let Some(fm) = original_parsed.frontmatter {\n        let mut mapping = serde_yaml::Mapping::new();\n        for (k, v) in fm.fields {\n            mapping.insert(serde_yaml::Value::String(k), v);\n        }\n        serde_yaml::Value::Mapping(mapping)\n    } else {\n        serde_yaml::Value::Null\n    };\n\n    // Determine final content body\n    // If hook returned content, it might contain frontmatter, so parse it to get just the body\n    let final_body = if let Some(ref new_content) = hook_result.content {\n        // Parse the hook's content to extract just the body (in case it includes frontmatter)\n        let content_parsed = parse_frontmatter(new_content).map_err(|e| e.to_string())?;\n        content_parsed.body\n    } else {\n        original_parsed.body\n    };\n\n    // Rebuild the document\n    let final_content = if final_frontmatter.is_null() {\n        final_body\n    } else {\n        let yaml_str =\n            serde_yaml::to_string(\u0026final_frontmatter).map_err(|e| e.to_string())?;\n        format!(\"---\\n{}---\\n{}\", yaml_str, final_body)\n    };\n\n    // Write back to file\n    fs::write(output_path, final_content).map_err(|e| e.to_string())\n}\n\n/// Log a creation event to today's daily note.\n/// Creates the daily note if it doesn't exist.\nfn log_to_daily(\n    cfg: \u0026ResolvedConfig,\n    note_type: \u0026str,\n    title: \u0026str,\n    note_id: \u0026str,\n    output_path: \u0026Path,\n) {\n    let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n    let time = chrono::Local::now().format(\"%H:%M\").to_string();\n\n    // Build daily note path (default pattern: Journal/Daily/YYYY-MM-DD.md)\n    let daily_path = cfg.vault_root.join(format!(\"Journal/Daily/{}.md\", today));\n\n    // Ensure parent directory exists\n    if let Some(parent) = daily_path.parent() {\n        if let Err(e) = fs::create_dir_all(parent) {\n            eprintln!(\"Warning: could not create daily directory: {e}\");\n            return;\n        }\n    }\n\n    // Read or create daily note\n    let mut content = match fs::read_to_string(\u0026daily_path) {\n        Ok(c) =\u003e c,\n        Err(e) if e.kind() == std::io::ErrorKind::NotFound =\u003e {\n            // Create minimal daily note\n            let content = format!(\n                \"---\\ntype: daily\\ndate: {}\\n---\\n\\n# {}\\n\\n## Log\\n\",\n                today, today\n            );\n            if let Err(e) = fs::write(\u0026daily_path, \u0026content) {\n                eprintln!(\"Warning: could not create daily note: {e}\");\n                return;\n            }\n            println!(\"Created daily note: {}\", daily_path.display());\n            content\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Warning: could not read daily note: {e}\");\n            return;\n        }\n    };\n\n    // Build the log entry with link to the note\n    let rel_path = output_path.strip_prefix(\u0026cfg.vault_root).unwrap_or(output_path);\n    let link = rel_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"note\");\n\n    // Format: \"- **HH:MM** Created task [MCP-001]: [[MCP-001|Title]]\"\n    let id_display =\n        if note_id.is_empty() { String::new() } else { format!(\" [{}]\", note_id) };\n\n    let log_entry = format!(\n        \"- **{}** Created {}{}: [[{}|{}]]\\n\",\n        time, note_type, id_display, link, title\n    );\n\n    // Find the Log section and append, or append at end\n    if let Some(log_pos) = content.find(\"## Log\") {\n        // Find the end of the Log section (next ## or end of file)\n        let after_log = \u0026content[log_pos + 6..]; // Skip \"## Log\"\n        let insert_pos = if let Some(next_section) = after_log.find(\"\\n## \") {\n            log_pos + 6 + next_section\n        } else {\n            content.len()\n        };\n\n        // Insert the log entry\n        content.insert_str(insert_pos, \u0026format!(\"\\n{}\", log_entry));\n    } else {\n        // No Log section, add one\n        content.push_str(\u0026format!(\"\\n## Log\\n{}\", log_entry));\n    }\n\n    // Write back\n    if let Err(e) = fs::write(\u0026daily_path, \u0026content) {\n        eprintln!(\"Warning: could not update daily note: {e}\");\n    }\n}\n\n/// Query existing projects from the index and prompt user to select one.\n/// Returns None if user cancels, Some(\"inbox\") for inbox, or Some(project_name) for a project.\nfn prompt_project_selection(cfg: \u0026ResolvedConfig) -\u003e Option\u003cString\u003e {\n    // Open the index database\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(_) =\u003e {\n            // No index yet, default to inbox\n            println!(\"No index found. Task will go to inbox.\");\n            return Some(\"inbox\".to_string());\n        }\n    };\n\n    // Query all projects\n    let query = NoteQuery { note_type: Some(NoteType::Project), ..Default::default() };\n\n    let projects = match db.query_notes(\u0026query) {\n        Ok(p) =\u003e p,\n        Err(_) =\u003e return Some(\"inbox\".to_string()),\n    };\n\n    // Build selection items: inbox first, then projects\n    let mut items: Vec\u003cString\u003e = vec![\"Inbox (no project - for triage)\".to_string()];\n\n    for p in \u0026projects {\n        let title = if p.title.is_empty() { \"Untitled\" } else { \u0026p.title };\n        items.push(title.to_string());\n    }\n\n    // Show selector\n    let selection = Select::with_theme(\u0026ColorfulTheme::default())\n        .with_prompt(\"Select project for this task\")\n        .items(\u0026items)\n        .default(0)\n        .interact_opt()\n        .ok()?;\n\n    // Handle selection\n    selection.map(|idx| {\n        if idx == 0 {\n            // Inbox selected\n            \"inbox\".to_string()\n        } else {\n            // Project selected (idx - 1 because inbox is at 0)\n            let project = \u0026projects[idx - 1];\n            project\n                .path\n                .file_stem()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"project\")\n                .to_string()\n        }\n    })\n}\n\n/// Collect variables from Lua schema fields that have `prompt` set.\n/// Prompts for fields that:\n/// - Have `prompt` defined (the prompt text to show)\n/// - Are not already provided in `provided_vars`\n/// - Are not marked as `core` (managed by Rust)\nfn collect_schema_variables(\n    typedef: \u0026TypeDefinition,\n    provided_vars: \u0026HashMap\u003cString, String\u003e,\n    options: \u0026PromptOptions,\n) -\u003e Result\u003cCollectedVars, String\u003e {\n    let mut result = CollectedVars {\n        values: HashMap::new(),\n        prompted: Vec::new(),\n        defaulted: Vec::new(),\n    };\n\n    // Start with provided vars\n    for (k, v) in provided_vars {\n        result.values.insert(k.clone(), v.clone());\n    }\n\n    // Process schema fields in alphabetical order for consistency\n    let mut fields: Vec\u003c_\u003e = typedef.schema.iter().collect();\n    fields.sort_by(|a, b| a.0.cmp(b.0));\n\n    for (field_name, schema) in fields {\n        // Skip if already provided\n        if result.values.contains_key(field_name) {\n            continue;\n        }\n\n        // Skip core fields (managed by Rust)\n        if schema.core {\n            continue;\n        }\n\n        // If field has a prompt, ask the user\n        if let Some(ref prompt_text) = schema.prompt {\n            if options.batch_mode {\n                // In batch mode, use default or fail if required\n                if let Some(ref default) = schema.default {\n                    let value = yaml_value_to_string(default);\n                    result.values.insert(field_name.clone(), value);\n                    result.defaulted.push(field_name.clone());\n                } else if schema.required {\n                    return Err(format!(\n                        \"Missing required field '{}' in batch mode\",\n                        field_name\n                    ));\n                }\n            } else {\n                // Interactive: prompt for field\n                let enum_values = schema.enum_values.as_deref();\n                let default_str = schema.default.as_ref().map(yaml_value_to_string);\n\n                match prompt_for_schema_field(\n                    field_name,\n                    prompt_text,\n                    enum_values,\n                    default_str.as_deref(),\n                    schema.required,\n                    schema.multiline,\n                ) {\n                    Ok(value) if !value.is_empty() =\u003e {\n                        result.values.insert(field_name.clone(), value);\n                        result.prompted.push(field_name.clone());\n                    }\n                    Ok(_) =\u003e {\n                        // Empty value - use default if available\n                        if let Some(ref default) = schema.default {\n                            result.values.insert(\n                                field_name.clone(),\n                                yaml_value_to_string(default),\n                            );\n                            result.defaulted.push(field_name.clone());\n                        }\n                        result.prompted.push(field_name.clone());\n                    }\n                    Err(e) =\u003e return Err(e),\n                }\n            }\n        } else if let Some(ref default) = schema.default {\n            // No prompt but has default - use it\n            result.values.insert(field_name.clone(), yaml_value_to_string(default));\n            result.defaulted.push(field_name.clone());\n        }\n    }\n\n    Ok(result)\n}\n\n/// Prompt for a single schema field value.\n///\n/// Uses different widgets based on field type:\n/// - Enum fields: Select widget for choosing from options\n/// - Multiline fields: Editor widget for multi-line text\n/// - Other fields: Input widget for single-line text\nfn prompt_for_schema_field(\n    field_name: \u0026str,\n    prompt_text: \u0026str,\n    enum_values: Option\u003c\u0026[String]\u003e,\n    default: Option\u003c\u0026str\u003e,\n    required: bool,\n    multiline: bool,\n) -\u003e Result\u003cString, String\u003e {\n    let theme = ColorfulTheme::default();\n\n    // If enum values provided, use Select widget\n    if let Some(values) = enum_values {\n        let default_idx =\n            default.and_then(|d| values.iter().position(|v| v == d)).unwrap_or(0);\n\n        let selection = Select::with_theme(\u0026theme)\n            .with_prompt(prompt_text)\n            .items(values)\n            .default(default_idx)\n            .interact_opt()\n            .map_err(|e| {\n                format!(\"Failed to read selection for '{}': {}\", field_name, e)\n            })?;\n\n        return match selection {\n            Some(idx) =\u003e Ok(values[idx].clone()),\n            None =\u003e {\n                // User cancelled - use default if available, else empty\n                Ok(default.unwrap_or(\"\").to_string())\n            }\n        };\n    }\n\n    // If multiline, use Editor widget\n    if multiline {\n        let initial = default.unwrap_or(\"\");\n        let content = Editor::new()\n            .edit(initial)\n            .map_err(|e| format!(\"Editor error for '{}': {}\", field_name, e))?\n            .unwrap_or_else(|| initial.to_string());\n        return Ok(content);\n    }\n\n    // Default: use Input widget\n    let mut builder = Input::\u003cString\u003e::with_theme(\u0026theme).with_prompt(prompt_text);\n\n    if let Some(def) = default {\n        builder = builder.default(def.to_string());\n    }\n\n    builder = builder.allow_empty(!required);\n\n    builder\n        .interact_text()\n        .map_err(|e| format!(\"Failed to read input for '{}': {}\", field_name, e))\n}\n\n/// Convert a serde_yaml::Value to a string for template context.\nfn yaml_value_to_string(value: \u0026serde_yaml::Value) -\u003e String {\n    match value {\n        serde_yaml::Value::String(s) =\u003e s.clone(),\n        serde_yaml::Value::Number(n) =\u003e n.to_string(),\n        serde_yaml::Value::Bool(b) =\u003e b.to_string(),\n        serde_yaml::Value::Null =\u003e String::new(),\n        other =\u003e serde_yaml::to_string(other).unwrap_or_default().trim().to_string(),\n    }\n}\n\n/// Render an output path template with variable substitution.\n/// Uses the template engine to support filters like `{{title | slugify}}`.\nfn render_output_path(\n    template: \u0026str,\n    cfg: \u0026ResolvedConfig,\n    ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003cPathBuf, String\u003e {\n    // Use the template engine to render with filter support\n    let rendered = render_string(template, ctx).map_err(|e| e.to_string())?;\n\n    // Make path absolute relative to vault root\n    let path = PathBuf::from(\u0026rendered);\n    if path.is_absolute() {\n        Ok(path)\n    } else {\n        Ok(cfg.vault_root.join(path))\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":10}},{"line":46,"address":[],"length":0,"stats":{"Line":30}},{"line":47,"address":[],"length":0,"stats":{"Line":20}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":30}},{"line":61,"address":[],"length":0,"stats":{"Line":30}},{"line":62,"address":[],"length":0,"stats":{"Line":10}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":10}},{"line":75,"address":[],"length":0,"stats":{"Line":20}},{"line":76,"address":[],"length":0,"stats":{"Line":20}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":30}},{"line":85,"address":[],"length":0,"stats":{"Line":20}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":30}},{"line":101,"address":[],"length":0,"stats":{"Line":10}},{"line":105,"address":[],"length":0,"stats":{"Line":20}},{"line":106,"address":[],"length":0,"stats":{"Line":50}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":50}},{"line":123,"address":[],"length":0,"stats":{"Line":60}},{"line":124,"address":[],"length":0,"stats":{"Line":10}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":10}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":40}},{"line":139,"address":[],"length":0,"stats":{"Line":20}},{"line":141,"address":[],"length":0,"stats":{"Line":20}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":30}},{"line":154,"address":[],"length":0,"stats":{"Line":10}},{"line":155,"address":[],"length":0,"stats":{"Line":10}},{"line":160,"address":[],"length":0,"stats":{"Line":20}},{"line":161,"address":[],"length":0,"stats":{"Line":18}},{"line":162,"address":[],"length":0,"stats":{"Line":6}},{"line":166,"address":[],"length":0,"stats":{"Line":24}},{"line":167,"address":[],"length":0,"stats":{"Line":10}},{"line":170,"address":[],"length":0,"stats":{"Line":20}},{"line":171,"address":[],"length":0,"stats":{"Line":8}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":18}},{"line":206,"address":[],"length":0,"stats":{"Line":18}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":54}},{"line":213,"address":[],"length":0,"stats":{"Line":54}},{"line":214,"address":[],"length":0,"stats":{"Line":45}},{"line":216,"address":[],"length":0,"stats":{"Line":27}},{"line":217,"address":[],"length":0,"stats":{"Line":45}},{"line":220,"address":[],"length":0,"stats":{"Line":9}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":27}},{"line":229,"address":[],"length":0,"stats":{"Line":18}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":18}},{"line":237,"address":[],"length":0,"stats":{"Line":9}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":18}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":27}},{"line":250,"address":[],"length":0,"stats":{"Line":9}},{"line":251,"address":[],"length":0,"stats":{"Line":9}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":18}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":18}},{"line":283,"address":[],"length":0,"stats":{"Line":18}},{"line":284,"address":[],"length":0,"stats":{"Line":27}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":9}},{"line":937,"address":[],"length":0,"stats":{"Line":36}},{"line":938,"address":[],"length":0,"stats":{"Line":18}},{"line":940,"address":[],"length":0,"stats":{"Line":6}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":2}},{"line":948,"address":[],"length":0,"stats":{"Line":9}},{"line":954,"address":[],"length":0,"stats":{"Line":9}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":9}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":0}},{"line":1048,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":0}},{"line":1054,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1090,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[],"length":0,"stats":{"Line":0}},{"line":1094,"address":[],"length":0,"stats":{"Line":0}},{"line":1098,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":0}},{"line":1100,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":0}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1106,"address":[],"length":0,"stats":{"Line":0}},{"line":1107,"address":[],"length":0,"stats":{"Line":0}},{"line":1112,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1116,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[],"length":0,"stats":{"Line":0}},{"line":1119,"address":[],"length":0,"stats":{"Line":0}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":0}},{"line":1128,"address":[],"length":0,"stats":{"Line":0}},{"line":1129,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":0}},{"line":1135,"address":[],"length":0,"stats":{"Line":0}},{"line":1138,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":0}},{"line":1149,"address":[],"length":0,"stats":{"Line":0}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1152,"address":[],"length":0,"stats":{"Line":0}},{"line":1153,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1162,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1173,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":0}},{"line":1178,"address":[],"length":0,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1187,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1192,"address":[],"length":0,"stats":{"Line":0}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[],"length":0,"stats":{"Line":0}},{"line":1195,"address":[],"length":0,"stats":{"Line":0}},{"line":1196,"address":[],"length":0,"stats":{"Line":0}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1198,"address":[],"length":0,"stats":{"Line":0}},{"line":1208,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1220,"address":[],"length":0,"stats":{"Line":0}},{"line":1221,"address":[],"length":0,"stats":{"Line":0}},{"line":1225,"address":[],"length":0,"stats":{"Line":0}},{"line":1226,"address":[],"length":0,"stats":{"Line":0}},{"line":1228,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[],"length":0,"stats":{"Line":0}},{"line":1231,"address":[],"length":0,"stats":{"Line":0}},{"line":1235,"address":[],"length":0,"stats":{"Line":0}},{"line":1236,"address":[],"length":0,"stats":{"Line":0}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[],"length":0,"stats":{"Line":0}},{"line":1243,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[],"length":0,"stats":{"Line":0}},{"line":1246,"address":[],"length":0,"stats":{"Line":0}},{"line":1247,"address":[],"length":0,"stats":{"Line":0}},{"line":1248,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1250,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1259,"address":[],"length":0,"stats":{"Line":0}},{"line":1260,"address":[],"length":0,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1263,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[],"length":0,"stats":{"Line":0}},{"line":1266,"address":[],"length":0,"stats":{"Line":0}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[],"length":0,"stats":{"Line":0}},{"line":1272,"address":[],"length":0,"stats":{"Line":0}},{"line":1273,"address":[],"length":0,"stats":{"Line":0}},{"line":1274,"address":[],"length":0,"stats":{"Line":0}},{"line":1275,"address":[],"length":0,"stats":{"Line":0}},{"line":1277,"address":[],"length":0,"stats":{"Line":0}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1281,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1286,"address":[],"length":0,"stats":{"Line":0}},{"line":1287,"address":[],"length":0,"stats":{"Line":0}},{"line":1291,"address":[],"length":0,"stats":{"Line":0}},{"line":1300,"address":[],"length":0,"stats":{"Line":0}},{"line":1308,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1312,"address":[],"length":0,"stats":{"Line":0}},{"line":1313,"address":[],"length":0,"stats":{"Line":0}},{"line":1315,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":0}},{"line":1317,"address":[],"length":0,"stats":{"Line":0}},{"line":1318,"address":[],"length":0,"stats":{"Line":0}},{"line":1320,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1324,"address":[],"length":0,"stats":{"Line":0}},{"line":1325,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1334,"address":[],"length":0,"stats":{"Line":0}},{"line":1335,"address":[],"length":0,"stats":{"Line":0}},{"line":1336,"address":[],"length":0,"stats":{"Line":0}},{"line":1337,"address":[],"length":0,"stats":{"Line":0}},{"line":1338,"address":[],"length":0,"stats":{"Line":0}},{"line":1339,"address":[],"length":0,"stats":{"Line":0}},{"line":1340,"address":[],"length":0,"stats":{"Line":0}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1350,"address":[],"length":0,"stats":{"Line":0}},{"line":1352,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1361,"address":[],"length":0,"stats":{"Line":0}},{"line":1362,"address":[],"length":0,"stats":{"Line":0}},{"line":1363,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":0}},{"line":1370,"address":[],"length":0,"stats":{"Line":0}},{"line":1376,"address":[],"length":0,"stats":{"Line":0}},{"line":1379,"address":[],"length":0,"stats":{"Line":0}},{"line":1380,"address":[],"length":0,"stats":{"Line":0}},{"line":1381,"address":[],"length":0,"stats":{"Line":0}},{"line":1383,"address":[],"length":0,"stats":{"Line":0}}],"covered":64,"coverable":683},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","orphans.rs"],"content":"//! Orphans command implementation.\n\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::IndexDb;\n\nuse super::output::{print_notes_json, print_notes_quiet, print_notes_table};\nuse crate::{OrphansArgs, OutputFormat};\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: OrphansArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Find orphans\n    let orphans = match db.find_orphans() {\n        Ok(notes) =\u003e notes,\n        Err(e) =\u003e {\n            eprintln!(\"Error finding orphans: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Resolve output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Output results\n    match format {\n        OutputFormat::Table =\u003e print_notes_table(\u0026orphans),\n        OutputFormat::Json =\u003e print_notes_json(\u0026orphans),\n        OutputFormat::Quiet =\u003e print_notes_quiet(\u0026orphans),\n    }\n}\n\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","output.rs"],"content":"//! Shared output formatting for query commands.\n\nuse mdvault_core::index::{IndexedLink, IndexedNote};\nuse serde::Serialize;\n\n/// Formatted note for JSON output.\n#[derive(Debug, Serialize)]\npub struct NoteOutput {\n    pub path: String,\n    #[serde(rename = \"type\")]\n    pub note_type: String,\n    pub title: String,\n    pub modified: String,\n}\n\nimpl From\u003c\u0026IndexedNote\u003e for NoteOutput {\n    fn from(note: \u0026IndexedNote) -\u003e Self {\n        Self {\n            path: note.path.to_string_lossy().to_string(),\n            note_type: note.note_type.as_str().to_string(),\n            title: note.title.clone(),\n            modified: note.modified.format(\"%Y-%m-%d %H:%M\").to_string(),\n        }\n    }\n}\n\n/// Formatted link for JSON output.\n#[derive(Debug, Serialize)]\npub struct LinkOutput {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub source_path: Option\u003cString\u003e,\n    pub target_path: String,\n    pub link_type: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub link_text: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub line_number: Option\u003cu32\u003e,\n}\n\nimpl LinkOutput {\n    pub fn from_link(link: \u0026IndexedLink, source_path: Option\u003c\u0026str\u003e) -\u003e Self {\n        Self {\n            source_path: source_path.map(|s| s.to_string()),\n            target_path: link.target_path.clone(),\n            link_type: link.link_type.as_str().to_string(),\n            link_text: link.link_text.clone(),\n            line_number: link.line_number,\n        }\n    }\n}\n\n/// Print notes as a table.\npub fn print_notes_table(notes: \u0026[IndexedNote]) {\n    if notes.is_empty() {\n        println!(\"(no notes found)\");\n        return;\n    }\n\n    // Calculate column widths\n    let path_width = notes\n        .iter()\n        .map(|n| n.path.to_string_lossy().len())\n        .max()\n        .unwrap_or(4)\n        .clamp(4, 50);\n    let type_width = 8; // \"project\" is longest\n    let title_width = notes.iter().map(|n| n.title.len()).max().unwrap_or(5).clamp(5, 40);\n\n    // Header\n    println!(\n        \"{:\u003cpath_width$}  {:\u003ctype_width$}  {:\u003ctitle_width$}  MODIFIED\",\n        \"PATH\",\n        \"TYPE\",\n        \"TITLE\",\n        path_width = path_width,\n        type_width = type_width,\n        title_width = title_width,\n    );\n    println!(\n        \"{:-\u003cpath_width$}  {:-\u003ctype_width$}  {:-\u003ctitle_width$}  {:-\u003c16}\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        path_width = path_width,\n        type_width = type_width,\n        title_width = title_width,\n    );\n\n    // Rows\n    for note in notes {\n        let path = truncate(\u0026note.path.to_string_lossy(), path_width);\n        let title = truncate(\u0026note.title, title_width);\n        let modified = note.modified.format(\"%Y-%m-%d %H:%M\").to_string();\n\n        println!(\n            \"{:\u003cpath_width$}  {:\u003ctype_width$}  {:\u003ctitle_width$}  {}\",\n            path,\n            note.note_type.as_str(),\n            title,\n            modified,\n            path_width = path_width,\n            type_width = type_width,\n            title_width = title_width,\n        );\n    }\n\n    println!();\n    println!(\"-- {} notes --\", notes.len());\n}\n\n/// Print notes as JSON.\npub fn print_notes_json(notes: \u0026[IndexedNote]) {\n    let output: Vec\u003cNoteOutput\u003e = notes.iter().map(NoteOutput::from).collect();\n    println!(\"{}\", serde_json::to_string_pretty(\u0026output).unwrap_or_default());\n}\n\n/// Print notes as paths only (quiet mode).\npub fn print_notes_quiet(notes: \u0026[IndexedNote]) {\n    for note in notes {\n        println!(\"{}\", note.path.display());\n    }\n}\n\n/// Print links as a table.\npub fn print_links_table(links: \u0026[LinkOutput], direction: \u0026str) {\n    if links.is_empty() {\n        println!(\"(no {} found)\", direction);\n        return;\n    }\n\n    let path_width = links\n        .iter()\n        .map(|l| {\n            l.target_path.len().max(l.source_path.as_ref().map(|s| s.len()).unwrap_or(0))\n        })\n        .max()\n        .unwrap_or(4)\n        .clamp(4, 50);\n    let type_width = 10;\n\n    println!(\n        \"{:\u003cpath_width$}  {:\u003ctype_width$}  LINE\",\n        \"PATH\",\n        \"LINK_TYPE\",\n        path_width = path_width,\n        type_width = type_width\n    );\n    println!(\n        \"{:-\u003cpath_width$}  {:-\u003ctype_width$}  {:-\u003c6}\",\n        \"\",\n        \"\",\n        \"\",\n        path_width = path_width,\n        type_width = type_width\n    );\n\n    for link in links {\n        let path = if direction == \"backlinks\" {\n            link.source_path.as_deref().unwrap_or(\u0026link.target_path)\n        } else {\n            \u0026link.target_path\n        };\n        let path = truncate(path, path_width);\n        let line =\n            link.line_number.map(|n| n.to_string()).unwrap_or_else(|| \"-\".to_string());\n\n        println!(\n            \"{:\u003cpath_width$}  {:\u003ctype_width$}  {}\",\n            path,\n            link.link_type,\n            line,\n            path_width = path_width,\n            type_width = type_width,\n        );\n    }\n\n    println!();\n    println!(\"-- {} {} --\", links.len(), direction);\n}\n\n/// Print links as JSON.\npub fn print_links_json(links: \u0026[LinkOutput]) {\n    println!(\"{}\", serde_json::to_string_pretty(\u0026links).unwrap_or_default());\n}\n\n/// Print links as paths only (quiet mode).\npub fn print_links_quiet(links: \u0026[LinkOutput], use_source: bool) {\n    for link in links {\n        if use_source {\n            if let Some(ref source) = link.source_path {\n                println!(\"{}\", source);\n            }\n        } else {\n            println!(\"{}\", link.target_path);\n        }\n    }\n}\n\n/// Truncate string with ellipsis if needed.\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else if max_len \u003e 3 {\n        format!(\"{}...\", \u0026s[..max_len - 3])\n    } else {\n        s[..max_len].to_string()\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":81},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","project.rs"],"content":"//! Project management commands.\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{IndexDb, IndexedNote, NoteQuery, NoteType};\nuse std::path::Path;\nuse tabled::{settings::Style, Table, Tabled};\n\n/// Row for project list table.\n#[derive(Tabled)]\nstruct ProjectRow {\n    #[tabled(rename = \"ID\")]\n    id: String,\n    #[tabled(rename = \"Title\")]\n    title: String,\n    #[tabled(rename = \"Status\")]\n    status: String,\n    #[tabled(rename = \"Open\")]\n    open: usize,\n    #[tabled(rename = \"Done\")]\n    done: usize,\n    #[tabled(rename = \"Total\")]\n    total: usize,\n}\n\n/// Row for task list in status view.\n#[derive(Tabled)]\nstruct TaskRow {\n    #[tabled(rename = \"ID\")]\n    id: String,\n    #[tabled(rename = \"Title\")]\n    title: String,\n    #[tabled(rename = \"Status\")]\n    status: String,\n}\n\n/// List all projects with task counts.\npub fn list(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, status_filter: Option\u003c\u0026str\u003e) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load config: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to open index: {e}\");\n            eprintln!(\"Run 'mdv reindex' first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Query all projects\n    let project_query =\n        NoteQuery { note_type: Some(NoteType::Project), ..Default::default() };\n\n    let projects = match db.query_notes(\u0026project_query) {\n        Ok(p) =\u003e p,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to query projects: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    if projects.is_empty() {\n        println!(\"No projects found.\");\n        println!(\"Create one with: mdv new project\");\n        return;\n    }\n\n    // Query all tasks to count per project\n    let task_query = NoteQuery { note_type: Some(NoteType::Task), ..Default::default() };\n    let tasks = db.query_notes(\u0026task_query).unwrap_or_default();\n\n    // Build table rows\n    let mut rows: Vec\u003cProjectRow\u003e = Vec::new();\n\n    for project in \u0026projects {\n        // Get project ID and status from frontmatter\n        let (project_id, project_status) = extract_project_info(project);\n\n        // Filter by status if specified\n        if let Some(filter) = status_filter {\n            if project_status != filter {\n                continue;\n            }\n        }\n\n        let title = if project.title.is_empty() {\n            project\n                .path\n                .file_stem()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"Untitled\")\n                .to_string()\n        } else {\n            project.title.clone()\n        };\n\n        // Count tasks for this project\n        let project_folder =\n            project.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n\n        let project_tasks: Vec\u003c_\u003e = tasks\n            .iter()\n            .filter(|t| {\n                let path_str = t.path.to_string_lossy();\n                path_str.contains(\u0026format!(\"Projects/{}/\", project_folder))\n            })\n            .collect();\n\n        let total = project_tasks.len();\n        let done = project_tasks\n            .iter()\n            .filter(|t| {\n                get_task_status(t)\n                    .map(|s| s == \"done\" || s == \"completed\")\n                    .unwrap_or(false)\n            })\n            .count();\n        let open = total - done;\n\n        rows.push(ProjectRow {\n            id: project_id,\n            title,\n            status: project_status,\n            open,\n            done,\n            total,\n        });\n    }\n\n    if rows.is_empty() {\n        println!(\"No projects match the filter.\");\n        return;\n    }\n\n    let table = Table::new(\u0026rows).with(Style::rounded()).to_string();\n\n    println!(\"{}\", table);\n    println!(\"\\nTotal: {} projects\", rows.len());\n}\n\n/// Show project status with tasks in kanban-style columns.\npub fn status(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, project_name: \u0026str) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load config: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to open index: {e}\");\n            eprintln!(\"Run 'mdv reindex' first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Find the project\n    let project_query =\n        NoteQuery { note_type: Some(NoteType::Project), ..Default::default() };\n    let projects = db.query_notes(\u0026project_query).unwrap_or_default();\n\n    let project = projects.iter().find(|p| {\n        let folder = p.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n        let (id, _) = extract_project_info(p);\n        folder.eq_ignore_ascii_case(project_name) || id.eq_ignore_ascii_case(project_name)\n    });\n\n    let project = match project {\n        Some(p) =\u003e p,\n        None =\u003e {\n            eprintln!(\"Project not found: {}\", project_name);\n            eprintln!(\"Run 'mdv project list' to see available projects.\");\n            std::process::exit(1);\n        }\n    };\n\n    let project_folder = project.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let (project_id, project_status) = extract_project_info(project);\n    let project_title = if project.title.is_empty() {\n        project_folder.to_string()\n    } else {\n        project.title.clone()\n    };\n\n    // Print project header\n    println!(\"Project: {} [{}]\", project_title, project_id);\n    println!(\"Status:  {}\", project_status);\n    println!();\n\n    // Query all tasks\n    let task_query = NoteQuery { note_type: Some(NoteType::Task), ..Default::default() };\n    let all_tasks = db.query_notes(\u0026task_query).unwrap_or_default();\n\n    // Filter tasks for this project\n    let project_tasks: Vec\u003c_\u003e = all_tasks\n        .into_iter()\n        .filter(|t| {\n            let path_str = t.path.to_string_lossy();\n            path_str.contains(\u0026format!(\"Projects/{}/\", project_folder))\n                || path_str.contains(\u0026format!(\"projects/{}/\", project_folder))\n        })\n        .collect();\n\n    if project_tasks.is_empty() {\n        println!(\"No tasks found for this project.\");\n        println!(\"Create one with: mdv new task\");\n        return;\n    }\n\n    // Group tasks by status\n    let mut todo: Vec\u003c\u0026IndexedNote\u003e = vec![];\n    let mut in_progress: Vec\u003c\u0026IndexedNote\u003e = vec![];\n    let mut blocked: Vec\u003c\u0026IndexedNote\u003e = vec![];\n    let mut done: Vec\u003c\u0026IndexedNote\u003e = vec![];\n\n    for task in \u0026project_tasks {\n        let status = get_task_status(task).unwrap_or_else(|| \"todo\".to_string());\n\n        match status.as_str() {\n            \"todo\" | \"open\" =\u003e todo.push(task),\n            \"in-progress\" | \"in_progress\" | \"doing\" =\u003e in_progress.push(task),\n            \"blocked\" | \"waiting\" =\u003e blocked.push(task),\n            \"done\" | \"completed\" =\u003e done.push(task),\n            _ =\u003e todo.push(task),\n        }\n    }\n\n    // Print summary\n    println!(\"Task Summary:\");\n    println!(\"  TODO:        {}\", todo.len());\n    println!(\"  In Progress: {}\", in_progress.len());\n    println!(\"  Blocked:     {}\", blocked.len());\n    println!(\"  Done:        {}\", done.len());\n    println!(\"  Total:       {}\", project_tasks.len());\n    println!();\n\n    // Print task tables by status\n    if !todo.is_empty() {\n        println!(\"TODO:\");\n        print_task_table(\u0026todo);\n        println!();\n    }\n\n    if !in_progress.is_empty() {\n        println!(\"IN PROGRESS:\");\n        print_task_table(\u0026in_progress);\n        println!();\n    }\n\n    if !blocked.is_empty() {\n        println!(\"BLOCKED:\");\n        print_task_table(\u0026blocked);\n        println!();\n    }\n\n    if !done.is_empty() {\n        println!(\"DONE:\");\n        print_task_table(\u0026done);\n        println!();\n    }\n}\n\n/// Print a table of tasks.\nfn print_task_table(tasks: \u0026[\u0026IndexedNote]) {\n    let rows: Vec\u003cTaskRow\u003e = tasks\n        .iter()\n        .map(|task| {\n            let task_id = get_task_id(task).unwrap_or_else(|| \"-\".to_string());\n            let title = if task.title.is_empty() {\n                task.path\n                    .file_stem()\n                    .and_then(|s| s.to_str())\n                    .unwrap_or(\"Untitled\")\n                    .to_string()\n            } else {\n                task.title.clone()\n            };\n            let status = get_task_status(task).unwrap_or_else(|| \"unknown\".to_string());\n\n            TaskRow { id: task_id, title, status }\n        })\n        .collect();\n\n    let table = Table::new(\u0026rows).with(Style::rounded()).to_string();\n\n    println!(\"{}\", table);\n}\n\n/// Extract project ID and status from frontmatter.\nfn extract_project_info(project: \u0026IndexedNote) -\u003e (String, String) {\n    let fm = project\n        .frontmatter_json\n        .as_ref()\n        .and_then(|fm| serde_json::from_str::\u003cserde_json::Value\u003e(fm).ok());\n\n    let id = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"project-id\").and_then(|v| v.as_str()))\n        .map(String::from)\n        .unwrap_or_else(|| {\n            project.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"???\").to_string()\n        });\n\n    let status = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"status\").and_then(|v| v.as_str()))\n        .map(String::from)\n        .unwrap_or_else(|| \"unknown\".to_string());\n\n    (id, status)\n}\n\n/// Get task status from frontmatter.\nfn get_task_status(task: \u0026IndexedNote) -\u003e Option\u003cString\u003e {\n    task.frontmatter_json\n        .as_ref()\n        .and_then(|fm| serde_json::from_str::\u003cserde_json::Value\u003e(fm).ok())\n        .and_then(|fm| fm.get(\"status\").and_then(|v| v.as_str()).map(String::from))\n}\n\n/// Get task ID from frontmatter.\nfn get_task_id(task: \u0026IndexedNote) -\u003e Option\u003cString\u003e {\n    task.frontmatter_json\n        .as_ref()\n        .and_then(|fm| serde_json::from_str::\u003cserde_json::Value\u003e(fm).ok())\n        .and_then(|fm| fm.get(\"task-id\").and_then(|v| v.as_str()).map(String::from))\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":179},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","reindex.rs"],"content":"//! Reindex command implementation.\n\nuse std::io::Write;\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{DerivedIndexBuilder, IndexBuilder, IndexDb};\n\n/// Run the reindex command.\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, verbose: bool, force: bool) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Determine index path\n    let index_dir = rc.vault_root.join(\".mdvault\");\n    let index_path = index_dir.join(\"index.db\");\n\n    // Ensure .mdvault directory exists\n    if let Err(e) = std::fs::create_dir_all(\u0026index_dir) {\n        eprintln!(\"Error creating index directory: {}\", e);\n        std::process::exit(1);\n    }\n\n    // Open database\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index database: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    let mode = if force { \"full\" } else { \"incremental\" };\n    println!(\"Indexing vault ({} mode): {}\", mode, rc.vault_root.display());\n\n    // Create progress callback\n    let progress: Option\u003cmdvault_core::index::ProgressCallback\u003e = if verbose {\n        Some(Box::new(|current, total, path| {\n            println!(\"[{}/{}] {}\", current, total, path);\n        }))\n    } else {\n        Some(Box::new(|current, total, _path| {\n            // Simple progress indicator\n            if current % 50 == 0 || current == total {\n                print!(\"\\rScanning... {}/{}\", current, total);\n                std::io::stdout().flush().ok();\n            }\n        }))\n    };\n\n    // Build index\n    let builder = IndexBuilder::new(\u0026db, \u0026rc.vault_root);\n    let result = if force {\n        builder.full_reindex(progress)\n    } else {\n        builder.incremental_reindex(progress)\n    };\n\n    match result {\n        Ok(stats) =\u003e {\n            if !verbose {\n                println!(); // Newline after progress\n            }\n            println!();\n            println!(\"Indexing complete:\");\n            println!(\"  Files found:    {}\", stats.files_found);\n\n            if force {\n                // Full reindex stats\n                println!(\"  Notes indexed:  {}\", stats.notes_indexed);\n            } else {\n                // Incremental stats\n                println!(\"  Unchanged:      {}\", stats.files_unchanged);\n                println!(\"  Added:          {}\", stats.files_added);\n                println!(\"  Updated:        {}\", stats.files_updated);\n                println!(\"  Deleted:        {}\", stats.files_deleted);\n            }\n\n            if stats.notes_skipped \u003e 0 {\n                println!(\"  Skipped:        {}\", stats.notes_skipped);\n            }\n            println!(\"  Links indexed:  {}\", stats.links_indexed);\n            println!(\"  Broken links:   {}\", stats.broken_links);\n            println!(\"  Duration:       {}ms\", stats.duration_ms);\n\n            // Compute derived indices\n            if verbose {\n                println!();\n                println!(\"Computing derived indices...\");\n            }\n            let derived_builder = DerivedIndexBuilder::new(\u0026db);\n            match derived_builder.compute_all() {\n                Ok(derived_stats) =\u003e {\n                    println!();\n                    println!(\"Derived indices:\");\n                    println!(\n                        \"  Dailies processed:    {}\",\n                        derived_stats.dailies_processed\n                    );\n                    println!(\n                        \"  Activity records:     {}\",\n                        derived_stats.activity_records\n                    );\n                    println!(\n                        \"  Activity summaries:   {}\",\n                        derived_stats.summaries_computed\n                    );\n                    println!(\n                        \"  Cooccurrence pairs:   {}\",\n                        derived_stats.cooccurrence_pairs\n                    );\n                    println!(\"  Duration:             {}ms\", derived_stats.duration_ms);\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"Warning: Failed to compute derived indices: {}\", e);\n                }\n            }\n\n            println!();\n            println!(\"Index stored at: {}\", index_path.display());\n        }\n        Err(e) =\u003e {\n            eprintln!(\"\\nError during indexing: {}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":75},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","rename.rs"],"content":"//! Rename command implementation.\n\nuse std::io::{self, Write};\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::IndexDb;\nuse mdvault_core::rename::{\n    execute_rename, generate_preview, FileChange, RenameError, RenamePreview,\n};\n\nuse crate::RenameArgs;\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: RenameArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Generate preview\n    let preview = match generate_preview(\u0026db, \u0026rc.vault_root, \u0026args.source, \u0026args.dest) {\n        Ok(p) =\u003e p,\n        Err(e) =\u003e {\n            print_error(\u0026e);\n            std::process::exit(1);\n        }\n    };\n\n    // Display preview\n    print_preview(\u0026preview, \u0026rc.vault_root);\n\n    // If dry-run, stop here\n    if args.dry_run {\n        println!();\n        println!(\"(dry-run mode - no changes made)\");\n        return;\n    }\n\n    // Confirm unless --yes\n    if !args.yes \u0026\u0026 !confirm_rename() {\n        println!(\"Cancelled.\");\n        return;\n    }\n\n    // Execute rename\n    match execute_rename(\u0026db, \u0026rc.vault_root, \u0026args.source, \u0026args.dest) {\n        Ok(result) =\u003e {\n            println!();\n            println!(\n                \"Renamed: {} -\u003e {}\",\n                result\n                    .old_path\n                    .strip_prefix(\u0026rc.vault_root)\n                    .unwrap_or(\u0026result.old_path)\n                    .display(),\n                result\n                    .new_path\n                    .strip_prefix(\u0026rc.vault_root)\n                    .unwrap_or(\u0026result.new_path)\n                    .display()\n            );\n            println!(\"Files modified: {}\", result.files_modified.len());\n            println!(\"References updated: {}\", result.references_updated);\n\n            // Print any warnings\n            for warning in \u0026result.warnings {\n                eprintln!(\"{}\", warning);\n            }\n        }\n        Err(e) =\u003e {\n            print_error(\u0026e);\n            std::process::exit(1);\n        }\n    }\n}\n\nfn print_error(e: \u0026RenameError) {\n    match e {\n        RenameError::SourceNotFound(path) =\u003e {\n            eprintln!(\"Error: Source file not found: {}\", path.display());\n        }\n        RenameError::TargetExists(path) =\u003e {\n            eprintln!(\"Error: Target file already exists: {}\", path.display());\n        }\n        RenameError::NoteNotInIndex(path) =\u003e {\n            eprintln!(\"Error: Note not found in index: {}\", path.display());\n            eprintln!(\"Hint: Run 'mdv reindex' to update the index.\");\n        }\n        _ =\u003e {\n            eprintln!(\"Error: {}\", e);\n        }\n    }\n}\n\nfn print_preview(preview: \u0026RenamePreview, vault_root: \u0026Path) {\n    let old_rel = preview.old_path.strip_prefix(vault_root).unwrap_or(\u0026preview.old_path);\n    let new_rel = preview.new_path.strip_prefix(vault_root).unwrap_or(\u0026preview.new_path);\n\n    println!(\"Renaming: {} -\u003e {}\", old_rel.display(), new_rel.display());\n    println!();\n\n    if preview.references.is_empty() {\n        println!(\"No references found to update.\");\n    } else {\n        println!(\n            \"Found {} reference(s) in {} file(s):\",\n            preview.total_references(),\n            preview.files_affected()\n        );\n        println!();\n\n        for change in \u0026preview.changes {\n            print_file_change(change, vault_root);\n        }\n    }\n\n    // Print warnings\n    for warning in \u0026preview.warnings {\n        println!();\n        eprintln!(\"{}\", warning);\n    }\n}\n\nfn print_file_change(change: \u0026FileChange, vault_root: \u0026Path) {\n    let rel_path = change.path.strip_prefix(vault_root).unwrap_or(\u0026change.path);\n    println!(\"{}:\", rel_path.display());\n\n    for reference in \u0026change.references {\n        let location = if reference.line_number \u003e 0 {\n            format!(\"  Line {}:\", reference.line_number)\n        } else {\n            \"  Frontmatter:\".to_string()\n        };\n\n        // Show the original reference\n        println!(\"{} {}\", location, reference.original);\n    }\n\n    println!();\n}\n\nfn confirm_rename() -\u003e bool {\n    print!(\"Proceed? [y/N] \");\n    io::stdout().flush().unwrap();\n\n    let mut input = String::new();\n    if io::stdin().read_line(\u0026mut input).is_err() {\n        return false;\n    }\n\n    let input = input.trim().to_lowercase();\n    input == \"y\" || input == \"yes\"\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":93},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","search.rs"],"content":"//! Search command implementation.\n\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{\n    IndexDb, MatchSource, SearchEngine, SearchMode, SearchQuery, SearchResult,\n};\nuse serde::Serialize;\n\nuse crate::{OutputFormat, SearchArgs, SearchModeArg};\n\n/// Search result for JSON output.\n#[derive(Debug, Serialize)]\nstruct SearchResultOutput {\n    path: String,\n    #[serde(rename = \"type\")]\n    note_type: String,\n    title: String,\n    score: f64,\n    match_source: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    staleness: Option\u003cf64\u003e,\n}\n\nimpl From\u003c\u0026SearchResult\u003e for SearchResultOutput {\n    fn from(result: \u0026SearchResult) -\u003e Self {\n        Self {\n            path: result.note.path.to_string_lossy().to_string(),\n            note_type: result.note.note_type.as_str().to_string(),\n            title: result.note.title.clone(),\n            score: result.score,\n            match_source: format_match_source(\u0026result.match_source),\n            staleness: result.staleness,\n        }\n    }\n}\n\nfn format_match_source(source: \u0026MatchSource) -\u003e String {\n    match source {\n        MatchSource::Direct =\u003e \"direct\".to_string(),\n        MatchSource::Linked { hops } =\u003e format!(\"linked({})\", hops),\n        MatchSource::Temporal { daily_path } =\u003e format!(\"temporal({})\", daily_path),\n        MatchSource::Cooccurrence { shared_dailies } =\u003e {\n            format!(\"cooccur({})\", shared_dailies)\n        }\n    }\n}\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: SearchArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Convert search mode\n    let mode = match args.mode {\n        SearchModeArg::Direct =\u003e SearchMode::Direct,\n        SearchModeArg::Neighbourhood =\u003e SearchMode::Neighbourhood { hops: 2 },\n        SearchModeArg::Temporal =\u003e SearchMode::Temporal { days: 30 },\n        SearchModeArg::Cooccurrence =\u003e SearchMode::Cooccurrence { min_shared: 2 },\n        SearchModeArg::Full =\u003e SearchMode::Full,\n    };\n\n    // Build search query\n    let query = SearchQuery {\n        text: args.query,\n        note_type: args.r#type.map(|t| t.into()),\n        path_prefix: None,\n        mode,\n        limit: args.limit,\n        temporal_boost: args.boost,\n    };\n\n    // Execute search\n    let engine = SearchEngine::new(\u0026db);\n    let results = match engine.search(\u0026query) {\n        Ok(results) =\u003e results,\n        Err(e) =\u003e {\n            eprintln!(\"Error searching: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Determine output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Output results\n    match format {\n        OutputFormat::Table =\u003e print_results_table(\u0026results),\n        OutputFormat::Json =\u003e print_results_json(\u0026results),\n        OutputFormat::Quiet =\u003e print_results_quiet(\u0026results),\n    }\n}\n\n/// Print search results as a table.\nfn print_results_table(results: \u0026[SearchResult]) {\n    if results.is_empty() {\n        println!(\"(no results found)\");\n        return;\n    }\n\n    // Calculate column widths\n    let path_width = results\n        .iter()\n        .map(|r| r.note.path.to_string_lossy().len())\n        .max()\n        .unwrap_or(4)\n        .clamp(4, 40);\n    let title_width =\n        results.iter().map(|r| r.note.title.len()).max().unwrap_or(5).clamp(5, 30);\n    let source_width = 15;\n\n    // Header\n    println!(\n        \"{:\u003cpath_width$}  {:\u003ctitle_width$}  SCORE  {:\u003csource_width$}\",\n        \"PATH\",\n        \"TITLE\",\n        \"SOURCE\",\n        path_width = path_width,\n        title_width = title_width,\n        source_width = source_width,\n    );\n    println!(\n        \"{:-\u003cpath_width$}  {:-\u003ctitle_width$}  {:-\u003c5}  {:-\u003csource_width$}\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        path_width = path_width,\n        title_width = title_width,\n        source_width = source_width,\n    );\n\n    // Rows\n    for result in results {\n        let path = truncate(\u0026result.note.path.to_string_lossy(), path_width);\n        let title = truncate(\u0026result.note.title, title_width);\n        let source = format_match_source(\u0026result.match_source);\n        let source = truncate(\u0026source, source_width);\n\n        println!(\n            \"{:\u003cpath_width$}  {:\u003ctitle_width$}  {:5.2}  {:\u003csource_width$}\",\n            path,\n            title,\n            result.score,\n            source,\n            path_width = path_width,\n            title_width = title_width,\n            source_width = source_width,\n        );\n    }\n\n    println!();\n    println!(\"-- {} results --\", results.len());\n}\n\n/// Print search results as JSON.\nfn print_results_json(results: \u0026[SearchResult]) {\n    let output: Vec\u003cSearchResultOutput\u003e =\n        results.iter().map(SearchResultOutput::from).collect();\n    println!(\"{}\", serde_json::to_string_pretty(\u0026output).unwrap_or_default());\n}\n\n/// Print search results as paths only.\nfn print_results_quiet(results: \u0026[SearchResult]) {\n    for result in results {\n        println!(\"{}\", result.note.path.display());\n    }\n}\n\n/// Truncate string with ellipsis if needed.\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else if max_len \u003e 3 {\n        format!(\"{}...\", \u0026s[..max_len - 3])\n    } else {\n        s[..max_len].to_string()\n    }\n}\n\n/// Resolve the output format from flags.\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":93},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","stale.rs"],"content":"//! Stale notes command implementation.\n\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{IndexDb, IndexedNote};\nuse serde::Serialize;\n\nuse crate::{OutputFormat, StaleArgs};\n\n/// Stale note output for JSON.\n#[derive(Debug, Serialize)]\nstruct StaleNoteOutput {\n    path: String,\n    #[serde(rename = \"type\")]\n    note_type: String,\n    title: String,\n    staleness: f64,\n    last_seen: Option\u003cString\u003e,\n}\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: StaleArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Get note type filter\n    let note_type_str = args.r#type.map(|t| {\n        use mdvault_core::index::NoteType;\n        let nt: NoteType = t.into();\n        nt.as_str().to_string()\n    });\n\n    // Query stale notes\n    let results: Vec\u003cStaleNote\u003e = if let Some(days) = args.days {\n        // Query by days not seen\n        match db.get_notes_not_seen_in_days(days, note_type_str.as_deref(), args.limit) {\n            Ok(notes) =\u003e notes\n                .into_iter()\n                .map(|(note, last_seen)| StaleNote {\n                    note,\n                    staleness: 1.0, // Max staleness for day-based query\n                    last_seen,\n                })\n                .collect(),\n            Err(e) =\u003e {\n                eprintln!(\"Error querying stale notes: {}\", e);\n                std::process::exit(1);\n            }\n        }\n    } else {\n        // Query by staleness threshold\n        match db.get_stale_notes(args.threshold, note_type_str.as_deref(), args.limit) {\n            Ok(notes) =\u003e notes\n                .into_iter()\n                .map(|(note, staleness)| StaleNote {\n                    note,\n                    staleness,\n                    last_seen: None, // Not available in staleness query\n                })\n                .collect(),\n            Err(e) =\u003e {\n                eprintln!(\"Error querying stale notes: {}\", e);\n                std::process::exit(1);\n            }\n        }\n    };\n\n    // Determine output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Output results\n    match format {\n        OutputFormat::Table =\u003e print_stale_table(\u0026results),\n        OutputFormat::Json =\u003e print_stale_json(\u0026results),\n        OutputFormat::Quiet =\u003e print_stale_quiet(\u0026results),\n    }\n}\n\n/// Internal stale note representation.\nstruct StaleNote {\n    note: IndexedNote,\n    staleness: f64,\n    last_seen: Option\u003cString\u003e,\n}\n\n/// Print stale notes as a table.\nfn print_stale_table(notes: \u0026[StaleNote]) {\n    if notes.is_empty() {\n        println!(\"(no stale notes found)\");\n        return;\n    }\n\n    // Calculate column widths\n    let path_width = notes\n        .iter()\n        .map(|n| n.note.path.to_string_lossy().len())\n        .max()\n        .unwrap_or(4)\n        .clamp(4, 45);\n    let title_width =\n        notes.iter().map(|n| n.note.title.len()).max().unwrap_or(5).clamp(5, 30);\n\n    // Header\n    println!(\n        \"{:\u003cpath_width$}  {:\u003ctitle_width$}  STALENESS  LAST_SEEN\",\n        \"PATH\",\n        \"TITLE\",\n        path_width = path_width,\n        title_width = title_width,\n    );\n    println!(\n        \"{:-\u003cpath_width$}  {:-\u003ctitle_width$}  {:-\u003c9}  {:-\u003c10}\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        path_width = path_width,\n        title_width = title_width,\n    );\n\n    // Rows\n    for stale in notes {\n        let path = truncate(\u0026stale.note.path.to_string_lossy(), path_width);\n        let title = truncate(\u0026stale.note.title, title_width);\n        let last_seen = stale.last_seen.as_deref().unwrap_or(\"-\");\n\n        println!(\n            \"{:\u003cpath_width$}  {:\u003ctitle_width$}  {:9.2}  {}\",\n            path,\n            title,\n            stale.staleness,\n            last_seen,\n            path_width = path_width,\n            title_width = title_width,\n        );\n    }\n\n    println!();\n    println!(\"-- {} stale notes --\", notes.len());\n}\n\n/// Print stale notes as JSON.\nfn print_stale_json(notes: \u0026[StaleNote]) {\n    let output: Vec\u003cStaleNoteOutput\u003e = notes\n        .iter()\n        .map(|stale| StaleNoteOutput {\n            path: stale.note.path.to_string_lossy().to_string(),\n            note_type: stale.note.note_type.as_str().to_string(),\n            title: stale.note.title.clone(),\n            staleness: stale.staleness,\n            last_seen: stale.last_seen.clone(),\n        })\n        .collect();\n    println!(\"{}\", serde_json::to_string_pretty(\u0026output).unwrap_or_default());\n}\n\n/// Print stale notes as paths only.\nfn print_stale_quiet(notes: \u0026[StaleNote]) {\n    for stale in notes {\n        println!(\"{}\", stale.note.path.display());\n    }\n}\n\n/// Truncate string with ellipsis if needed.\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else if max_len \u003e 3 {\n        format!(\"{}...\", \u0026s[..max_len - 3])\n    } else {\n        s[..max_len].to_string()\n    }\n}\n\n/// Resolve the output format from flags.\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":89},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","task.rs"],"content":"//! Task management commands.\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{IndexDb, IndexedNote, NoteQuery, NoteType};\nuse std::path::Path;\nuse tabled::{settings::Style, Table, Tabled};\n\n/// Row for task list table.\n#[derive(Tabled)]\nstruct TaskListRow {\n    #[tabled(rename = \"ID\")]\n    id: String,\n    #[tabled(rename = \"Title\")]\n    title: String,\n    #[tabled(rename = \"Status\")]\n    status: String,\n    #[tabled(rename = \"Project\")]\n    project: String,\n}\n\n/// List tasks with optional filters.\npub fn list(\n    config: Option\u003c\u0026Path\u003e,\n    profile: Option\u003c\u0026str\u003e,\n    project_filter: Option\u003c\u0026str\u003e,\n    status_filter: Option\u003c\u0026str\u003e,\n) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load config: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to open index: {e}\");\n            eprintln!(\"Run 'mdv reindex' first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Query all tasks\n    let query = NoteQuery { note_type: Some(NoteType::Task), ..Default::default() };\n\n    let tasks = match db.query_notes(\u0026query) {\n        Ok(t) =\u003e t,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to query tasks: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    if tasks.is_empty() {\n        println!(\"No tasks found.\");\n        return;\n    }\n\n    // Build table rows\n    let mut rows: Vec\u003cTaskListRow\u003e = Vec::new();\n\n    for task in \u0026tasks {\n        let path_str = task.path.to_string_lossy();\n\n        // Filter by project if specified\n        if let Some(proj) = project_filter {\n            if !path_str.contains(proj) {\n                continue;\n            }\n        }\n\n        // Get task info from frontmatter\n        let (task_id, task_status, project) = extract_task_info(task);\n\n        // Filter by status if specified\n        if let Some(status) = status_filter {\n            if task_status != status {\n                continue;\n            }\n        }\n\n        let title = if task.title.is_empty() {\n            task.path\n                .file_stem()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"Untitled\")\n                .to_string()\n        } else {\n            task.title.clone()\n        };\n\n        rows.push(TaskListRow { id: task_id, title, status: task_status, project });\n    }\n\n    if rows.is_empty() {\n        println!(\"No tasks match the filter.\");\n        return;\n    }\n\n    // Sort by project then ID\n    rows.sort_by(|a, b| a.project.cmp(\u0026b.project).then_with(|| a.id.cmp(\u0026b.id)));\n\n    let table = Table::new(\u0026rows).with(Style::rounded()).to_string();\n\n    println!(\"{}\", table);\n    println!(\"\\nTotal: {} tasks\", rows.len());\n}\n\n/// Show detailed status for a specific task.\npub fn status(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, task_id: \u0026str) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load config: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to open index: {e}\");\n            eprintln!(\"Run 'mdv reindex' first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Query all tasks and find the one with matching ID\n    let query = NoteQuery { note_type: Some(NoteType::Task), ..Default::default() };\n    let tasks = db.query_notes(\u0026query).unwrap_or_default();\n\n    let task = tasks.iter().find(|t| {\n        let (id, _, _) = extract_task_info(t);\n        id.eq_ignore_ascii_case(task_id)\n    });\n\n    let task = match task {\n        Some(t) =\u003e t,\n        None =\u003e {\n            // Also try matching by filename\n            let task_by_path = tasks.iter().find(|t| {\n                let stem = t.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n                stem.eq_ignore_ascii_case(task_id)\n            });\n            match task_by_path {\n                Some(t) =\u003e t,\n                None =\u003e {\n                    eprintln!(\"Task not found: {}\", task_id);\n                    eprintln!(\"Run 'mdv task list' to see available tasks.\");\n                    std::process::exit(1);\n                }\n            }\n        }\n    };\n\n    // Extract all task info\n    let (id, status, project) = extract_task_info(task);\n    let title = if task.title.is_empty() {\n        task.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"Untitled\").to_string()\n    } else {\n        task.title.clone()\n    };\n\n    // Get additional info from frontmatter\n    let fm = task\n        .frontmatter_json\n        .as_ref()\n        .and_then(|fm| serde_json::from_str::\u003cserde_json::Value\u003e(fm).ok());\n\n    let created = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"created\").and_then(|v| v.as_str()))\n        .unwrap_or(\"-\");\n\n    let completed_at = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"completed_at\").and_then(|v| v.as_str()))\n        .unwrap_or(\"-\");\n\n    // Print task details\n    println!(\"Task: {} [{}]\", title, id);\n    println!();\n    println!(\"  Status:       {}\", status);\n    println!(\"  Project:      {}\", project);\n    println!(\"  Created:      {}\", created);\n    if status == \"done\" || status == \"completed\" {\n        println!(\"  Completed:    {}\", completed_at);\n    }\n    println!(\"  Path:         {}\", task.path.display());\n}\n\n/// Mark a task as done.\npub fn done(\n    config: Option\u003c\u0026Path\u003e,\n    profile: Option\u003c\u0026str\u003e,\n    task_path: \u0026Path,\n    summary: Option\u003c\u0026str\u003e,\n) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load config: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Resolve task path relative to vault root\n    let full_path = if task_path.is_absolute() {\n        task_path.to_path_buf()\n    } else {\n        cfg.vault_root.join(task_path)\n    };\n\n    if !full_path.exists() {\n        eprintln!(\"Task not found: {}\", full_path.display());\n        std::process::exit(1);\n    }\n\n    // Read the task file\n    let content = match std::fs::read_to_string(\u0026full_path) {\n        Ok(c) =\u003e c,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to read task: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Parse and update frontmatter\n    let parsed = match mdvault_core::frontmatter::parse(\u0026content) {\n        Ok(p) =\u003e p,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to parse task frontmatter: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let mut fm = match parsed.frontmatter {\n        Some(fm) =\u003e fm,\n        None =\u003e {\n            eprintln!(\"Task has no frontmatter\");\n            std::process::exit(1);\n        }\n    };\n\n    // Update status to done\n    fm.fields.insert(\"status\".to_string(), serde_yaml::Value::String(\"done\".to_string()));\n\n    // Update completed_at\n    let now = chrono::Utc::now().format(\"%Y-%m-%dT%H:%M:%S\").to_string();\n    fm.fields.insert(\"completed_at\".to_string(), serde_yaml::Value::String(now.clone()));\n\n    // Get task ID for output\n    let task_id = fm\n        .fields\n        .get(\"task-id\")\n        .and_then(|v| match v {\n            serde_yaml::Value::String(s) =\u003e Some(s.clone()),\n            _ =\u003e None,\n        })\n        .unwrap_or_else(|| {\n            full_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"task\").to_string()\n        });\n\n    // Rebuild the document\n    let mut mapping = serde_yaml::Mapping::new();\n    for (k, v) in fm.fields {\n        mapping.insert(serde_yaml::Value::String(k), v);\n    }\n    let yaml_str = match serde_yaml::to_string(\u0026serde_yaml::Value::Mapping(mapping)) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to serialize frontmatter: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Append summary to body if provided\n    let body = if let Some(sum) = summary {\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n        let time = chrono::Local::now().format(\"%H:%M\").to_string();\n        format!(\n            \"{}\\n- **[[{}]] {}** : Completed - {}\\n\",\n            parsed.body.trim_end(),\n            today,\n            time,\n            sum\n        )\n    } else {\n        parsed.body\n    };\n\n    let final_content = format!(\"---\\n{}---\\n{}\", yaml_str, body);\n\n    // Write back\n    if let Err(e) = std::fs::write(\u0026full_path, final_content) {\n        eprintln!(\"Failed to write task: {e}\");\n        std::process::exit(1);\n    }\n\n    println!(\"OK   mdv task done\");\n    println!(\"task:   {}\", task_id);\n    println!(\"status: done\");\n    if summary.is_some() {\n        println!(\"summary: logged to task\");\n    }\n}\n\n/// Extract task ID, status, and project from frontmatter.\nfn extract_task_info(task: \u0026IndexedNote) -\u003e (String, String, String) {\n    let fm = task\n        .frontmatter_json\n        .as_ref()\n        .and_then(|fm| serde_json::from_str::\u003cserde_json::Value\u003e(fm).ok());\n\n    let id = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"task-id\").and_then(|v| v.as_str()))\n        .map(String::from)\n        .unwrap_or_else(|| \"-\".to_string());\n\n    let status = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"status\").and_then(|v| v.as_str()))\n        .map(String::from)\n        .unwrap_or_else(|| \"unknown\".to_string());\n\n    let project = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"project\").and_then(|v| v.as_str()))\n        .map(String::from)\n        .unwrap_or_else(|| {\n            // Try to extract from path\n            extract_project_from_path(\u0026task.path.to_string_lossy())\n        });\n\n    (id, status, project)\n}\n\n/// Extract project name from a task path.\nfn extract_project_from_path(path: \u0026str) -\u003e String {\n    // Expected format: Projects/\u003cproject\u003e/Tasks/\u003ctask\u003e.md\n    let parts: Vec\u003c\u0026str\u003e = path.split('/').collect();\n    if parts.len() \u003e= 3 \u0026\u0026 parts[0] == \"Projects\" {\n        return parts[1].to_string();\n    }\n    \"inbox\".to_string()\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":173},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","validate.rs"],"content":"//! Validate command implementation.\n\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::frontmatter::parse as parse_frontmatter;\nuse mdvault_core::index::IndexDb;\nuse mdvault_core::types::{\n    add_link_integrity_warnings, apply_fixes, try_fix_note, validate_note, TypeRegistry,\n    TypedefRepository, ValidationResult,\n};\n\nuse crate::{OutputFormat, ValidateArgs};\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: ValidateArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Load type definitions\n    let typedef_repo = match TypedefRepository::new(\u0026rc.typedefs_dir) {\n        Ok(repo) =\u003e repo,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading type definitions: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    let registry = match TypeRegistry::from_repository(\u0026typedef_repo) {\n        Ok(reg) =\u003e reg,\n        Err(e) =\u003e {\n            eprintln!(\"Error building type registry: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // If --list-types, just show available types\n    if args.list_types {\n        print_types(\u0026registry);\n        return;\n    }\n\n    // Open index database if needed (for querying notes or link checking)\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let index_db: Option\u003cIndexDb\u003e = if args.path.is_none() || args.check_links {\n        match IndexDb::open(\u0026index_path) {\n            Ok(db) =\u003e Some(db),\n            Err(e) =\u003e {\n                if args.path.is_none() {\n                    // Index is required for index-based mode\n                    eprintln!(\"Error opening index: {}\", e);\n                    eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n                    std::process::exit(1);\n                } else if args.check_links {\n                    // Index is optional for single-file mode with link checking\n                    eprintln!(\n                        \"Warning: Cannot check links - index not available. Run 'mdv reindex' first.\"\n                    );\n                    None\n                } else {\n                    None\n                }\n            }\n        }\n    } else {\n        None\n    };\n\n    // Check if we're validating a specific file or using the index\n    let notes_to_validate = if let Some(ref path) = args.path {\n        // Single file mode\n        let full_path = if Path::new(path).is_absolute() {\n            std::path::PathBuf::from(path)\n        } else {\n            rc.vault_root.join(path)\n        };\n\n        if !full_path.exists() {\n            eprintln!(\"Error: File not found: {}\", full_path.display());\n            std::process::exit(1);\n        }\n\n        let content = match std::fs::read_to_string(\u0026full_path) {\n            Ok(c) =\u003e c,\n            Err(e) =\u003e {\n                eprintln!(\"Error reading file: {}\", e);\n                std::process::exit(1);\n            }\n        };\n\n        // Extract note type from frontmatter\n        let note_type = extract_note_type(\u0026content);\n\n        // Compute relative path for link checking\n        let relative_path = full_path\n            .strip_prefix(\u0026rc.vault_root)\n            .map(|p| p.to_path_buf())\n            .unwrap_or_else(|_| full_path.clone());\n\n        vec![NoteInfo { path: full_path, relative_path, note_type, content }]\n    } else {\n        // Index-based mode - index_db is guaranteed to be Some here\n        let db = index_db.as_ref().unwrap();\n\n        // Query notes to validate\n        let query = mdvault_core::index::NoteQuery {\n            note_type: args.r#type.as_ref().map(|s| s.parse().unwrap_or_default()),\n            path_prefix: None,\n            modified_after: None,\n            modified_before: None,\n            limit: args.limit,\n            offset: None,\n        };\n\n        let notes = match db.query_notes(\u0026query) {\n            Ok(notes) =\u003e notes,\n            Err(e) =\u003e {\n                eprintln!(\"Error querying notes: {}\", e);\n                std::process::exit(1);\n            }\n        };\n\n        // Convert to NoteInfo\n        let note_infos: Vec\u003cNoteInfo\u003e = notes\n            .into_iter()\n            .map(|n| {\n                let full_path = rc.vault_root.join(\u0026n.path);\n                let content = std::fs::read_to_string(\u0026full_path).unwrap_or_default();\n                NoteInfo {\n                    path: full_path,\n                    relative_path: n.path,\n                    note_type: n.note_type.as_str().to_string(),\n                    content,\n                }\n            })\n            .collect();\n\n        note_infos\n    };\n\n    // Validate each note\n    let mut total = 0;\n    let mut valid_count = 0;\n    let mut error_count = 0;\n    let mut fixed_count = 0;\n    let mut results: Vec\u003c(\n        std::path::PathBuf,\n        String,\n        ValidationResult,\n        Option\u003cVec\u003cString\u003e\u003e,\n    )\u003e = Vec::new();\n\n    for note in \u0026notes_to_validate {\n        total += 1;\n        let note_type = \u0026note.note_type;\n\n        // Parse frontmatter\n        let frontmatter: serde_yaml::Value = parse_frontmatter(\u0026note.content)\n            .ok()\n            .and_then(|p| p.frontmatter)\n            .map(|fm| {\n                let mut map = serde_yaml::Mapping::new();\n                for (k, v) in fm.fields {\n                    map.insert(serde_yaml::Value::String(k), v);\n                }\n                serde_yaml::Value::Mapping(map)\n            })\n            .unwrap_or(serde_yaml::Value::Mapping(serde_yaml::Mapping::new()));\n\n        // Run type-based validation (skip for untyped notes without custom definitions)\n        let mut result = if !registry.has_definition(note_type) \u0026\u0026 note_type == \"none\" {\n            ValidationResult::default()\n        } else {\n            validate_note(\n                \u0026registry,\n                note_type,\n                \u0026note.path.to_string_lossy(),\n                \u0026frontmatter,\n                \u0026note.content,\n            )\n        };\n\n        // Check link integrity if requested and index is available\n        if args.check_links {\n            if let Some(ref db) = index_db {\n                add_link_integrity_warnings(\u0026mut result, db, \u0026note.relative_path);\n            }\n        }\n\n        // Determine if note is valid (errors only, warnings don't count)\n        let has_errors = !result.errors.is_empty();\n        let has_warnings = !result.warnings.is_empty();\n\n        if !has_errors \u0026\u0026 !has_warnings {\n            valid_count += 1;\n        } else if !has_errors {\n            // Only warnings, still valid but add to results for display\n            valid_count += 1;\n            results.push((note.path.clone(), note_type.clone(), result, None));\n        } else {\n            // Has errors - try to fix if --fix is set\n            let fixes = if args.fix {\n                let fix_result =\n                    try_fix_note(\u0026registry, note_type, \u0026note.content, \u0026result.errors);\n                if fix_result.fixed {\n                    if let Some(new_content) = fix_result.content {\n                        if let Err(e) = apply_fixes(\u0026note.path, \u0026new_content) {\n                            eprintln!(\n                                \"Warning: Failed to apply fixes to {}: {}\",\n                                note.path.display(),\n                                e\n                            );\n                            None\n                        } else {\n                            fixed_count += 1;\n                            Some(fix_result.fixes)\n                        }\n                    } else {\n                        None\n                    }\n                } else {\n                    None\n                }\n            } else {\n                None\n            };\n\n            // Only count as error if not fully fixed\n            if fixes.is_none()\n                || result.errors.len() \u003e fixes.as_ref().map_or(0, |f| f.len())\n            {\n                error_count += 1;\n            }\n            results.push((note.path.clone(), note_type.clone(), result, fixes));\n        }\n    }\n\n    // Determine output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Output results\n    match format {\n        OutputFormat::Table =\u003e print_results_table(\n            \u0026results,\n            total,\n            valid_count,\n            error_count,\n            fixed_count,\n            args.fix,\n        ),\n        OutputFormat::Json =\u003e {\n            print_results_json(\u0026results, total, valid_count, error_count, fixed_count)\n        }\n        OutputFormat::Quiet =\u003e print_results_quiet(\u0026results),\n    }\n\n    // Exit with error code if any validation failures remain unfixed\n    if error_count \u003e 0 {\n        std::process::exit(1);\n    }\n}\n\n/// Information about a note to validate.\nstruct NoteInfo {\n    path: std::path::PathBuf,\n    relative_path: std::path::PathBuf,\n    note_type: String,\n    content: String,\n}\n\n/// Extract note type from content's frontmatter.\nfn extract_note_type(content: \u0026str) -\u003e String {\n    parse_frontmatter(content)\n        .ok()\n        .and_then(|p| p.frontmatter)\n        .and_then(|fm| fm.fields.get(\"type\").cloned())\n        .and_then(|v| match v {\n            serde_yaml::Value::String(s) =\u003e Some(s),\n            _ =\u003e None,\n        })\n        .unwrap_or_else(|| \"none\".to_string())\n}\n\nfn print_types(registry: \u0026TypeRegistry) {\n    println!(\"Available note types:\");\n    println!();\n\n    // Built-in types\n    println!(\"Built-in types:\");\n    for name in [\"daily\", \"weekly\", \"task\", \"project\", \"zettel\"] {\n        let has_override = registry.has_definition(name);\n        if has_override {\n            println!(\"  {} (with Lua override)\", name);\n        } else {\n            println!(\"  {}\", name);\n        }\n    }\n\n    // Custom types\n    let custom = registry.list_custom_types();\n    if !custom.is_empty() {\n        println!();\n        println!(\"Custom types:\");\n        for name in custom {\n            if let Some(td) = registry.get(name) {\n                if let Some(desc) = \u0026td.description {\n                    println!(\"  {} - {}\", name, desc);\n                } else {\n                    println!(\"  {}\", name);\n                }\n            }\n        }\n    }\n}\n\nfn print_results_table(\n    results: \u0026[(std::path::PathBuf, String, ValidationResult, Option\u003cVec\u003cString\u003e\u003e)],\n    total: usize,\n    valid: usize,\n    errors: usize,\n    fixed: usize,\n    fix_mode: bool,\n) {\n    if results.is_empty() {\n        println!(\"All {} notes validated successfully.\", total);\n        return;\n    }\n\n    if fix_mode \u0026\u0026 fixed \u003e 0 {\n        println!(\n            \"Validation Results: {} valid, {} fixed, {} with errors (of {} total)\",\n            valid, fixed, errors, total\n        );\n    } else {\n        println!(\n            \"Validation Results: {} valid, {} with errors (of {} total)\",\n            valid, errors, total\n        );\n    }\n    println!();\n\n    for (path, note_type, result, fixes) in results {\n        println!(\"{}  [type: {}]\", path.display(), note_type);\n\n        // Show fixes if any\n        if let Some(applied_fixes) = fixes {\n            for fix in applied_fixes {\n                println!(\"  + {}\", fix);\n            }\n        }\n\n        // Show remaining errors\n        for error in \u0026result.errors {\n            // Skip errors that were fixed\n            if let Some(ref applied) = fixes {\n                let error_str = error.to_string();\n                if applied\n                    .iter()\n                    .any(|f| error_str.contains(f.split('\\'').nth(1).unwrap_or(\"\")))\n                {\n                    continue;\n                }\n            }\n            println!(\"  - {}\", error);\n        }\n\n        for warning in \u0026result.warnings {\n            println!(\"  ~ {}\", warning);\n        }\n        println!();\n    }\n}\n\nfn print_results_json(\n    results: \u0026[(std::path::PathBuf, String, ValidationResult, Option\u003cVec\u003cString\u003e\u003e)],\n    total: usize,\n    valid: usize,\n    errors: usize,\n    fixed: usize,\n) {\n    #[derive(serde::Serialize)]\n    struct Output {\n        total: usize,\n        valid: usize,\n        errors: usize,\n        fixed: usize,\n        results: Vec\u003cNoteResult\u003e,\n    }\n\n    #[derive(serde::Serialize)]\n    struct NoteResult {\n        path: String,\n        note_type: String,\n        valid: bool,\n        errors: Vec\u003cString\u003e,\n        warnings: Vec\u003cString\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        fixes_applied: Option\u003cVec\u003cString\u003e\u003e,\n    }\n\n    let output = Output {\n        total,\n        valid,\n        errors,\n        fixed,\n        results: results\n            .iter()\n            .map(|(path, note_type, result, fixes)| NoteResult {\n                path: path.to_string_lossy().to_string(),\n                note_type: note_type.clone(),\n                valid: result.valid,\n                errors: result.errors.iter().map(|e| e.to_string()).collect(),\n                warnings: result.warnings.clone(),\n                fixes_applied: fixes.clone(),\n            })\n            .collect(),\n    };\n\n    println!(\"{}\", serde_json::to_string_pretty(\u0026output).unwrap());\n}\n\nfn print_results_quiet(\n    results: \u0026[(std::path::PathBuf, String, ValidationResult, Option\u003cVec\u003cString\u003e\u003e)],\n) {\n    for (path, _, _, _) in results {\n        println!(\"{}\", path.display());\n    }\n}\n\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":204},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","completions.rs"],"content":"//! Shell completion support with dynamic value completers.\n//!\n//! This module provides intelligent tab completions that understand the user's vault\n//! configuration, offering context-aware suggestions for types, templates, captures, etc.\n\nuse clap_complete::engine::CompletionCandidate;\nuse mdvault_core::captures::CaptureRepository;\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::macros::MacroRepository;\nuse mdvault_core::templates::repository::TemplateRepository;\nuse mdvault_core::types::{TypeRegistry, TypedefRepository};\nuse std::ffi::OsStr;\n\n/// Load the resolved config, returning None if it fails.\nfn load_config() -\u003e Option\u003cmdvault_core::config::types::ResolvedConfig\u003e {\n    ConfigLoader::load(None, None).ok()\n}\n\n/// Complete note types (built-in + custom from TypeRegistry).\npub fn complete_types(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    // Built-in types are always available\n    let builtin_types = [\n        (\"daily\", \"Daily journal notes\"),\n        (\"weekly\", \"Weekly overview notes\"),\n        (\"task\", \"Individual actionable tasks\"),\n        (\"project\", \"Collections of related tasks\"),\n        (\"zettel\", \"Knowledge notes (Zettelkasten-style)\"),\n    ];\n\n    for (name, help) in builtin_types {\n        if name.starts_with(current_str) {\n            completions.push(CompletionCandidate::new(name).help(Some(help.into())));\n        }\n    }\n\n    // Try to load custom types from config\n    if let Some(cfg) = load_config() {\n        if let Ok(typedef_repo) = TypedefRepository::new(\u0026cfg.typedefs_dir) {\n            if let Ok(registry) = TypeRegistry::from_repository(\u0026typedef_repo) {\n                for type_name in registry.list_custom_types() {\n                    if type_name.starts_with(current_str) {\n                        completions.push(\n                            CompletionCandidate::new(type_name)\n                                .help(Some(\"Custom type\".into())),\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n/// Complete template names from TemplateRepository.\npub fn complete_templates(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    if let Some(cfg) = load_config() {\n        if let Ok(repo) = TemplateRepository::new(\u0026cfg.templates_dir) {\n            for info in repo.list_all() {\n                if info.logical_name.starts_with(current_str) {\n                    completions.push(CompletionCandidate::new(\u0026info.logical_name));\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n/// Complete capture names from CaptureRepository.\npub fn complete_captures(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    if let Some(cfg) = load_config() {\n        if let Ok(repo) = CaptureRepository::new(\u0026cfg.captures_dir) {\n            for info in repo.list_all() {\n                if info.logical_name.starts_with(current_str) {\n                    completions.push(CompletionCandidate::new(\u0026info.logical_name));\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n/// Complete macro names from MacroRepository.\npub fn complete_macros(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    if let Some(cfg) = load_config() {\n        if let Ok(repo) = MacroRepository::new(\u0026cfg.macros_dir) {\n            for info in repo.list_all() {\n                if info.logical_name.starts_with(current_str) {\n                    completions.push(CompletionCandidate::new(\u0026info.logical_name));\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n/// Complete project names from the index.\npub fn complete_projects(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    use mdvault_core::index::{IndexDb, NoteQuery, NoteType};\n\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    if let Some(cfg) = load_config() {\n        let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n        if let Ok(db) = IndexDb::open(\u0026index_path) {\n            let query =\n                NoteQuery { note_type: Some(NoteType::Project), ..Default::default() };\n            if let Ok(projects) = db.query_notes(\u0026query) {\n                for project in projects {\n                    // Use folder name as the project identifier\n                    let name =\n                        project.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n                    if name.starts_with(current_str) {\n                        let title = if project.title.is_empty() {\n                            name.to_string()\n                        } else {\n                            project.title.clone()\n                        };\n                        completions.push(\n                            CompletionCandidate::new(name).help(Some(title.into())),\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n/// Complete note paths from the vault.\n/// This walks the vault directory and returns markdown files.\npub fn complete_notes(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    if let Some(cfg) = load_config() {\n        // Walk and collect note paths relative to vault root\n        for entry in walkdir::WalkDir::new(\u0026cfg.vault_root)\n            .min_depth(1)\n            .max_depth(5) // Limit depth for performance\n            .into_iter()\n            .filter_map(|e| e.ok())\n            .filter(|e| e.path().extension().map(|ext| ext == \"md\").unwrap_or(false))\n            .take(100)\n        // Limit results for performance\n        {\n            if let Ok(rel_path) = entry.path().strip_prefix(\u0026cfg.vault_root) {\n                let path_str = rel_path.to_string_lossy();\n                if path_str.starts_with(current_str) {\n                    completions.push(CompletionCandidate::new(path_str.to_string()));\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_complete_types_builtin() {\n        let completions = complete_types(OsStr::new(\"\"));\n        let names: Vec\u003c_\u003e =\n            completions.iter().map(|c| c.get_value().to_str().unwrap()).collect();\n\n        assert!(names.contains(\u0026\"daily\"));\n        assert!(names.contains(\u0026\"task\"));\n        assert!(names.contains(\u0026\"project\"));\n    }\n\n    #[test]\n    fn test_complete_types_prefix_filter() {\n        let completions = complete_types(OsStr::new(\"da\"));\n        let names: Vec\u003c_\u003e =\n            completions.iter().map(|c| c.get_value().to_str().unwrap()).collect();\n\n        assert!(names.contains(\u0026\"daily\"));\n        assert!(!names.contains(\u0026\"task\"));\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":8}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":22,"address":[],"length":0,"stats":{"Line":10}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":32}},{"line":34,"address":[],"length":0,"stats":{"Line":36}},{"line":35,"address":[],"length":0,"stats":{"Line":36}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}}],"covered":19,"coverable":85},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","main.rs"],"content":"mod cmd;\nmod completions;\nmod prompt;\nmod tui;\n\nuse clap::{Args, CommandFactory, Parser, Subcommand, ValueEnum};\nuse clap_complete::engine::ArgValueCompleter;\nuse clap_complete::env::CompleteEnv;\nuse clap_complete::Shell;\nuse std::path::PathBuf;\n\n/// Output format for query commands.\n#[derive(Debug, Clone, Copy, Default, ValueEnum)]\npub enum OutputFormat {\n    /// Human-readable table format\n    #[default]\n    Table,\n    /// JSON output\n    Json,\n    /// Quiet mode - paths only\n    Quiet,\n}\n\n/// Note type filter for list command.\n#[derive(Debug, Clone, Copy, ValueEnum)]\npub enum NoteTypeArg {\n    /// Daily journal notes\n    Daily,\n    /// Weekly overview notes\n    Weekly,\n    /// Individual actionable tasks\n    Task,\n    /// Collections of related tasks\n    Project,\n    /// Knowledge notes (Zettelkasten-style)\n    Zettel,\n}\n\nimpl From\u003cNoteTypeArg\u003e for mdvault_core::index::NoteType {\n    fn from(arg: NoteTypeArg) -\u003e Self {\n        match arg {\n            NoteTypeArg::Daily =\u003e mdvault_core::index::NoteType::Daily,\n            NoteTypeArg::Weekly =\u003e mdvault_core::index::NoteType::Weekly,\n            NoteTypeArg::Task =\u003e mdvault_core::index::NoteType::Task,\n            NoteTypeArg::Project =\u003e mdvault_core::index::NoteType::Project,\n            NoteTypeArg::Zettel =\u003e mdvault_core::index::NoteType::Zettel,\n        }\n    }\n}\n\n#[derive(Debug, Parser)]\n#[command(name = \"mdv\", version, about = \"Your markdown vault on the command line\")]\nstruct Cli {\n    #[arg(long, global = true)]\n    config: Option\u003cPathBuf\u003e,\n\n    #[arg(long, global = true)]\n    profile: Option\u003cString\u003e,\n\n    #[command(subcommand)]\n    command: Option\u003cCommands\u003e,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    /// Validate configuration and print resolved paths\n    Doctor,\n\n    /// List logical template names discovered under templates_dir\n    ListTemplates,\n\n    /// Render a template into a new file\n    New(NewArgs),\n\n    /// Capture content into an existing file's section\n    Capture(CaptureArgs),\n\n    /// Execute a multi-step macro workflow\n    Macro(MacroArgs),\n\n    /// Build or rebuild the vault index\n    Reindex(ReindexArgs),\n\n    /// List notes in the vault with optional filters\n    List(ListArgs),\n\n    /// Show links for a note (backlinks and/or outgoing)\n    Links(LinksArgs),\n\n    /// Find orphan notes (no incoming links)\n    Orphans(OrphansArgs),\n\n    /// Validate notes against type definitions\n    Validate(ValidateArgs),\n\n    /// Lint notes (alias for validate)\n    #[command(hide = true)]\n    Lint(ValidateArgs),\n\n    /// Search notes with contextual expansion\n    Search(SearchArgs),\n\n    /// Find stale notes (not referenced in recent dailies)\n    Stale(StaleArgs),\n\n    /// Rename a note and update all references to it\n    Rename(RenameArgs),\n\n    /// Generate shell completion scripts\n    Completions(CompletionsArgs),\n\n    /// Task management commands\n    #[command(subcommand)]\n    Task(TaskCommands),\n\n    /// Project management commands\n    #[command(subcommand)]\n    Project(ProjectCommands),\n}\n\n/// Task management subcommands.\n#[derive(Debug, Subcommand)]\nenum TaskCommands {\n    /// List tasks with optional filters\n    List(TaskListArgs),\n\n    /// Mark a task as done\n    Done(TaskDoneArgs),\n\n    /// Show detailed status for a task\n    Status(TaskStatusArgs),\n}\n\n/// Project management subcommands.\n#[derive(Debug, Subcommand)]\nenum ProjectCommands {\n    /// List all projects with task counts\n    List(ProjectListArgs),\n\n    /// Show project status with tasks in kanban-style view\n    Status(ProjectStatusArgs),\n}\n\n#[derive(Debug, Args)]\npub struct TaskListArgs {\n    /// Filter by project name\n    #[arg(long, short)]\n    pub project: Option\u003cString\u003e,\n\n    /// Filter by status (todo, in-progress, done, blocked)\n    #[arg(long, short)]\n    pub status: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct TaskDoneArgs {\n    /// Path to the task note (relative to vault root)\n    #[arg(add = ArgValueCompleter::new(completions::complete_notes))]\n    pub task: PathBuf,\n\n    /// Summary of what was done (logged to task)\n    #[arg(long, short)]\n    pub summary: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct ProjectListArgs {\n    /// Filter by status (active, completed, on-hold, archived)\n    #[arg(long, short)]\n    pub status: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct ProjectStatusArgs {\n    /// Project ID or folder name (e.g., \"MCP\" or \"my-cool-project\")\n    #[arg(add = ArgValueCompleter::new(completions::complete_projects))]\n    pub project: String,\n}\n\n#[derive(Debug, Args)]\npub struct TaskStatusArgs {\n    /// Task ID (e.g., \"MCP-001\")\n    #[arg(add = ArgValueCompleter::new(completions::complete_notes))]\n    pub task_id: String,\n}\n\n#[derive(Debug, Args)]\npub struct ReindexArgs {\n    /// Show verbose output (list each file as it's indexed)\n    #[arg(long, short)]\n    pub verbose: bool,\n\n    /// Force full rebuild of the index (default: incremental)\n    #[arg(long)]\n    pub force: bool,\n\n    /// Explicitly request incremental update (default behavior)\n    #[arg(long, conflicts_with = \"force\")]\n    pub incremental: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv macro --list\n  mdv macro weekly-review\n  mdv macro deploy-notes --trust\n  mdv macro setup --var project=\\\"my-app\\\"\n\")]\npub struct MacroArgs {\n    /// Logical macro name (e.g. \\\"weekly-review\\\" or \\\"deploy\\\")\n    #[arg(required_unless_present = \"list\", add = ArgValueCompleter::new(completions::complete_macros))]\n    pub name: Option\u003cString\u003e,\n\n    /// List available macros\n    #[arg(long, short)]\n    pub list: bool,\n\n    /// Variables to pass to the macro (e.g. --var topic=\\\"Planning\\\")\n    #[arg(long = \"var\", value_parser = parse_key_val)]\n    pub vars: Vec\u003c(String, String)\u003e,\n\n    /// Non-interactive mode: fail if variables are missing instead of prompting\n    #[arg(long)]\n    pub batch: bool,\n\n    /// Trust shell commands in the macro\n    #[arg(long)]\n    pub trust: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv new task \\\"My Task\\\" --var project=myproject\n  mdv new --template daily\n  mdv new project \\\"New Project\\\" --var status=active -o projects/new.md\n\")]\npub struct NewArgs {\n    /// Note type for scaffolding (e.g., \\\"task\\\", \\\"project\\\", \\\"zettel\\\")\n    /// Creates a note with frontmatter based on the type's schema\n    #[arg(add = ArgValueCompleter::new(completions::complete_types))]\n    pub note_type: Option\u003cString\u003e,\n\n    /// Note title (used in frontmatter and as heading)\n    pub title: Option\u003cString\u003e,\n\n    /// Use a template file instead of type-based scaffolding\n    #[arg(long, add = ArgValueCompleter::new(completions::complete_templates))]\n    pub template: Option\u003cString\u003e,\n\n    /// Output file path (auto-generated from type/title if not provided)\n    #[arg(long, short)]\n    pub output: Option\u003cPathBuf\u003e,\n\n    /// Variables/fields to set (e.g. --var project=myproject)\n    #[arg(long = \"var\", value_parser = parse_key_val)]\n    pub vars: Vec\u003c(String, String)\u003e,\n\n    /// Non-interactive mode: fail if variables are missing instead of prompting\n    #[arg(long)]\n    pub batch: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv capture --list\n  mdv capture inbox --var text=\\\"Buy milk\\\"\n  mdv capture todo --var task=\\\"Review PR\\\" --var priority=high\n\")]\npub struct CaptureArgs {\n    /// Logical capture name (e.g. \"inbox\" or \"todo\")\n    #[arg(required_unless_present = \"list\", add = ArgValueCompleter::new(completions::complete_captures))]\n    pub name: Option\u003cString\u003e,\n\n    /// List available captures and their expected variables\n    #[arg(long, short)]\n    pub list: bool,\n\n    /// Variables to pass to the capture (e.g. --var text=\"My note\")\n    #[arg(long = \"var\", value_parser = parse_key_val)]\n    pub vars: Vec\u003c(String, String)\u003e,\n\n    /// Non-interactive mode: fail if variables are missing instead of prompting\n    #[arg(long)]\n    pub batch: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv list                              # List all notes\n  mdv list --type task                  # Filter by type\n  mdv list --modified-after 2024-01-01  # Filter by date\n  mdv list --modified-after \\\"today - 7d\\\" # Notes from last week\n  mdv list --json                       # JSON output\n  mdv list -q                           # Paths only\n\")]\npub struct ListArgs {\n    /// Filter by note type\n    #[arg(long)]\n    pub r#type: Option\u003cNoteTypeArg\u003e,\n\n    /// Show only notes modified after this date (YYYY-MM-DD or date expression)\n    #[arg(long)]\n    pub modified_after: Option\u003cString\u003e,\n\n    /// Show only notes modified before this date (YYYY-MM-DD or date expression)\n    #[arg(long)]\n    pub modified_before: Option\u003cString\u003e,\n\n    /// Maximum number of notes to return\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cu32\u003e,\n\n    /// Output format\n    #[arg(long, short, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv links note.md                     # Show backlinks and outlinks\n  mdv links note.md --backlinks         # Only backlinks\n  mdv links note.md --outlinks          # Only outlinks\n  mdv links tasks/todo.md --json        # JSON output\n\")]\npub struct LinksArgs {\n    /// Path to the note (relative to vault root)\n    #[arg(add = ArgValueCompleter::new(completions::complete_notes))]\n    pub note: String,\n\n    /// Show only backlinks (notes linking to this note)\n    #[arg(long, short = 'b')]\n    pub backlinks: bool,\n\n    /// Show only outgoing links (notes this note links to)\n    #[arg(long, short = 'o')]\n    pub outlinks: bool,\n\n    /// Output format\n    #[arg(long, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv orphans                           # Find orphan notes\n  mdv orphans --json                    # JSON output\n  mdv orphans -q                        # Paths only\n\")]\npub struct OrphansArgs {\n    /// Output format\n    #[arg(long, short, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv validate                          # Validate all notes\n  mdv validate path/to/note.md          # Validate specific file\n  mdv validate --type task              # Validate only task notes\n  mdv validate --fix                    # Auto-fix safe issues\n  mdv validate --list-types             # Show available type definitions\n  mdv validate --json                   # JSON output\n\")]\npub struct ValidateArgs {\n    /// Specific note path to validate (relative to vault root)\n    pub path: Option\u003cString\u003e,\n\n    /// Only validate notes of this type\n    #[arg(long)]\n    pub r#type: Option\u003cString\u003e,\n\n    /// Maximum number of notes to validate\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cu32\u003e,\n\n    /// Auto-fix safe issues (missing defaults, enum case normalization)\n    #[arg(long)]\n    pub fix: bool,\n\n    /// List available type definitions\n    #[arg(long)]\n    pub list_types: bool,\n\n    /// Output format\n    #[arg(long, short, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n\n    /// Check link integrity (report broken links as warnings)\n    #[arg(long)]\n    pub check_links: bool,\n}\n\n/// Search mode for result expansion.\n#[derive(Debug, Clone, Copy, Default, ValueEnum)]\npub enum SearchModeArg {\n    /// Only return notes directly matching the query\n    #[default]\n    Direct,\n    /// Include linked notes within 2 hops\n    Neighbourhood,\n    /// Include recent dailies referencing matches\n    Temporal,\n    /// Include notes that cooccur with matches\n    Cooccurrence,\n    /// Full contextual search (all modes)\n    Full,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv search \\\"parser\\\"                     # Direct search for 'parser'\n  mdv search \\\"parser\\\" --mode full         # Search with full context\n  mdv search \\\"fix bug\\\" --type task        # Search only task notes\n  mdv search --type task --mode full       # All tasks with context\n  mdv search \\\"ML\\\" --boost                 # Boost recently active notes\n\")]\npub struct SearchArgs {\n    /// Search query (matches title and path)\n    pub query: Option\u003cString\u003e,\n\n    /// Filter by note type\n    #[arg(long)]\n    pub r#type: Option\u003cNoteTypeArg\u003e,\n\n    /// Search mode for context expansion\n    #[arg(long, value_enum, default_value = \"direct\")]\n    pub mode: SearchModeArg,\n\n    /// Boost recently active notes\n    #[arg(long)]\n    pub boost: bool,\n\n    /// Maximum number of results\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cu32\u003e,\n\n    /// Output format\n    #[arg(long, short, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv stale                              # List all stale notes\n  mdv stale --type task                  # Only stale tasks\n  mdv stale --threshold 0.7              # Higher staleness threshold\n  mdv stale --days 90                    # Notes not seen in 90 days\n\")]\npub struct StaleArgs {\n    /// Filter by note type\n    #[arg(long)]\n    pub r#type: Option\u003cNoteTypeArg\u003e,\n\n    /// Minimum staleness score (0.0-1.0, default 0.5)\n    #[arg(long, default_value = \"0.5\")]\n    pub threshold: f64,\n\n    /// Show notes not seen for this many days (alternative to threshold)\n    #[arg(long)]\n    pub days: Option\u003cu32\u003e,\n\n    /// Maximum number of results\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cu32\u003e,\n\n    /// Output format\n    #[arg(long, short, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv rename old.md new.md              # Rename note and update references\n  mdv rename old.md new.md --dry-run    # Preview changes without modifying files\n  mdv rename old.md new.md --yes        # Skip confirmation prompt\n\")]\npub struct RenameArgs {\n    /// Source file path (relative to vault root)\n    #[arg(add = ArgValueCompleter::new(completions::complete_notes))]\n    pub source: std::path::PathBuf,\n\n    /// Destination file path (relative to vault root)\n    pub dest: std::path::PathBuf,\n\n    /// Preview changes without modifying files\n    #[arg(long)]\n    pub dry_run: bool,\n\n    /// Skip confirmation prompt\n    #[arg(long, short)]\n    pub yes: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv completions bash \u003e ~/.local/share/bash-completion/completions/mdv\n  mdv completions zsh \u003e ~/.zfunc/_mdv\n  mdv completions fish \u003e ~/.config/fish/completions/mdv.fish\n\")]\npub struct CompletionsArgs {\n    /// Shell to generate completions for\n    #[arg(value_enum)]\n    pub shell: Shell,\n}\n\nfn parse_key_val(s: \u0026str) -\u003e Result\u003c(String, String), String\u003e {\n    let pos =\n        s.find('=').ok_or_else(|| format!(\"invalid KEY=value: no `=` found in `{s}`\"))?;\n    Ok((s[..pos].to_string(), s[pos + 1..].to_string()))\n}\n\nfn main() {\n    // Enable dynamic shell completions\n    // This intercepts completion requests before normal CLI parsing\n    CompleteEnv::with_factory(Cli::command).complete();\n\n    let cli = Cli::parse();\n\n    match cli.command {\n        // No command provided - launch TUI\n        None =\u003e {\n            if let Err(e) = tui::run(cli.config.as_deref(), cli.profile.as_deref()) {\n                eprintln!(\"Error: {e}\");\n                std::process::exit(1);\n            }\n        }\n        Some(Commands::Doctor) =\u003e {\n            cmd::doctor::run(cli.config.as_deref(), cli.profile.as_deref())\n        }\n        Some(Commands::ListTemplates) =\u003e {\n            cmd::list_templates::run(cli.config.as_deref(), cli.profile.as_deref())\n        }\n        Some(Commands::New(args)) =\u003e {\n            cmd::new::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Capture(args)) =\u003e {\n            if args.list {\n                cmd::capture::run_list(cli.config.as_deref(), cli.profile.as_deref());\n            } else {\n                cmd::capture::run(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    args.name.as_ref().unwrap(),\n                    \u0026args.vars,\n                    args.batch,\n                );\n            }\n        }\n        Some(Commands::Macro(args)) =\u003e {\n            if args.list {\n                cmd::macro_cmd::run_list(cli.config.as_deref(), cli.profile.as_deref());\n            } else {\n                cmd::macro_cmd::run(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    args.name.as_ref().unwrap(),\n                    \u0026args.vars,\n                    args.batch,\n                    args.trust,\n                );\n            }\n        }\n        Some(Commands::Reindex(args)) =\u003e {\n            cmd::reindex::run(\n                cli.config.as_deref(),\n                cli.profile.as_deref(),\n                args.verbose,\n                args.force,\n            );\n        }\n        Some(Commands::List(args)) =\u003e {\n            cmd::list::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Links(args)) =\u003e {\n            cmd::links::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Orphans(args)) =\u003e {\n            cmd::orphans::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Validate(args)) | Some(Commands::Lint(args)) =\u003e {\n            cmd::validate::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Search(args)) =\u003e {\n            cmd::search::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Stale(args)) =\u003e {\n            cmd::stale::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Rename(args)) =\u003e {\n            cmd::rename::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Completions(args)) =\u003e {\n            clap_complete::generate(\n                args.shell,\n                \u0026mut Cli::command(),\n                \"mdv\",\n                \u0026mut std::io::stdout(),\n            );\n        }\n        Some(Commands::Task(subcmd)) =\u003e match subcmd {\n            TaskCommands::List(args) =\u003e {\n                cmd::task::list(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    args.project.as_deref(),\n                    args.status.as_deref(),\n                );\n            }\n            TaskCommands::Done(args) =\u003e {\n                cmd::task::done(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    \u0026args.task,\n                    args.summary.as_deref(),\n                );\n            }\n            TaskCommands::Status(args) =\u003e {\n                cmd::task::status(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    \u0026args.task_id,\n                );\n            }\n        },\n        Some(Commands::Project(subcmd)) =\u003e match subcmd {\n            ProjectCommands::List(args) =\u003e {\n                cmd::project::list(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    args.status.as_deref(),\n                );\n            }\n            ProjectCommands::Status(args) =\u003e {\n                cmd::project::status(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    \u0026args.project,\n                );\n            }\n        },\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":16}},{"line":566,"address":[],"length":0,"stats":{"Line":16}},{"line":567,"address":[],"length":0,"stats":{"Line":48}},{"line":568,"address":[],"length":0,"stats":{"Line":48}},{"line":571,"address":[],"length":0,"stats":{"Line":39}},{"line":574,"address":[],"length":0,"stats":{"Line":78}},{"line":576,"address":[],"length":0,"stats":{"Line":78}},{"line":578,"address":[],"length":0,"stats":{"Line":39}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":20}},{"line":590,"address":[],"length":0,"stats":{"Line":5}},{"line":592,"address":[],"length":0,"stats":{"Line":20}},{"line":593,"address":[],"length":0,"stats":{"Line":50}},{"line":595,"address":[],"length":0,"stats":{"Line":15}},{"line":596,"address":[],"length":0,"stats":{"Line":16}},{"line":597,"address":[],"length":0,"stats":{"Line":4}},{"line":600,"address":[],"length":0,"stats":{"Line":42}},{"line":601,"address":[],"length":0,"stats":{"Line":42}},{"line":602,"address":[],"length":0,"stats":{"Line":42}},{"line":603,"address":[],"length":0,"stats":{"Line":14}},{"line":604,"address":[],"length":0,"stats":{"Line":14}},{"line":608,"address":[],"length":0,"stats":{"Line":9}},{"line":609,"address":[],"length":0,"stats":{"Line":11}},{"line":610,"address":[],"length":0,"stats":{"Line":8}},{"line":613,"address":[],"length":0,"stats":{"Line":21}},{"line":614,"address":[],"length":0,"stats":{"Line":21}},{"line":615,"address":[],"length":0,"stats":{"Line":21}},{"line":616,"address":[],"length":0,"stats":{"Line":14}},{"line":617,"address":[],"length":0,"stats":{"Line":7}},{"line":618,"address":[],"length":0,"stats":{"Line":7}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}}],"covered":29,"coverable":86},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","prompt.rs"],"content":"//! Interactive prompts for collecting variable values.\n//!\n//! This module provides functionality to:\n//! - Prompt users for missing variable values\n//! - Show prompts and descriptions from VarSpec\n//! - Handle defaults and required/optional status\n//! - Support batch mode (non-interactive) for CI/scripting\n\nuse dialoguer::{theme::ColorfulTheme, Input};\nuse mdvault_core::templates::engine::RenderContext;\nuse mdvault_core::vars::{\n    collect_all_variables, try_evaluate_date_expr, VarSpec, VarsMap,\n};\nuse std::collections::HashMap;\nuse std::io::{self, IsTerminal};\n\n/// Options for prompting behavior.\n#[derive(Debug, Clone, Default)]\npub struct PromptOptions {\n    /// If true, fail on missing variables instead of prompting.\n    pub batch_mode: bool,\n}\n\n/// Result of variable collection.\n#[derive(Debug)]\npub struct CollectedVars {\n    /// All collected variable values.\n    pub values: HashMap\u003cString, String\u003e,\n    /// Variables that were prompted for.\n    #[allow(dead_code)]\n    pub prompted: Vec\u003cString\u003e,\n    /// Variables that used defaults.\n    #[allow(dead_code)]\n    pub defaulted: Vec\u003cString\u003e,\n}\n\n/// Error type for variable collection.\n#[derive(Debug)]\npub enum PromptError {\n    /// Missing required variable in batch mode.\n    MissingRequired(String),\n    /// IO error during prompting.\n    Io(io::Error),\n    /// User cancelled input.\n    Cancelled,\n}\n\nimpl std::fmt::Display for PromptError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            PromptError::MissingRequired(name) =\u003e {\n                write!(f, \"missing required variable: {name}\\n  Hint: use --var {name}=\\\"...\\\" or remove --batch\")\n            }\n            PromptError::Io(e) =\u003e write!(f, \"IO error: {e}\"),\n            PromptError::Cancelled =\u003e write!(f, \"input cancelled by user\"),\n        }\n    }\n}\n\nimpl std::error::Error for PromptError {}\n\nimpl From\u003cio::Error\u003e for PromptError {\n    fn from(e: io::Error) -\u003e Self {\n        PromptError::Io(e)\n    }\n}\n\n/// Collect all required variables by prompting the user for missing values.\n///\n/// # Arguments\n/// * `vars_map` - Variable specifications from template/capture frontmatter\n/// * `content` - Template/capture content to extract additional variables from\n/// * `provided` - Variables already provided via --var flags\n/// * `context` - Render context with built-in variables\n/// * `options` - Prompting options (batch mode, etc.)\n///\n/// # Returns\n/// Collected variables including provided, prompted, and defaulted values.\npub fn collect_variables(\n    vars_map: Option\u003c\u0026VarsMap\u003e,\n    content: \u0026str,\n    provided: \u0026HashMap\u003cString, String\u003e,\n    context: \u0026RenderContext,\n    options: \u0026PromptOptions,\n) -\u003e Result\u003cCollectedVars, PromptError\u003e {\n    let mut values = provided.clone();\n    let mut prompted = Vec::new();\n    let mut defaulted = Vec::new();\n\n    // Check if stdin is a terminal (interactive)\n    let is_interactive = io::stdin().is_terminal() \u0026\u0026 !options.batch_mode;\n\n    // Get all variables needed\n    let all_vars = collect_all_variables(vars_map, content);\n\n    for (name, spec) in all_vars {\n        // Skip if already provided\n        if values.contains_key(\u0026name) {\n            continue;\n        }\n\n        // Skip if it's in the context (built-in variable)\n        if context.contains_key(\u0026name) {\n            continue;\n        }\n\n        // Try to get default value\n        let default_value = spec\n            .as_ref()\n            .and_then(|s| s.default())\n            .and_then(|d| resolve_default(d, \u0026values, context));\n\n        let is_required = spec.as_ref().is_none_or(|s| s.is_required());\n\n        if let Some(default) = default_value {\n            if is_interactive {\n                // Prompt with default pre-filled\n                let value = prompt_with_default(\u0026name, spec.as_ref(), \u0026default)?;\n                if value != default {\n                    prompted.push(name.clone());\n                } else {\n                    defaulted.push(name.clone());\n                }\n                values.insert(name, value);\n            } else {\n                // Use default in batch mode\n                defaulted.push(name.clone());\n                values.insert(name, default);\n            }\n        } else if is_required {\n            if is_interactive {\n                // Prompt for required variable\n                let value = prompt_required(\u0026name, spec.as_ref())?;\n                prompted.push(name.clone());\n                values.insert(name, value);\n            } else {\n                // Fail in batch mode\n                return Err(PromptError::MissingRequired(name));\n            }\n        }\n        // Optional variables without defaults are skipped\n    }\n\n    Ok(CollectedVars { values, prompted, defaulted })\n}\n\n/// Resolve a default value, which may contain date math expressions.\nfn resolve_default(\n    default: \u0026str,\n    values: \u0026HashMap\u003cString, String\u003e,\n    context: \u0026RenderContext,\n) -\u003e Option\u003cString\u003e {\n    // Check if it's a date math expression like \"{{today + 1d}}\"\n    let trimmed = default.trim();\n    if trimmed.starts_with(\"{{\") \u0026\u0026 trimmed.ends_with(\"}}\") {\n        let inner = \u0026trimmed[2..trimmed.len() - 2].trim();\n        if let Some(evaluated) = try_evaluate_date_expr(inner) {\n            return Some(evaluated);\n        }\n        // Try variable lookup\n        if let Some(val) = values.get(*inner).or_else(|| context.get(*inner)) {\n            return Some(val.clone());\n        }\n    }\n\n    // Return as-is if it's a static default\n    Some(default.to_string())\n}\n\n/// Prompt for a required variable (no default).\nfn prompt_required(name: \u0026str, spec: Option\u003c\u0026VarSpec\u003e) -\u003e Result\u003cString, PromptError\u003e {\n    let theme = ColorfulTheme::default();\n    let prompt_text = spec.map(|s| s.prompt()).filter(|p| !p.is_empty()).unwrap_or(name);\n\n    // Show description if available\n    if let Some(desc) = spec.and_then(|s| s.description()) {\n        eprintln!(\"  {desc}\");\n    }\n\n    Input::\u003cString\u003e::with_theme(\u0026theme)\n        .with_prompt(prompt_text)\n        .interact_text()\n        .map_err(dialoguer_error_to_prompt_error)\n}\n\n/// Prompt for a variable with a default value.\nfn prompt_with_default(\n    name: \u0026str,\n    spec: Option\u003c\u0026VarSpec\u003e,\n    default: \u0026str,\n) -\u003e Result\u003cString, PromptError\u003e {\n    let theme = ColorfulTheme::default();\n    let prompt_text = spec.map(|s| s.prompt()).filter(|p| !p.is_empty()).unwrap_or(name);\n\n    // Show description if available\n    if let Some(desc) = spec.and_then(|s| s.description()) {\n        eprintln!(\"  {desc}\");\n    }\n\n    Input::\u003cString\u003e::with_theme(\u0026theme)\n        .with_prompt(prompt_text)\n        .default(default.to_string())\n        .allow_empty(true)\n        .interact_text()\n        .map_err(dialoguer_error_to_prompt_error)\n}\n\n/// Convert dialoguer error to our PromptError.\nfn dialoguer_error_to_prompt_error(e: dialoguer::Error) -\u003e PromptError {\n    match e {\n        dialoguer::Error::IO(io_err) =\u003e {\n            if io_err.kind() == io::ErrorKind::UnexpectedEof {\n                PromptError::Cancelled\n            } else {\n                PromptError::Io(io_err)\n            }\n        }\n    }\n}\n\n/// Prompt for a single field value.\n///\n/// This is a simpler interface for prompting for individual fields,\n/// used by type-based scaffolding to collect missing required fields.\n///\n/// # Arguments\n/// * `field` - The field name (used in error messages)\n/// * `prompt` - The prompt text to display\n/// * `enum_hint` - Optional hint for enum values (e.g., \"low/medium/high\")\n/// * `required` - Whether the field is required\n///\n/// # Returns\n/// The user's input, or an error if cancelled or required field empty.\npub fn prompt_for_field(\n    field: \u0026str,\n    prompt: \u0026str,\n    enum_hint: Option\u003c\u0026str\u003e,\n    required: bool,\n) -\u003e Result\u003cString, PromptError\u003e {\n    let is_interactive = io::stdin().is_terminal();\n\n    if !is_interactive {\n        return Err(PromptError::MissingRequired(field.to_string()));\n    }\n\n    let theme = ColorfulTheme::default();\n\n    // Build prompt with enum hint if provided\n    let prompt_text = if let Some(hint) = enum_hint {\n        format!(\"{} [{}]\", prompt, hint)\n    } else {\n        prompt.to_string()\n    };\n\n    let input: String = Input::with_theme(\u0026theme)\n        .with_prompt(\u0026prompt_text)\n        .allow_empty(!required)\n        .interact_text()\n        .map_err(dialoguer_error_to_prompt_error)?;\n\n    if required \u0026\u0026 input.is_empty() {\n        return Err(PromptError::MissingRequired(field.to_string()));\n    }\n\n    Ok(input)\n}\n\n/// Parse --var arguments into a HashMap.\n///\n/// Expected format: `key=value`\n#[allow(dead_code)]\npub fn parse_var_args(args: \u0026[String]) -\u003e HashMap\u003cString, String\u003e {\n    let mut map = HashMap::new();\n    for arg in args {\n        if let Some((key, value)) = arg.split_once('=') {\n            map.insert(key.to_string(), value.to_string());\n        }\n    }\n    map\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_var_args() {\n        let args = vec![\n            \"title=Hello\".to_string(),\n            \"author=World\".to_string(),\n            \"empty=\".to_string(),\n        ];\n        let map = parse_var_args(\u0026args);\n        assert_eq!(map.get(\"title\"), Some(\u0026\"Hello\".to_string()));\n        assert_eq!(map.get(\"author\"), Some(\u0026\"World\".to_string()));\n        assert_eq!(map.get(\"empty\"), Some(\u0026String::new()));\n    }\n\n    #[test]\n    fn test_resolve_default_static() {\n        let values = HashMap::new();\n        let context = RenderContext::new();\n        let result = resolve_default(\"hello\", \u0026values, \u0026context);\n        assert_eq!(result, Some(\"hello\".to_string()));\n    }\n\n    #[test]\n    fn test_resolve_default_date_expr() {\n        let values = HashMap::new();\n        let context = RenderContext::new();\n        let result = resolve_default(\"{{today}}\", \u0026values, \u0026context);\n        // Should be a date string\n        assert!(result.is_some());\n        assert!(result.unwrap().contains(\"-\")); // YYYY-MM-DD format\n    }\n\n    #[test]\n    fn test_resolve_default_variable_lookup() {\n        let mut context = RenderContext::new();\n        context.insert(\"vault_root\".to_string(), \"/home/user/vault\".to_string());\n        let values = HashMap::new();\n        let result = resolve_default(\"{{vault_root}}\", \u0026values, \u0026context);\n        assert_eq!(result, Some(\"/home/user/vault\".to_string()));\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":18}},{"line":86,"address":[],"length":0,"stats":{"Line":54}},{"line":87,"address":[],"length":0,"stats":{"Line":36}},{"line":88,"address":[],"length":0,"stats":{"Line":36}},{"line":91,"address":[],"length":0,"stats":{"Line":54}},{"line":94,"address":[],"length":0,"stats":{"Line":72}},{"line":96,"address":[],"length":0,"stats":{"Line":63}},{"line":98,"address":[],"length":0,"stats":{"Line":45}},{"line":99,"address":[],"length":0,"stats":{"Line":13}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":10}},{"line":113,"address":[],"length":0,"stats":{"Line":12}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":10}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":36}},{"line":148,"address":[],"length":0,"stats":{"Line":5}},{"line":154,"address":[],"length":0,"stats":{"Line":15}},{"line":155,"address":[],"length":0,"stats":{"Line":14}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":7}},{"line":275,"address":[],"length":0,"stats":{"Line":12}},{"line":276,"address":[],"length":0,"stats":{"Line":15}},{"line":279,"address":[],"length":0,"stats":{"Line":1}}],"covered":34,"coverable":92},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","actions.rs"],"content":"//! Execution logic for templates, captures, and macros.\n\nuse std::collections::{HashMap, HashSet};\nuse std::fs;\nuse std::path::Path;\n\nuse chrono::Local;\nuse regex::Regex;\n\nuse mdvault_core::captures::{CaptureRepository, CaptureSpec};\nuse mdvault_core::config::types::ResolvedConfig;\nuse mdvault_core::frontmatter::{apply_ops, parse, serialize};\nuse mdvault_core::macros::{\n    run_macro, MacroRepository, RunContext, RunOptions, StepExecutor,\n};\nuse mdvault_core::markdown_ast::{MarkdownAstError, MarkdownEditor, SectionMatch};\nuse mdvault_core::templates::discovery::TemplateInfo;\nuse mdvault_core::templates::engine::{build_render_context, render};\nuse mdvault_core::templates::repository::TemplateRepository;\n\n/// Built-in variables that are automatically provided.\nconst BUILTIN_VARS: \u0026[\u0026str] = \u0026[\n    \"date\",\n    \"time\",\n    \"datetime\",\n    \"vault_root\",\n    \"templates_dir\",\n    \"captures_dir\",\n    \"macros_dir\",\n];\n\n/// Extract user-defined variables from a capture spec (excludes built-ins).\npub fn extract_user_variables(spec: \u0026CaptureSpec) -\u003e Vec\u003cString\u003e {\n    let re = Regex::new(r\"\\{\\{([a-zA-Z0-9_]+)\\}\\}\").unwrap();\n    let builtin: HashSet\u003c\u0026str\u003e = BUILTIN_VARS.iter().copied().collect();\n\n    let mut vars = HashSet::new();\n\n    // Extract from content (if present)\n    if let Some(content) = \u0026spec.content {\n        for cap in re.captures_iter(content) {\n            let var = cap.get(1).unwrap().as_str();\n            if !builtin.contains(var) {\n                vars.insert(var.to_string());\n            }\n        }\n    }\n\n    // Extract from target file path\n    for cap in re.captures_iter(\u0026spec.target.file) {\n        let var = cap.get(1).unwrap().as_str();\n        if !builtin.contains(var) {\n            vars.insert(var.to_string());\n        }\n    }\n\n    // Extract from section (if present)\n    if let Some(section) = \u0026spec.target.section {\n        for cap in re.captures_iter(section) {\n            let var = cap.get(1).unwrap().as_str();\n            if !builtin.contains(var) {\n                vars.insert(var.to_string());\n            }\n        }\n    }\n\n    let mut sorted: Vec\u003c_\u003e = vars.into_iter().collect();\n    sorted.sort();\n    sorted\n}\n\n/// Execute template creation.\npub fn execute_template(\n    config: \u0026ResolvedConfig,\n    template_name: \u0026str,\n    output_path: \u0026Path,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003cString, String\u003e {\n    // Check output doesn't exist\n    if output_path.exists() {\n        return Err(format!(\"File already exists: {}\", output_path.display()));\n    }\n\n    // Load template\n    let repo = TemplateRepository::new(\u0026config.templates_dir)\n        .map_err(|e| format!(\"Failed to load templates: {e}\"))?;\n\n    let loaded =\n        repo.get_by_name(template_name).map_err(|e| format!(\"Template error: {e}\"))?;\n\n    // Build context with user variables\n    let info = TemplateInfo {\n        logical_name: loaded.logical_name.clone(),\n        path: loaded.path.clone(),\n    };\n\n    let mut ctx = build_render_context(config, \u0026info, output_path);\n    // Add user-provided variables to context\n    for (k, v) in vars {\n        ctx.insert(k.clone(), v.clone());\n    }\n\n    let rendered = render(\u0026loaded, \u0026ctx).map_err(|e| format!(\"Render error: {e}\"))?;\n\n    // Create parent dirs and write\n    if let Some(parent) = output_path.parent() {\n        fs::create_dir_all(parent)\n            .map_err(|e| format!(\"Failed to create directories: {e}\"))?;\n    }\n\n    fs::write(output_path, rendered).map_err(|e| format!(\"Write failed: {e}\"))?;\n\n    Ok(format!(\"Created: {}\", output_path.display()))\n}\n\n/// Execute capture insertion.\npub fn execute_capture(\n    config: \u0026ResolvedConfig,\n    capture_name: \u0026str,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003cString, String\u003e {\n    // Load capture\n    let repo = CaptureRepository::new(\u0026config.captures_dir)\n        .map_err(|e| format!(\"Failed to load captures: {e}\"))?;\n\n    let loaded =\n        repo.get_by_name(capture_name).map_err(|e| format!(\"Capture error: {e}\"))?;\n\n    // Build full context (builtins + user vars)\n    let mut ctx = build_capture_context(config);\n    for (k, v) in vars {\n        ctx.insert(k.clone(), v.clone());\n    }\n\n    // Resolve target file\n    let target_path = render_string(\u0026loaded.spec.target.file, \u0026ctx);\n    let target_path = resolve_target_path(\u0026config.vault_root, \u0026target_path);\n\n    // Read existing file\n    let existing = fs::read_to_string(\u0026target_path)\n        .map_err(|e| format!(\"Failed to read {}: {e}\", target_path.display()))?;\n\n    // Execute capture operations\n    let (result_content, section_info) =\n        execute_capture_operations(\u0026existing, \u0026loaded.spec, \u0026ctx)?;\n\n    // Write back\n    fs::write(\u0026target_path, \u0026result_content).map_err(|e| format!(\"Write failed: {e}\"))?;\n\n    let mut msg = format!(\"Captured to: {}\", target_path.display());\n    if let Some((title, _level)) = section_info {\n        msg.push_str(\u0026format!(\" (section: {})\", title));\n    }\n    if loaded.spec.frontmatter.is_some() {\n        msg.push_str(\" [frontmatter updated]\");\n    }\n\n    Ok(msg)\n}\n\n/// Execute capture operations: frontmatter modification and/or content insertion.\nfn execute_capture_operations(\n    existing_content: \u0026str,\n    spec: \u0026CaptureSpec,\n    ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(String, Option\u003c(String, u8)\u003e), String\u003e {\n    // Parse frontmatter from existing content first\n    let mut parsed = parse(existing_content)\n        .map_err(|e| format!(\"Failed to parse frontmatter: {e}\"))?;\n    let mut section_info = None;\n\n    // Apply frontmatter operations if specified\n    if let Some(fm_ops) = \u0026spec.frontmatter {\n        parsed = apply_ops(parsed, fm_ops, ctx)\n            .map_err(|e| format!(\"Frontmatter error: {e}\"))?;\n    }\n\n    // Insert content if specified - operate on body only to preserve frontmatter\n    if let Some(content_template) = \u0026spec.content {\n        let section = spec.target.section.as_ref().ok_or_else(|| {\n            \"Capture has content but no target section specified\".to_string()\n        })?;\n\n        let rendered_content = render_string(content_template, ctx);\n        let section_match = SectionMatch::new(section);\n        let position = spec.target.position.clone().into();\n\n        let result = MarkdownEditor::insert_into_section(\n            \u0026parsed.body,\n            \u0026section_match,\n            \u0026rendered_content,\n            position,\n        )\n        .map_err(|e| match \u0026e {\n            MarkdownAstError::SectionNotFound(s) =\u003e format!(\"Section not found: '{s}'\"),\n            MarkdownAstError::EmptyDocument =\u003e \"Target file is empty\".to_string(),\n            MarkdownAstError::RenderError(msg) =\u003e format!(\"Render error: {msg}\"),\n        })?;\n\n        section_info = Some((result.matched_heading.title, result.matched_heading.level));\n        parsed.body = result.content;\n    }\n\n    // Serialize the document (frontmatter + body)\n    let final_content = serialize(\u0026parsed);\n    Ok((final_content, section_info))\n}\n\nfn build_capture_context(cfg: \u0026ResolvedConfig) -\u003e HashMap\u003cString, String\u003e {\n    let mut ctx = HashMap::new();\n\n    // Date/time\n    let now = Local::now();\n    ctx.insert(\"date\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"time\".into(), now.format(\"%H:%M\").to_string());\n    ctx.insert(\"datetime\".into(), now.to_rfc3339());\n\n    // Config paths\n    ctx.insert(\"vault_root\".into(), cfg.vault_root.to_string_lossy().to_string());\n    ctx.insert(\"templates_dir\".into(), cfg.templates_dir.to_string_lossy().to_string());\n    ctx.insert(\"captures_dir\".into(), cfg.captures_dir.to_string_lossy().to_string());\n    ctx.insert(\"macros_dir\".into(), cfg.macros_dir.to_string_lossy().to_string());\n\n    ctx\n}\n\nfn render_string(template: \u0026str, ctx: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    let re = Regex::new(r\"\\{\\{([a-zA-Z0-9_]+)\\}\\}\").unwrap();\n    re.replace_all(template, |caps: \u0026regex::Captures\u003c'_\u003e| {\n        let key = \u0026caps[1];\n        ctx.get(key).cloned().unwrap_or_else(|| caps[0].to_string())\n    })\n    .into_owned()\n}\n\nfn resolve_target_path(vault_root: \u0026Path, target: \u0026str) -\u003e std::path::PathBuf {\n    let path = std::path::Path::new(target);\n    if path.is_absolute() {\n        path.to_path_buf()\n    } else {\n        vault_root.join(path)\n    }\n}\n\n/// Execute a macro workflow.\npub fn execute_macro(\n    config: \u0026ResolvedConfig,\n    macro_name: \u0026str,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003cString, String\u003e {\n    use mdvault_core::macros::{\n        CaptureStep, MacroRunError, ShellStep, StepResult, TemplateStep,\n    };\n\n    // Load macro\n    let repo = MacroRepository::new(\u0026config.macros_dir)\n        .map_err(|e| format!(\"Failed to load macros: {e}\"))?;\n\n    let loaded = repo.get_by_name(macro_name).map_err(|e| format!(\"Macro error: {e}\"))?;\n\n    // Build context with provided vars\n    let mut ctx_vars = build_capture_context(config);\n    for (k, v) in vars {\n        ctx_vars.insert(k.clone(), v.clone());\n    }\n\n    // TUI executor (no shell support)\n    struct TuiStepExecutor\u003c'a\u003e {\n        config: \u0026'a ResolvedConfig,\n    }\n\n    impl\u003c'a\u003e StepExecutor for TuiStepExecutor\u003c'a\u003e {\n        fn execute_template(\n            \u0026self,\n            step: \u0026TemplateStep,\n            ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            use mdvault_core::templates::engine::{\n                build_minimal_context, render, render_string,\n                resolve_template_output_path,\n            };\n\n            let step_vars = ctx.with_step_vars(\u0026step.vars_with);\n\n            // Load template\n            let repo = TemplateRepository::new(\u0026self.config.templates_dir)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n            let loaded = repo\n                .get_by_name(\u0026step.template)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n            // Build template info\n            let info = TemplateInfo {\n                logical_name: loaded.logical_name.clone(),\n                path: loaded.path.clone(),\n            };\n\n            // Resolve output path\n            let output_path = if let Some(ref output) = step.output {\n                let rendered = render_string(output, \u0026step_vars)\n                    .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n                self.config.vault_root.join(\u0026rendered)\n            } else {\n                let minimal_ctx = build_minimal_context(self.config, \u0026info);\n                let mut merged_ctx = minimal_ctx;\n                for (k, v) in \u0026step_vars {\n                    merged_ctx.insert(k.clone(), v.clone());\n                }\n                resolve_template_output_path(\u0026loaded, self.config, \u0026merged_ctx)\n                    .map_err(|e| MacroRunError::TemplateError(e.to_string()))?\n                    .ok_or_else(|| {\n                        MacroRunError::TemplateError(\n                            \"Template has no output path\".to_string(),\n                        )\n                    })?\n            };\n\n            // Check if file exists\n            if output_path.exists() {\n                return Err(MacroRunError::TemplateError(format!(\n                    \"File already exists: {}\",\n                    output_path.display()\n                )));\n            }\n\n            // Render template (includes frontmatter extra fields)\n            let rendered = render(\u0026loaded, \u0026step_vars)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n            // Create parent directories\n            if let Some(parent) = output_path.parent() {\n                fs::create_dir_all(parent)\n                    .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n            }\n\n            // Write file\n            fs::write(\u0026output_path, \u0026rendered)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Created {}\", output_path.display()),\n                output_path: Some(output_path),\n            })\n        }\n\n        fn execute_capture(\n            \u0026self,\n            step: \u0026CaptureStep,\n            ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            use mdvault_core::templates::engine::render_string;\n\n            let step_vars = ctx.with_step_vars(\u0026step.vars_with);\n\n            // Load capture\n            let repo = CaptureRepository::new(\u0026self.config.captures_dir)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n            let loaded = repo\n                .get_by_name(\u0026step.capture)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n            // Render target file path\n            let target_file_raw = render_string(\u0026loaded.spec.target.file, \u0026step_vars)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n            let target_file =\n                resolve_target_path(\u0026self.config.vault_root, \u0026target_file_raw);\n\n            // Read existing file\n            let existing_content = fs::read_to_string(\u0026target_file).map_err(|e| {\n                MacroRunError::CaptureError(format!(\n                    \"Failed to read {}: {e}\",\n                    target_file.display()\n                ))\n            })?;\n\n            // Parse frontmatter\n            let mut parsed = parse(\u0026existing_content)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n            // Apply frontmatter operations\n            if let Some(fm_ops) = \u0026loaded.spec.frontmatter {\n                parsed = apply_ops(parsed, fm_ops, \u0026step_vars)\n                    .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n            }\n\n            // Insert content if specified\n            if let Some(content_template) = \u0026loaded.spec.content {\n                let section = loaded.spec.target.section.as_ref().ok_or_else(|| {\n                    MacroRunError::CaptureError(\n                        \"Capture has content but no target section\".to_string(),\n                    )\n                })?;\n\n                let rendered_content = render_string(content_template, \u0026step_vars)\n                    .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n                let section_match = SectionMatch::new(section);\n                let position = loaded.spec.target.position.clone().into();\n\n                let result = MarkdownEditor::insert_into_section(\n                    \u0026parsed.body,\n                    \u0026section_match,\n                    \u0026rendered_content,\n                    position,\n                )\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n                parsed.body = result.content;\n            }\n\n            // Serialize and write\n            let final_content = serialize(\u0026parsed);\n            fs::write(\u0026target_file, \u0026final_content)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Updated {}\", target_file.display()),\n                output_path: Some(target_file),\n            })\n        }\n\n        fn execute_shell(\n            \u0026self,\n            _step: \u0026ShellStep,\n            _ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            // Shell not supported in TUI\n            Err(MacroRunError::TrustRequired)\n        }\n    }\n\n    let executor = TuiStepExecutor { config };\n\n    // Run with no trust (shell commands will fail)\n    let run_options = RunOptions { trust: false, allow_shell: false, dry_run: false };\n\n    let run_ctx = RunContext::new(ctx_vars, run_options);\n    let result = run_macro(\u0026loaded, \u0026executor, run_ctx);\n\n    if result.success {\n        let mut msg = format!(\"Completed {} steps\", result.step_results.len());\n        if let Some(last) = result.step_results.last() {\n            if let Some(path) = \u0026last.output_path {\n                msg.push_str(\u0026format!(\"  {}\", path.display()));\n            }\n        }\n        Ok(msg)\n    } else {\n        let failed = result\n            .step_results\n            .iter()\n            .find(|r| !r.success)\n            .map(|r| r.message.clone())\n            .unwrap_or_else(|| \"Unknown error\".to_string());\n        Err(format!(\"Macro failed: {}\", failed))\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":211},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","app.rs"],"content":"//! Application state and update logic following The Elm Architecture.\n\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\nuse mdvault_core::captures::CaptureInfo;\nuse mdvault_core::config::types::ResolvedConfig;\nuse mdvault_core::macros::{requires_trust, MacroInfo};\nuse mdvault_core::templates::discovery::TemplateInfo;\nuse mdvault_core::templates::engine::build_minimal_context;\nuse mdvault_core::templates::repository::TemplateRepository;\nuse mdvault_core::vars::collect_all_variables;\n\n/// Unified item that can be either a template, capture, or macro.\n#[derive(Debug, Clone)]\npub enum PaletteItem {\n    Template(TemplateInfo),\n    Capture(CaptureInfo),\n    Macro(MacroInfo),\n}\n\nimpl PaletteItem {\n    pub fn name(\u0026self) -\u003e \u0026str {\n        match self {\n            PaletteItem::Template(t) =\u003e \u0026t.logical_name,\n            PaletteItem::Capture(c) =\u003e \u0026c.logical_name,\n            PaletteItem::Macro(m) =\u003e \u0026m.logical_name,\n        }\n    }\n}\n\n/// Variable info with display metadata.\n#[derive(Debug, Clone)]\npub struct VarInfo {\n    /// Variable name.\n    pub name: String,\n    /// Prompt text to show user.\n    pub prompt: Option\u003cString\u003e,\n    /// Description of what this variable is for.\n    pub description: Option\u003cString\u003e,\n    /// Default value (pre-fills input).\n    pub default: Option\u003cString\u003e,\n}\n\n/// Current operating mode.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Mode {\n    /// Browsing palette, selecting item.\n    Browse,\n    /// Entering output path for template.\n    OutputPath,\n    /// Entering variables for selected item.\n    Input { var_index: usize },\n    /// Showing result (success/error).\n    Result,\n}\n\n/// Preview content for the selected item.\n#[derive(Debug, Clone)]\npub enum Preview {\n    None,\n    Template { content: String },\n    Capture { content: String },\n    Macro { content: String, requires_trust: bool },\n    Error(String),\n}\n\n/// Feedback message to display in status bar.\n#[derive(Debug, Clone)]\npub struct StatusMessage {\n    pub text: String,\n    pub is_error: bool,\n}\n\n/// Messages that drive state updates.\n#[derive(Debug, Clone)]\npub enum Message {\n    // Navigation\n    SelectNext,\n    SelectPrev,\n\n    // Mode transitions\n    Execute,\n    Cancel,\n\n    // Input handling\n    InputChar(char),\n    InputBackspace,\n    InputSubmit,\n\n    // System\n    Quit,\n    ClearStatus,\n}\n\n/// Main application state.\npub struct App {\n    /// Operating mode.\n    pub mode: Mode,\n\n    /// Resolved configuration.\n    pub config: ResolvedConfig,\n\n    /// All palette items (templates + captures + macros).\n    pub items: Vec\u003cPaletteItem\u003e,\n\n    /// Index where captures start in items list.\n    pub captures_start_index: usize,\n\n    /// Index where macros start in items list.\n    pub macros_start_index: usize,\n\n    /// Currently selected index in palette.\n    pub selected: usize,\n\n    /// Preview of currently selected item.\n    pub preview: Preview,\n\n    /// Variables required by current item (with metadata for prompts).\n    pub required_var_infos: Vec\u003cVarInfo\u003e,\n\n    /// Variable values entered by user.\n    pub var_values: HashMap\u003cString, String\u003e,\n\n    /// Current input buffer (for variable/path entry).\n    pub input_buffer: String,\n\n    /// Status bar message.\n    pub status: Option\u003cStatusMessage\u003e,\n\n    /// Should quit.\n    pub should_quit: bool,\n\n    /// Resolved output path for template (from frontmatter or user input).\n    pub resolved_output_path: Option\u003cPathBuf\u003e,\n}\n\nimpl App {\n    /// Create a new App with loaded config and discovered items.\n    pub fn new(\n        config: ResolvedConfig,\n        templates: Vec\u003cTemplateInfo\u003e,\n        captures: Vec\u003cCaptureInfo\u003e,\n        macros: Vec\u003cMacroInfo\u003e,\n    ) -\u003e Self {\n        let captures_start_index = templates.len();\n        let macros_start_index = templates.len() + captures.len();\n\n        let mut items: Vec\u003cPaletteItem\u003e =\n            templates.into_iter().map(PaletteItem::Template).collect();\n        items.extend(captures.into_iter().map(PaletteItem::Capture));\n        items.extend(macros.into_iter().map(PaletteItem::Macro));\n\n        let mut app = App {\n            mode: Mode::Browse,\n            config,\n            items,\n            captures_start_index,\n            macros_start_index,\n            selected: 0,\n            preview: Preview::None,\n            required_var_infos: Vec::new(),\n            var_values: HashMap::new(),\n            input_buffer: String::new(),\n            status: None,\n            should_quit: false,\n            resolved_output_path: None,\n        };\n\n        // Load preview for first item if any\n        app.load_preview();\n        app\n    }\n\n    /// Process a message and update state.\n    pub fn update(\u0026mut self, msg: Message) {\n        match msg {\n            Message::SelectNext =\u003e {\n                if self.selected \u003c self.items.len().saturating_sub(1) {\n                    self.selected += 1;\n                    self.load_preview();\n                }\n            }\n            Message::SelectPrev =\u003e {\n                if self.selected \u003e 0 {\n                    self.selected -= 1;\n                    self.load_preview();\n                }\n            }\n            Message::Execute =\u003e {\n                self.start_execution();\n            }\n            Message::Cancel =\u003e {\n                self.mode = Mode::Browse;\n                self.input_buffer.clear();\n                self.required_var_infos.clear();\n                self.var_values.clear();\n                self.resolved_output_path = None;\n            }\n            Message::InputChar(c) =\u003e {\n                self.input_buffer.push(c);\n            }\n            Message::InputBackspace =\u003e {\n                self.input_buffer.pop();\n            }\n            Message::InputSubmit =\u003e {\n                self.submit_input();\n            }\n            Message::ClearStatus =\u003e {\n                self.status = None;\n                self.mode = Mode::Browse;\n                self.input_buffer.clear();\n                self.required_var_infos.clear();\n                self.var_values.clear();\n                self.resolved_output_path = None;\n            }\n            Message::Quit =\u003e {\n                self.should_quit = true;\n            }\n        }\n    }\n\n    /// Load preview for currently selected item.\n    pub fn load_preview(\u0026mut self) {\n        use mdvault_core::macros::MacroRepository;\n\n        if self.items.is_empty() {\n            self.preview = Preview::None;\n            return;\n        }\n\n        let item = \u0026self.items[self.selected];\n        match item {\n            PaletteItem::Template(info) =\u003e match std::fs::read_to_string(\u0026info.path) {\n                Ok(content) =\u003e self.preview = Preview::Template { content },\n                Err(e) =\u003e self.preview = Preview::Error(format!(\"Failed to read: {e}\")),\n            },\n            PaletteItem::Capture(info) =\u003e match std::fs::read_to_string(\u0026info.path) {\n                Ok(content) =\u003e self.preview = Preview::Capture { content },\n                Err(e) =\u003e self.preview = Preview::Error(format!(\"Failed to read: {e}\")),\n            },\n            PaletteItem::Macro(info) =\u003e {\n                // Load macro to check if it requires trust\n                let needs_trust = match MacroRepository::new(\u0026self.config.macros_dir) {\n                    Ok(repo) =\u003e match repo.get_by_name(\u0026info.logical_name) {\n                        Ok(loaded) =\u003e requires_trust(\u0026loaded.spec),\n                        Err(_) =\u003e false,\n                    },\n                    Err(_) =\u003e false,\n                };\n                match std::fs::read_to_string(\u0026info.path) {\n                    Ok(content) =\u003e {\n                        self.preview =\n                            Preview::Macro { content, requires_trust: needs_trust }\n                    }\n                    Err(e) =\u003e {\n                        self.preview = Preview::Error(format!(\"Failed to read: {e}\"))\n                    }\n                }\n            }\n        }\n    }\n\n    /// Start execution workflow for selected item.\n    fn start_execution(\u0026mut self) {\n        if self.items.is_empty() {\n            return;\n        }\n\n        let item = \u0026self.items[self.selected];\n        match item {\n            PaletteItem::Template(info) =\u003e {\n                // Load template variables first\n                match self.load_template_var_infos(\u0026info.logical_name) {\n                    Ok(var_infos) =\u003e {\n                        self.required_var_infos = var_infos;\n                        self.var_values.clear();\n                        if self.required_var_infos.is_empty() {\n                            // No vars needed, proceed to output path resolution\n                            self.proceed_to_template_output();\n                        } else {\n                            // Pre-fill with default if available\n                            if let Some(default) = \u0026self.required_var_infos[0].default {\n                                self.input_buffer = default.clone();\n                            } else {\n                                self.input_buffer.clear();\n                            }\n                            self.mode = Mode::Input { var_index: 0 };\n                        }\n                    }\n                    Err(e) =\u003e {\n                        self.status = Some(StatusMessage { text: e, is_error: true });\n                        self.mode = Mode::Result;\n                    }\n                }\n            }\n            PaletteItem::Capture(info) =\u003e {\n                // Load capture to extract required variables with metadata\n                match self.load_capture_var_infos(\u0026info.logical_name) {\n                    Ok(var_infos) =\u003e {\n                        self.required_var_infos = var_infos;\n                        self.var_values.clear();\n                        if self.required_var_infos.is_empty() {\n                            // No vars needed, execute immediately\n                            self.execute_capture();\n                        } else {\n                            // Pre-fill with default if available\n                            if let Some(default) = \u0026self.required_var_infos[0].default {\n                                self.input_buffer = default.clone();\n                            } else {\n                                self.input_buffer.clear();\n                            }\n                            self.mode = Mode::Input { var_index: 0 };\n                        }\n                    }\n                    Err(e) =\u003e {\n                        self.status = Some(StatusMessage { text: e, is_error: true });\n                        self.mode = Mode::Result;\n                    }\n                }\n            }\n            PaletteItem::Macro(info) =\u003e {\n                // Load macro to extract required variables with metadata\n                match self.load_macro_var_infos(\u0026info.logical_name) {\n                    Ok((var_infos, needs_trust)) =\u003e {\n                        if needs_trust {\n                            // Macros with shell commands aren't supported in TUI yet\n                            self.status = Some(StatusMessage {\n                                text: \"Macro requires --trust flag. Use CLI: mdv macro --trust\".to_string(),\n                                is_error: true,\n                            });\n                            self.mode = Mode::Result;\n                            return;\n                        }\n                        self.required_var_infos = var_infos;\n                        self.var_values.clear();\n                        if self.required_var_infos.is_empty() {\n                            // No vars needed, execute immediately\n                            self.execute_macro();\n                        } else {\n                            // Pre-fill with default if available\n                            if let Some(default) = \u0026self.required_var_infos[0].default {\n                                self.input_buffer = default.clone();\n                            } else {\n                                self.input_buffer.clear();\n                            }\n                            self.mode = Mode::Input { var_index: 0 };\n                        }\n                    }\n                    Err(e) =\u003e {\n                        self.status = Some(StatusMessage { text: e, is_error: true });\n                        self.mode = Mode::Result;\n                    }\n                }\n            }\n        }\n    }\n\n    /// Try to resolve template output path from frontmatter.\n    fn resolve_template_output(\u0026self, name: \u0026str) -\u003e Result\u003cOption\u003cPathBuf\u003e, String\u003e {\n        use mdvault_core::templates::engine::render_string;\n\n        let repo = TemplateRepository::new(\u0026self.config.templates_dir)\n            .map_err(|e| format!(\"Failed to load templates: {e}\"))?;\n\n        let loaded = repo\n            .get_by_name(name)\n            .map_err(|e| format!(\"Failed to load template: {e}\"))?;\n\n        let info = TemplateInfo {\n            logical_name: loaded.logical_name.clone(),\n            path: loaded.path.clone(),\n        };\n\n        // Build context with user variables for output path resolution\n        let mut ctx = build_minimal_context(\u0026self.config, \u0026info);\n        for (k, v) in \u0026self.var_values {\n            ctx.insert(k.clone(), v.clone());\n        }\n\n        // Check if template has output path in frontmatter\n        if let Some(ref fm) = loaded.frontmatter {\n            if let Some(ref output) = fm.output {\n                let rendered = render_string(output, \u0026ctx)\n                    .map_err(|e| format!(\"Failed to render output path: {e}\"))?;\n                let path = self.config.vault_root.join(\u0026rendered);\n                return Ok(Some(path));\n            }\n        }\n\n        Ok(None)\n    }\n\n    /// Proceed to output path resolution after collecting variables.\n    fn proceed_to_template_output(\u0026mut self) {\n        let Some(PaletteItem::Template(info)) = self.items.get(self.selected) else {\n            return;\n        };\n\n        match self.resolve_template_output(\u0026info.logical_name) {\n            Ok(Some(path)) =\u003e {\n                // Template has frontmatter output, execute directly\n                self.resolved_output_path = Some(path);\n                self.execute_template();\n            }\n            Ok(None) =\u003e {\n                // No frontmatter output, prompt user\n                self.resolved_output_path = None;\n                self.input_buffer.clear();\n                self.mode = Mode::OutputPath;\n            }\n            Err(e) =\u003e {\n                self.status = Some(StatusMessage { text: e, is_error: true });\n                self.mode = Mode::Result;\n            }\n        }\n    }\n\n    /// Submit current input and advance to next step.\n    fn submit_input(\u0026mut self) {\n        match \u0026self.mode {\n            Mode::OutputPath =\u003e {\n                if self.input_buffer.is_empty() {\n                    return;\n                }\n                // Convert input to absolute path and execute\n                let output_path = PathBuf::from(\u0026self.input_buffer);\n                let output_path = if output_path.is_absolute() {\n                    output_path\n                } else {\n                    self.config.vault_root.join(\u0026output_path)\n                };\n                self.resolved_output_path = Some(output_path);\n                self.execute_template();\n            }\n            Mode::Input { var_index } =\u003e {\n                let var_index = *var_index;\n                if var_index \u003c self.required_var_infos.len() {\n                    let var_name = self.required_var_infos[var_index].name.clone();\n                    self.var_values.insert(var_name, self.input_buffer.clone());\n\n                    if var_index + 1 \u003c self.required_var_infos.len() {\n                        // Pre-fill next input with default if available\n                        if let Some(default) =\n                            \u0026self.required_var_infos[var_index + 1].default\n                        {\n                            self.input_buffer = default.clone();\n                        } else {\n                            self.input_buffer.clear();\n                        }\n                        // More vars to collect\n                        self.mode = Mode::Input { var_index: var_index + 1 };\n                    } else {\n                        // All vars collected, execute based on item type\n                        self.input_buffer.clear();\n                        match \u0026self.items[self.selected] {\n                            // Templates need output path resolution after vars\n                            PaletteItem::Template(_) =\u003e self.proceed_to_template_output(),\n                            PaletteItem::Capture(_) =\u003e self.execute_capture(),\n                            PaletteItem::Macro(_) =\u003e self.execute_macro(),\n                        }\n                    }\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    /// Load capture and extract user-defined variables with metadata.\n    fn load_capture_var_infos(\u0026self, name: \u0026str) -\u003e Result\u003cVec\u003cVarInfo\u003e, String\u003e {\n        use mdvault_core::captures::CaptureRepository;\n\n        let repo = CaptureRepository::new(\u0026self.config.captures_dir)\n            .map_err(|e| format!(\"Failed to load captures: {e}\"))?;\n\n        let loaded =\n            repo.get_by_name(name).map_err(|e| format!(\"Failed to load capture: {e}\"))?;\n\n        // Get variable names from content/target/section\n        let var_names = super::actions::extract_user_variables(\u0026loaded.spec);\n\n        // Enrich with metadata from vars spec\n        let var_infos: Vec\u003cVarInfo\u003e = var_names\n            .into_iter()\n            .map(|name| {\n                let (prompt, description, default) =\n                    if let Some(vars_map) = \u0026loaded.spec.vars {\n                        if let Some(var_spec) = vars_map.get(\u0026name) {\n                            let prompt_text = var_spec.prompt();\n                            // Only use prompt if non-empty (simple form has prompt, full form might have empty)\n                            let prompt_opt = if prompt_text.is_empty() {\n                                None\n                            } else {\n                                Some(prompt_text.to_string())\n                            };\n                            (\n                                prompt_opt,\n                                var_spec.description().map(|s| s.to_string()),\n                                var_spec.default().map(|s| s.to_string()),\n                            )\n                        } else {\n                            (None, None, None)\n                        }\n                    } else {\n                        (None, None, None)\n                    };\n                VarInfo { name, prompt, description, default }\n            })\n            .collect();\n\n        Ok(var_infos)\n    }\n\n    /// Load macro and extract user-defined variables with metadata.\n    /// Returns (var_infos, needs_trust).\n    fn load_macro_var_infos(\u0026self, name: \u0026str) -\u003e Result\u003c(Vec\u003cVarInfo\u003e, bool), String\u003e {\n        use mdvault_core::macros::MacroRepository;\n\n        let repo = MacroRepository::new(\u0026self.config.macros_dir)\n            .map_err(|e| format!(\"Failed to load macros: {e}\"))?;\n\n        let loaded =\n            repo.get_by_name(name).map_err(|e| format!(\"Failed to load macro: {e}\"))?;\n\n        let needs_trust = requires_trust(\u0026loaded.spec);\n\n        // Get variables from macro spec\n        let var_infos: Vec\u003cVarInfo\u003e = if let Some(vars_map) = \u0026loaded.spec.vars {\n            vars_map\n                .iter()\n                .map(|(name, spec)| {\n                    let prompt_text = spec.prompt();\n                    let prompt_opt = if prompt_text.is_empty() {\n                        None\n                    } else {\n                        Some(prompt_text.to_string())\n                    };\n                    VarInfo {\n                        name: name.clone(),\n                        prompt: prompt_opt,\n                        description: spec.description().map(|s| s.to_string()),\n                        default: spec.default().map(|s| s.to_string()),\n                    }\n                })\n                .collect()\n        } else {\n            Vec::new()\n        };\n\n        Ok((var_infos, needs_trust))\n    }\n\n    /// Load template and extract user-defined variables with metadata.\n    fn load_template_var_infos(\u0026self, name: \u0026str) -\u003e Result\u003cVec\u003cVarInfo\u003e, String\u003e {\n        let repo = TemplateRepository::new(\u0026self.config.templates_dir)\n            .map_err(|e| format!(\"Failed to load templates: {e}\"))?;\n\n        let loaded = repo\n            .get_by_name(name)\n            .map_err(|e| format!(\"Failed to load template: {e}\"))?;\n\n        // Collect variables from frontmatter vars and body content\n        let all_vars = collect_all_variables(\n            loaded.frontmatter.as_ref().and_then(|fm| fm.vars.as_ref()),\n            \u0026loaded.body,\n        );\n\n        // Convert to VarInfo with metadata\n        let var_infos: Vec\u003cVarInfo\u003e = all_vars\n            .into_iter()\n            .map(|(name, spec_opt)| {\n                if let Some(spec) = spec_opt {\n                    let prompt_text = spec.prompt();\n                    let prompt_opt = if prompt_text.is_empty() {\n                        None\n                    } else {\n                        Some(prompt_text.to_string())\n                    };\n                    VarInfo {\n                        name,\n                        prompt: prompt_opt,\n                        description: spec.description().map(|s| s.to_string()),\n                        default: spec.default().map(|s| s.to_string()),\n                    }\n                } else {\n                    // Variable found in content but not declared in frontmatter\n                    VarInfo { name, prompt: None, description: None, default: None }\n                }\n            })\n            .collect();\n\n        Ok(var_infos)\n    }\n\n    /// Execute template creation.\n    fn execute_template(\u0026mut self) {\n        let Some(PaletteItem::Template(info)) = self.items.get(self.selected) else {\n            return;\n        };\n\n        let Some(output_path) = self.resolved_output_path.take() else {\n            self.status = Some(StatusMessage {\n                text: \"No output path resolved\".to_string(),\n                is_error: true,\n            });\n            self.mode = Mode::Result;\n            return;\n        };\n\n        match super::actions::execute_template(\n            \u0026self.config,\n            \u0026info.logical_name,\n            \u0026output_path,\n            \u0026self.var_values,\n        ) {\n            Ok(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: false });\n            }\n            Err(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: true });\n            }\n        }\n        self.mode = Mode::Result;\n        self.input_buffer.clear();\n    }\n\n    /// Execute capture insertion.\n    fn execute_capture(\u0026mut self) {\n        let Some(PaletteItem::Capture(info)) = self.items.get(self.selected) else {\n            return;\n        };\n\n        match super::actions::execute_capture(\n            \u0026self.config,\n            \u0026info.logical_name,\n            \u0026self.var_values,\n        ) {\n            Ok(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: false });\n            }\n            Err(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: true });\n            }\n        }\n        self.mode = Mode::Result;\n    }\n\n    /// Execute macro workflow.\n    fn execute_macro(\u0026mut self) {\n        let Some(PaletteItem::Macro(info)) = self.items.get(self.selected) else {\n            return;\n        };\n\n        match super::actions::execute_macro(\n            \u0026self.config,\n            \u0026info.logical_name,\n            \u0026self.var_values,\n        ) {\n            Ok(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: false });\n            }\n            Err(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: true });\n            }\n        }\n        self.mode = Mode::Result;\n    }\n\n    /// Get current input prompt label.\n    pub fn current_input_label(\u0026self) -\u003e Option\u003cString\u003e {\n        match \u0026self.mode {\n            Mode::OutputPath =\u003e Some(\"Output path\".to_string()),\n            Mode::Input { var_index } =\u003e {\n                self.required_var_infos.get(*var_index).map(|info| {\n                    // Use prompt if available, otherwise variable name\n                    info.prompt.clone().unwrap_or_else(|| info.name.clone())\n                })\n            }\n            _ =\u003e None,\n        }\n    }\n\n    /// Get current input description (if available).\n    pub fn current_input_description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match \u0026self.mode {\n            Mode::Input { var_index } =\u003e self\n                .required_var_infos\n                .get(*var_index)\n                .and_then(|info| info.description.as_deref()),\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":304},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","event.rs"],"content":"//! Event handling: maps keyboard events to application messages.\n\nuse crossterm::event::{KeyCode, KeyEvent, KeyModifiers};\n\nuse super::app::{App, Message, Mode};\n\n/// Map a key event to an optional message based on current app mode.\npub fn map_key_event(app: \u0026App, key: KeyEvent) -\u003e Option\u003cMessage\u003e {\n    // Global bindings (work in any mode)\n    if key.code == KeyCode::Char('c') \u0026\u0026 key.modifiers.contains(KeyModifiers::CONTROL) {\n        return Some(Message::Quit);\n    }\n\n    // Mode-specific bindings\n    match \u0026app.mode {\n        Mode::Browse =\u003e map_browse_keys(key),\n        Mode::OutputPath | Mode::Input { .. } =\u003e map_input_keys(key),\n        Mode::Result =\u003e map_result_keys(key),\n    }\n}\n\nfn map_browse_keys(key: KeyEvent) -\u003e Option\u003cMessage\u003e {\n    match key.code {\n        // Vim-style navigation\n        KeyCode::Char('j') | KeyCode::Down =\u003e Some(Message::SelectNext),\n        KeyCode::Char('k') | KeyCode::Up =\u003e Some(Message::SelectPrev),\n\n        // Actions\n        KeyCode::Enter =\u003e Some(Message::Execute),\n        KeyCode::Char('q') | KeyCode::Esc =\u003e Some(Message::Quit),\n\n        _ =\u003e None,\n    }\n}\n\nfn map_input_keys(key: KeyEvent) -\u003e Option\u003cMessage\u003e {\n    match key.code {\n        KeyCode::Char(c) =\u003e Some(Message::InputChar(c)),\n        KeyCode::Backspace =\u003e Some(Message::InputBackspace),\n        KeyCode::Enter =\u003e Some(Message::InputSubmit),\n        KeyCode::Esc =\u003e Some(Message::Cancel),\n        _ =\u003e None,\n    }\n}\n\nfn map_result_keys(key: KeyEvent) -\u003e Option\u003cMessage\u003e {\n    match key.code {\n        KeyCode::Enter | KeyCode::Esc | KeyCode::Char(' ') | KeyCode::Char('q') =\u003e {\n            Some(Message::ClearStatus)\n        }\n        _ =\u003e None,\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","mod.rs"],"content":"//! TUI module for interactive mode.\n\nmod actions;\nmod app;\nmod event;\nmod ui;\n\nuse std::io;\nuse std::path::Path;\nuse std::time::Duration;\n\nuse color_eyre::eyre::Result;\nuse crossterm::{\n    event::{poll, read, Event},\n    execute,\n    terminal::{\n        disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen,\n    },\n};\nuse ratatui::prelude::*;\n\nuse mdvault_core::captures::CaptureRepository;\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::macros::MacroRepository;\nuse mdvault_core::templates::repository::TemplateRepository;\n\nuse app::App;\nuse event::map_key_event;\n\n/// Run the TUI application.\npub fn run(config_path: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e) -\u003e Result\u003c()\u003e {\n    // Load config (fail fast if config broken)\n    let config = ConfigLoader::load(config_path, profile).map_err(|e| {\n        color_eyre::eyre::eyre!(\"Configuration error: {e}\\nRun 'mdv doctor' to diagnose.\")\n    })?;\n\n    // Discover templates\n    let templates = match TemplateRepository::new(\u0026config.templates_dir) {\n        Ok(repo) =\u003e repo.list_all().to_vec(),\n        Err(e) =\u003e {\n            eprintln!(\"Warning: Failed to load templates: {e}\");\n            Vec::new()\n        }\n    };\n\n    // Discover captures\n    let captures = match CaptureRepository::new(\u0026config.captures_dir) {\n        Ok(repo) =\u003e repo.list_all().to_vec(),\n        Err(e) =\u003e {\n            eprintln!(\"Warning: Failed to load captures: {e}\");\n            Vec::new()\n        }\n    };\n\n    // Discover macros\n    let macros = match MacroRepository::new(\u0026config.macros_dir) {\n        Ok(repo) =\u003e repo.list_all().to_vec(),\n        Err(e) =\u003e {\n            eprintln!(\"Warning: Failed to load macros: {e}\");\n            Vec::new()\n        }\n    };\n\n    // Initialize app\n    let app = App::new(config, templates, captures, macros);\n\n    // Setup terminal\n    let mut terminal = setup_terminal()?;\n\n    // Run with cleanup on panic\n    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n        run_app(\u0026mut terminal, app)\n    }));\n\n    // Always restore terminal\n    restore_terminal(\u0026mut terminal)?;\n\n    match result {\n        Ok(Ok(())) =\u003e Ok(()),\n        Ok(Err(e)) =\u003e Err(e),\n        Err(_) =\u003e Err(color_eyre::eyre::eyre!(\"Application panicked\")),\n    }\n}\n\nfn setup_terminal() -\u003e Result\u003cTerminal\u003cCrosstermBackend\u003cio::Stdout\u003e\u003e\u003e {\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backend = CrosstermBackend::new(stdout);\n    let terminal = Terminal::new(backend)?;\n    Ok(terminal)\n}\n\nfn restore_terminal(terminal: \u0026mut Terminal\u003cCrosstermBackend\u003cio::Stdout\u003e\u003e) -\u003e Result\u003c()\u003e {\n    disable_raw_mode()?;\n    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;\n    terminal.show_cursor()?;\n    Ok(())\n}\n\nfn run_app(\n    terminal: \u0026mut Terminal\u003cCrosstermBackend\u003cio::Stdout\u003e\u003e,\n    mut app: App,\n) -\u003e Result\u003c()\u003e {\n    loop {\n        // 1. Render current state\n        terminal.draw(|frame| ui::draw(frame, \u0026app))?;\n\n        // 2. Poll for events (with timeout for responsiveness)\n        if poll(Duration::from_millis(100))? {\n            if let Event::Key(key) = read()? {\n                // 3. Map key event to message\n                if let Some(msg) = map_key_event(\u0026app, key) {\n                    // 4. Process message\n                    app.update(msg);\n                }\n            }\n        }\n\n        // 5. Check quit condition\n        if app.should_quit {\n            return Ok(());\n        }\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","ui","layout.rs"],"content":"//! Main layout and frame composition.\n\nuse ratatui::{prelude::*, widgets::Paragraph};\n\nuse super::{palette, preview, status};\nuse crate::tui::app::App;\n\n/// Draw the entire application UI.\npub fn draw(frame: \u0026mut Frame, app: \u0026App) {\n    // Main layout: header, body, footer\n    let main_chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Length(1), // Header\n            Constraint::Min(5),    // Body\n            Constraint::Length(2), // Status bar\n        ])\n        .split(frame.area());\n\n    // Header\n    draw_header(frame, main_chunks[0], app);\n\n    // Body: palette | preview\n    let body_chunks = Layout::default()\n        .direction(Direction::Horizontal)\n        .constraints([\n            Constraint::Percentage(30), // Palette\n            Constraint::Percentage(70), // Preview\n        ])\n        .split(main_chunks[1]);\n\n    palette::draw(frame, body_chunks[0], app);\n    preview::draw(frame, body_chunks[1], app);\n\n    // Status bar\n    status::draw(frame, main_chunks[2], app);\n}\n\nfn draw_header(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let profile_text = format!(\"[{}]\", app.config.active_profile);\n    let title = \"mdvault\";\n\n    // Calculate padding for right-alignment\n    let padding =\n        area.width.saturating_sub(title.len() as u16 + profile_text.len() as u16 + 2)\n            as usize;\n\n    let line = Line::from(vec![\n        Span::styled(format!(\" {}\", title), Style::default().fg(Color::Cyan).bold()),\n        Span::raw(\" \".repeat(padding)),\n        Span::styled(profile_text, Style::default().fg(Color::DarkGray)),\n        Span::raw(\" \"),\n    ]);\n\n    let paragraph = Paragraph::new(line);\n    frame.render_widget(paragraph, area);\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":31},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","ui","mod.rs"],"content":"//! UI rendering modules.\n\nmod layout;\nmod palette;\nmod preview;\nmod status;\n\npub use layout::draw;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","ui","palette.rs"],"content":"//! Palette list rendering (templates, captures, and macros).\n\nuse ratatui::{\n    prelude::*,\n    widgets::{Block, Borders, List, ListItem},\n};\n\nuse crate::tui::app::App;\n\npub fn draw(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let mut items: Vec\u003cListItem\u003e = Vec::new();\n\n    // Templates section\n    if app.captures_start_index \u003e 0 {\n        items.push(ListItem::new(Line::from(vec![Span::styled(\n            \" TEMPLATES\",\n            Style::default().fg(Color::Cyan).bold(),\n        )])));\n\n        for (i, item) in app.items.iter().enumerate().take(app.captures_start_index) {\n            let style = if i == app.selected {\n                Style::default().bg(Color::DarkGray).fg(Color::White)\n            } else {\n                Style::default()\n            };\n\n            let prefix = if i == app.selected { \" \u003e \" } else { \"   \" };\n            items.push(ListItem::new(format!(\"{}{}\", prefix, item.name())).style(style));\n        }\n    }\n\n    // Captures section\n    let has_captures = app.macros_start_index \u003e app.captures_start_index;\n    if has_captures {\n        // Add spacing if we had templates\n        if app.captures_start_index \u003e 0 {\n            items.push(ListItem::new(\"\"));\n        }\n\n        items.push(ListItem::new(Line::from(vec![Span::styled(\n            \" CAPTURES\",\n            Style::default().fg(Color::Magenta).bold(),\n        )])));\n\n        for i in app.captures_start_index..app.macros_start_index {\n            let item = \u0026app.items[i];\n            let style = if i == app.selected {\n                Style::default().bg(Color::DarkGray).fg(Color::White)\n            } else {\n                Style::default()\n            };\n\n            let prefix = if i == app.selected { \" \u003e \" } else { \"   \" };\n            items.push(ListItem::new(format!(\"{}{}\", prefix, item.name())).style(style));\n        }\n    }\n\n    // Macros section\n    let has_macros = app.macros_start_index \u003c app.items.len();\n    if has_macros {\n        // Add spacing if we had captures or templates\n        if app.macros_start_index \u003e 0 {\n            items.push(ListItem::new(\"\"));\n        }\n\n        items.push(ListItem::new(Line::from(vec![Span::styled(\n            \" MACROS\",\n            Style::default().fg(Color::Yellow).bold(),\n        )])));\n\n        for i in app.macros_start_index..app.items.len() {\n            let item = \u0026app.items[i];\n            let style = if i == app.selected {\n                Style::default().bg(Color::DarkGray).fg(Color::White)\n            } else {\n                Style::default()\n            };\n\n            let prefix = if i == app.selected { \" \u003e \" } else { \"   \" };\n            items.push(ListItem::new(format!(\"{}{}\", prefix, item.name())).style(style));\n        }\n    }\n\n    // Empty state\n    if app.items.is_empty() {\n        items.push(ListItem::new(Span::styled(\n            \" (no items found)\",\n            Style::default().fg(Color::DarkGray).italic(),\n        )));\n    }\n\n    let list = List::new(items).block(\n        Block::default()\n            .borders(Borders::ALL)\n            .border_style(Style::default().fg(Color::DarkGray)),\n    );\n\n    // We don't use ListState for selection since we manually handle the styling\n    frame.render_widget(list, area);\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","ui","preview.rs"],"content":"//! Preview pane rendering.\n\nuse ratatui::{\n    prelude::*,\n    widgets::{Block, Borders, Paragraph, Wrap},\n};\n\nuse crate::tui::app::{App, Mode, Preview};\n\npub fn draw(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    // In input modes, show the input form instead of preview\n    if matches!(app.mode, Mode::OutputPath | Mode::Input { .. }) {\n        draw_input_form(frame, area, app);\n        return;\n    }\n\n    let (title, content, style) = match \u0026app.preview {\n        Preview::None =\u003e (\n            \"Preview\".to_string(),\n            String::from(\"Select an item to preview\"),\n            Style::default().fg(Color::DarkGray),\n        ),\n        Preview::Template { content } =\u003e {\n            (\"Template Preview\".to_string(), content.clone(), Style::default())\n        }\n        Preview::Capture { content } =\u003e {\n            (\"Capture Preview\".to_string(), content.clone(), Style::default())\n        }\n        Preview::Macro { content, requires_trust } =\u003e {\n            let title = if *requires_trust {\n                \"Macro Preview [requires --trust]\".to_string()\n            } else {\n                \"Macro Preview\".to_string()\n            };\n            (title, content.clone(), Style::default())\n        }\n        Preview::Error(e) =\u003e {\n            (\"Error\".to_string(), e.clone(), Style::default().fg(Color::Red))\n        }\n    };\n\n    let paragraph = Paragraph::new(content)\n        .style(style)\n        .block(\n            Block::default()\n                .title(title)\n                .borders(Borders::ALL)\n                .border_style(Style::default().fg(Color::DarkGray)),\n        )\n        .wrap(Wrap { trim: false });\n\n    frame.render_widget(paragraph, area);\n}\n\nfn draw_input_form(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let label = app.current_input_label().unwrap_or_else(|| \"Input\".to_string());\n\n    let title = match \u0026app.mode {\n        Mode::OutputPath =\u003e \"Enter Output Path\".to_string(),\n        Mode::Input { var_index } =\u003e {\n            if app.required_var_infos.len() \u003e 1 {\n                // Show progress\n                format!(\"Variable {} of {}\", var_index + 1, app.required_var_infos.len())\n            } else {\n                \"Enter Variable\".to_string()\n            }\n        }\n        _ =\u003e \"Input\".to_string(),\n    };\n\n    let mut content = vec![\n        Line::from(\"\"),\n        Line::from(vec![Span::styled(\n            format!(\"  {}: \", label),\n            Style::default().fg(Color::Cyan).bold(),\n        )]),\n        Line::from(vec![\n            Span::raw(\"  \"),\n            Span::styled(\u0026app.input_buffer, Style::default().fg(Color::White)),\n            Span::styled(\"_\", Style::default().fg(Color::Gray).rapid_blink()),\n        ]),\n    ];\n\n    // Show description if available\n    if let Some(description) = app.current_input_description() {\n        content.push(Line::from(\"\"));\n        content.push(Line::from(vec![Span::styled(\n            format!(\"  {}\", description),\n            Style::default().fg(Color::DarkGray).italic(),\n        )]));\n    }\n\n    content.push(Line::from(\"\"));\n    content.push(Line::from(vec![Span::styled(\n        \"  [Enter] submit  [Esc] cancel\",\n        Style::default().fg(Color::DarkGray),\n    )]));\n\n    let paragraph = Paragraph::new(content).block(\n        Block::default()\n            .title(title)\n            .borders(Borders::ALL)\n            .border_style(Style::default().fg(Color::Cyan)),\n    );\n\n    frame.render_widget(paragraph, area);\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":60},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","ui","status.rs"],"content":"//! Status bar rendering.\n\nuse ratatui::{\n    prelude::*,\n    widgets::{Block, Borders, Paragraph},\n};\n\nuse crate::tui::app::{App, Mode};\n\npub fn draw(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let (left_text, right_text) = match \u0026app.mode {\n        Mode::Browse =\u003e (\" [j/k] navigate  [Enter] execute  [q] quit\", \"Ready\"),\n        Mode::OutputPath | Mode::Input { .. } =\u003e {\n            (\" [Enter] submit  [Esc] cancel\", \"Input Mode\")\n        }\n        Mode::Result =\u003e (\" [Enter] continue\", \"Done\"),\n    };\n\n    // If there's a status message, show it on the right\n    let right_content = if let Some(status) = \u0026app.status {\n        let style = if status.is_error {\n            Style::default().fg(Color::Red)\n        } else {\n            Style::default().fg(Color::Green)\n        };\n        Span::styled(\u0026status.text, style)\n    } else {\n        Span::styled(right_text, Style::default().fg(Color::DarkGray))\n    };\n\n    let left = Span::styled(left_text, Style::default().fg(Color::DarkGray));\n\n    // Calculate padding for right-alignment\n    let left_len = left_text.len();\n    let right_len = if app.status.is_some() {\n        app.status.as_ref().unwrap().text.len()\n    } else {\n        right_text.len()\n    };\n    let padding =\n        area.width.saturating_sub(left_len as u16 + right_len as u16 + 2) as usize;\n\n    let line = Line::from(vec![left, Span::raw(\" \".repeat(padding)), right_content]);\n\n    let paragraph = Paragraph::new(line).block(\n        Block::default()\n            .borders(Borders::TOP)\n            .border_style(Style::default().fg(Color::DarkGray)),\n    );\n\n    frame.render_widget(paragraph, area);\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","capture_frontmatter.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(dir: \u0026std::path::Path, rel: \u0026str, content: impl AsRef\u003cstr\u003e) {\n    let path = dir.join(rel);\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content.as_ref()).unwrap();\n}\n\nfn make_config(vault_root: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{{{{vault_root}}}}/templates\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\"#\n    )\n}\n\n#[test]\nfn capture_sets_frontmatter_field() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that sets a frontmatter field\n    write(\n        root,\n        \"vault/captures/mark-done.yaml\",\n        r#\"\nname: mark-done\ndescription: Mark daily note as completed\n\ntarget:\n  file: \"daily/today.md\"\n\nfrontmatter:\n  completed: true\n  reviewed_at: \"{{datetime}}\"\n\"#,\n    );\n\n    // Target file with existing frontmatter\n    write(\n        root,\n        \"vault/daily/today.md\",\n        r#\"---\ntitle: Today's Note\ncompleted: false\n---\n\n# Today\n\nSome content here.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"capture\").arg(\"mark-done\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv capture\"))\n        .stdout(predicate::str::contains(\"frontmatter: modified\"));\n\n    let content = fs::read_to_string(root.join(\"vault/daily/today.md\")).unwrap();\n    assert!(content.contains(\"completed: true\"), \"completed should be true\");\n    assert!(content.contains(\"reviewed_at:\"), \"reviewed_at should be set\");\n    assert!(content.contains(\"title: Today's Note\"), \"title should be preserved\");\n}\n\n#[test]\nfn capture_toggles_frontmatter_boolean() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that toggles a boolean field\n    write(\n        root,\n        \"vault/captures/toggle-flag.yaml\",\n        r#\"\nname: toggle-flag\ndescription: Toggle a flag\n\ntarget:\n  file: \"notes.md\"\n\nfrontmatter:\n  - field: active\n    op: toggle\n\"#,\n    );\n\n    // Target file with a false flag\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"---\ntitle: Notes\nactive: false\n---\n\n# Notes\n\nContent here.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"capture\").arg(\"toggle-flag\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(root.join(\"vault/notes.md\")).unwrap();\n    assert!(content.contains(\"active: true\"), \"active should be toggled to true\");\n}\n\n#[test]\nfn capture_increments_frontmatter_counter() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that increments a counter\n    write(\n        root,\n        \"vault/captures/increment-views.yaml\",\n        r#\"\nname: increment-views\ndescription: Increment view count\n\ntarget:\n  file: \"article.md\"\n\nfrontmatter:\n  - field: views\n    op: increment\n\"#,\n    );\n\n    // Target file with a counter\n    write(\n        root,\n        \"vault/article.md\",\n        r#\"---\ntitle: Article\nviews: 5\n---\n\n# Article\n\nContent here.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"increment-views\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(root.join(\"vault/article.md\")).unwrap();\n    assert!(content.contains(\"views: 6\"), \"views should be incremented to 6\");\n}\n\n#[test]\nfn capture_appends_to_frontmatter_list() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that appends to a list\n    write(\n        root,\n        \"vault/captures/add-tag.yaml\",\n        r#\"\nname: add-tag\ndescription: Add a tag\n\ntarget:\n  file: \"note.md\"\n\nfrontmatter:\n  - field: tags\n    op: append\n    value: \"{{tag}}\"\n\"#,\n    );\n\n    // Target file with existing tags\n    write(\n        root,\n        \"vault/note.md\",\n        r#\"---\ntitle: Note\ntags:\n  - existing\n---\n\n# Note\n\nContent here.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"add-tag\")\n        .arg(\"--var\")\n        .arg(\"tag=new-tag\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(root.join(\"vault/note.md\")).unwrap();\n    assert!(content.contains(\"- existing\"), \"existing tag should be preserved\");\n    assert!(content.contains(\"- new-tag\"), \"new tag should be appended\");\n}\n\n#[test]\nfn capture_combines_content_and_frontmatter() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that does both content insertion and frontmatter modification\n    write(\n        root,\n        \"vault/captures/add-task.yaml\",\n        r#\"\nname: add-task\ndescription: Add a task and update frontmatter\n\ntarget:\n  file: \"tasks.md\"\n  section: \"TODO\"\n  position: end\n\ncontent: \"- [ ] {{task}}\"\n\nfrontmatter:\n  has_tasks: true\n  last_updated: \"{{date}}\"\n\"#,\n    );\n\n    // Target file\n    write(\n        root,\n        \"vault/tasks.md\",\n        r#\"---\ntitle: Tasks\nhas_tasks: false\n---\n\n# Tasks\n\n## TODO\n\n- [ ] Existing task\n\n## Done\n\n- [x] Completed\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"add-task\")\n        .arg(\"--var\")\n        .arg(\"task=New important task\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"section: TODO\"))\n        .stdout(predicate::str::contains(\"frontmatter: modified\"));\n\n    let content = fs::read_to_string(root.join(\"vault/tasks.md\")).unwrap();\n    // Check frontmatter was modified\n    assert!(content.contains(\"has_tasks: true\"), \"has_tasks should be true\");\n    assert!(content.contains(\"last_updated:\"), \"last_updated should be set\");\n    // Check content was inserted\n    assert!(content.contains(\"- [ ] New important task\"), \"task should be added\");\n    assert!(content.contains(\"- [ ] Existing task\"), \"existing task should be preserved\");\n}\n\n#[test]\nfn capture_creates_frontmatter_if_missing() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that sets frontmatter\n    write(\n        root,\n        \"vault/captures/add-metadata.yaml\",\n        r#\"\nname: add-metadata\ndescription: Add metadata to file\n\ntarget:\n  file: \"plain.md\"\n\nfrontmatter:\n  created: \"{{date}}\"\n  status: draft\n\"#,\n    );\n\n    // Target file without frontmatter\n    write(\n        root,\n        \"vault/plain.md\",\n        r#\"# Plain Document\n\nThis file has no frontmatter.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"capture\").arg(\"add-metadata\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(root.join(\"vault/plain.md\")).unwrap();\n    assert!(content.contains(\"---\"), \"frontmatter should be created\");\n    assert!(content.contains(\"created:\"), \"created field should exist\");\n    assert!(content.contains(\"status: draft\"), \"status should be draft\");\n    assert!(content.contains(\"# Plain Document\"), \"content should be preserved\");\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":18}},{"line":8,"address":[],"length":0,"stats":{"Line":72}},{"line":9,"address":[],"length":0,"stats":{"Line":54}},{"line":10,"address":[],"length":0,"stats":{"Line":36}},{"line":12,"address":[],"length":0,"stats":{"Line":90}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":6}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","capture_simple.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(dir: \u0026std::path::Path, rel: \u0026str, content: impl AsRef\u003cstr\u003e) {\n    let path = dir.join(rel);\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content.as_ref()).unwrap();\n}\n\nfn make_config(vault_root: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{{{{vault_root}}}}/templates\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\"#\n    )\n}\n\n#[test]\nfn capture_inserts_at_section_begin() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ndescription: Add to inbox\n\ntarget:\n  file: \"notes.md\"\n  section: \"Inbox\"\n  position: begin\n\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"# My Notes\n\n## Inbox\n\n- Existing item\n\n## Done\n\n- Completed task\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"inbox\")\n        .arg(\"--var\")\n        .arg(\"text=New captured item\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv capture\"))\n        .stdout(predicate::str::contains(\"capture: inbox\"))\n        .stdout(predicate::str::contains(\"section: Inbox\"));\n\n    let content = fs::read_to_string(root.join(\"vault/notes.md\")).unwrap();\n    assert!(content.contains(\"- New captured item\"));\n    assert!(content.contains(\"- Existing item\"));\n\n    let new_pos = content.find(\"New captured item\").unwrap();\n    let existing_pos = content.find(\"Existing item\").unwrap();\n    assert!(new_pos \u003c existing_pos, \"New item should appear before existing item\");\n}\n\n#[test]\nfn capture_inserts_at_section_end() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/todo.yaml\",\n        r#\"\nname: todo\ndescription: Add to TODO\n\ntarget:\n  file: \"tasks.md\"\n  section: \"TODO\"\n  position: end\n\ncontent: \"- [ ] {{task}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/tasks.md\",\n        r#\"# Tasks\n\n## TODO\n\n- [ ] First task\n\n## Done\n\n- [x] Completed\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"todo\")\n        .arg(\"--var\")\n        .arg(\"task=New task\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(root.join(\"vault/tasks.md\")).unwrap();\n    assert!(content.contains(\"- [ ] New task\"));\n\n    let first_pos = content.find(\"First task\").unwrap();\n    let new_pos = content.find(\"New task\").unwrap();\n    assert!(new_pos \u003e first_pos, \"New task should appear after first task\");\n\n    let done_pos = content.find(\"## Done\").unwrap();\n    assert!(new_pos \u003c done_pos, \"New task should appear before Done section\");\n}\n\n#[test]\nfn capture_fails_on_missing_section() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ntarget:\n  file: \"notes.md\"\n  section: \"NonExistent\"\n  position: begin\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"# Notes\n\n## Existing Section\n\nContent here\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"inbox\")\n        .arg(\"--var\")\n        .arg(\"text=Test\");\n\n    cmd.assert()\n        .failure()\n        .stderr(predicate::str::contains(\"Section not found\"))\n        .stderr(predicate::str::contains(\"Existing Section\"));\n}\n\n#[test]\nfn capture_fails_on_missing_file() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ntarget:\n  file: \"missing.md\"\n  section: \"Inbox\"\n  position: begin\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"inbox\")\n        .arg(\"--var\")\n        .arg(\"text=Test\");\n\n    cmd.assert().failure().stderr(predicate::str::contains(\"Failed to read target file\"));\n}\n\n#[test]\nfn capture_not_found_shows_available() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ntarget:\n  file: \"notes.md\"\n  section: \"Inbox\"\n  position: begin\ncontent: \"test\"\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"capture\").arg(\"nonexistent\");\n\n    cmd.assert()\n        .failure()\n        .stderr(predicate::str::contains(\"Capture not found: nonexistent\"))\n        .stderr(predicate::str::contains(\"inbox\"));\n}\n\n#[test]\nfn capture_list_shows_variables() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ntarget:\n  file: \"notes.md\"\n  section: \"Inbox\"\n  position: begin\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/todo.yaml\",\n        r#\"\nname: todo\ntarget:\n  file: \"tasks.md\"\n  section: \"TODO\"\n  position: end\ncontent: \"- [ ] {{task}} ({{priority}})\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/simple.yaml\",\n        r#\"\nname: simple\ntarget:\n  file: \"log.md\"\n  section: \"Log\"\n  position: end\ncontent: \"Entry at {{date}}\"\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"capture\").arg(\"--list\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"inbox  [text]\"))\n        .stdout(predicate::str::contains(\"todo  [priority, task]\"))\n        .stdout(predicate::str::contains(\"simple\\n\")) // no variables\n        .stdout(predicate::str::contains(\"-- 3 captures --\"));\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":17}},{"line":8,"address":[],"length":0,"stats":{"Line":68}},{"line":9,"address":[],"length":0,"stats":{"Line":51}},{"line":10,"address":[],"length":0,"stats":{"Line":34}},{"line":12,"address":[],"length":0,"stats":{"Line":85}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":6}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","date_math.rs"],"content":"//! Integration tests for date math expressions in templates.\n\nuse assert_cmd::prelude::*;\nuse std::fs;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(dir: \u0026std::path::Path, rel: \u0026str, content: impl AsRef\u003cstr\u003e) {\n    let path = dir.join(rel);\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content.as_ref()).unwrap();\n}\n\nfn make_config(vault_root: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{{{{vault_root}}}}/templates\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\"#\n    )\n}\n\n#[test]\nfn template_with_date_math_today() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/dated.md\",\n        r#\"# Note for {{today}}\n\nTomorrow: {{today + 1d}}\nYesterday: {{today - 1d}}\nNext week: {{today + 1w}}\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let output = vault.join(\"output.md\");\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"dated\")\n        .arg(\"--output\")\n        .arg(\u0026output);\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(\u0026output).unwrap();\n\n    // Check that date math expressions are replaced with actual dates\n    // (we can't check exact values since they depend on current date)\n    assert!(!content.contains(\"{{today}}\"), \"today should be replaced\");\n    assert!(!content.contains(\"{{today + 1d}}\"), \"today + 1d should be replaced\");\n    assert!(!content.contains(\"{{today - 1d}}\"), \"today - 1d should be replaced\");\n    assert!(!content.contains(\"{{today + 1w}}\"), \"today + 1w should be replaced\");\n\n    // Check format is YYYY-MM-DD\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    assert!(lines[0].starts_with(\"# Note for 20\"), \"Date should be in YYYY format\");\n}\n\n#[test]\nfn template_with_date_format() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/formatted.md\",\n        r#\"Day name: {{today | %A}}\nMonth: {{today | %B}}\nYear: {{today | %Y}}\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let output = vault.join(\"output.md\");\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"formatted\")\n        .arg(\"--output\")\n        .arg(\u0026output);\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(\u0026output).unwrap();\n\n    // Format expressions should be replaced\n    assert!(!content.contains(\"{{today | %A}}\"), \"format should be replaced\");\n    assert!(!content.contains(\"{{today | %B}}\"), \"format should be replaced\");\n\n    // Should contain day/month names (not numeric)\n    assert!(content.contains(\"Day name: \"));\n    assert!(content.contains(\"Month: \"));\n    assert!(content.contains(\"Year: 20\"));\n}\n\n#[test]\nfn capture_with_date_math() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"# Notes\n\n## Log\n\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/log.yaml\",\n        r#\"\nname: log\ntarget:\n  file: \"notes.md\"\n  section: Log\n  position: begin\ncontent: \"- [{{today}}] {{text}} (due: {{today + 7d}})\"\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"log\")\n        .arg(\"--var\")\n        .arg(\"text=Test entry\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(vault.join(\"notes.md\")).unwrap();\n\n    // Date expressions should be replaced\n    assert!(!content.contains(\"{{today}}\"), \"today should be replaced\");\n    assert!(!content.contains(\"{{today + 7d}}\"), \"date math should be replaced\");\n    assert!(content.contains(\"Test entry\"));\n    assert!(content.contains(\"due:\"));\n}\n\n#[test]\nfn template_with_weekday_math() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/weekly.md\",\n        r#\"# Weekly Planning\n\nNext Monday: {{today + monday}}\nLast Friday: {{today - friday}}\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let output = vault.join(\"output.md\");\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"weekly\")\n        .arg(\"--output\")\n        .arg(\u0026output);\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(\u0026output).unwrap();\n\n    // Weekday expressions should be replaced\n    assert!(!content.contains(\"{{today + monday}}\"), \"weekday should be replaced\");\n    assert!(!content.contains(\"{{today - friday}}\"), \"weekday should be replaced\");\n}\n\n#[test]\nfn template_output_path_with_date_math() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Template with date math in output path\n    write(\n        root,\n        \"vault/templates/daily.md\",\n        r#\"---\noutput: \"daily/{{today}}.md\"\n---\n# Daily Note\n\nDate: {{today}}\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"daily\");\n\n    cmd.assert().success();\n\n    // Find the created file in daily/ directory\n    let daily_dir = vault.join(\"daily\");\n    assert!(daily_dir.exists(), \"daily directory should be created\");\n\n    let entries: Vec\u003c_\u003e = fs::read_dir(\u0026daily_dir).unwrap().collect();\n    assert_eq!(entries.len(), 1, \"Should have one daily note\");\n\n    let file_path = entries[0].as_ref().unwrap().path();\n    let filename = file_path.file_name().unwrap().to_string_lossy();\n    assert!(filename.ends_with(\".md\"));\n    assert!(filename.starts_with(\"20\"), \"Filename should start with year\");\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":11}},{"line":9,"address":[],"length":0,"stats":{"Line":44}},{"line":10,"address":[],"length":0,"stats":{"Line":33}},{"line":11,"address":[],"length":0,"stats":{"Line":22}},{"line":13,"address":[],"length":0,"stats":{"Line":55}},{"line":16,"address":[],"length":0,"stats":{"Line":5}},{"line":17,"address":[],"length":0,"stats":{"Line":5}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","doctor_fail.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n#[test]\nfn doctor_fails_when_config_missing() {\n    let tmp = tempdir().unwrap();\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.env(\"XDG_CONFIG_HOME\", tmp.path()); // empty dir  no config\n    cmd.arg(\"doctor\");\n    cmd.assert()\n        .failure()\n        .stdout(predicate::str::contains(\"FAIL mdv doctor\"))\n        .stdout(predicate::str::contains(\"looked for:\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","doctor_ok.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn doctor_reads_provided_config_path() {\n    let tmp = tempdir().unwrap();\n    let cfg = tmp.path().join(\"config.toml\");\n    let toml = r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"/tmp/v\"\ntemplates_dir = \"{{vault_root}}/.mdvault/templates\"\ncaptures_dir  = \"{{vault_root}}/.mdvault/captures\"\nmacros_dir    = \"{{vault_root}}/.mdvault/macros\"\n\n[security]\nallow_shell = false\nallow_http  = false\n\"#;\n    write_file(\u0026cfg, toml);\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.args([\"doctor\", \"--config\", cfg.to_str().unwrap()]);\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv doctor\"))\n        .stdout(predicate::str::contains(\"profile: default\"))\n        .stdout(predicate::str::contains(\"vault_root: /tmp/v\"));\n}\n\n#[test]\nfn doctor_uses_xdg_default_when_present() {\n    let tmp = tempdir().unwrap();\n    let cfg_dir = tmp.path().join(\"mdvault\");\n    let cfg_path = cfg_dir.join(\"config.toml\");\n    fs::create_dir_all(\u0026cfg_dir).unwrap();\n    write_file(\n        \u0026cfg_path,\n        r#\"\nversion = 1\nprofile = \"default\"\n[profiles.default]\nvault_root = \"/tmp/v\"\ntemplates_dir = \"{{vault_root}}/t\"\ncaptures_dir  = \"{{vault_root}}/c\"\nmacros_dir    = \"{{vault_root}}/m\"\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.env(\"XDG_CONFIG_HOME\", tmp.path());\n    cmd.arg(\"doctor\");\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv doctor\"))\n        .stdout(predicate::str::contains(\"vault_root: /tmp/v\"));\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":2}},{"line":9,"address":[],"length":0,"stats":{"Line":6}},{"line":10,"address":[],"length":0,"stats":{"Line":4}},{"line":12,"address":[],"length":0,"stats":{"Line":8}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","doctor_snapshot.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse regex::Regex;\nuse std::fs;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\nfn normalize_paths(s: \u0026str) -\u003e String {\n    let re = Regex::new(r#\"(?m)^path: .*$\"#).unwrap();\n    re.replace(s, \"path: \u003cCFG\u003e\").to_string()\n}\n\n#[test]\nfn doctor_snapshot_default_profile() {\n    let tmp = tempdir().unwrap();\n    let cfg = tmp.path().join(\"config.toml\");\n\n    let toml = r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"/tmp/v\"\ntemplates_dir = \"{{vault_root}}/.mdvault/templates\"\ncaptures_dir  = \"{{vault_root}}/.mdvault/captures\"\nmacros_dir    = \"{{vault_root}}/.mdvault/macros\"\n\n[security]\nallow_shell = false\nallow_http  = false\n\"#;\n    write_file(\u0026cfg, toml);\n\n    let assert = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"))\n        .args([\"doctor\", \"--config\", cfg.to_str().unwrap()])\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv doctor\"));\n\n    let out = String::from_utf8(assert.get_output().stdout.clone()).unwrap();\n    let norm = normalize_paths(\u0026out);\n\n    insta::assert_snapshot!(\"doctor_default_profile\", norm);\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":1}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":11,"address":[],"length":0,"stats":{"Line":2}},{"line":13,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":4}},{"line":18,"address":[],"length":0,"stats":{"Line":3}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","list_templates_ok.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*; // needed for `.not()`\nuse std::fs;\nuse std::path::PathBuf;\nuse tempfile::tempdir;\n\nfn write(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn list_templates_reports_markdown_files_only() {\n    let tmp = tempdir().unwrap();\n\n    // XDG-style config location\n    let xdg = tmp.path().join(\"xdg\");\n    let cfg_dir = xdg.join(\"mdvault\");\n    let cfg_path = cfg_dir.join(\"config.toml\");\n    fs::create_dir_all(\u0026cfg_dir).unwrap();\n\n    // Templates tree\n    let tpl_root = tmp.path().join(\"vault\").join(\".mdvault\").join(\"templates\");\n    let a = tpl_root.join(\"daily.md\");\n    let b = tpl_root.join(\"blog\").join(\"post.md\");\n    let ignored = tpl_root.join(\"ignore.tpl.md\"); // should be ignored under MD-only rule\n\n    write(\u0026a, \"# daily\");\n    write(\u0026b, \"# blog\");\n    write(\u0026ignored, \"nope\");\n\n    // Config pointing to our temporary vault/templates\n    let toml = format!(\n        r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"{vault}\"\ntemplates_dir = \"{tpl}\"\ncaptures_dir  = \"{{{{vault_root}}}}/.mdvault/captures\"\nmacros_dir    = \"{{{{vault_root}}}}/.mdvault/macros\"\n\"#,\n        vault = tmp.path().join(\"vault\").display(),\n        tpl = tpl_root.display(),\n    );\n    fs::write(\u0026cfg_path, toml).unwrap();\n\n    // With clap: global flags can be before the subcommand\n    let mut cmd = std::process::Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.env(\"XDG_CONFIG_HOME\", \u0026xdg);\n    cmd.env(\"NO_COLOR\", \"1\"); // keep output deterministic\n    cmd.args([\n        \"--config\",\n        cfg_path.to_str().unwrap(),\n        \"--profile\",\n        \"default\",\n        \"list-templates\",\n    ]);\n\n    cmd.assert()\n        .success()\n        .stdout(predicates::str::contains(\"daily\"))\n        .stdout(predicates::str::contains(\"blog/post\"))\n        .stdout(predicates::str::contains(\"-- 2 templates --\"))\n        // `not_contains` doesn't exist; use `contains(...).not()` from PredicateBooleanExt\n        .stdout(predicates::str::contains(\"ignore\").not());\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":3}},{"line":8,"address":[],"length":0,"stats":{"Line":9}},{"line":9,"address":[],"length":0,"stats":{"Line":6}},{"line":11,"address":[],"length":0,"stats":{"Line":12}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","macro_simple.rs"],"content":"//! Integration tests for macro command.\n\nuse assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(dir: \u0026std::path::Path, rel: \u0026str, content: impl AsRef\u003cstr\u003e) {\n    let path = dir.join(rel);\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content.as_ref()).unwrap();\n}\n\nfn make_config(vault_root: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{{{{vault_root}}}}/templates\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\n[security]\nallow_shell = false\n\"#\n    )\n}\n\n#[test]\nfn macro_list_shows_available_macros() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/macros/weekly-review.yaml\",\n        r#\"\nname: weekly-review\ndescription: Set up weekly review documents\nsteps:\n  - template: summary\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/daily-setup.yaml\",\n        r#\"\nname: daily-setup\ndescription: Create daily note\nsteps:\n  - template: daily\n  - capture: inbox-clear\n\"#,\n    );\n\n    // Create templates/captures directories\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"macro\").arg(\"--list\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"weekly-review\"))\n        .stdout(predicate::str::contains(\"Set up weekly review\"))\n        .stdout(predicate::str::contains(\"daily-setup\"))\n        .stdout(predicate::str::contains(\"2 steps\"))\n        .stdout(predicate::str::contains(\"-- 2 macros --\"));\n}\n\n#[test]\nfn macro_not_found_shows_available() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/macros/existing.yaml\",\n        r#\"\nname: existing\nsteps:\n  - template: test\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"macro\").arg(\"nonexistent\");\n\n    cmd.assert()\n        .failure()\n        .stderr(predicate::str::contains(\"Macro not found: nonexistent\"))\n        .stderr(predicate::str::contains(\"existing\"));\n}\n\n#[test]\nfn macro_with_shell_requires_trust() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/macros/deploy.yaml\",\n        r#\"\nname: deploy\ndescription: Deploy with git\nsteps:\n  - shell: \"git add .\"\n    description: Stage changes\n  - shell: \"git commit -m 'deploy'\"\n    description: Commit\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    // Without --trust, should fail\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"macro\").arg(\"deploy\");\n\n    cmd.assert()\n        .failure()\n        .stderr(predicate::str::contains(\"--trust\"))\n        .stderr(predicate::str::contains(\"git add\"));\n}\n\n#[test]\nfn macro_list_shows_trust_required() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/macros/safe.yaml\",\n        r#\"\nname: safe\nsteps:\n  - template: note\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/dangerous.yaml\",\n        r#\"\nname: dangerous\nsteps:\n  - template: note\n  - shell: \"echo hello\"\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"macro\").arg(\"--list\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"safe  (1 steps)\"))\n        .stdout(predicate::str::contains(\"dangerous  (2 steps) [requires --trust]\"));\n}\n\n#[test]\nfn macro_runs_template_step() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/note.md\",\n        r#\"---\noutput: \"notes/{{title}}.md\"\n---\n# {{title}}\n\nCreated on {{date}}\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/create-note.yaml\",\n        r#\"\nname: create-note\ndescription: Create a note\nvars:\n  title: \"Note title\"\nsteps:\n  - template: note\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"macro\")\n        .arg(\"create-note\")\n        .arg(\"--var\")\n        .arg(\"title=My Test Note\")\n        .arg(\"--batch\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv macro\"))\n        .stdout(predicate::str::contains(\"1 completed\"));\n\n    // Verify file was created\n    let output_file = vault.join(\"notes/My Test Note.md\");\n    assert!(output_file.exists(), \"Output file should be created\");\n\n    let content = fs::read_to_string(\u0026output_file).unwrap();\n    assert!(content.contains(\"# My Test Note\"));\n}\n\n#[test]\nfn macro_runs_capture_step() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/inbox.md\",\n        r#\"# Inbox\n\n## Items\n\n- Existing item\n\n## Archive\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/add-item.yaml\",\n        r#\"\nname: add-item\ntarget:\n  file: \"inbox.md\"\n  section: Items\n  position: end\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/quick-add.yaml\",\n        r#\"\nname: quick-add\ndescription: Add item to inbox\nvars:\n  text: \"Item text\"\nsteps:\n  - capture: add-item\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"macro\")\n        .arg(\"quick-add\")\n        .arg(\"--var\")\n        .arg(\"text=New macro item\")\n        .arg(\"--batch\");\n\n    cmd.assert().success().stdout(predicate::str::contains(\"OK   mdv macro\"));\n\n    let content = fs::read_to_string(vault.join(\"inbox.md\")).unwrap();\n    assert!(content.contains(\"- New macro item\"));\n    assert!(content.contains(\"- Existing item\"));\n}\n\n#[test]\nfn macro_runs_multiple_steps() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/meeting.md\",\n        r#\"---\noutput: \"meetings/{{topic}}.md\"\n---\n# Meeting: {{topic}}\n\n## Attendees\n\n## Notes\n\n## Actions\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/log.md\",\n        r#\"# Meeting Log\n\n## Recent\n\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/log-meeting.yaml\",\n        r#\"\nname: log-meeting\ntarget:\n  file: \"log.md\"\n  section: Recent\n  position: begin\ncontent: \"- [[meetings/{{topic}}]] - {{date}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/new-meeting.yaml\",\n        r#\"\nname: new-meeting\ndescription: Create meeting note and log it\nvars:\n  topic: \"Meeting topic\"\nsteps:\n  - template: meeting\n  - capture: log-meeting\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"macro\")\n        .arg(\"new-meeting\")\n        .arg(\"--var\")\n        .arg(\"topic=Weekly Sync\")\n        .arg(\"--batch\");\n\n    cmd.assert().success().stdout(predicate::str::contains(\"2 completed\"));\n\n    // Check meeting file was created\n    let meeting_file = vault.join(\"meetings/Weekly Sync.md\");\n    assert!(meeting_file.exists());\n    let meeting_content = fs::read_to_string(\u0026meeting_file).unwrap();\n    assert!(meeting_content.contains(\"# Meeting: Weekly Sync\"));\n\n    // Check log was updated\n    let log_content = fs::read_to_string(vault.join(\"log.md\")).unwrap();\n    assert!(log_content.contains(\"[[meetings/Weekly Sync]]\"));\n}\n\n#[test]\nfn macro_with_step_vars_override() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/note.md\",\n        r#\"---\noutput: \"notes/{{filename}}.md\"\n---\n# {{title}}\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/fixed-output.yaml\",\n        r#\"\nname: fixed-output\ndescription: Create note with fixed filename\nvars:\n  title: \"Note title\"\nsteps:\n  - template: note\n    with:\n      filename: \"fixed-name\"\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"macro\")\n        .arg(\"fixed-output\")\n        .arg(\"--var\")\n        .arg(\"title=Dynamic Title\")\n        .arg(\"--batch\");\n\n    cmd.assert().success();\n\n    // Should use fixed filename from step vars\n    let output_file = vault.join(\"notes/fixed-name.md\");\n    assert!(output_file.exists());\n\n    let content = fs::read_to_string(\u0026output_file).unwrap();\n    assert!(content.contains(\"# Dynamic Title\"));\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":25}},{"line":10,"address":[],"length":0,"stats":{"Line":100}},{"line":11,"address":[],"length":0,"stats":{"Line":75}},{"line":12,"address":[],"length":0,"stats":{"Line":50}},{"line":14,"address":[],"length":0,"stats":{"Line":125}},{"line":17,"address":[],"length":0,"stats":{"Line":8}},{"line":18,"address":[],"length":0,"stats":{"Line":8}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","new_simple.rs"],"content":"use assert_cmd::prelude::*;\nuse std::fs;\nuse std::path::PathBuf;\nuse tempfile::tempdir;\n\nfn write(path: \u0026PathBuf, contents: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, contents).unwrap();\n}\n\n#[test]\nfn new_renders_template_to_output_file() {\n    let tmp = tempdir().unwrap();\n\n    // XDG config\n    let xdg = tmp.path().join(\"xdg\");\n    let cfg_dir = xdg.join(\"mdvault\");\n    let cfg_path = cfg_dir.join(\"config.toml\");\n    fs::create_dir_all(\u0026cfg_dir).unwrap();\n\n    // Vault and templates\n    let vault = tmp.path().join(\"vault\");\n    let tpl_root = vault.join(\".mdvault\").join(\"templates\");\n    let tpl_daily = tpl_root.join(\"daily.md\");\n\n    write(\n        \u0026tpl_daily,\n        \"Title: {{template_name}}\\nVault: {{vault_root}}\\nFile: {{output_filename}}\\n\",\n    );\n\n    let toml = format!(\n        r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"{vault}\"\ntemplates_dir = \"{tpl}\"\ncaptures_dir  = \"{{{{vault_root}}}}/.mdvault/captures\"\nmacros_dir    = \"{{{{vault_root}}}}/.mdvault/macros\"\n\"#,\n        vault = vault.display(),\n        tpl = tpl_root.display(),\n    );\n    fs::write(\u0026cfg_path, toml).unwrap();\n\n    let output = vault.join(\"rendered.md\");\n\n    let mut cmd = std::process::Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.env(\"XDG_CONFIG_HOME\", \u0026xdg);\n    cmd.env(\"NO_COLOR\", \"1\");\n    cmd.args([\n        \"--config\",\n        cfg_path.to_str().unwrap(),\n        \"--profile\",\n        \"default\",\n        \"new\",\n        \"--template\",\n        \"daily\",\n        \"--output\",\n        output.to_str().unwrap(),\n    ]);\n\n    cmd.assert()\n        .success()\n        .stdout(predicates::str::contains(\"OK   mdv new\"))\n        .stdout(predicates::str::contains(\"template: daily\"));\n\n    let rendered = fs::read_to_string(\u0026output).unwrap();\n\n    assert!(rendered.contains(\"Title: daily\"));\n    assert!(rendered.contains(\"Vault:\"));\n    assert!(rendered.contains(\"File: rendered.md\"));\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":1}},{"line":7,"address":[],"length":0,"stats":{"Line":3}},{"line":8,"address":[],"length":0,"stats":{"Line":2}},{"line":10,"address":[],"length":0,"stats":{"Line":4}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","template_frontmatter.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(path: \u0026PathBuf, contents: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, contents).unwrap();\n}\n\nfn make_config(vault_root: \u0026str, templates_dir: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{templates_dir}\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\"#\n    )\n}\n\n#[test]\nfn template_with_frontmatter_output_creates_file_without_output_flag() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n\n    let vault = root.join(\"vault\");\n    let templates = vault.join(\"templates\");\n    let config_path = root.join(\"config.toml\");\n\n    write(\n        \u0026config_path,\n        \u0026make_config(\u0026vault.to_string_lossy(), \u0026templates.to_string_lossy()),\n    );\n\n    // Template with frontmatter output path\n    write(\n        \u0026templates.join(\"daily.md\"),\n        r#\"---\noutput: daily/{{date}}.md\n---\n# Daily Note for {{date}}\n\n## Inbox\n\n## Tasks\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(\u0026config_path).arg(\"new\").arg(\"--template\").arg(\"daily\");\n    // Note: no --output flag\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv new\"))\n        .stdout(predicate::str::contains(\"template: daily\"))\n        .stdout(predicate::str::contains(\"daily/\"));\n\n    // Verify the file was created in the expected location\n    let daily_dir = vault.join(\"daily\");\n    assert!(daily_dir.exists(), \"daily directory should be created\");\n\n    let files: Vec\u003c_\u003e = fs::read_dir(\u0026daily_dir).unwrap().collect();\n    assert_eq!(files.len(), 1, \"should have one file\");\n\n    let file_path = files[0].as_ref().unwrap().path();\n    let content = fs::read_to_string(\u0026file_path).unwrap();\n    assert!(content.contains(\"# Daily Note for\"));\n    assert!(content.contains(\"## Inbox\"));\n    assert!(content.contains(\"## Tasks\"));\n    // Frontmatter should be stripped\n    assert!(!content.contains(\"output:\"));\n}\n\n#[test]\nfn template_without_frontmatter_requires_output_flag() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n\n    let vault = root.join(\"vault\");\n    let templates = vault.join(\"templates\");\n    let config_path = root.join(\"config.toml\");\n\n    write(\n        \u0026config_path,\n        \u0026make_config(\u0026vault.to_string_lossy(), \u0026templates.to_string_lossy()),\n    );\n\n    // Template without frontmatter output path\n    write(\n        \u0026templates.join(\"simple.md\"),\n        r#\"# Simple Note\n\nContent here.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(\u0026config_path).arg(\"new\").arg(\"--template\").arg(\"simple\");\n    // Note: no --output flag\n\n    cmd.assert().failure().stderr(predicate::str::contains(\"--output is required\"));\n}\n\n#[test]\nfn template_extra_frontmatter_is_rendered_in_output() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n\n    let vault = root.join(\"vault\");\n    let templates = vault.join(\"templates\");\n    let config_path = root.join(\"config.toml\");\n\n    write(\n        \u0026config_path,\n        \u0026make_config(\u0026vault.to_string_lossy(), \u0026templates.to_string_lossy()),\n    );\n\n    // Template with output path AND extra frontmatter fields\n    write(\n        \u0026templates.join(\"daily.md\"),\n        r#\"---\noutput: daily/{{date}}.md\ncreated: \"{{date}}\"\ntags:\n  - daily\n  - journal\n---\n# Daily Note for {{date}}\n\n## Inbox\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(\u0026config_path).arg(\"new\").arg(\"--template\").arg(\"daily\");\n\n    cmd.assert().success();\n\n    // Read the created file\n    let daily_dir = vault.join(\"daily\");\n    let files: Vec\u003c_\u003e = fs::read_dir(\u0026daily_dir).unwrap().collect();\n    let file_path = files[0].as_ref().unwrap().path();\n    let content = fs::read_to_string(\u0026file_path).unwrap();\n\n    // Extra frontmatter fields should be in output\n    assert!(content.contains(\"---\"), \"should have frontmatter delimiters\");\n    assert!(content.contains(\"created:\"), \"should have created field\");\n    assert!(content.contains(\"tags:\"), \"should have tags field\");\n    assert!(content.contains(\"- daily\"), \"should have daily tag\");\n    assert!(content.contains(\"- journal\"), \"should have journal tag\");\n\n    // The created field should have the date substituted (not {{date}})\n    assert!(!content.contains(\"{{date}}\"), \"date placeholder should be substituted\");\n\n    // The output field should NOT be in the rendered output\n    assert!(\n        !content.contains(\"output:\"),\n        \"output field should not be in rendered output\"\n    );\n}\n\n#[test]\nfn template_with_user_vars_in_frontmatter() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n\n    let vault = root.join(\"vault\");\n    let templates = vault.join(\"templates\");\n    let config_path = root.join(\"config.toml\");\n\n    write(\n        \u0026config_path,\n        \u0026make_config(\u0026vault.to_string_lossy(), \u0026templates.to_string_lossy()),\n    );\n\n    // Template with user-defined variable in frontmatter\n    write(\n        \u0026templates.join(\"meeting.md\"),\n        r#\"---\noutput: meetings/{{date}}.md\ntitle: \"{{meeting_title}}\"\nattendees: \"{{attendees}}\"\nvars:\n  meeting_title: \"Meeting title\"\n  attendees: \"Attendees\"\n---\n# {{meeting_title}}\n\nAttendees: {{attendees}}\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(\u0026config_path)\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"meeting\")\n        .arg(\"--var\")\n        .arg(\"meeting_title=Quarterly Review\")\n        .arg(\"--var\")\n        .arg(\"attendees=Alice, Bob\");\n\n    cmd.assert().success();\n\n    // Read the created file\n    let meetings_dir = vault.join(\"meetings\");\n    let files: Vec\u003c_\u003e = fs::read_dir(\u0026meetings_dir).unwrap().collect();\n    let file_path = files[0].as_ref().unwrap().path();\n    let content = fs::read_to_string(\u0026file_path).unwrap();\n\n    // User variables should be substituted in frontmatter\n    assert!(\n        content.contains(\"title: Quarterly Review\"),\n        \"title should have user value, got: {}\",\n        content\n    );\n    assert!(\n        content.contains(\"attendees: Alice, Bob\"),\n        \"attendees should have user value\"\n    );\n\n    // User variables should also be substituted in body\n    assert!(\n        content.contains(\"# Quarterly Review\"),\n        \"title in body should be substituted\"\n    );\n    assert!(\n        content.contains(\"Attendees: Alice, Bob\"),\n        \"attendees in body should be substituted\"\n    );\n\n    // The vars field should NOT be in the output (it's metadata)\n    assert!(!content.contains(\"vars:\"), \"vars metadata should not be in output\");\n}\n\n#[test]\nfn output_flag_overrides_frontmatter_output() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n\n    let vault = root.join(\"vault\");\n    let templates = vault.join(\"templates\");\n    let config_path = root.join(\"config.toml\");\n\n    write(\n        \u0026config_path,\n        \u0026make_config(\u0026vault.to_string_lossy(), \u0026templates.to_string_lossy()),\n    );\n\n    // Template with frontmatter output path\n    write(\n        \u0026templates.join(\"daily.md\"),\n        r#\"---\noutput: daily/{{date}}.md\n---\n# Daily Note\n\nContent\n\"#,\n    );\n\n    let custom_output = vault.join(\"custom\").join(\"my-note.md\");\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(\u0026config_path)\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"daily\")\n        .arg(\"--output\")\n        .arg(\u0026custom_output);\n\n    cmd.assert().success().stdout(predicate::str::contains(\"my-note.md\"));\n\n    assert!(custom_output.exists(), \"custom output should be created\");\n\n    // The frontmatter output path should not be used\n    assert!(\n        !vault.join(\"daily\").exists(),\n        \"frontmatter output dir should not be created\"\n    );\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":10}},{"line":9,"address":[],"length":0,"stats":{"Line":30}},{"line":10,"address":[],"length":0,"stats":{"Line":20}},{"line":12,"address":[],"length":0,"stats":{"Line":40}},{"line":15,"address":[],"length":0,"stats":{"Line":5}},{"line":16,"address":[],"length":0,"stats":{"Line":5}}],"covered":6,"coverable":6},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","variable_metadata.rs"],"content":"//! Integration tests for variable metadata (prompts, defaults, descriptions).\n//!\n//! Note: Template `vars:` DSL was removed in v0.2.0 in favor of Lua-based schemas.\n//! Templates now use `lua:` frontmatter to reference Lua scripts that define schemas.\n//! These tests cover captures and macros which still support `vars:`.\n\nuse assert_cmd::prelude::*;\nuse std::fs;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(dir: \u0026std::path::Path, rel: \u0026str, content: impl AsRef\u003cstr\u003e) {\n    let path = dir.join(rel);\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content.as_ref()).unwrap();\n}\n\nfn make_config(vault_root: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{{{{vault_root}}}}/templates\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\"#\n    )\n}\n\n#[test]\nfn capture_with_vars_metadata_uses_default() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"# Notes\n\n## Inbox\n\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ndescription: Add to inbox with priority\n\nvars:\n  text:\n    prompt: \"What to add?\"\n    required: true\n  priority:\n    prompt: \"Priority level\"\n    default: \"normal\"\n    description: \"Can be low, normal, or high\"\n\ntarget:\n  file: \"notes.md\"\n  section: Inbox\n  position: end\n\ncontent: \"- [{{priority}}] {{text}}\"\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"inbox\")\n        .arg(\"--var\")\n        .arg(\"text=Review PR\")\n        .arg(\"--batch\"); // Uses default priority\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(vault.join(\"notes.md\")).unwrap();\n    assert!(content.contains(\"- [normal] Review PR\"));\n}\n\n#[test]\nfn macro_with_vars_metadata() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/project.md\",\n        r#\"---\noutput: \"projects/{{name}}.md\"\n---\n# Project: {{name}}\n\nStatus: {{status}}\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/new-project.yaml\",\n        r#\"\nname: new-project\ndescription: Create a new project\nvars:\n  name:\n    prompt: \"Project name\"\n    required: true\n  status:\n    prompt: \"Initial status\"\n    default: \"planning\"\n    description: \"planning, active, or completed\"\nsteps:\n  - template: project\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"macro\")\n        .arg(\"new-project\")\n        .arg(\"--var\")\n        .arg(\"name=Website Redesign\")\n        .arg(\"--batch\"); // Uses default status\n\n    cmd.assert().success();\n\n    let output_file = vault.join(\"projects/Website Redesign.md\");\n    assert!(output_file.exists());\n\n    let content = fs::read_to_string(\u0026output_file).unwrap();\n    assert!(content.contains(\"# Project: Website Redesign\"));\n    assert!(content.contains(\"Status: planning\"));\n}\n\n#[test]\nfn simple_var_spec_as_prompt() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Simple form: just the prompt string\n    write(\n        root,\n        \"vault/captures/quick.yaml\",\n        r#\"\nname: quick\nvars:\n  text: \"Quick note text\"\ntarget:\n  file: \"notes.md\"\n  section: Quick\n  position: end\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"# Notes\n\n## Quick\n\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"quick\")\n        .arg(\"--var\")\n        .arg(\"text=Simple note\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(vault.join(\"notes.md\")).unwrap();\n    assert!(content.contains(\"- Simple note\"));\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":9}},{"line":13,"address":[],"length":0,"stats":{"Line":36}},{"line":14,"address":[],"length":0,"stats":{"Line":27}},{"line":15,"address":[],"length":0,"stats":{"Line":18}},{"line":17,"address":[],"length":0,"stats":{"Line":45}},{"line":20,"address":[],"length":0,"stats":{"Line":3}},{"line":21,"address":[],"length":0,"stats":{"Line":3}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","captures","discovery.rs"],"content":"use std::path::Path;\nuse walkdir::WalkDir;\n\nuse super::types::{CaptureDiscoveryError, CaptureInfo};\n\n/// Discover all capture YAML files in the given directory\npub fn discover_captures(root: \u0026Path) -\u003e Result\u003cVec\u003cCaptureInfo\u003e, CaptureDiscoveryError\u003e {\n    let root = root\n        .canonicalize()\n        .map_err(|_| CaptureDiscoveryError::MissingDir(root.display().to_string()))?;\n\n    if !root.exists() {\n        return Err(CaptureDiscoveryError::MissingDir(root.display().to_string()));\n    }\n\n    let mut out = Vec::new();\n\n    for entry in WalkDir::new(\u0026root) {\n        let entry = entry.map_err(|e| {\n            CaptureDiscoveryError::WalkError(root.display().to_string(), e)\n        })?;\n\n        let path = entry.path();\n        if !path.is_file() {\n            continue;\n        }\n        if !is_yaml_file(path) {\n            continue;\n        }\n\n        let rel = path.strip_prefix(\u0026root).unwrap_or(path);\n        let logical = logical_name_from_relative(rel);\n\n        out.push(CaptureInfo { logical_name: logical, path: path.to_path_buf() });\n    }\n\n    out.sort_by(|a, b| a.logical_name.cmp(\u0026b.logical_name));\n    Ok(out)\n}\n\nfn is_yaml_file(path: \u0026Path) -\u003e bool {\n    let name = path.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    name.ends_with(\".yaml\") || name.ends_with(\".yml\")\n}\n\nfn logical_name_from_relative(rel: \u0026Path) -\u003e String {\n    let s = rel.to_string_lossy();\n    // Remove .yaml or .yml extension\n    if let Some(stripped) = s.strip_suffix(\".yaml\") {\n        return stripped.to_string();\n    }\n    if let Some(stripped) = s.strip_suffix(\".yml\") {\n        return stripped.to_string();\n    }\n    s.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs::File;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_discover_captures_simple() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        // Create some files\n        File::create(root.join(\"todo.yaml\")).unwrap();\n        File::create(root.join(\"ideas.yml\")).unwrap();\n        File::create(root.join(\"ignored.txt\")).unwrap();\n        File::create(root.join(\"README.md\")).unwrap();\n\n        let captures = discover_captures(root).unwrap();\n\n        assert_eq!(captures.len(), 2);\n        assert_eq!(captures[0].logical_name, \"ideas\");\n        assert_eq!(captures[1].logical_name, \"todo\");\n    }\n\n    #[test]\n    fn test_discover_captures_nested() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        std::fs::create_dir(root.join(\"subdir\")).unwrap();\n        File::create(root.join(\"subdir/nested.yaml\")).unwrap();\n\n        let captures = discover_captures(root).unwrap();\n\n        assert_eq!(captures.len(), 1);\n        assert_eq!(captures[0].logical_name, \"subdir/nested\");\n    }\n\n    #[test]\n    fn test_discover_captures_missing_dir() {\n        let dir = tempdir().unwrap();\n        let missing = dir.path().join(\"missing\");\n        \n        let result = discover_captures(\u0026missing);\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":23}},{"line":8,"address":[],"length":0,"stats":{"Line":45}},{"line":10,"address":[],"length":0,"stats":{"Line":26}},{"line":12,"address":[],"length":0,"stats":{"Line":22}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":44}},{"line":18,"address":[],"length":0,"stats":{"Line":91}},{"line":19,"address":[],"length":0,"stats":{"Line":141}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":141}},{"line":24,"address":[],"length":0,"stats":{"Line":47}},{"line":25,"address":[],"length":0,"stats":{"Line":23}},{"line":27,"address":[],"length":0,"stats":{"Line":24}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":132}},{"line":32,"address":[],"length":0,"stats":{"Line":66}},{"line":34,"address":[],"length":0,"stats":{"Line":88}},{"line":37,"address":[],"length":0,"stats":{"Line":56}},{"line":38,"address":[],"length":0,"stats":{"Line":22}},{"line":41,"address":[],"length":0,"stats":{"Line":24}},{"line":42,"address":[],"length":0,"stats":{"Line":192}},{"line":43,"address":[],"length":0,"stats":{"Line":54}},{"line":46,"address":[],"length":0,"stats":{"Line":22}},{"line":47,"address":[],"length":0,"stats":{"Line":66}},{"line":49,"address":[],"length":0,"stats":{"Line":43}},{"line":50,"address":[],"length":0,"stats":{"Line":42}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":26,"coverable":29},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","captures","mod.rs"],"content":"pub mod discovery;\npub mod repository;\npub mod types;\n\n// Re-export primary API\npub use repository::CaptureRepository;\npub use types::{\n    CaptureDiscoveryError, CaptureInfo, CapturePosition, CaptureRepoError, CaptureSpec,\n    CaptureTarget, LoadedCapture,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","captures","repository.rs"],"content":"use std::fs;\nuse std::path::{Path, PathBuf};\n\nuse super::discovery::discover_captures;\nuse super::types::{\n    CaptureDiscoveryError, CaptureInfo, CaptureRepoError, CaptureSpec, LoadedCapture,\n};\n\n/// Repository for discovering and loading capture specifications\npub struct CaptureRepository {\n    pub root: PathBuf,\n    pub captures: Vec\u003cCaptureInfo\u003e,\n}\n\nimpl CaptureRepository {\n    /// Create a new repository by scanning the captures directory\n    pub fn new(root: \u0026Path) -\u003e Result\u003cSelf, CaptureDiscoveryError\u003e {\n        let captures = discover_captures(root)?;\n        Ok(Self { root: root.to_path_buf(), captures })\n    }\n\n    /// List all discovered captures\n    pub fn list_all(\u0026self) -\u003e \u0026[CaptureInfo] {\n        \u0026self.captures\n    }\n\n    /// Load a capture by its logical name\n    pub fn get_by_name(\u0026self, name: \u0026str) -\u003e Result\u003cLoadedCapture, CaptureRepoError\u003e {\n        let info = self\n            .captures\n            .iter()\n            .find(|c| c.logical_name == name)\n            .ok_or_else(|| CaptureRepoError::NotFound(name.to_string()))?;\n\n        let content = fs::read_to_string(\u0026info.path)\n            .map_err(|e| CaptureRepoError::Io { path: info.path.clone(), source: e })?;\n\n        let spec: CaptureSpec = serde_yaml::from_str(\u0026content).map_err(|e| {\n            CaptureRepoError::Parse { path: info.path.clone(), source: e }\n        })?;\n\n        Ok(LoadedCapture {\n            logical_name: info.logical_name.clone(),\n            path: info.path.clone(),\n            spec,\n        })\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":20}},{"line":18,"address":[],"length":0,"stats":{"Line":60}},{"line":19,"address":[],"length":0,"stats":{"Line":40}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":19}},{"line":29,"address":[],"length":0,"stats":{"Line":37}},{"line":30,"address":[],"length":0,"stats":{"Line":19}},{"line":32,"address":[],"length":0,"stats":{"Line":63}},{"line":33,"address":[],"length":0,"stats":{"Line":22}},{"line":35,"address":[],"length":0,"stats":{"Line":54}},{"line":36,"address":[],"length":0,"stats":{"Line":18}},{"line":38,"address":[],"length":0,"stats":{"Line":90}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":18}},{"line":43,"address":[],"length":0,"stats":{"Line":54}},{"line":44,"address":[],"length":0,"stats":{"Line":36}},{"line":45,"address":[],"length":0,"stats":{"Line":18}}],"covered":17,"coverable":18},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","captures","types.rs"],"content":"use serde::Deserialize;\nuse std::path::PathBuf;\nuse thiserror::Error;\n\nuse crate::frontmatter::FrontmatterOps;\nuse crate::markdown_ast::InsertPosition;\nuse crate::vars::VarsMap;\n\n/// A capture specification loaded from a YAML file\n#[derive(Debug, Clone, Deserialize)]\npub struct CaptureSpec {\n    /// Logical name of the capture\n    pub name: String,\n\n    /// Human-readable description\n    #[serde(default)]\n    pub description: String,\n\n    /// Variable specifications with prompts and defaults.\n    #[serde(default)]\n    pub vars: Option\u003cVarsMap\u003e,\n\n    /// Target file and section configuration\n    pub target: CaptureTarget,\n\n    /// Content template to insert (supports {{var}} placeholders)\n    /// Optional: capture may only modify frontmatter without adding content\n    #[serde(default)]\n    pub content: Option\u003cString\u003e,\n\n    /// Frontmatter operations to apply to the target file\n    #[serde(default)]\n    pub frontmatter: Option\u003cFrontmatterOps\u003e,\n}\n\n/// Target configuration for where to insert captured content\n#[derive(Debug, Clone, Deserialize)]\npub struct CaptureTarget {\n    /// Path to the target file (supports {{var}} placeholders)\n    pub file: String,\n\n    /// Section heading to insert into (optional: not needed for frontmatter-only captures)\n    #[serde(default)]\n    pub section: Option\u003cString\u003e,\n\n    /// Where in the section to insert (begin or end)\n    #[serde(default)]\n    pub position: CapturePosition,\n\n    /// If true, create the target file if it doesn't exist.\n    /// The file will be created with minimal frontmatter (type: daily, date) and the target section.\n    #[serde(default)]\n    pub create_if_missing: bool,\n}\n\n/// Position within a section (maps to InsertPosition)\n#[derive(Debug, Clone, Default, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum CapturePosition {\n    #[default]\n    Begin,\n    End,\n}\n\nimpl From\u003cCapturePosition\u003e for InsertPosition {\n    fn from(pos: CapturePosition) -\u003e Self {\n        match pos {\n            CapturePosition::Begin =\u003e InsertPosition::Begin,\n            CapturePosition::End =\u003e InsertPosition::End,\n        }\n    }\n}\n\n/// Information about a discovered capture file\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct CaptureInfo {\n    /// Logical name (filename without .yaml extension)\n    pub logical_name: String,\n    /// Full path to the YAML file\n    pub path: PathBuf,\n}\n\n/// A fully loaded capture ready for execution\n#[derive(Debug, Clone)]\npub struct LoadedCapture {\n    pub logical_name: String,\n    pub path: PathBuf,\n    pub spec: CaptureSpec,\n}\n\n#[derive(Debug, Error)]\npub enum CaptureDiscoveryError {\n    #[error(\"captures directory does not exist: {0}\")]\n    MissingDir(String),\n\n    #[error(\"failed to read captures directory {0}: {1}\")]\n    WalkError(String, #[source] walkdir::Error),\n}\n\n#[derive(Debug, Error)]\npub enum CaptureRepoError {\n    #[error(transparent)]\n    Discovery(#[from] CaptureDiscoveryError),\n\n    #[error(\"capture not found: {0}\")]\n    NotFound(String),\n\n    #[error(\"failed to read capture file {path}: {source}\")]\n    Io {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    #[error(\"failed to parse capture YAML {path}: {source}\")]\n    Parse {\n        path: PathBuf,\n        #[source]\n        source: serde_yaml::Error,\n    },\n}\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":9}},{"line":67,"address":[],"length":0,"stats":{"Line":9}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":5}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","config","loader.rs"],"content":"use crate::config::types::{ConfigFile, Profile, ResolvedConfig, SecurityPolicy};\nuse shellexpand::full;\nuse std::path::{Path, PathBuf};\nuse std::{env, fs};\n\nuse dirs::home_dir;\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum ConfigError {\n    #[error(\"config file not found at {0}\")]\n    NotFound(String),\n\n    #[error(\"failed to read config file {0}: {1}\")]\n    ReadError(String, #[source] std::io::Error),\n\n    #[error(\"failed to parse TOML in {0}: {1}\")]\n    ParseError(String, #[source] toml::de::Error),\n\n    #[error(\"profile '{0}' not found\")]\n    ProfileNotFound(String),\n\n    #[error(\"no profiles defined in config\")]\n    NoProfiles,\n\n    #[error(\"version {0} is unsupported (expected 1)\")]\n    BadVersion(u32),\n\n    #[error(\"home directory not available to expand '~'\")]\n    NoHome,\n}\n\npub struct ConfigLoader;\n\nimpl ConfigLoader {\n    pub fn load(\n        config_path: Option\u003c\u0026Path\u003e,\n        profile_override: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cResolvedConfig, ConfigError\u003e {\n        let path = match config_path {\n            Some(p) =\u003e p.to_path_buf(),\n            None =\u003e default_config_path(),\n        };\n\n        if !path.exists() {\n            return Err(ConfigError::NotFound(path.display().to_string()));\n        }\n\n        let s = fs::read_to_string(\u0026path)\n            .map_err(|e| ConfigError::ReadError(path.display().to_string(), e))?;\n\n        let cf: ConfigFile = toml::from_str(\u0026s)\n            .map_err(|e| ConfigError::ParseError(path.display().to_string(), e))?;\n\n        if cf.version != 1 {\n            return Err(ConfigError::BadVersion(cf.version));\n        }\n        if cf.profiles.is_empty() {\n            return Err(ConfigError::NoProfiles);\n        }\n\n        let active = profile_override\n            .map(ToOwned::to_owned)\n            .or(cf.profile.clone())\n            .unwrap_or_else(|| \"default\".to_string());\n\n        let prof = cf\n            .profiles\n            .get(\u0026active)\n            .ok_or_else(|| ConfigError::ProfileNotFound(active.clone()))?;\n\n        let resolved = Self::resolve_profile(\u0026active, prof, \u0026cf.security)?;\n        Ok(resolved)\n    }\n\n    fn resolve_profile(\n        active: \u0026str,\n        prof: \u0026Profile,\n        sec: \u0026SecurityPolicy,\n    ) -\u003e Result\u003cResolvedConfig, ConfigError\u003e {\n        let vault_root = expand_path(\u0026prof.vault_root)?;\n        let sub = |s: \u0026str| s.replace(\"{{vault_root}}\", \u0026vault_root.to_string_lossy());\n\n        let templates_dir = expand_path(\u0026sub(\u0026prof.templates_dir))?;\n        let captures_dir = expand_path(\u0026sub(\u0026prof.captures_dir))?;\n        let macros_dir = expand_path(\u0026sub(\u0026prof.macros_dir))?;\n        let typedefs_dir = match \u0026prof.typedefs_dir {\n            Some(dir) =\u003e expand_path(\u0026sub(dir))?,\n            None =\u003e default_typedefs_dir(),\n        };\n\n        Ok(ResolvedConfig {\n            active_profile: active.to_string(),\n            vault_root,\n            templates_dir,\n            captures_dir,\n            macros_dir,\n            typedefs_dir,\n            security: sec.clone(),\n        })\n    }\n}\n\npub fn default_config_path() -\u003e PathBuf {\n    if let Ok(xdg) = env::var(\"XDG_CONFIG_HOME\") {\n        return Path::new(\u0026xdg).join(\"mdvault\").join(\"config.toml\");\n    }\n    let home = home_dir().unwrap_or_else(|| PathBuf::from(\"~\"));\n    home.join(\".config\").join(\"mdvault\").join(\"config.toml\")\n}\n\n/// Default directory for Lua type definitions.\n/// Global location: ~/.config/mdvault/types/\npub fn default_typedefs_dir() -\u003e PathBuf {\n    if let Ok(xdg) = env::var(\"XDG_CONFIG_HOME\") {\n        return Path::new(\u0026xdg).join(\"mdvault\").join(\"types\");\n    }\n    let home = home_dir().unwrap_or_else(|| PathBuf::from(\"~\"));\n    home.join(\".config\").join(\"mdvault\").join(\"types\")\n}\n\nfn expand_path(input: \u0026str) -\u003e Result\u003cPathBuf, ConfigError\u003e {\n    let expanded = full(input).map_err(|_| ConfigError::NoHome)?;\n    Ok(PathBuf::from(expanded.to_string()))\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":55}},{"line":40,"address":[],"length":0,"stats":{"Line":110}},{"line":41,"address":[],"length":0,"stats":{"Line":147}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":55}},{"line":46,"address":[],"length":0,"stats":{"Line":3}},{"line":49,"address":[],"length":0,"stats":{"Line":156}},{"line":50,"address":[],"length":0,"stats":{"Line":52}},{"line":52,"address":[],"length":0,"stats":{"Line":208}},{"line":53,"address":[],"length":0,"stats":{"Line":52}},{"line":55,"address":[],"length":0,"stats":{"Line":52}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":100}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":96}},{"line":63,"address":[],"length":0,"stats":{"Line":48}},{"line":64,"address":[],"length":0,"stats":{"Line":144}},{"line":65,"address":[],"length":0,"stats":{"Line":48}},{"line":67,"address":[],"length":0,"stats":{"Line":94}},{"line":68,"address":[],"length":0,"stats":{"Line":48}},{"line":69,"address":[],"length":0,"stats":{"Line":96}},{"line":70,"address":[],"length":0,"stats":{"Line":54}},{"line":72,"address":[],"length":0,"stats":{"Line":230}},{"line":73,"address":[],"length":0,"stats":{"Line":46}},{"line":76,"address":[],"length":0,"stats":{"Line":46}},{"line":81,"address":[],"length":0,"stats":{"Line":138}},{"line":82,"address":[],"length":0,"stats":{"Line":460}},{"line":84,"address":[],"length":0,"stats":{"Line":138}},{"line":85,"address":[],"length":0,"stats":{"Line":138}},{"line":86,"address":[],"length":0,"stats":{"Line":138}},{"line":87,"address":[],"length":0,"stats":{"Line":92}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":46}},{"line":92,"address":[],"length":0,"stats":{"Line":46}},{"line":93,"address":[],"length":0,"stats":{"Line":138}},{"line":94,"address":[],"length":0,"stats":{"Line":92}},{"line":95,"address":[],"length":0,"stats":{"Line":92}},{"line":96,"address":[],"length":0,"stats":{"Line":92}},{"line":97,"address":[],"length":0,"stats":{"Line":92}},{"line":98,"address":[],"length":0,"stats":{"Line":92}},{"line":99,"address":[],"length":0,"stats":{"Line":46}},{"line":104,"address":[],"length":0,"stats":{"Line":8}},{"line":105,"address":[],"length":0,"stats":{"Line":12}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":12}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":46}},{"line":115,"address":[],"length":0,"stats":{"Line":49}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":129}},{"line":119,"address":[],"length":0,"stats":{"Line":43}},{"line":122,"address":[],"length":0,"stats":{"Line":184}},{"line":123,"address":[],"length":0,"stats":{"Line":736}},{"line":124,"address":[],"length":0,"stats":{"Line":368}}],"covered":53,"coverable":54},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","config","mod.rs"],"content":"pub mod loader;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","config","types.rs"],"content":"use std::collections::HashMap;\nuse std::path::PathBuf;\n\nuse serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\npub struct ConfigFile {\n    pub version: u32,\n    pub profile: Option\u003cString\u003e,\n    pub profiles: HashMap\u003cString, Profile\u003e,\n    #[serde(default)]\n    pub security: SecurityPolicy,\n}\n\n#[derive(Debug, Deserialize)]\npub struct Profile {\n    pub vault_root: String,\n    pub templates_dir: String,\n    pub captures_dir: String,\n    pub macros_dir: String,\n    /// Optional override for typedefs directory (defaults to global ~/.config/mdvault/types/)\n    pub typedefs_dir: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize, Default, Clone)]\npub struct SecurityPolicy {\n    #[serde(default)]\n    pub allow_shell: bool,\n    #[serde(default)]\n    pub allow_http: bool,\n}\n\n#[derive(Debug, Clone)]\npub struct ResolvedConfig {\n    pub active_profile: String,\n    pub vault_root: PathBuf,\n    pub templates_dir: PathBuf,\n    pub captures_dir: PathBuf,\n    pub macros_dir: PathBuf,\n    /// Directory for Lua type definitions (global, not per-profile).\n    pub typedefs_dir: PathBuf,\n    pub security: SecurityPolicy,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","frontmatter","mod.rs"],"content":"//! Frontmatter parsing, modification, and serialization.\n//!\n//! This module provides functionality to:\n//! - Parse YAML frontmatter from markdown documents\n//! - Modify frontmatter fields (set, toggle, increment, append)\n//! - Serialize documents back to markdown with frontmatter\n\npub mod modifier;\npub mod parser;\npub mod serializer;\npub mod types;\n\npub use modifier::{FrontmatterModifyError, apply_ops};\npub use parser::{FrontmatterParseError, parse, parse_template_frontmatter};\npub use serializer::serialize;\npub use types::{\n    Frontmatter, FrontmatterOp, FrontmatterOpType, FrontmatterOps, ParsedDocument,\n    TemplateFrontmatter,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","frontmatter","modifier.rs"],"content":"//! Frontmatter modification operations.\n\nuse super::types::{\n    Frontmatter, FrontmatterOp, FrontmatterOpType, FrontmatterOps, ParsedDocument,\n};\nuse regex::Regex;\nuse serde_yaml::Value;\nuse std::collections::HashMap;\nuse thiserror::Error;\n\n/// Errors that can occur during frontmatter modification.\n#[derive(Debug, Error)]\npub enum FrontmatterModifyError {\n    #[error(\"field '{0}' is not a boolean, cannot toggle\")]\n    NotBoolean(String),\n    #[error(\"field '{0}' is not a number, cannot increment\")]\n    NotNumber(String),\n    #[error(\"field '{0}' is not a list, cannot append\")]\n    NotList(String),\n}\n\n/// Apply frontmatter operations to a document.\npub fn apply_ops(\n    mut doc: ParsedDocument,\n    ops: \u0026FrontmatterOps,\n    render_ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003cParsedDocument, FrontmatterModifyError\u003e {\n    // Ensure frontmatter exists\n    if doc.frontmatter.is_none() {\n        doc.frontmatter = Some(Frontmatter::default());\n    }\n    let fm = doc.frontmatter.as_mut().unwrap();\n\n    match ops {\n        FrontmatterOps::Simple(map) =\u003e {\n            for (field, value) in map {\n                let rendered_value = render_value(value, render_ctx);\n                fm.fields.insert(field.clone(), rendered_value);\n            }\n        }\n        FrontmatterOps::Operations(op_list) =\u003e {\n            for op in op_list {\n                apply_single_op(fm, op, render_ctx)?;\n            }\n        }\n    }\n\n    Ok(doc)\n}\n\n/// Apply a single frontmatter operation.\nfn apply_single_op(\n    fm: \u0026mut Frontmatter,\n    op: \u0026FrontmatterOp,\n    render_ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(), FrontmatterModifyError\u003e {\n    match \u0026op.op {\n        FrontmatterOpType::Set =\u003e {\n            if let Some(value) = \u0026op.value {\n                let rendered = render_value(value, render_ctx);\n                fm.fields.insert(op.field.clone(), rendered);\n            }\n        }\n        FrontmatterOpType::Toggle =\u003e {\n            let current = fm.fields.get(\u0026op.field);\n            match current {\n                Some(Value::Bool(b)) =\u003e {\n                    fm.fields.insert(op.field.clone(), Value::Bool(!b));\n                }\n                None =\u003e {\n                    // Default: toggle from false to true\n                    fm.fields.insert(op.field.clone(), Value::Bool(true));\n                }\n                _ =\u003e return Err(FrontmatterModifyError::NotBoolean(op.field.clone())),\n            }\n        }\n        FrontmatterOpType::Increment =\u003e {\n            let current = fm.fields.get(\u0026op.field).cloned();\n            let increment = op.value.as_ref().and_then(|v| v.as_i64()).unwrap_or(1);\n\n            match current {\n                Some(Value::Number(n)) =\u003e {\n                    let new_val = n.as_i64().unwrap_or(0) + increment;\n                    fm.fields.insert(op.field.clone(), Value::Number(new_val.into()));\n                }\n                None =\u003e {\n                    fm.fields.insert(op.field.clone(), Value::Number(increment.into()));\n                }\n                _ =\u003e return Err(FrontmatterModifyError::NotNumber(op.field.clone())),\n            }\n        }\n        FrontmatterOpType::Append =\u003e {\n            let current = fm.fields.get(\u0026op.field).cloned();\n            let append_val = op\n                .value\n                .as_ref()\n                .map(|v| render_value(v, render_ctx))\n                .unwrap_or(Value::Null);\n\n            match current {\n                Some(Value::Sequence(mut seq)) =\u003e {\n                    seq.push(append_val);\n                    fm.fields.insert(op.field.clone(), Value::Sequence(seq));\n                }\n                None =\u003e {\n                    fm.fields.insert(op.field.clone(), Value::Sequence(vec![append_val]));\n                }\n                _ =\u003e return Err(FrontmatterModifyError::NotList(op.field.clone())),\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Render {{var}} placeholders in YAML values.\nfn render_value(value: \u0026Value, ctx: \u0026HashMap\u003cString, String\u003e) -\u003e Value {\n    match value {\n        Value::String(s) =\u003e {\n            let rendered = render_string(s, ctx);\n            Value::String(rendered)\n        }\n        // Recursively handle nested structures\n        Value::Mapping(map) =\u003e {\n            let rendered_map: serde_yaml::Mapping =\n                map.iter().map(|(k, v)| (k.clone(), render_value(v, ctx))).collect();\n            Value::Mapping(rendered_map)\n        }\n        Value::Sequence(seq) =\u003e {\n            Value::Sequence(seq.iter().map(|v| render_value(v, ctx)).collect())\n        }\n        _ =\u003e value.clone(),\n    }\n}\n\n/// Render {{var}} placeholders in a string.\nfn render_string(template: \u0026str, ctx: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    let re = Regex::new(r\"\\{\\{([a-zA-Z0-9_]+)\\}\\}\").unwrap();\n    re.replace_all(template, |caps: \u0026regex::Captures\u003c'_\u003e| {\n        let key = \u0026caps[1];\n        ctx.get(key).cloned().unwrap_or_else(|| caps[0].to_string())\n    })\n    .into_owned()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::frontmatter::parser::parse;\n\n    fn make_ctx() -\u003e HashMap\u003cString, String\u003e {\n        let mut ctx = HashMap::new();\n        ctx.insert(\"date\".to_string(), \"2024-01-15\".to_string());\n        ctx.insert(\"time\".to_string(), \"14:30\".to_string());\n        ctx\n    }\n\n    #[test]\n    fn test_simple_set() {\n        let content = \"---\\ntitle: Old\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let mut ops_map = HashMap::new();\n        ops_map.insert(\"title\".to_string(), Value::String(\"New\".to_string()));\n        ops_map.insert(\"added\".to_string(), Value::Bool(true));\n\n        let ops = FrontmatterOps::Simple(ops_map);\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"title\").and_then(|v| v.as_str()), Some(\"New\"));\n        assert_eq!(fm.fields.get(\"added\").and_then(|v| v.as_bool()), Some(true));\n    }\n\n    #[test]\n    fn test_toggle_existing_true() {\n        let content = \"---\\nflag: true\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"flag\".to_string(),\n            op: FrontmatterOpType::Toggle,\n            value: None,\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"flag\").and_then(|v| v.as_bool()), Some(false));\n    }\n\n    #[test]\n    fn test_toggle_missing_field() {\n        let content = \"---\\nother: value\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"flag\".to_string(),\n            op: FrontmatterOpType::Toggle,\n            value: None,\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"flag\").and_then(|v| v.as_bool()), Some(true));\n    }\n\n    #[test]\n    fn test_increment() {\n        let content = \"---\\ncount: 5\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"count\".to_string(),\n            op: FrontmatterOpType::Increment,\n            value: None, // Default increment of 1\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"count\").and_then(|v| v.as_i64()), Some(6));\n    }\n\n    #[test]\n    fn test_increment_with_value() {\n        let content = \"---\\ncount: 10\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"count\".to_string(),\n            op: FrontmatterOpType::Increment,\n            value: Some(Value::Number(5.into())),\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"count\").and_then(|v| v.as_i64()), Some(15));\n    }\n\n    #[test]\n    fn test_append_to_existing_list() {\n        let content = \"---\\nitems:\\n  - one\\n  - two\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"items\".to_string(),\n            op: FrontmatterOpType::Append,\n            value: Some(Value::String(\"three\".to_string())),\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        let items = fm.fields.get(\"items\").unwrap().as_sequence().unwrap();\n        assert_eq!(items.len(), 3);\n        assert_eq!(items[2].as_str(), Some(\"three\"));\n    }\n\n    #[test]\n    fn test_append_to_new_list() {\n        let content = \"---\\nother: value\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"items\".to_string(),\n            op: FrontmatterOpType::Append,\n            value: Some(Value::String(\"first\".to_string())),\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        let items = fm.fields.get(\"items\").unwrap().as_sequence().unwrap();\n        assert_eq!(items.len(), 1);\n        assert_eq!(items[0].as_str(), Some(\"first\"));\n    }\n\n    #[test]\n    fn test_variable_substitution() {\n        let content = \"---\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let mut ops_map = HashMap::new();\n        ops_map.insert(\n            \"modified\".to_string(),\n            Value::String(\"{{date}} at {{time}}\".to_string()),\n        );\n\n        let ops = FrontmatterOps::Simple(ops_map);\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(\n            fm.fields.get(\"modified\").and_then(|v| v.as_str()),\n            Some(\"2024-01-15 at 14:30\")\n        );\n    }\n\n    #[test]\n    fn test_creates_frontmatter_if_missing() {\n        let doc =\n            ParsedDocument { frontmatter: None, body: \"# No frontmatter\".to_string() };\n\n        let mut ops_map = HashMap::new();\n        ops_map.insert(\"new_field\".to_string(), Value::Bool(true));\n\n        let ops = FrontmatterOps::Simple(ops_map);\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n\n        assert!(result.frontmatter.is_some());\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"new_field\").and_then(|v| v.as_bool()), Some(true));\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":15}},{"line":29,"address":[],"length":0,"stats":{"Line":32}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":60}},{"line":34,"address":[],"length":0,"stats":{"Line":15}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":46}},{"line":37,"address":[],"length":0,"stats":{"Line":50}},{"line":38,"address":[],"length":0,"stats":{"Line":40}},{"line":41,"address":[],"length":0,"stats":{"Line":9}},{"line":42,"address":[],"length":0,"stats":{"Line":27}},{"line":43,"address":[],"length":0,"stats":{"Line":36}},{"line":48,"address":[],"length":0,"stats":{"Line":15}},{"line":52,"address":[],"length":0,"stats":{"Line":9}},{"line":57,"address":[],"length":0,"stats":{"Line":9}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":12}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":15}},{"line":79,"address":[],"length":0,"stats":{"Line":17}},{"line":81,"address":[],"length":0,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":83,"address":[],"length":0,"stats":{"Line":15}},{"line":84,"address":[],"length":0,"stats":{"Line":15}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":15}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":12}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":8}},{"line":103,"address":[],"length":0,"stats":{"Line":8}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":5}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":9}},{"line":116,"address":[],"length":0,"stats":{"Line":13}},{"line":117,"address":[],"length":0,"stats":{"Line":13}},{"line":118,"address":[],"length":0,"stats":{"Line":9}},{"line":119,"address":[],"length":0,"stats":{"Line":36}},{"line":120,"address":[],"length":0,"stats":{"Line":9}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":8}},{"line":136,"address":[],"length":0,"stats":{"Line":9}},{"line":137,"address":[],"length":0,"stats":{"Line":36}},{"line":138,"address":[],"length":0,"stats":{"Line":33}},{"line":139,"address":[],"length":0,"stats":{"Line":12}},{"line":140,"address":[],"length":0,"stats":{"Line":30}}],"covered":50,"coverable":64},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","frontmatter","parser.rs"],"content":"//! Frontmatter parsing from markdown documents.\n\nuse super::types::{Frontmatter, ParsedDocument, TemplateFrontmatter};\nuse thiserror::Error;\n\n/// Errors that can occur during frontmatter parsing.\n#[derive(Debug, Error)]\npub enum FrontmatterParseError {\n    #[error(\"invalid YAML frontmatter: {0}\")]\n    InvalidYaml(#[from] serde_yaml::Error),\n}\n\n/// Parse frontmatter from markdown content.\n///\n/// Frontmatter is delimited by `---` at the start of the document:\n/// ```markdown\n/// ---\n/// key: value\n/// ---\n/// # Document content\n/// ```\npub fn parse(content: \u0026str) -\u003e Result\u003cParsedDocument, FrontmatterParseError\u003e {\n    let trimmed = content.trim_start();\n\n    // Check if document starts with frontmatter delimiter\n    if !trimmed.starts_with(\"---\") {\n        return Ok(ParsedDocument { frontmatter: None, body: content.to_string() });\n    }\n\n    // Find the closing ---\n    let after_first = \u0026trimmed[3..];\n\n    // Skip the newline after opening ---\n    let after_newline = after_first\n        .strip_prefix('\\n')\n        .or_else(|| after_first.strip_prefix(\"\\r\\n\"))\n        .unwrap_or(after_first);\n\n    // Find closing delimiter\n    if let Some(end_pos) = find_closing_delimiter(after_newline) {\n        let yaml_content = \u0026after_newline[..end_pos];\n\n        // Calculate body start (skip closing --- and following newline)\n        let after_closing = \u0026after_newline[end_pos + 3..];\n        let body = after_closing\n            .strip_prefix('\\n')\n            .or_else(|| after_closing.strip_prefix(\"\\r\\n\"))\n            .unwrap_or(after_closing)\n            .to_string();\n\n        // Parse YAML\n        let frontmatter: Frontmatter = if yaml_content.trim().is_empty() {\n            Frontmatter::default()\n        } else {\n            serde_yaml::from_str(yaml_content.trim())?\n        };\n\n        Ok(ParsedDocument { frontmatter: Some(frontmatter), body })\n    } else {\n        // No closing ---, treat as no frontmatter\n        Ok(ParsedDocument { frontmatter: None, body: content.to_string() })\n    }\n}\n\n/// Find the position of closing `---` delimiter.\nfn find_closing_delimiter(content: \u0026str) -\u003e Option\u003cusize\u003e {\n    // Look for --- at the start of a line\n    for (i, line) in content.lines().enumerate() {\n        if line.trim() == \"---\" {\n            // Calculate byte position\n            let pos: usize = content\n                .lines()\n                .take(i)\n                .map(|l| l.len() + 1) // +1 for newline\n                .sum();\n            return Some(pos);\n        }\n    }\n    None\n}\n\n/// Parse template-specific frontmatter.\n///\n/// Returns the parsed template frontmatter (if present) and the body content.\npub fn parse_template_frontmatter(\n    content: \u0026str,\n) -\u003e Result\u003c(Option\u003cTemplateFrontmatter\u003e, String), FrontmatterParseError\u003e {\n    let parsed = parse(content)?;\n\n    if let Some(fm) = parsed.frontmatter {\n        // Convert Frontmatter to TemplateFrontmatter\n        let yaml_value = serde_yaml::to_value(\u0026fm.fields)?;\n        let template_fm: TemplateFrontmatter = serde_yaml::from_value(yaml_value)?;\n        Ok((Some(template_fm), parsed.body))\n    } else {\n        Ok((None, parsed.body))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_no_frontmatter() {\n        let content = \"# Hello\\n\\nSome content\";\n        let result = parse(content).unwrap();\n        assert!(result.frontmatter.is_none());\n        assert_eq!(result.body, content);\n    }\n\n    #[test]\n    fn parse_simple_frontmatter() {\n        let content = \"---\\ntitle: Hello\\n---\\n# Content\";\n        let result = parse(content).unwrap();\n        assert!(result.frontmatter.is_some());\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"title\").and_then(|v| v.as_str()), Some(\"Hello\"));\n        assert_eq!(result.body, \"# Content\");\n    }\n\n    #[test]\n    fn parse_frontmatter_with_multiple_fields() {\n        let content =\n            \"---\\ntitle: Test\\ndate: 2024-01-15\\ntags:\\n  - rust\\n  - cli\\n---\\n\\nBody\";\n        let result = parse(content).unwrap();\n        assert!(result.frontmatter.is_some());\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"title\").and_then(|v| v.as_str()), Some(\"Test\"));\n        assert!(fm.fields.contains_key(\"tags\"));\n        assert_eq!(result.body, \"\\nBody\");\n    }\n\n    #[test]\n    fn parse_empty_frontmatter() {\n        let content = \"---\\n---\\n# Content\";\n        let result = parse(content).unwrap();\n        assert!(result.frontmatter.is_some());\n        assert!(result.frontmatter.unwrap().fields.is_empty());\n        assert_eq!(result.body, \"# Content\");\n    }\n\n    #[test]\n    fn parse_template_frontmatter_with_output() {\n        let content = \"---\\noutput: daily/{{date}}.md\\ntags: [daily]\\n---\\n# Daily\";\n        let (fm, body) = parse_template_frontmatter(content).unwrap();\n        assert!(fm.is_some());\n        let fm = fm.unwrap();\n        assert_eq!(fm.output, Some(\"daily/{{date}}.md\".to_string()));\n        assert!(fm.extra.contains_key(\"tags\"));\n        assert_eq!(body, \"# Daily\");\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":131}},{"line":23,"address":[],"length":0,"stats":{"Line":393}},{"line":26,"address":[],"length":0,"stats":{"Line":131}},{"line":27,"address":[],"length":0,"stats":{"Line":120}},{"line":31,"address":[],"length":0,"stats":{"Line":142}},{"line":34,"address":[],"length":0,"stats":{"Line":142}},{"line":36,"address":[],"length":0,"stats":{"Line":71}},{"line":37,"address":[],"length":0,"stats":{"Line":142}},{"line":40,"address":[],"length":0,"stats":{"Line":142}},{"line":41,"address":[],"length":0,"stats":{"Line":142}},{"line":44,"address":[],"length":0,"stats":{"Line":142}},{"line":45,"address":[],"length":0,"stats":{"Line":142}},{"line":47,"address":[],"length":0,"stats":{"Line":71}},{"line":48,"address":[],"length":0,"stats":{"Line":142}},{"line":52,"address":[],"length":0,"stats":{"Line":284}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":138}},{"line":58,"address":[],"length":0,"stats":{"Line":71}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":71}},{"line":68,"address":[],"length":0,"stats":{"Line":671}},{"line":69,"address":[],"length":0,"stats":{"Line":229}},{"line":71,"address":[],"length":0,"stats":{"Line":213}},{"line":73,"address":[],"length":0,"stats":{"Line":142}},{"line":74,"address":[],"length":0,"stats":{"Line":387}},{"line":76,"address":[],"length":0,"stats":{"Line":71}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":15}},{"line":88,"address":[],"length":0,"stats":{"Line":45}},{"line":90,"address":[],"length":0,"stats":{"Line":25}},{"line":92,"address":[],"length":0,"stats":{"Line":30}},{"line":93,"address":[],"length":0,"stats":{"Line":40}},{"line":94,"address":[],"length":0,"stats":{"Line":10}},{"line":96,"address":[],"length":0,"stats":{"Line":5}}],"covered":32,"coverable":34},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","frontmatter","serializer.rs"],"content":"//! Frontmatter serialization back to markdown.\n\nuse super::types::{Frontmatter, ParsedDocument};\nuse serde_yaml::Value;\nuse std::collections::HashMap;\n\n/// Serialize a parsed document back to markdown string.\npub fn serialize(doc: \u0026ParsedDocument) -\u003e String {\n    if let Some(fm) = \u0026doc.frontmatter\n        \u0026\u0026 !fm.fields.is_empty()\n    {\n        let yaml = serialize_frontmatter(\u0026fm.fields);\n        return format!(\"---\\n{}---\\n\\n{}\", yaml, doc.body);\n    }\n    doc.body.clone()\n}\n\n/// Serialize frontmatter fields to YAML string.\nfn serialize_frontmatter(fields: \u0026HashMap\u003cString, Value\u003e) -\u003e String {\n    serde_yaml::to_string(fields).unwrap_or_default()\n}\n\n/// Serialize a Frontmatter struct to YAML string (without delimiters).\npub fn frontmatter_to_yaml(fm: \u0026Frontmatter) -\u003e String {\n    serialize_frontmatter(\u0026fm.fields)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::frontmatter::parser::parse;\n\n    #[test]\n    fn serialize_document_without_frontmatter() {\n        let doc =\n            ParsedDocument { frontmatter: None, body: \"# Hello\\n\\nWorld\".to_string() };\n        assert_eq!(serialize(\u0026doc), \"# Hello\\n\\nWorld\");\n    }\n\n    #[test]\n    fn serialize_document_with_frontmatter() {\n        let mut fields = HashMap::new();\n        fields.insert(\"title\".to_string(), Value::String(\"Test\".to_string()));\n\n        let doc = ParsedDocument {\n            frontmatter: Some(Frontmatter { fields }),\n            body: \"# Content\".to_string(),\n        };\n\n        let result = serialize(\u0026doc);\n        assert!(result.starts_with(\"---\\n\"));\n        assert!(result.contains(\"title: Test\"));\n        assert!(result.ends_with(\"---\\n\\n# Content\"));\n    }\n\n    #[test]\n    fn roundtrip_frontmatter() {\n        let original = \"---\\ntitle: Hello\\ncount: 42\\n---\\n\\n# Body\";\n        let parsed = parse(original).unwrap();\n        let serialized = serialize(\u0026parsed);\n\n        // Re-parse and verify\n        let reparsed = parse(\u0026serialized).unwrap();\n        assert!(reparsed.frontmatter.is_some());\n        let fm = reparsed.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"title\").and_then(|v| v.as_str()), Some(\"Hello\"));\n        assert_eq!(fm.fields.get(\"count\").and_then(|v| v.as_i64()), Some(42));\n        assert!(reparsed.body.contains(\"# Body\"));\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":18}},{"line":9,"address":[],"length":0,"stats":{"Line":28}},{"line":10,"address":[],"length":0,"stats":{"Line":10}},{"line":12,"address":[],"length":0,"stats":{"Line":30}},{"line":13,"address":[],"length":0,"stats":{"Line":20}},{"line":15,"address":[],"length":0,"stats":{"Line":16}},{"line":19,"address":[],"length":0,"stats":{"Line":10}},{"line":20,"address":[],"length":0,"stats":{"Line":30}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":10},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","frontmatter","types.rs"],"content":"//! Frontmatter types and data structures.\n\nuse serde::{Deserialize, Serialize};\nuse serde_yaml::Value;\nuse std::collections::HashMap;\n\nuse crate::vars::VarsMap;\n\n/// Represents parsed YAML frontmatter from a markdown document.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct Frontmatter {\n    /// Fields as key-value pairs.\n    #[serde(flatten)]\n    pub fields: HashMap\u003cString, Value\u003e,\n}\n\n/// Result of splitting frontmatter from markdown.\n#[derive(Debug, Clone)]\npub struct ParsedDocument {\n    /// Parsed frontmatter (if present).\n    pub frontmatter: Option\u003cFrontmatter\u003e,\n    /// The markdown body (everything after frontmatter).\n    pub body: String,\n}\n\n/// Template-specific frontmatter fields.\n#[derive(Debug, Clone, Deserialize, Default)]\npub struct TemplateFrontmatter {\n    /// Path to Lua script that defines this template's behavior.\n    /// When present, schema, prompts, output path, and hooks come from Lua.\n    pub lua: Option\u003cString\u003e,\n\n    /// Output path template (supports {{var}} placeholders).\n    /// DEPRECATED: Use Lua script's `output` field instead.\n    pub output: Option\u003cString\u003e,\n\n    /// Variable specifications with prompts and defaults.\n    /// DEPRECATED: Use Lua script's schema with `prompt` fields instead.\n    #[serde(default)]\n    pub vars: Option\u003cVarsMap\u003e,\n\n    /// Other fields are passed through to output.\n    #[serde(flatten)]\n    pub extra: HashMap\u003cString, Value\u003e,\n}\n\n/// Frontmatter operations specification.\n/// Supports both simple key-value pairs and explicit operations.\n#[derive(Debug, Clone, Deserialize)]\n#[serde(untagged)]\npub enum FrontmatterOps {\n    /// Simple map form: { field: value } implies \"set\".\n    Simple(HashMap\u003cString, Value\u003e),\n    /// List of explicit operations.\n    Operations(Vec\u003cFrontmatterOp\u003e),\n}\n\n/// A single frontmatter modification operation.\n#[derive(Debug, Clone, Deserialize)]\npub struct FrontmatterOp {\n    /// Field name to modify.\n    pub field: String,\n    /// Operation type.\n    pub op: FrontmatterOpType,\n    /// Value for set/append operations (supports {{var}} in string values).\n    #[serde(default)]\n    pub value: Option\u003cValue\u003e,\n}\n\n/// Type of frontmatter operation.\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum FrontmatterOpType {\n    /// Set field to value (creates if missing).\n    Set,\n    /// Toggle boolean field.\n    Toggle,\n    /// Increment numeric field.\n    Increment,\n    /// Append to list field.\n    Append,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","ids.rs"],"content":"//! ID generation utilities for projects and tasks.\n//!\n//! Projects get a 3-letter ID derived from their title.\n//! Tasks get the project ID + a 3-digit counter (e.g., \"MCP-001\").\n\n/// Generate a project ID from a title.\n///\n/// Takes up to 3 meaningful letters from the title:\n/// - If multiple words, takes first letter of each word (up to 3)\n/// - If single word, takes first 3 letters\n/// - Converts to uppercase\n///\n/// # Examples\n/// ```\n/// use mdvault_core::ids::generate_project_id;\n///\n/// assert_eq!(generate_project_id(\"My Cool Project\"), \"MCP\");\n/// assert_eq!(generate_project_id(\"Inventory\"), \"INV\");\n/// assert_eq!(generate_project_id(\"AI\"), \"AI\");\n/// assert_eq!(generate_project_id(\"a b c d e\"), \"ABC\");\n/// ```\npub fn generate_project_id(title: \u0026str) -\u003e String {\n    let words: Vec\u003c\u0026str\u003e = title.split_whitespace().filter(|w| !w.is_empty()).collect();\n\n    let id = if words.len() \u003e= 3 {\n        // Take first letter of first 3 words\n        words.iter().take(3).filter_map(|w| w.chars().next()).collect::\u003cString\u003e()\n    } else if words.len() == 2 {\n        // Two words: first letter of each, plus second letter of longer word\n        let mut chars: Vec\u003cchar\u003e =\n            words.iter().filter_map(|w| w.chars().next()).collect();\n        // Add one more char from the longer word\n        let longer = if words[0].len() \u003e= words[1].len() { words[0] } else { words[1] };\n        if let Some(c) = longer.chars().nth(1) {\n            chars.push(c);\n        }\n        chars.into_iter().collect()\n    } else if words.len() == 1 {\n        // Single word: take first 3 letters\n        words[0].chars().take(3).collect()\n    } else {\n        // Empty title, generate placeholder\n        \"XXX\".to_string()\n    };\n\n    id.to_uppercase()\n}\n\n/// Generate a task ID from a project ID and counter.\n///\n/// Format: `{project_id}-{counter:03}`\n///\n/// # Examples\n/// ```\n/// use mdvault_core::ids::generate_task_id;\n///\n/// assert_eq!(generate_task_id(\"MCP\", 1), \"MCP-001\");\n/// assert_eq!(generate_task_id(\"INV\", 42), \"INV-042\");\n/// assert_eq!(generate_task_id(\"AI\", 999), \"AI-999\");\n/// ```\npub fn generate_task_id(project_id: \u0026str, counter: u32) -\u003e String {\n    format!(\"{}-{:03}\", project_id, counter)\n}\n\n/// Parse a task ID to extract project ID and counter.\n///\n/// Returns None if the format is invalid.\n///\n/// # Examples\n/// ```\n/// use mdvault_core::ids::parse_task_id;\n///\n/// assert_eq!(parse_task_id(\"MCP-001\"), Some((\"MCP\".to_string(), 1)));\n/// assert_eq!(parse_task_id(\"INV-042\"), Some((\"INV\".to_string(), 42)));\n/// assert_eq!(parse_task_id(\"invalid\"), None);\n/// ```\npub fn parse_task_id(task_id: \u0026str) -\u003e Option\u003c(String, u32)\u003e {\n    let parts: Vec\u003c\u0026str\u003e = task_id.splitn(2, '-').collect();\n    if parts.len() != 2 {\n        return None;\n    }\n\n    let project_id = parts[0].to_string();\n    let counter = parts[1].parse::\u003cu32\u003e().ok()?;\n\n    Some((project_id, counter))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_project_id_multiple_words() {\n        assert_eq!(generate_project_id(\"My Cool Project\"), \"MCP\");\n        assert_eq!(generate_project_id(\"Knowledge Base System\"), \"KBS\");\n    }\n\n    #[test]\n    fn test_project_id_two_words() {\n        // Two words: first letter of each + second letter of longer word\n        assert_eq!(generate_project_id(\"Home Automation\"), \"HAU\");\n        assert_eq!(generate_project_id(\"AI Research\"), \"ARE\");\n    }\n\n    #[test]\n    fn test_project_id_single_word() {\n        assert_eq!(generate_project_id(\"Inventory\"), \"INV\");\n        assert_eq!(generate_project_id(\"AI\"), \"AI\");\n        assert_eq!(generate_project_id(\"X\"), \"X\");\n    }\n\n    #[test]\n    fn test_project_id_empty() {\n        assert_eq!(generate_project_id(\"\"), \"XXX\");\n        assert_eq!(generate_project_id(\"   \"), \"XXX\");\n    }\n\n    #[test]\n    fn test_project_id_lowercase() {\n        assert_eq!(generate_project_id(\"my cool project\"), \"MCP\");\n    }\n\n    #[test]\n    fn test_task_id_generation() {\n        assert_eq!(generate_task_id(\"MCP\", 1), \"MCP-001\");\n        assert_eq!(generate_task_id(\"MCP\", 42), \"MCP-042\");\n        assert_eq!(generate_task_id(\"MCP\", 999), \"MCP-999\");\n    }\n\n    #[test]\n    fn test_parse_task_id() {\n        assert_eq!(parse_task_id(\"MCP-001\"), Some((\"MCP\".to_string(), 1)));\n        assert_eq!(parse_task_id(\"INV-042\"), Some((\"INV\".to_string(), 42)));\n        assert_eq!(parse_task_id(\"invalid\"), None);\n        assert_eq!(parse_task_id(\"MCP-abc\"), None);\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":10}},{"line":23,"address":[],"length":0,"stats":{"Line":92}},{"line":25,"address":[],"length":0,"stats":{"Line":20}},{"line":27,"address":[],"length":0,"stats":{"Line":30}},{"line":28,"address":[],"length":0,"stats":{"Line":7}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":14}},{"line":33,"address":[],"length":0,"stats":{"Line":10}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":6}},{"line":38,"address":[],"length":0,"stats":{"Line":5}},{"line":40,"address":[],"length":0,"stats":{"Line":12}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":10}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":20}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":9}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":2}}],"covered":24,"coverable":24},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","builder.rs"],"content":"//! Index building orchestration.\n\nuse std::path::Path;\n\nuse chrono::{DateTime, Utc};\nuse thiserror::Error;\n\nuse super::db::{IndexDb, IndexError};\nuse super::types::{IndexedLink, IndexedNote};\nuse crate::vault::{\n    VaultWalker, VaultWalkerError, WalkedFile, content_hash, extract_note,\n};\n\n#[derive(Debug, Error)]\npub enum BuilderError {\n    #[error(\"Vault walker error: {0}\")]\n    Walker(#[from] VaultWalkerError),\n\n    #[error(\"Index database error: {0}\")]\n    Index(#[from] IndexError),\n\n    #[error(\"Failed to read file {path}: {source}\")]\n    FileRead {\n        path: String,\n        #[source]\n        source: std::io::Error,\n    },\n}\n\n/// Statistics from an indexing operation.\n#[derive(Debug, Clone, Default)]\npub struct IndexStats {\n    /// Number of files discovered.\n    pub files_found: usize,\n    /// Number of notes indexed (new or updated).\n    pub notes_indexed: usize,\n    /// Number of notes skipped due to errors.\n    pub notes_skipped: usize,\n    /// Number of links indexed.\n    pub links_indexed: usize,\n    /// Number of broken links found.\n    pub broken_links: usize,\n    /// Indexing duration in milliseconds.\n    pub duration_ms: u64,\n    /// Number of files unchanged (hash match) - incremental mode only.\n    pub files_unchanged: usize,\n    /// Number of files added (new to index) - incremental mode only.\n    pub files_added: usize,\n    /// Number of files updated (content changed) - incremental mode only.\n    pub files_updated: usize,\n    /// Number of files deleted (removed from vault) - incremental mode only.\n    pub files_deleted: usize,\n}\n\n/// File change classification for incremental updates.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum FileChange {\n    /// File is new (not in index).\n    Added,\n    /// File content has changed.\n    Modified,\n    /// File content unchanged.\n    Unchanged,\n}\n\n/// Progress callback for indexing operations.\n/// Parameters: (current, total, current_path)\npub type ProgressCallback = Box\u003cdyn Fn(usize, usize, \u0026str)\u003e;\n\n/// Builder for populating the vault index.\npub struct IndexBuilder\u003c'a\u003e {\n    db: \u0026'a IndexDb,\n    vault_root: \u0026'a Path,\n}\n\nimpl\u003c'a\u003e IndexBuilder\u003c'a\u003e {\n    /// Create a new index builder.\n    pub fn new(db: \u0026'a IndexDb, vault_root: \u0026'a Path) -\u003e Self {\n        Self { db, vault_root }\n    }\n\n    /// Perform a full reindex of the vault.\n    /// Clears existing data and rebuilds from scratch.\n    pub fn full_reindex(\n        \u0026self,\n        progress: Option\u003cProgressCallback\u003e,\n    ) -\u003e Result\u003cIndexStats, BuilderError\u003e {\n        let start = std::time::Instant::now();\n        let mut stats = IndexStats::default();\n\n        // Walk the vault\n        let walker = VaultWalker::new(self.vault_root)?;\n        let files = walker.walk()?;\n        stats.files_found = files.len();\n\n        // Clear existing index\n        self.db.clear_all()?;\n\n        // Phase 1: Index all notes\n        for (i, file) in files.iter().enumerate() {\n            if let Some(ref cb) = progress {\n                cb(i + 1, files.len(), \u0026file.relative_path.to_string_lossy());\n            }\n\n            match self.index_note(file) {\n                Ok(link_count) =\u003e {\n                    stats.notes_indexed += 1;\n                    stats.links_indexed += link_count;\n                }\n                Err(e) =\u003e {\n                    // Log error but continue indexing\n                    tracing::warn!(\n                        \"Failed to index {}: {}\",\n                        file.relative_path.display(),\n                        e\n                    );\n                    stats.notes_skipped += 1;\n                }\n            }\n        }\n\n        // Phase 2: Resolve link targets\n        self.db.resolve_link_targets()?;\n        stats.broken_links = self.db.count_broken_links()? as usize;\n\n        stats.duration_ms = start.elapsed().as_millis() as u64;\n        Ok(stats)\n    }\n\n    /// Perform an incremental reindex of the vault.\n    /// Only processes files that have changed since last index.\n    pub fn incremental_reindex(\n        \u0026self,\n        progress: Option\u003cProgressCallback\u003e,\n    ) -\u003e Result\u003cIndexStats, BuilderError\u003e {\n        let start = std::time::Instant::now();\n        let mut stats = IndexStats::default();\n\n        // Phase 1: Walk the vault and collect all current files\n        let walker = VaultWalker::new(self.vault_root)?;\n        let files = walker.walk()?;\n        stats.files_found = files.len();\n\n        // Phase 2: Get all currently indexed paths for deletion detection\n        let indexed_paths: std::collections::HashSet\u003cstd::path::PathBuf\u003e =\n            self.db.get_all_paths()?.into_iter().collect();\n\n        // Track which paths we've seen in the vault\n        let mut seen_paths: std::collections::HashSet\u003cstd::path::PathBuf\u003e =\n            std::collections::HashSet::with_capacity(files.len());\n\n        // Phase 3: Classify and process each file\n        for (i, file) in files.iter().enumerate() {\n            if let Some(ref cb) = progress {\n                cb(i + 1, files.len(), \u0026file.relative_path.to_string_lossy());\n            }\n\n            seen_paths.insert(file.relative_path.clone());\n\n            // Classify the change\n            let change = self.classify_change(file)?;\n\n            match change {\n                FileChange::Unchanged =\u003e {\n                    stats.files_unchanged += 1;\n                }\n                FileChange::Added | FileChange::Modified =\u003e match self.index_note(file) {\n                    Ok(link_count) =\u003e {\n                        stats.notes_indexed += 1;\n                        stats.links_indexed += link_count;\n                        if change == FileChange::Added {\n                            stats.files_added += 1;\n                        } else {\n                            stats.files_updated += 1;\n                        }\n                    }\n                    Err(e) =\u003e {\n                        tracing::warn!(\n                            \"Failed to index {}: {}\",\n                            file.relative_path.display(),\n                            e\n                        );\n                        stats.notes_skipped += 1;\n                    }\n                },\n            }\n        }\n\n        // Phase 4: Detect and delete removed files\n        for indexed_path in \u0026indexed_paths {\n            if !seen_paths.contains(indexed_path) \u0026\u0026 self.db.delete_note(indexed_path)? {\n                stats.files_deleted += 1;\n                tracing::debug!(\"Deleted from index: {}\", indexed_path.display());\n            }\n        }\n\n        // Phase 5: Resolve link targets (handles newly valid links)\n        self.db.resolve_link_targets()?;\n        stats.broken_links = self.db.count_broken_links()? as usize;\n\n        stats.duration_ms = start.elapsed().as_millis() as u64;\n        Ok(stats)\n    }\n\n    /// Classify a file's change status by comparing content hashes.\n    fn classify_change(\u0026self, file: \u0026WalkedFile) -\u003e Result\u003cFileChange, BuilderError\u003e {\n        // Get stored hash (if any)\n        let stored_hash = self.db.get_content_hash(\u0026file.relative_path)?;\n\n        match stored_hash {\n            None =\u003e Ok(FileChange::Added),\n            Some(stored) =\u003e {\n                // Compute current hash\n                let current = content_hash(\u0026file.absolute_path).map_err(|e| {\n                    BuilderError::FileRead {\n                        path: file.absolute_path.display().to_string(),\n                        source: e,\n                    }\n                })?;\n\n                if current == stored {\n                    Ok(FileChange::Unchanged)\n                } else {\n                    Ok(FileChange::Modified)\n                }\n            }\n        }\n    }\n\n    /// Index a single note file.\n    /// Returns the number of links indexed.\n    fn index_note(\u0026self, file: \u0026WalkedFile) -\u003e Result\u003cusize, BuilderError\u003e {\n        // Read file content\n        let content = std::fs::read_to_string(\u0026file.absolute_path).map_err(|e| {\n            BuilderError::FileRead {\n                path: file.absolute_path.display().to_string(),\n                source: e,\n            }\n        })?;\n\n        // Compute content hash\n        let hash =\n            content_hash(\u0026file.absolute_path).map_err(|e| BuilderError::FileRead {\n                path: file.absolute_path.display().to_string(),\n                source: e,\n            })?;\n\n        // Extract note metadata\n        let extracted = extract_note(\u0026content, \u0026file.relative_path);\n\n        // Convert modified time to DateTime\u003cUtc\u003e\n        let modified: DateTime\u003cUtc\u003e = file.modified.into();\n\n        // Create indexed note\n        let note = IndexedNote {\n            id: None,\n            path: file.relative_path.clone(),\n            note_type: extracted.note_type,\n            title: extracted.title,\n            created: None, // Could extract from frontmatter if present\n            modified,\n            frontmatter_json: extracted.frontmatter_json,\n            content_hash: hash,\n        };\n\n        // Insert note and get ID\n        let note_id = self.db.upsert_note(\u0026note)?;\n\n        // Delete existing links for this note (in case of update)\n        self.db.delete_links_from(note_id)?;\n\n        // Insert links\n        let link_count = extracted.links.len();\n        for link in extracted.links {\n            let indexed_link = IndexedLink {\n                id: None,\n                source_id: note_id,\n                target_id: None, // Resolved in phase 2\n                target_path: link.target,\n                link_text: link.text,\n                link_type: link.link_type,\n                context: link.context,\n                line_number: Some(link.line_number),\n            };\n            self.db.insert_link(\u0026indexed_link)?;\n        }\n\n        Ok(link_count)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    fn create_test_vault() -\u003e TempDir {\n        let dir = TempDir::new().unwrap();\n        let root = dir.path();\n\n        // Create some markdown files with links\n        fs::write(\n            root.join(\"note1.md\"),\n            r#\"---\ntitle: Note One\ntype: zettel\n---\n# Note One\n\nThis links to [[note2]] and [[missing-note]].\n\"#,\n        )\n        .unwrap();\n\n        fs::write(\n            root.join(\"note2.md\"),\n            r#\"---\ntitle: Note Two\ntype: task\nproject: note1\n---\n# Note Two\n\nBack to [[note1]].\n\"#,\n        )\n        .unwrap();\n\n        fs::create_dir(root.join(\"subdir\")).unwrap();\n        fs::write(\n            root.join(\"subdir/note3.md\"),\n            r#\"# Note Three\n\nLinks to [Note One](../note1.md).\n\"#,\n        )\n        .unwrap();\n\n        dir\n    }\n\n    #[test]\n    fn test_full_reindex() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n        let stats = builder.full_reindex(None).unwrap();\n\n        assert_eq!(stats.files_found, 3);\n        assert_eq!(stats.notes_indexed, 3);\n        assert_eq!(stats.notes_skipped, 0);\n        assert!(stats.links_indexed \u003e= 4); // At least 4 links across all notes\n    }\n\n    #[test]\n    fn test_notes_are_indexed_correctly() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n        builder.full_reindex(None).unwrap();\n\n        // Check note1 is indexed\n        let note1 = db\n            .get_note_by_path(Path::new(\"note1.md\"))\n            .unwrap()\n            .expect(\"note1 should exist\");\n        assert_eq!(note1.title, \"Note One\");\n        assert_eq!(note1.note_type, crate::index::types::NoteType::Zettel);\n\n        // Check note2 is indexed\n        let note2 = db\n            .get_note_by_path(Path::new(\"note2.md\"))\n            .unwrap()\n            .expect(\"note2 should exist\");\n        assert_eq!(note2.title, \"Note Two\");\n        assert_eq!(note2.note_type, crate::index::types::NoteType::Task);\n    }\n\n    #[test]\n    fn test_links_are_indexed() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n        builder.full_reindex(None).unwrap();\n\n        let note1 = db\n            .get_note_by_path(Path::new(\"note1.md\"))\n            .unwrap()\n            .expect(\"note1 should exist\");\n\n        let outgoing = db.get_outgoing_links(note1.id.unwrap()).unwrap();\n        assert_eq!(outgoing.len(), 2); // [[note2]] and [[missing-note]]\n    }\n\n    #[test]\n    fn test_link_targets_resolved() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n        let stats = builder.full_reindex(None).unwrap();\n\n        // At least one broken link (missing-note)\n        assert!(stats.broken_links \u003e= 1);\n\n        // Check that existing links have target_id resolved\n        let note2 = db\n            .get_note_by_path(Path::new(\"note2.md\"))\n            .unwrap()\n            .expect(\"note2 should exist\");\n\n        let backlinks = db.get_backlinks(note2.id.unwrap()).unwrap();\n        // note1 links to note2\n        assert!(!backlinks.is_empty());\n    }\n\n    #[test]\n    fn test_reindex_clears_old_data() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        // Index twice\n        builder.full_reindex(None).unwrap();\n        let stats = builder.full_reindex(None).unwrap();\n\n        // Should still have same counts (not doubled)\n        assert_eq!(stats.notes_indexed, 3);\n        assert_eq!(db.count_notes().unwrap(), 3);\n    }\n\n    // \n    // Incremental reindex tests\n    // \n\n    #[test]\n    fn test_incremental_first_run() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        let stats = builder.incremental_reindex(None).unwrap();\n\n        assert_eq!(stats.files_found, 3);\n        assert_eq!(stats.files_added, 3);\n        assert_eq!(stats.files_unchanged, 0);\n        assert_eq!(stats.files_updated, 0);\n        assert_eq!(stats.files_deleted, 0);\n        assert_eq!(stats.notes_indexed, 3);\n    }\n\n    #[test]\n    fn test_incremental_no_changes() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        builder.incremental_reindex(None).unwrap();\n        let stats = builder.incremental_reindex(None).unwrap();\n\n        assert_eq!(stats.files_found, 3);\n        assert_eq!(stats.files_unchanged, 3);\n        assert_eq!(stats.files_added, 0);\n        assert_eq!(stats.files_updated, 0);\n        assert_eq!(stats.files_deleted, 0);\n        assert_eq!(stats.notes_indexed, 0);\n    }\n\n    #[test]\n    fn test_incremental_file_modified() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        builder.incremental_reindex(None).unwrap();\n\n        // Modify a file\n        fs::write(vault.path().join(\"note1.md\"), \"# Note 1 Modified\\n\\nNew content.\")\n            .unwrap();\n\n        let stats = builder.incremental_reindex(None).unwrap();\n\n        assert_eq!(stats.files_unchanged, 2);\n        assert_eq!(stats.files_updated, 1);\n        assert_eq!(stats.files_added, 0);\n        assert_eq!(stats.notes_indexed, 1);\n    }\n\n    #[test]\n    fn test_incremental_file_added() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        builder.incremental_reindex(None).unwrap();\n\n        // Add a new file\n        fs::write(vault.path().join(\"note4.md\"), \"# Note 4\\n\\nBrand new note.\").unwrap();\n\n        let stats = builder.incremental_reindex(None).unwrap();\n\n        assert_eq!(stats.files_found, 4);\n        assert_eq!(stats.files_unchanged, 3);\n        assert_eq!(stats.files_added, 1);\n        assert_eq!(stats.files_updated, 0);\n        assert_eq!(stats.notes_indexed, 1);\n    }\n\n    #[test]\n    fn test_incremental_file_deleted() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        builder.incremental_reindex(None).unwrap();\n\n        // Delete a file\n        fs::remove_file(vault.path().join(\"note2.md\")).unwrap();\n\n        let stats = builder.incremental_reindex(None).unwrap();\n\n        assert_eq!(stats.files_found, 2);\n        assert_eq!(stats.files_deleted, 1);\n        assert_eq!(stats.files_unchanged, 2);\n\n        // Verify it's gone from the index\n        assert!(db.get_note_by_path(Path::new(\"note2.md\")).unwrap().is_none());\n        assert_eq!(db.count_notes().unwrap(), 2);\n    }\n\n    #[test]\n    fn test_incremental_links_updated_on_change() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        builder.incremental_reindex(None).unwrap();\n\n        let note1 = db.get_note_by_path(Path::new(\"note1.md\")).unwrap().unwrap();\n        let links_before = db.get_outgoing_links(note1.id.unwrap()).unwrap();\n        assert_eq!(links_before.len(), 2); // [[note2]] and [[missing-note]]\n\n        // Modify to have different links\n        fs::write(vault.path().join(\"note1.md\"), \"# Note 1\\n\\n[[note3]] only now.\")\n            .unwrap();\n        builder.incremental_reindex(None).unwrap();\n\n        let note1 = db.get_note_by_path(Path::new(\"note1.md\")).unwrap().unwrap();\n        let links_after = db.get_outgoing_links(note1.id.unwrap()).unwrap();\n        assert_eq!(links_after.len(), 1);\n        assert_eq!(links_after[0].target_path, \"note3\");\n    }\n\n    #[test]\n    fn test_incremental_broken_links_resolved() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        // note1 links to note2 and missing-note\n        let stats1 = builder.incremental_reindex(None).unwrap();\n        assert!(stats1.broken_links \u003e 0); // missing-note is broken\n\n        // Now create the missing note\n        fs::write(vault.path().join(\"missing-note.md\"), \"# Missing Note\\n\\nNow exists!\")\n            .unwrap();\n\n        let stats2 = builder.incremental_reindex(None).unwrap();\n        assert_eq!(stats2.files_added, 1);\n\n        // The link to missing-note should now be resolved\n        let missing = db.get_note_by_path(Path::new(\"missing-note.md\")).unwrap().unwrap();\n        let backlinks = db.get_backlinks(missing.id.unwrap()).unwrap();\n        assert!(!backlinks.is_empty());\n    }\n}\n","traces":[{"line":78,"address":[],"length":0,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":12}},{"line":89,"address":[],"length":0,"stats":{"Line":12}},{"line":92,"address":[],"length":0,"stats":{"Line":18}},{"line":93,"address":[],"length":0,"stats":{"Line":18}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":12}},{"line":100,"address":[],"length":0,"stats":{"Line":48}},{"line":101,"address":[],"length":0,"stats":{"Line":18}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":36}},{"line":106,"address":[],"length":0,"stats":{"Line":36}},{"line":107,"address":[],"length":0,"stats":{"Line":18}},{"line":108,"address":[],"length":0,"stats":{"Line":18}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":12}},{"line":124,"address":[],"length":0,"stats":{"Line":12}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":13}},{"line":136,"address":[],"length":0,"stats":{"Line":26}},{"line":137,"address":[],"length":0,"stats":{"Line":26}},{"line":140,"address":[],"length":0,"stats":{"Line":39}},{"line":141,"address":[],"length":0,"stats":{"Line":39}},{"line":142,"address":[],"length":0,"stats":{"Line":13}},{"line":145,"address":[],"length":0,"stats":{"Line":26}},{"line":146,"address":[],"length":0,"stats":{"Line":52}},{"line":149,"address":[],"length":0,"stats":{"Line":26}},{"line":150,"address":[],"length":0,"stats":{"Line":39}},{"line":153,"address":[],"length":0,"stats":{"Line":106}},{"line":154,"address":[],"length":0,"stats":{"Line":40}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":160}},{"line":161,"address":[],"length":0,"stats":{"Line":160}},{"line":163,"address":[],"length":0,"stats":{"Line":40}},{"line":164,"address":[],"length":0,"stats":{"Line":15}},{"line":165,"address":[],"length":0,"stats":{"Line":15}},{"line":167,"address":[],"length":0,"stats":{"Line":50}},{"line":168,"address":[],"length":0,"stats":{"Line":25}},{"line":169,"address":[],"length":0,"stats":{"Line":25}},{"line":170,"address":[],"length":0,"stats":{"Line":25}},{"line":171,"address":[],"length":0,"stats":{"Line":48}},{"line":172,"address":[],"length":0,"stats":{"Line":23}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":49}},{"line":191,"address":[],"length":0,"stats":{"Line":39}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":26}},{"line":199,"address":[],"length":0,"stats":{"Line":26}},{"line":201,"address":[],"length":0,"stats":{"Line":13}},{"line":202,"address":[],"length":0,"stats":{"Line":13}},{"line":206,"address":[],"length":0,"stats":{"Line":40}},{"line":208,"address":[],"length":0,"stats":{"Line":160}},{"line":210,"address":[],"length":0,"stats":{"Line":40}},{"line":211,"address":[],"length":0,"stats":{"Line":23}},{"line":212,"address":[],"length":0,"stats":{"Line":17}},{"line":214,"address":[],"length":0,"stats":{"Line":68}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":17}},{"line":222,"address":[],"length":0,"stats":{"Line":15}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":43}},{"line":234,"address":[],"length":0,"stats":{"Line":172}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":43}},{"line":243,"address":[],"length":0,"stats":{"Line":129}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":172}},{"line":252,"address":[],"length":0,"stats":{"Line":172}},{"line":257,"address":[],"length":0,"stats":{"Line":129}},{"line":258,"address":[],"length":0,"stats":{"Line":86}},{"line":259,"address":[],"length":0,"stats":{"Line":86}},{"line":262,"address":[],"length":0,"stats":{"Line":43}},{"line":267,"address":[],"length":0,"stats":{"Line":172}},{"line":270,"address":[],"length":0,"stats":{"Line":129}},{"line":273,"address":[],"length":0,"stats":{"Line":129}},{"line":274,"address":[],"length":0,"stats":{"Line":175}},{"line":279,"address":[],"length":0,"stats":{"Line":132}},{"line":280,"address":[],"length":0,"stats":{"Line":132}},{"line":281,"address":[],"length":0,"stats":{"Line":132}},{"line":282,"address":[],"length":0,"stats":{"Line":66}},{"line":283,"address":[],"length":0,"stats":{"Line":66}},{"line":285,"address":[],"length":0,"stats":{"Line":198}},{"line":288,"address":[],"length":0,"stats":{"Line":43}}],"covered":80,"coverable":102},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","db.rs"],"content":"//! Database connection and operations.\n\nuse std::path::Path;\n\nuse rusqlite::{Connection, OptionalExtension, params};\nuse thiserror::Error;\n\nuse super::schema::{SchemaError, init_schema};\nuse super::types::{IndexedLink, IndexedNote, LinkType, NoteQuery, NoteType};\n\n#[derive(Debug, Error)]\npub enum IndexError {\n    #[error(\"Database error: {0}\")]\n    Database(#[from] rusqlite::Error),\n\n    #[error(\"Schema error: {0}\")]\n    Schema(#[from] SchemaError),\n\n    #[error(\"Note not found: {0}\")]\n    NoteNotFound(String),\n\n    #[error(\"Invalid data: {0}\")]\n    InvalidData(String),\n}\n\n/// Vault index database handle.\npub struct IndexDb {\n    conn: Connection,\n}\n\nimpl IndexDb {\n    /// Open or create an index database at the given path.\n    pub fn open(path: \u0026Path) -\u003e Result\u003cSelf, IndexError\u003e {\n        let conn = Connection::open(path)?;\n        conn.execute_batch(\n            \"PRAGMA journal_mode = WAL;\n             PRAGMA foreign_keys = ON;\n             PRAGMA busy_timeout = 5000;\",\n        )?;\n        init_schema(\u0026conn)?;\n        Ok(Self { conn })\n    }\n\n    /// Create an in-memory database (for testing).\n    pub fn open_in_memory() -\u003e Result\u003cSelf, IndexError\u003e {\n        let conn = Connection::open_in_memory()?;\n        conn.execute_batch(\"PRAGMA foreign_keys = ON;\")?;\n        init_schema(\u0026conn)?;\n        Ok(Self { conn })\n    }\n\n    /// Get the underlying connection (for transactions).\n    pub fn connection(\u0026self) -\u003e \u0026Connection {\n        \u0026self.conn\n    }\n\n    // \n    // Notes CRUD\n    // \n\n    /// Insert a new note into the index.\n    pub fn insert_note(\u0026self, note: \u0026IndexedNote) -\u003e Result\u003ci64, IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO notes (path, note_type, title, created_at, modified_at, frontmatter_json, content_hash)\n             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)\",\n            params![\n                note.path.to_string_lossy(),\n                note.note_type.as_str(),\n                note.title,\n                note.created.map(|d| d.to_rfc3339()),\n                note.modified.to_rfc3339(),\n                note.frontmatter_json,\n                note.content_hash,\n            ],\n        )?;\n        Ok(self.conn.last_insert_rowid())\n    }\n\n    /// Update an existing note in the index.\n    pub fn update_note(\u0026self, note: \u0026IndexedNote) -\u003e Result\u003c(), IndexError\u003e {\n        let id = note.id.ok_or_else(|| {\n            IndexError::InvalidData(\"Note must have an ID for update\".to_string())\n        })?;\n\n        let rows = self.conn.execute(\n            \"UPDATE notes SET\n                path = ?1, note_type = ?2, title = ?3,\n                created_at = ?4, modified_at = ?5,\n                frontmatter_json = ?6, content_hash = ?7\n             WHERE id = ?8\",\n            params![\n                note.path.to_string_lossy(),\n                note.note_type.as_str(),\n                note.title,\n                note.created.map(|d| d.to_rfc3339()),\n                note.modified.to_rfc3339(),\n                note.frontmatter_json,\n                note.content_hash,\n                id,\n            ],\n        )?;\n\n        if rows == 0 {\n            return Err(IndexError::NoteNotFound(format!(\"ID {}\", id)));\n        }\n        Ok(())\n    }\n\n    /// Upsert a note (insert or update based on path).\n    pub fn upsert_note(\u0026self, note: \u0026IndexedNote) -\u003e Result\u003ci64, IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO notes (path, note_type, title, created_at, modified_at, frontmatter_json, content_hash)\n             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)\n             ON CONFLICT(path) DO UPDATE SET\n                note_type = excluded.note_type,\n                title = excluded.title,\n                created_at = excluded.created_at,\n                modified_at = excluded.modified_at,\n                frontmatter_json = excluded.frontmatter_json,\n                content_hash = excluded.content_hash\",\n            params![\n                note.path.to_string_lossy(),\n                note.note_type.as_str(),\n                note.title,\n                note.created.map(|d| d.to_rfc3339()),\n                note.modified.to_rfc3339(),\n                note.frontmatter_json,\n                note.content_hash,\n            ],\n        )?;\n\n        // Get the ID (either new or existing)\n        let id: i64 = self.conn.query_row(\n            \"SELECT id FROM notes WHERE path = ?1\",\n            [note.path.to_string_lossy()],\n            |row| row.get(0),\n        )?;\n\n        Ok(id)\n    }\n\n    /// Get a note by its path.\n    pub fn get_note_by_path(\n        \u0026self,\n        path: \u0026Path,\n    ) -\u003e Result\u003cOption\u003cIndexedNote\u003e, IndexError\u003e {\n        self.conn\n            .query_row(\n                \"SELECT id, path, note_type, title, created_at, modified_at, frontmatter_json, content_hash\n                 FROM notes WHERE path = ?1\",\n                [path.to_string_lossy()],\n                Self::row_to_note,\n            )\n            .optional()\n            .map_err(Into::into)\n    }\n\n    /// Get a note by its ID.\n    pub fn get_note_by_id(\u0026self, id: i64) -\u003e Result\u003cOption\u003cIndexedNote\u003e, IndexError\u003e {\n        self.conn\n            .query_row(\n                \"SELECT id, path, note_type, title, created_at, modified_at, frontmatter_json, content_hash\n                 FROM notes WHERE id = ?1\",\n                [id],\n                Self::row_to_note,\n            )\n            .optional()\n            .map_err(Into::into)\n    }\n\n    /// Query notes with filters.\n    pub fn query_notes(\u0026self, query: \u0026NoteQuery) -\u003e Result\u003cVec\u003cIndexedNote\u003e, IndexError\u003e {\n        let mut sql = String::from(\n            \"SELECT id, path, note_type, title, created_at, modified_at, frontmatter_json, content_hash\n             FROM notes WHERE 1=1\",\n        );\n        let mut params_vec: Vec\u003cBox\u003cdyn rusqlite::ToSql\u003e\u003e = Vec::new();\n\n        if let Some(note_type) = \u0026query.note_type {\n            sql.push_str(\" AND note_type = ?\");\n            params_vec.push(Box::new(note_type.as_str().to_string()));\n        }\n\n        if let Some(prefix) = \u0026query.path_prefix {\n            sql.push_str(\" AND path LIKE ?\");\n            params_vec.push(Box::new(format!(\"{}%\", prefix.to_string_lossy())));\n        }\n\n        if let Some(after) = \u0026query.modified_after {\n            sql.push_str(\" AND modified_at \u003e= ?\");\n            params_vec.push(Box::new(after.to_rfc3339()));\n        }\n\n        if let Some(before) = \u0026query.modified_before {\n            sql.push_str(\" AND modified_at \u003c= ?\");\n            params_vec.push(Box::new(before.to_rfc3339()));\n        }\n\n        sql.push_str(\" ORDER BY modified_at DESC\");\n\n        if let Some(limit) = query.limit {\n            sql.push_str(\u0026format!(\" LIMIT {}\", limit));\n        }\n\n        if let Some(offset) = query.offset {\n            sql.push_str(\u0026format!(\" OFFSET {}\", offset));\n        }\n\n        let params_refs: Vec\u003c\u0026dyn rusqlite::ToSql\u003e =\n            params_vec.iter().map(|p| p.as_ref()).collect();\n\n        let mut stmt = self.conn.prepare(\u0026sql)?;\n        let notes = stmt\n            .query_map(params_refs.as_slice(), Self::row_to_note)?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(notes)\n    }\n\n    /// Delete a note by path (also deletes associated links via CASCADE).\n    pub fn delete_note(\u0026self, path: \u0026Path) -\u003e Result\u003cbool, IndexError\u003e {\n        let rows = self\n            .conn\n            .execute(\"DELETE FROM notes WHERE path = ?1\", [path.to_string_lossy()])?;\n        Ok(rows \u003e 0)\n    }\n\n    /// Get content hash for a note path (for change detection).\n    pub fn get_content_hash(\u0026self, path: \u0026Path) -\u003e Result\u003cOption\u003cString\u003e, IndexError\u003e {\n        self.conn\n            .query_row(\n                \"SELECT content_hash FROM notes WHERE path = ?1\",\n                [path.to_string_lossy()],\n                |row| row.get(0),\n            )\n            .optional()\n            .map_err(Into::into)\n    }\n\n    /// Get all indexed note paths (for detecting deletions during incremental reindex).\n    pub fn get_all_paths(\u0026self) -\u003e Result\u003cVec\u003cstd::path::PathBuf\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\"SELECT path FROM notes\")?;\n        let paths = stmt\n            .query_map([], |row| {\n                let path_str: String = row.get(0)?;\n                Ok(std::path::PathBuf::from(path_str))\n            })?\n            .filter_map(|r| r.ok())\n            .collect();\n        Ok(paths)\n    }\n\n    fn row_to_note(row: \u0026rusqlite::Row) -\u003e Result\u003cIndexedNote, rusqlite::Error\u003e {\n        let path_str: String = row.get(1)?;\n        let type_str: String = row.get(2)?;\n        let created_str: Option\u003cString\u003e = row.get(4)?;\n        let modified_str: String = row.get(5)?;\n\n        Ok(IndexedNote {\n            id: Some(row.get(0)?),\n            path: path_str.into(),\n            note_type: type_str.parse().unwrap(),\n            title: row.get(3)?,\n            created: created_str.and_then(|s| {\n                chrono::DateTime::parse_from_rfc3339(\u0026s)\n                    .ok()\n                    .map(|d| d.with_timezone(\u0026chrono::Utc))\n            }),\n            modified: chrono::DateTime::parse_from_rfc3339(\u0026modified_str)\n                .map(|d| d.with_timezone(\u0026chrono::Utc))\n                .unwrap_or_else(|_| chrono::Utc::now()),\n            frontmatter_json: row.get(6)?,\n            content_hash: row.get(7)?,\n        })\n    }\n\n    // \n    // Links CRUD\n    // \n\n    /// Insert a link between notes.\n    pub fn insert_link(\u0026self, link: \u0026IndexedLink) -\u003e Result\u003ci64, IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO links (source_id, target_id, target_path, link_text, link_type, context, line_number)\n             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)\",\n            params![\n                link.source_id,\n                link.target_id,\n                link.target_path,\n                link.link_text,\n                link.link_type.as_str(),\n                link.context,\n                link.line_number,\n            ],\n        )?;\n        Ok(self.conn.last_insert_rowid())\n    }\n\n    /// Delete all links from a source note.\n    pub fn delete_links_from(\u0026self, source_id: i64) -\u003e Result\u003cusize, IndexError\u003e {\n        let rows =\n            self.conn.execute(\"DELETE FROM links WHERE source_id = ?1\", [source_id])?;\n        Ok(rows)\n    }\n\n    /// Get outgoing links from a note.\n    pub fn get_outgoing_links(\n        \u0026self,\n        source_id: i64,\n    ) -\u003e Result\u003cVec\u003cIndexedLink\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT id, source_id, target_id, target_path, link_text, link_type, context, line_number\n             FROM links WHERE source_id = ?1\",\n        )?;\n\n        let links = stmt\n            .query_map([source_id], Self::row_to_link)?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(links)\n    }\n\n    /// Get incoming links (backlinks) to a note.\n    pub fn get_backlinks(\u0026self, target_id: i64) -\u003e Result\u003cVec\u003cIndexedLink\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT id, source_id, target_id, target_path, link_text, link_type, context, line_number\n             FROM links WHERE target_id = ?1\",\n        )?;\n\n        let links = stmt\n            .query_map([target_id], Self::row_to_link)?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(links)\n    }\n\n    /// Find orphan notes (no incoming links).\n    pub fn find_orphans(\u0026self) -\u003e Result\u003cVec\u003cIndexedNote\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT n.id, n.path, n.note_type, n.title, n.created_at, n.modified_at, n.frontmatter_json, n.content_hash\n             FROM notes n\n             LEFT JOIN links l ON l.target_id = n.id\n             WHERE l.id IS NULL\",\n        )?;\n\n        let notes =\n            stmt.query_map([], Self::row_to_note)?.filter_map(|r| r.ok()).collect();\n\n        Ok(notes)\n    }\n\n    /// Resolve target_id for links by matching target_path to notes.\n    /// Returns the number of links that were successfully resolved.\n    pub fn resolve_link_targets(\u0026self) -\u003e Result\u003cusize, IndexError\u003e {\n        self.conn.execute(\n            \"UPDATE links SET target_id = (\n                SELECT n.id FROM notes n\n                WHERE links.target_path = n.path\n                   OR links.target_path || '.md' = n.path\n                   OR links.target_path = REPLACE(n.path, '.md', '')\n             )\n             WHERE target_id IS NULL\",\n            [],\n        )?;\n\n        // Count how many links now have a resolved target\n        let resolved: i64 = self.conn.query_row(\n            \"SELECT COUNT(*) FROM links WHERE target_id IS NOT NULL\",\n            [],\n            |row| row.get(0),\n        )?;\n        Ok(resolved as usize)\n    }\n\n    /// Count links that have no resolved target (broken links).\n    pub fn count_broken_links(\u0026self) -\u003e Result\u003ci64, IndexError\u003e {\n        let count: i64 = self.conn.query_row(\n            \"SELECT COUNT(*) FROM links WHERE target_id IS NULL\",\n            [],\n            |row| row.get(0),\n        )?;\n        Ok(count)\n    }\n\n    fn row_to_link(row: \u0026rusqlite::Row) -\u003e Result\u003cIndexedLink, rusqlite::Error\u003e {\n        let type_str: String = row.get(5)?;\n        Ok(IndexedLink {\n            id: Some(row.get(0)?),\n            source_id: row.get(1)?,\n            target_id: row.get(2)?,\n            target_path: row.get(3)?,\n            link_text: row.get(4)?,\n            link_type: LinkType::parse(\u0026type_str).unwrap_or(LinkType::Wikilink),\n            context: row.get(6)?,\n            line_number: row.get(7)?,\n        })\n    }\n\n    // \n    // Statistics\n    // \n\n    /// Get count of notes by type.\n    pub fn count_by_type(\u0026self) -\u003e Result\u003cVec\u003c(NoteType, i64)\u003e, IndexError\u003e {\n        let mut stmt = self\n            .conn\n            .prepare(\"SELECT note_type, COUNT(*) FROM notes GROUP BY note_type\")?;\n\n        let counts = stmt\n            .query_map([], |row| {\n                let type_str: String = row.get(0)?;\n                let count: i64 = row.get(1)?;\n                Ok((type_str.parse().unwrap(), count))\n            })?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(counts)\n    }\n\n    /// Get total note count.\n    pub fn count_notes(\u0026self) -\u003e Result\u003ci64, IndexError\u003e {\n        let count: i64 =\n            self.conn.query_row(\"SELECT COUNT(*) FROM notes\", [], |row| row.get(0))?;\n        Ok(count)\n    }\n\n    /// Get total link count.\n    pub fn count_links(\u0026self) -\u003e Result\u003ci64, IndexError\u003e {\n        let count: i64 =\n            self.conn.query_row(\"SELECT COUNT(*) FROM links\", [], |row| row.get(0))?;\n        Ok(count)\n    }\n\n    /// Clear all data from the index (for full reindex).\n    pub fn clear_all(\u0026self) -\u003e Result\u003c(), IndexError\u003e {\n        self.conn.execute_batch(\n            \"DELETE FROM links;\n             DELETE FROM temporal_activity;\n             DELETE FROM activity_summary;\n             DELETE FROM note_cooccurrence;\n             DELETE FROM notes;\",\n        )?;\n        Ok(())\n    }\n\n    // \n    // Derived Index Operations\n    // \n\n    /// Clear derived tables (temporal_activity, activity_summary, note_cooccurrence).\n    pub fn clear_derived_tables(\u0026self) -\u003e Result\u003c(), IndexError\u003e {\n        self.conn.execute_batch(\n            \"DELETE FROM temporal_activity;\n             DELETE FROM activity_summary;\n             DELETE FROM note_cooccurrence;\",\n        )?;\n        Ok(())\n    }\n\n    /// Get notes filtered by type.\n    pub fn get_notes_by_type(\n        \u0026self,\n        type_str: \u0026str,\n    ) -\u003e Result\u003cVec\u003cIndexedNote\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT id, path, note_type, title, created_at, modified_at, frontmatter_json, content_hash\n             FROM notes WHERE note_type = ?1\",\n        )?;\n\n        let notes = stmt\n            .query_map([type_str], Self::row_to_note)?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(notes)\n    }\n\n    /// Count temporal activity records.\n    pub fn count_temporal_activity(\u0026self) -\u003e Result\u003ci64, IndexError\u003e {\n        let count: i64 =\n            self.conn.query_row(\"SELECT COUNT(*) FROM temporal_activity\", [], |row| {\n                row.get(0)\n            })?;\n        Ok(count)\n    }\n\n    /// Insert a temporal activity record.\n    pub fn insert_temporal_activity(\n        \u0026self,\n        note_id: i64,\n        daily_id: i64,\n        activity_date: \u0026str,\n        context: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003ci64, IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO temporal_activity (note_id, daily_id, activity_date, context)\n             VALUES (?1, ?2, ?3, ?4)\",\n            params![note_id, daily_id, activity_date, context],\n        )?;\n        Ok(self.conn.last_insert_rowid())\n    }\n\n    /// Aggregate activity data for computing summaries.\n    ///\n    /// Returns aggregated activity counts for each note that has temporal activity.\n    pub fn aggregate_activity(\n        \u0026self,\n        thirty_days_ago: \u0026str,\n        ninety_days_ago: \u0026str,\n    ) -\u003e Result\u003cVec\u003csuper::types::AggregateActivity\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT\n                note_id,\n                MAX(activity_date) as last_seen,\n                SUM(CASE WHEN activity_date \u003e= ?1 THEN 1 ELSE 0 END) as count_30d,\n                SUM(CASE WHEN activity_date \u003e= ?2 THEN 1 ELSE 0 END) as count_90d\n             FROM temporal_activity\n             GROUP BY note_id\",\n        )?;\n\n        let results = stmt\n            .query_map([thirty_days_ago, ninety_days_ago], |row| {\n                Ok(super::types::AggregateActivity {\n                    note_id: row.get(0)?,\n                    last_seen: row.get(1)?,\n                    access_count_30d: row.get(2)?,\n                    access_count_90d: row.get(3)?,\n                })\n            })?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(results)\n    }\n\n    /// Upsert an activity summary for a note.\n    pub fn upsert_activity_summary(\n        \u0026self,\n        note_id: i64,\n        last_seen: Option\u003c\u0026str\u003e,\n        access_count_30d: i32,\n        access_count_90d: i32,\n        staleness_score: f64,\n    ) -\u003e Result\u003c(), IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO activity_summary (note_id, last_seen, access_count_30d, access_count_90d, staleness_score)\n             VALUES (?1, ?2, ?3, ?4, ?5)\n             ON CONFLICT(note_id) DO UPDATE SET\n                last_seen = excluded.last_seen,\n                access_count_30d = excluded.access_count_30d,\n                access_count_90d = excluded.access_count_90d,\n                staleness_score = excluded.staleness_score\",\n            params![note_id, last_seen, access_count_30d, access_count_90d, staleness_score],\n        )?;\n        Ok(())\n    }\n\n    /// Compute cooccurrence pairs from temporal activity.\n    ///\n    /// Finds pairs of notes that are referenced in the same daily notes.\n    pub fn compute_cooccurrence_pairs(\n        \u0026self,\n    ) -\u003e Result\u003cVec\u003csuper::types::CooccurrencePair\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT\n                a.note_id as note_a,\n                b.note_id as note_b,\n                COUNT(DISTINCT a.daily_id) as shared_count,\n                MAX(a.activity_date) as most_recent\n             FROM temporal_activity a\n             JOIN temporal_activity b ON a.daily_id = b.daily_id\n             WHERE a.note_id \u003c b.note_id\n             GROUP BY a.note_id, b.note_id\n             HAVING shared_count \u003e 0\",\n        )?;\n\n        let pairs = stmt\n            .query_map([], |row| {\n                Ok(super::types::CooccurrencePair {\n                    note_a_id: row.get(0)?,\n                    note_b_id: row.get(1)?,\n                    shared_count: row.get(2)?,\n                    most_recent: row.get(3)?,\n                })\n            })?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(pairs)\n    }\n\n    /// Upsert a note cooccurrence record.\n    pub fn upsert_cooccurrence(\n        \u0026self,\n        note_a: i64,\n        note_b: i64,\n        shared_count: i32,\n        most_recent: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003c(), IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO note_cooccurrence (note_a_id, note_b_id, shared_daily_count, most_recent)\n             VALUES (?1, ?2, ?3, ?4)\n             ON CONFLICT(note_a_id, note_b_id) DO UPDATE SET\n                shared_daily_count = excluded.shared_daily_count,\n                most_recent = excluded.most_recent\",\n            params![note_a, note_b, shared_count, most_recent],\n        )?;\n        Ok(())\n    }\n\n    /// Get activity summary for a note.\n    pub fn get_activity_summary(\n        \u0026self,\n        note_id: i64,\n    ) -\u003e Result\u003cOption\u003csuper::types::ActivitySummary\u003e, IndexError\u003e {\n        self.conn\n            .query_row(\n                \"SELECT note_id, last_seen, access_count_30d, access_count_90d, staleness_score\n                 FROM activity_summary WHERE note_id = ?1\",\n                [note_id],\n                |row| {\n                    let last_seen_str: Option\u003cString\u003e = row.get(1)?;\n                    Ok(super::types::ActivitySummary {\n                        note_id: row.get(0)?,\n                        last_seen: last_seen_str.and_then(|s| {\n                            chrono::NaiveDate::parse_from_str(\u0026s, \"%Y-%m-%d\").ok()\n                        }),\n                        access_count_30d: row.get::\u003c_, i32\u003e(2)? as u32,\n                        access_count_90d: row.get::\u003c_, i32\u003e(3)? as u32,\n                        staleness_score: row.get(4)?,\n                    })\n                },\n            )\n            .optional()\n            .map_err(Into::into)\n    }\n\n    /// Get cooccurrent notes for a given note.\n    ///\n    /// Returns notes that frequently appear together with the given note in dailies.\n    pub fn get_cooccurrent_notes(\n        \u0026self,\n        note_id: i64,\n        limit: u32,\n    ) -\u003e Result\u003cVec\u003c(IndexedNote, i32)\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT n.id, n.path, n.note_type, n.title, n.created_at, n.modified_at,\n                    n.frontmatter_json, n.content_hash, c.shared_daily_count\n             FROM note_cooccurrence c\n             JOIN notes n ON (\n                 CASE WHEN c.note_a_id = ?1 THEN c.note_b_id ELSE c.note_a_id END = n.id\n             )\n             WHERE c.note_a_id = ?1 OR c.note_b_id = ?1\n             ORDER BY c.shared_daily_count DESC\n             LIMIT ?2\",\n        )?;\n\n        let results = stmt\n            .query_map(params![note_id, limit], |row| {\n                let note = Self::row_to_note(row)?;\n                let count: i32 = row.get(8)?;\n                Ok((note, count))\n            })?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(results)\n    }\n\n    /// Get stale notes (high staleness score).\n    ///\n    /// Returns notes ordered by staleness score descending.\n    pub fn get_stale_notes(\n        \u0026self,\n        min_staleness: f64,\n        note_type: Option\u003c\u0026str\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e Result\u003cVec\u003c(IndexedNote, f64)\u003e, IndexError\u003e {\n        let mut sql = String::from(\n            \"SELECT n.id, n.path, n.note_type, n.title, n.created_at, n.modified_at,\n                    n.frontmatter_json, n.content_hash, s.staleness_score\n             FROM notes n\n             LEFT JOIN activity_summary s ON n.id = s.note_id\n             WHERE COALESCE(s.staleness_score, 1.0) \u003e= ?1\",\n        );\n\n        if note_type.is_some() {\n            sql.push_str(\" AND n.note_type = ?2\");\n        }\n\n        sql.push_str(\" ORDER BY COALESCE(s.staleness_score, 1.0) DESC\");\n\n        if let Some(limit) = limit {\n            sql.push_str(\u0026format!(\" LIMIT {}\", limit));\n        }\n\n        let mut stmt = self.conn.prepare(\u0026sql)?;\n\n        let results = if let Some(nt) = note_type {\n            stmt.query_map(params![min_staleness, nt], |row| {\n                let note = Self::row_to_note(row)?;\n                let staleness: Option\u003cf64\u003e = row.get(8)?;\n                Ok((note, staleness.unwrap_or(1.0)))\n            })?\n            .filter_map(|r| r.ok())\n            .collect()\n        } else {\n            stmt.query_map([min_staleness], |row| {\n                let note = Self::row_to_note(row)?;\n                let staleness: Option\u003cf64\u003e = row.get(8)?;\n                Ok((note, staleness.unwrap_or(1.0)))\n            })?\n            .filter_map(|r| r.ok())\n            .collect()\n        };\n\n        Ok(results)\n    }\n\n    /// Get notes not seen in a number of days.\n    pub fn get_notes_not_seen_in_days(\n        \u0026self,\n        days: u32,\n        note_type: Option\u003c\u0026str\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e Result\u003cVec\u003c(IndexedNote, Option\u003cString\u003e)\u003e, IndexError\u003e {\n        let cutoff_date = (chrono::Utc::now() - chrono::Duration::days(days as i64))\n            .format(\"%Y-%m-%d\")\n            .to_string();\n\n        let mut sql = String::from(\n            \"SELECT n.id, n.path, n.note_type, n.title, n.created_at, n.modified_at,\n                    n.frontmatter_json, n.content_hash, s.last_seen\n             FROM notes n\n             LEFT JOIN activity_summary s ON n.id = s.note_id\n             WHERE s.last_seen IS NULL OR s.last_seen \u003c ?1\",\n        );\n\n        if note_type.is_some() {\n            sql.push_str(\" AND n.note_type = ?2\");\n        }\n\n        sql.push_str(\" ORDER BY s.last_seen ASC NULLS FIRST\");\n\n        if let Some(limit) = limit {\n            sql.push_str(\u0026format!(\" LIMIT {}\", limit));\n        }\n\n        let mut stmt = self.conn.prepare(\u0026sql)?;\n\n        let results = if let Some(nt) = note_type {\n            stmt.query_map(params![\u0026cutoff_date, nt], |row| {\n                let note = Self::row_to_note(row)?;\n                let last_seen: Option\u003cString\u003e = row.get(8)?;\n                Ok((note, last_seen))\n            })?\n            .filter_map(|r| r.ok())\n            .collect()\n        } else {\n            stmt.query_map([\u0026cutoff_date], |row| {\n                let note = Self::row_to_note(row)?;\n                let last_seen: Option\u003cString\u003e = row.get(8)?;\n                Ok((note, last_seen))\n            })?\n            .filter_map(|r| r.ok())\n            .collect()\n        };\n\n        Ok(results)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::Utc;\n    use std::path::PathBuf;\n\n    fn sample_note(path: \u0026str) -\u003e IndexedNote {\n        IndexedNote {\n            id: None,\n            path: PathBuf::from(path),\n            note_type: NoteType::Zettel,\n            title: \"Test Note\".to_string(),\n            created: Some(Utc::now()),\n            modified: Utc::now(),\n            frontmatter_json: Some(r#\"{\"tags\": [\"test\"]}\"#.to_string()),\n            content_hash: \"abc123\".to_string(),\n        }\n    }\n\n    #[test]\n    fn test_insert_and_get_note() {\n        let db = IndexDb::open_in_memory().unwrap();\n        let note = sample_note(\"test/note.md\");\n\n        let id = db.insert_note(\u0026note).unwrap();\n        assert!(id \u003e 0);\n\n        let retrieved = db.get_note_by_path(Path::new(\"test/note.md\")).unwrap();\n        assert!(retrieved.is_some());\n        let retrieved = retrieved.unwrap();\n        assert_eq!(retrieved.title, \"Test Note\");\n        assert_eq!(retrieved.note_type, NoteType::Zettel);\n    }\n\n    #[test]\n    fn test_upsert_note() {\n        let db = IndexDb::open_in_memory().unwrap();\n        let mut note = sample_note(\"test/note.md\");\n\n        let id1 = db.upsert_note(\u0026note).unwrap();\n        note.title = \"Updated Title\".to_string();\n        let id2 = db.upsert_note(\u0026note).unwrap();\n\n        assert_eq!(id1, id2); // Same ID after upsert\n\n        let retrieved = db.get_note_by_id(id1).unwrap().unwrap();\n        assert_eq!(retrieved.title, \"Updated Title\");\n    }\n\n    #[test]\n    fn test_query_by_type() {\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let mut zettel = sample_note(\"knowledge/note1.md\");\n        zettel.note_type = NoteType::Zettel;\n        db.insert_note(\u0026zettel).unwrap();\n\n        let mut task = sample_note(\"tasks/task1.md\");\n        task.note_type = NoteType::Task;\n        db.insert_note(\u0026task).unwrap();\n\n        let query = NoteQuery { note_type: Some(NoteType::Zettel), ..Default::default() };\n        let results = db.query_notes(\u0026query).unwrap();\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].note_type, NoteType::Zettel);\n    }\n\n    #[test]\n    fn test_links() {\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let note1 = sample_note(\"note1.md\");\n        let note2 = sample_note(\"note2.md\");\n        let id1 = db.insert_note(\u0026note1).unwrap();\n        let id2 = db.insert_note(\u0026note2).unwrap();\n\n        let link = IndexedLink {\n            id: None,\n            source_id: id1,\n            target_id: Some(id2),\n            target_path: \"note2.md\".to_string(),\n            link_text: Some(\"Note 2\".to_string()),\n            link_type: LinkType::Wikilink,\n            context: None,\n            line_number: Some(10),\n        };\n        db.insert_link(\u0026link).unwrap();\n\n        let outgoing = db.get_outgoing_links(id1).unwrap();\n        assert_eq!(outgoing.len(), 1);\n\n        let backlinks = db.get_backlinks(id2).unwrap();\n        assert_eq!(backlinks.len(), 1);\n    }\n\n    #[test]\n    fn test_orphans() {\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let note1 = sample_note(\"note1.md\");\n        let note2 = sample_note(\"note2.md\");\n        let id1 = db.insert_note(\u0026note1).unwrap();\n        let id2 = db.insert_note(\u0026note2).unwrap();\n\n        // Link note1 -\u003e note2, so note1 is orphan (no incoming)\n        let link = IndexedLink {\n            id: None,\n            source_id: id1,\n            target_id: Some(id2),\n            target_path: \"note2.md\".to_string(),\n            link_text: None,\n            link_type: LinkType::Wikilink,\n            context: None,\n            line_number: None,\n        };\n        db.insert_link(\u0026link).unwrap();\n\n        let orphans = db.find_orphans().unwrap();\n        assert_eq!(orphans.len(), 1);\n        assert_eq!(orphans[0].path, PathBuf::from(\"note1.md\"));\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":25}},{"line":46,"address":[],"length":0,"stats":{"Line":50}},{"line":47,"address":[],"length":0,"stats":{"Line":75}},{"line":48,"address":[],"length":0,"stats":{"Line":50}},{"line":49,"address":[],"length":0,"stats":{"Line":25}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":17}},{"line":63,"address":[],"length":0,"stats":{"Line":34}},{"line":66,"address":[],"length":0,"stats":{"Line":17}},{"line":67,"address":[],"length":0,"stats":{"Line":17}},{"line":68,"address":[],"length":0,"stats":{"Line":34}},{"line":70,"address":[],"length":0,"stats":{"Line":68}},{"line":71,"address":[],"length":0,"stats":{"Line":34}},{"line":76,"address":[],"length":0,"stats":{"Line":17}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":45}},{"line":111,"address":[],"length":0,"stats":{"Line":90}},{"line":121,"address":[],"length":0,"stats":{"Line":45}},{"line":122,"address":[],"length":0,"stats":{"Line":45}},{"line":123,"address":[],"length":0,"stats":{"Line":90}},{"line":125,"address":[],"length":0,"stats":{"Line":94}},{"line":126,"address":[],"length":0,"stats":{"Line":90}},{"line":133,"address":[],"length":0,"stats":{"Line":180}},{"line":135,"address":[],"length":0,"stats":{"Line":45}},{"line":136,"address":[],"length":0,"stats":{"Line":90}},{"line":139,"address":[],"length":0,"stats":{"Line":45}},{"line":143,"address":[],"length":0,"stats":{"Line":14}},{"line":147,"address":[],"length":0,"stats":{"Line":14}},{"line":151,"address":[],"length":0,"stats":{"Line":14}},{"line":155,"address":[],"length":0,"stats":{"Line":14}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":6}},{"line":177,"address":[],"length":0,"stats":{"Line":18}},{"line":179,"address":[],"length":0,"stats":{"Line":10}},{"line":180,"address":[],"length":0,"stats":{"Line":8}},{"line":181,"address":[],"length":0,"stats":{"Line":8}},{"line":184,"address":[],"length":0,"stats":{"Line":6}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":6}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":6}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":18}},{"line":201,"address":[],"length":0,"stats":{"Line":6}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":6}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":12}},{"line":210,"address":[],"length":0,"stats":{"Line":22}},{"line":212,"address":[],"length":0,"stats":{"Line":24}},{"line":213,"address":[],"length":0,"stats":{"Line":12}},{"line":214,"address":[],"length":0,"stats":{"Line":18}},{"line":215,"address":[],"length":0,"stats":{"Line":24}},{"line":218,"address":[],"length":0,"stats":{"Line":6}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":3}},{"line":226,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":40}},{"line":231,"address":[],"length":0,"stats":{"Line":40}},{"line":234,"address":[],"length":0,"stats":{"Line":40}},{"line":235,"address":[],"length":0,"stats":{"Line":34}},{"line":238,"address":[],"length":0,"stats":{"Line":40}},{"line":242,"address":[],"length":0,"stats":{"Line":13}},{"line":243,"address":[],"length":0,"stats":{"Line":52}},{"line":244,"address":[],"length":0,"stats":{"Line":26}},{"line":245,"address":[],"length":0,"stats":{"Line":44}},{"line":246,"address":[],"length":0,"stats":{"Line":72}},{"line":247,"address":[],"length":0,"stats":{"Line":18}},{"line":249,"address":[],"length":0,"stats":{"Line":49}},{"line":251,"address":[],"length":0,"stats":{"Line":13}},{"line":254,"address":[],"length":0,"stats":{"Line":24}},{"line":255,"address":[],"length":0,"stats":{"Line":96}},{"line":256,"address":[],"length":0,"stats":{"Line":96}},{"line":257,"address":[],"length":0,"stats":{"Line":96}},{"line":258,"address":[],"length":0,"stats":{"Line":96}},{"line":261,"address":[],"length":0,"stats":{"Line":48}},{"line":262,"address":[],"length":0,"stats":{"Line":48}},{"line":263,"address":[],"length":0,"stats":{"Line":48}},{"line":264,"address":[],"length":0,"stats":{"Line":48}},{"line":265,"address":[],"length":0,"stats":{"Line":65}},{"line":266,"address":[],"length":0,"stats":{"Line":34}},{"line":267,"address":[],"length":0,"stats":{"Line":17}},{"line":268,"address":[],"length":0,"stats":{"Line":68}},{"line":270,"address":[],"length":0,"stats":{"Line":48}},{"line":271,"address":[],"length":0,"stats":{"Line":96}},{"line":272,"address":[],"length":0,"stats":{"Line":24}},{"line":273,"address":[],"length":0,"stats":{"Line":48}},{"line":274,"address":[],"length":0,"stats":{"Line":48}},{"line":283,"address":[],"length":0,"stats":{"Line":69}},{"line":284,"address":[],"length":0,"stats":{"Line":138}},{"line":287,"address":[],"length":0,"stats":{"Line":69}},{"line":292,"address":[],"length":0,"stats":{"Line":138}},{"line":297,"address":[],"length":0,"stats":{"Line":69}},{"line":301,"address":[],"length":0,"stats":{"Line":43}},{"line":302,"address":[],"length":0,"stats":{"Line":43}},{"line":303,"address":[],"length":0,"stats":{"Line":172}},{"line":304,"address":[],"length":0,"stats":{"Line":43}},{"line":308,"address":[],"length":0,"stats":{"Line":4}},{"line":312,"address":[],"length":0,"stats":{"Line":12}},{"line":317,"address":[],"length":0,"stats":{"Line":8}},{"line":318,"address":[],"length":0,"stats":{"Line":8}},{"line":319,"address":[],"length":0,"stats":{"Line":16}},{"line":322,"address":[],"length":0,"stats":{"Line":4}},{"line":326,"address":[],"length":0,"stats":{"Line":6}},{"line":327,"address":[],"length":0,"stats":{"Line":18}},{"line":332,"address":[],"length":0,"stats":{"Line":12}},{"line":333,"address":[],"length":0,"stats":{"Line":12}},{"line":334,"address":[],"length":0,"stats":{"Line":14}},{"line":337,"address":[],"length":0,"stats":{"Line":6}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":342,"address":[],"length":0,"stats":{"Line":3}},{"line":349,"address":[],"length":0,"stats":{"Line":1}},{"line":350,"address":[],"length":0,"stats":{"Line":7}},{"line":352,"address":[],"length":0,"stats":{"Line":1}},{"line":357,"address":[],"length":0,"stats":{"Line":21}},{"line":358,"address":[],"length":0,"stats":{"Line":42}},{"line":370,"address":[],"length":0,"stats":{"Line":84}},{"line":373,"address":[],"length":0,"stats":{"Line":42}},{"line":375,"address":[],"length":0,"stats":{"Line":21}},{"line":379,"address":[],"length":0,"stats":{"Line":19}},{"line":380,"address":[],"length":0,"stats":{"Line":76}},{"line":383,"address":[],"length":0,"stats":{"Line":38}},{"line":385,"address":[],"length":0,"stats":{"Line":19}},{"line":388,"address":[],"length":0,"stats":{"Line":10}},{"line":389,"address":[],"length":0,"stats":{"Line":40}},{"line":391,"address":[],"length":0,"stats":{"Line":20}},{"line":392,"address":[],"length":0,"stats":{"Line":20}},{"line":393,"address":[],"length":0,"stats":{"Line":20}},{"line":394,"address":[],"length":0,"stats":{"Line":20}},{"line":395,"address":[],"length":0,"stats":{"Line":20}},{"line":396,"address":[],"length":0,"stats":{"Line":40}},{"line":397,"address":[],"length":0,"stats":{"Line":20}},{"line":398,"address":[],"length":0,"stats":{"Line":20}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":4}},{"line":427,"address":[],"length":0,"stats":{"Line":12}},{"line":428,"address":[],"length":0,"stats":{"Line":2}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":6}},{"line":440,"address":[],"length":0,"stats":{"Line":12}},{"line":447,"address":[],"length":0,"stats":{"Line":6}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":3}},{"line":620,"address":[],"length":0,"stats":{"Line":3}},{"line":624,"address":[],"length":0,"stats":{"Line":3}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":3}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}}],"covered":144,"coverable":285},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","derived.rs"],"content":"//! Derived index computation.\n//!\n//! This module builds secondary indices from the primary note and link data:\n//! - `temporal_activity`: When notes are referenced in daily notes\n//! - `activity_summary`: Aggregated activity metrics per note\n//! - `note_cooccurrence`: Notes that appear together in daily notes\n\nuse chrono::{Duration, NaiveDate, Utc};\nuse thiserror::Error;\n\nuse super::IndexError;\nuse super::db::IndexDb;\n\n/// Errors that can occur during derived index computation.\n#[derive(Debug, Error)]\npub enum DerivedError {\n    #[error(\"Index database error: {0}\")]\n    Index(#[from] IndexError),\n\n    #[error(\"Failed to parse date: {0}\")]\n    DateParse(String),\n}\n\n/// Statistics from derived index computation.\n#[derive(Debug, Clone, Default)]\npub struct DerivedStats {\n    /// Number of daily notes processed.\n    pub dailies_processed: usize,\n    /// Number of temporal activity records created.\n    pub activity_records: usize,\n    /// Number of activity summaries computed.\n    pub summaries_computed: usize,\n    /// Number of cooccurrence pairs found.\n    pub cooccurrence_pairs: usize,\n    /// Duration in milliseconds.\n    pub duration_ms: u64,\n}\n\n/// Builder for computing derived indices.\npub struct DerivedIndexBuilder\u003c'a\u003e {\n    db: \u0026'a IndexDb,\n}\n\nimpl\u003c'a\u003e DerivedIndexBuilder\u003c'a\u003e {\n    /// Create a new derived index builder.\n    pub fn new(db: \u0026'a IndexDb) -\u003e Self {\n        Self { db }\n    }\n\n    /// Compute all derived indices.\n    ///\n    /// This should be called after the primary index is built/updated.\n    pub fn compute_all(\u0026self) -\u003e Result\u003cDerivedStats, DerivedError\u003e {\n        let start = std::time::Instant::now();\n        let mut stats = DerivedStats::default();\n\n        // Clear existing derived data\n        self.db.clear_derived_tables()?;\n\n        // Step 1: Build temporal activity from daily notes\n        stats.dailies_processed = self.build_temporal_activity()?;\n\n        // Step 2: Count activity records\n        stats.activity_records = self.db.count_temporal_activity()? as usize;\n\n        // Step 3: Compute activity summaries\n        stats.summaries_computed = self.compute_activity_summaries()?;\n\n        // Step 4: Compute cooccurrence matrix\n        stats.cooccurrence_pairs = self.compute_cooccurrence()?;\n\n        stats.duration_ms = start.elapsed().as_millis() as u64;\n        Ok(stats)\n    }\n\n    /// Build temporal activity records from daily notes.\n    ///\n    /// For each daily note, finds all outgoing links and creates\n    /// temporal_activity records linking the referenced note to the daily.\n    fn build_temporal_activity(\u0026self) -\u003e Result\u003cusize, DerivedError\u003e {\n        // Get all daily notes\n        let dailies = self.db.get_notes_by_type(\"daily\")?;\n        let mut count = 0;\n\n        for daily in \u0026dailies {\n            let daily_id = match daily.id {\n                Some(id) =\u003e id,\n                None =\u003e continue,\n            };\n\n            // Extract date from the daily note\n            // Daily notes typically have date in frontmatter or path\n            let activity_date = self.extract_daily_date(daily)?;\n\n            // Get all outgoing links from this daily\n            let links = self.db.get_outgoing_links(daily_id)?;\n\n            for link in \u0026links {\n                // Skip self-references and unresolved links\n                if link.target_id.is_none() {\n                    continue;\n                }\n\n                let target_id = link.target_id.unwrap();\n                if target_id == daily_id {\n                    continue; // Skip self-links\n                }\n\n                // Create temporal activity record\n                self.db.insert_temporal_activity(\n                    target_id,\n                    daily_id,\n                    \u0026activity_date,\n                    link.context.as_deref(),\n                )?;\n            }\n\n            count += 1;\n        }\n\n        Ok(count)\n    }\n\n    /// Extract the date from a daily note.\n    fn extract_daily_date(\n        \u0026self,\n        daily: \u0026super::types::IndexedNote,\n    ) -\u003e Result\u003cString, DerivedError\u003e {\n        // Try to get date from frontmatter first\n        if let Some(ref fm_json) = daily.frontmatter_json\n            \u0026\u0026 let Ok(fm) = serde_json::from_str::\u003cserde_json::Value\u003e(fm_json)\n            \u0026\u0026 let Some(date) = fm.get(\"date\").and_then(|v| v.as_str())\n        {\n            return Ok(date.to_string());\n        }\n\n        // Fall back to extracting date from path (e.g., \"daily/2025-01-15.md\")\n        let path_str = daily.path.to_string_lossy();\n        if let Some(date_str) = extract_date_from_path(\u0026path_str) {\n            return Ok(date_str);\n        }\n\n        // Fall back to modified date\n        Ok(daily.modified.format(\"%Y-%m-%d\").to_string())\n    }\n\n    /// Compute activity summaries for all notes.\n    fn compute_activity_summaries(\u0026self) -\u003e Result\u003cusize, DerivedError\u003e {\n        let today = Utc::now().date_naive();\n        let thirty_days_ago = today - Duration::days(30);\n        let ninety_days_ago = today - Duration::days(90);\n\n        // Get aggregated activity data\n        let summaries = self.db.aggregate_activity(\n            \u0026thirty_days_ago.to_string(),\n            \u0026ninety_days_ago.to_string(),\n        )?;\n\n        let mut count = 0;\n        for summary in summaries {\n            // Compute staleness score\n            let staleness = self.compute_staleness_score(\n                summary.last_seen.as_deref(),\n                summary.access_count_30d,\n                summary.access_count_90d,\n            );\n\n            self.db.upsert_activity_summary(\n                summary.note_id,\n                summary.last_seen.as_deref(),\n                summary.access_count_30d,\n                summary.access_count_90d,\n                staleness,\n            )?;\n            count += 1;\n        }\n\n        Ok(count)\n    }\n\n    /// Compute staleness score based on activity patterns.\n    ///\n    /// Score ranges from 0.0 (very active) to 1.0 (very stale).\n    fn compute_staleness_score(\n        \u0026self,\n        last_seen: Option\u003c\u0026str\u003e,\n        count_30d: i32,\n        count_90d: i32,\n    ) -\u003e f64 {\n        let today = Utc::now().date_naive();\n\n        // Days since last seen (default to 365 if never seen)\n        let days_since = last_seen\n            .and_then(|s| NaiveDate::parse_from_str(s, \"%Y-%m-%d\").ok())\n            .map(|d| (today - d).num_days() as f64)\n            .unwrap_or(365.0);\n\n        // Base staleness from recency (0.0 = today, 1.0 = 90+ days)\n        let recency_score = (days_since / 90.0).min(1.0);\n\n        // Activity factor (more activity = less stale)\n        let activity_factor = if count_30d \u003e 0 {\n            0.0 // Active in last 30 days - not stale\n        } else if count_90d \u003e 0 {\n            0.3 // Active in last 90 days - slightly stale\n        } else {\n            0.6 // No recent activity - more stale\n        };\n\n        // Combined score\n        (recency_score * 0.6 + activity_factor * 0.4).min(1.0)\n    }\n\n    /// Compute note cooccurrence matrix.\n    ///\n    /// Finds pairs of notes that are referenced together in daily notes.\n    fn compute_cooccurrence(\u0026self) -\u003e Result\u003cusize, DerivedError\u003e {\n        // Get cooccurrence data from temporal activity\n        let pairs = self.db.compute_cooccurrence_pairs()?;\n        let mut count = 0;\n\n        for pair in pairs {\n            self.db.upsert_cooccurrence(\n                pair.note_a_id,\n                pair.note_b_id,\n                pair.shared_count,\n                pair.most_recent.as_deref(),\n            )?;\n            count += 1;\n        }\n\n        Ok(count)\n    }\n}\n\n/// Extract a date string (YYYY-MM-DD) from a file path.\nfn extract_date_from_path(path: \u0026str) -\u003e Option\u003cString\u003e {\n    // Look for date patterns in the path\n    let re = regex::Regex::new(r\"(\\d{4}-\\d{2}-\\d{2})\").ok()?;\n    re.captures(path).map(|c| c[1].to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_extract_date_from_path() {\n        assert_eq!(\n            extract_date_from_path(\"daily/2025-01-15.md\"),\n            Some(\"2025-01-15\".to_string())\n        );\n        assert_eq!(\n            extract_date_from_path(\"2025-01-15-meeting.md\"),\n            Some(\"2025-01-15\".to_string())\n        );\n        assert_eq!(extract_date_from_path(\"notes/random.md\"), None);\n    }\n\n    #[test]\n    fn test_staleness_score() {\n        let builder = DerivedIndexBuilder { db: \u0026IndexDb::open_in_memory().unwrap() };\n\n        // Very active (accessed today, high count)\n        let score = builder.compute_staleness_score(\n            Some(\u0026Utc::now().format(\"%Y-%m-%d\").to_string()),\n            5,\n            10,\n        );\n        assert!(score \u003c 0.1, \"Active notes should have low staleness\");\n\n        // Never seen: days_since=365, recency_score=1.0, activity_factor=0.6\n        // Combined: 1.0*0.6 + 0.6*0.4 = 0.84\n        let score = builder.compute_staleness_score(None, 0, 0);\n        assert!(score \u003e 0.8, \"Never-seen notes should be stale (score: {})\", score);\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[],"length":0,"stats":{"Line":6}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":194,"address":[],"length":0,"stats":{"Line":6}},{"line":195,"address":[],"length":0,"stats":{"Line":4}},{"line":199,"address":[],"length":0,"stats":{"Line":6}},{"line":202,"address":[],"length":0,"stats":{"Line":4}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":12}},{"line":240,"address":[],"length":0,"stats":{"Line":16}}],"covered":14,"coverable":89},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","mod.rs"],"content":"//! Vault index for fast queries on notes and links.\n//!\n//! This module provides SQLite-based indexing for:\n//! - Note metadata (path, type, title, frontmatter)\n//! - Links between notes (wikilinks, markdown links, frontmatter refs)\n//! - Temporal activity (when notes are referenced in dailies)\n//!\n//! # Example\n//!\n//! ```no_run\n//! use mdvault_core::index::{IndexDb, IndexedNote, NoteType, NoteQuery};\n//! use std::path::Path;\n//!\n//! let db = IndexDb::open(Path::new(\".mdvault/index.db\")).unwrap();\n//!\n//! // Query all tasks\n//! let query = NoteQuery {\n//!     note_type: Some(NoteType::Task),\n//!     ..Default::default()\n//! };\n//! let tasks = db.query_notes(\u0026query).unwrap();\n//! ```\n\npub mod builder;\npub mod db;\npub mod derived;\npub mod schema;\npub mod search;\npub mod types;\n\npub use builder::{BuilderError, FileChange, IndexBuilder, IndexStats, ProgressCallback};\npub use db::{IndexDb, IndexError};\npub use derived::{DerivedError, DerivedIndexBuilder, DerivedStats};\npub use schema::{SCHEMA_VERSION, SchemaError};\npub use search::{MatchSource, SearchEngine, SearchMode, SearchQuery, SearchResult};\npub use types::{\n    ActivitySummary, AggregateActivity, CooccurrencePair, IndexedLink, IndexedNote,\n    LinkType, NoteQuery, NoteType, ProjectStatus, TaskStatus, TemporalActivity,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","schema.rs"],"content":"//! SQLite schema definition and migrations.\n\nuse rusqlite::Connection;\nuse thiserror::Error;\n\n/// Current schema version.\npub const SCHEMA_VERSION: i32 = 1;\n\n#[derive(Debug, Error)]\npub enum SchemaError {\n    #[error(\"Database error: {0}\")]\n    Database(#[from] rusqlite::Error),\n\n    #[error(\"Schema version {found} is newer than supported {supported}\")]\n    VersionTooNew { found: i32, supported: i32 },\n\n    #[error(\"Migration failed: {0}\")]\n    MigrationFailed(String),\n}\n\n/// Initialize or migrate the database schema.\npub fn init_schema(conn: \u0026Connection) -\u003e Result\u003c(), SchemaError\u003e {\n    let version = get_schema_version(conn)?;\n\n    if version == 0 {\n        // Fresh database - create all tables\n        create_schema_v1(conn)?;\n        set_schema_version(conn, SCHEMA_VERSION)?;\n    } else if version \u003c SCHEMA_VERSION {\n        // Run migrations\n        migrate(conn, version)?;\n    } else if version \u003e SCHEMA_VERSION {\n        return Err(SchemaError::VersionTooNew {\n            found: version,\n            supported: SCHEMA_VERSION,\n        });\n    }\n\n    Ok(())\n}\n\nfn get_schema_version(conn: \u0026Connection) -\u003e Result\u003ci32, SchemaError\u003e {\n    // Check if schema_version table exists\n    let exists: bool = conn.query_row(\n        \"SELECT COUNT(*) \u003e 0 FROM sqlite_master WHERE type='table' AND name='schema_version'\",\n        [],\n        |row| row.get(0),\n    )?;\n\n    if !exists {\n        return Ok(0);\n    }\n\n    let version: i32 =\n        conn.query_row(\"SELECT version FROM schema_version\", [], |row| row.get(0))?;\n\n    Ok(version)\n}\n\nfn set_schema_version(conn: \u0026Connection, version: i32) -\u003e Result\u003c(), SchemaError\u003e {\n    conn.execute(\n        \"INSERT OR REPLACE INTO schema_version (id, version) VALUES (1, ?1)\",\n        [version],\n    )?;\n    Ok(())\n}\n\nfn create_schema_v1(conn: \u0026Connection) -\u003e Result\u003c(), SchemaError\u003e {\n    conn.execute_batch(\n        r#\"\n        -- Schema version tracking\n        CREATE TABLE schema_version (\n            id INTEGER PRIMARY KEY CHECK (id = 1),\n            version INTEGER NOT NULL\n        );\n\n        -- Notes table: core metadata for each markdown file\n        CREATE TABLE notes (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            path TEXT NOT NULL UNIQUE,\n            note_type TEXT NOT NULL DEFAULT 'none',\n            title TEXT NOT NULL,\n            created_at TEXT,\n            modified_at TEXT NOT NULL,\n            frontmatter_json TEXT,\n            content_hash TEXT NOT NULL\n        );\n\n        -- Index for common queries\n        CREATE INDEX idx_notes_type ON notes(note_type);\n        CREATE INDEX idx_notes_modified ON notes(modified_at);\n        CREATE INDEX idx_notes_path ON notes(path);\n\n        -- Links table: relationships between notes\n        CREATE TABLE links (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            source_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,\n            target_id INTEGER REFERENCES notes(id) ON DELETE SET NULL,\n            target_path TEXT NOT NULL,\n            link_text TEXT,\n            link_type TEXT NOT NULL,\n            context TEXT,\n            line_number INTEGER\n        );\n\n        -- Indexes for link queries\n        CREATE INDEX idx_links_source ON links(source_id);\n        CREATE INDEX idx_links_target ON links(target_id);\n        CREATE INDEX idx_links_target_path ON links(target_path);\n\n        -- Temporal activity: when notes are referenced in dailies\n        CREATE TABLE temporal_activity (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            note_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,\n            daily_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,\n            activity_date TEXT NOT NULL,\n            context TEXT\n        );\n\n        CREATE INDEX idx_temporal_note ON temporal_activity(note_id);\n        CREATE INDEX idx_temporal_daily ON temporal_activity(daily_id);\n        CREATE INDEX idx_temporal_date ON temporal_activity(activity_date);\n\n        -- Activity summary: cached aggregations (can be rebuilt)\n        CREATE TABLE activity_summary (\n            note_id INTEGER PRIMARY KEY REFERENCES notes(id) ON DELETE CASCADE,\n            last_seen TEXT,\n            access_count_30d INTEGER NOT NULL DEFAULT 0,\n            access_count_90d INTEGER NOT NULL DEFAULT 0,\n            staleness_score REAL NOT NULL DEFAULT 0.0\n        );\n\n        -- Note cooccurrence: notes appearing together in dailies\n        CREATE TABLE note_cooccurrence (\n            note_a_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,\n            note_b_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,\n            shared_daily_count INTEGER NOT NULL DEFAULT 0,\n            most_recent TEXT,\n            PRIMARY KEY (note_a_id, note_b_id)\n        );\n\n        CREATE INDEX idx_cooccurrence_a ON note_cooccurrence(note_a_id);\n        CREATE INDEX idx_cooccurrence_b ON note_cooccurrence(note_b_id);\n\n        -- Full-text search virtual table (optional, for content search)\n        CREATE VIRTUAL TABLE IF NOT EXISTS notes_fts USING fts5(\n            title,\n            content,\n            content_rowid='id'\n        );\n        \"#,\n    )?;\n\n    Ok(())\n}\n\nfn migrate(_conn: \u0026Connection, from_version: i32) -\u003e Result\u003c(), SchemaError\u003e {\n    // Add migration steps here as schema evolves\n    // Example:\n    // match from_version {\n    //     1 =\u003e migrate_v1_to_v2(conn)?,\n    //     2 =\u003e migrate_v2_to_v3(conn)?,\n    //     _ =\u003e {}\n    // }\n\n    // For now, no migrations exist - we only have v1\n    Err(SchemaError::MigrationFailed(format!(\n        \"No migration path from version {} to {}\",\n        from_version, SCHEMA_VERSION\n    )))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rusqlite::Connection;\n\n    #[test]\n    fn test_init_fresh_database() {\n        let conn = Connection::open_in_memory().unwrap();\n        init_schema(\u0026conn).unwrap();\n\n        // Verify schema version\n        let version: i32 = conn\n            .query_row(\"SELECT version FROM schema_version\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(version, SCHEMA_VERSION);\n\n        // Verify tables exist\n        let tables: Vec\u003cString\u003e = conn\n            .prepare(\"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name\")\n            .unwrap()\n            .query_map([], |row| row.get(0))\n            .unwrap()\n            .filter_map(|r| r.ok())\n            .collect();\n\n        assert!(tables.contains(\u0026\"notes\".to_string()));\n        assert!(tables.contains(\u0026\"links\".to_string()));\n        assert!(tables.contains(\u0026\"temporal_activity\".to_string()));\n    }\n\n    #[test]\n    fn test_init_idempotent() {\n        let conn = Connection::open_in_memory().unwrap();\n        init_schema(\u0026conn).unwrap();\n        init_schema(\u0026conn).unwrap(); // Should not fail on second call\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":28}},{"line":23,"address":[],"length":0,"stats":{"Line":84}},{"line":25,"address":[],"length":0,"stats":{"Line":28}},{"line":27,"address":[],"length":0,"stats":{"Line":54}},{"line":28,"address":[],"length":0,"stats":{"Line":54}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":28}},{"line":42,"address":[],"length":0,"stats":{"Line":28}},{"line":44,"address":[],"length":0,"stats":{"Line":112}},{"line":47,"address":[],"length":0,"stats":{"Line":56}},{"line":50,"address":[],"length":0,"stats":{"Line":28}},{"line":51,"address":[],"length":0,"stats":{"Line":27}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":27}},{"line":61,"address":[],"length":0,"stats":{"Line":54}},{"line":63,"address":[],"length":0,"stats":{"Line":27}},{"line":65,"address":[],"length":0,"stats":{"Line":27}},{"line":68,"address":[],"length":0,"stats":{"Line":27}},{"line":69,"address":[],"length":0,"stats":{"Line":54}},{"line":154,"address":[],"length":0,"stats":{"Line":27}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}}],"covered":23,"coverable":31},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","search.rs"],"content":"//! Contextual search beyond keyword matching.\n//!\n//! This module provides multi-modal search capabilities:\n//! - Direct match: Notes matching a query string\n//! - Graph neighbourhood: Linked notes within N hops\n//! - Temporal context: Recent dailies referencing matches\n//! - Cooccurrence: Notes that appeared together in dailies\n\nuse std::collections::{HashMap, HashSet};\n\nuse super::IndexError;\nuse super::db::IndexDb;\nuse super::types::{IndexedNote, NoteType};\n\n/// Search mode determining how results are expanded.\n#[derive(Debug, Clone, Copy, Default)]\npub enum SearchMode {\n    /// Only return notes directly matching the query.\n    #[default]\n    Direct,\n    /// Include linked notes within N hops.\n    Neighbourhood { hops: u32 },\n    /// Include recent dailies referencing matching notes.\n    Temporal { days: u32 },\n    /// Include notes that cooccur with matches in dailies.\n    Cooccurrence { min_shared: u32 },\n    /// Combined: neighbourhood + temporal + cooccurrence.\n    Full,\n}\n\n/// Search query parameters.\n#[derive(Debug, Clone, Default)]\npub struct SearchQuery {\n    /// Text to search for (in title, path, or content).\n    pub text: Option\u003cString\u003e,\n    /// Filter by note type.\n    pub note_type: Option\u003cNoteType\u003e,\n    /// Path prefix filter.\n    pub path_prefix: Option\u003cString\u003e,\n    /// Search mode for result expansion.\n    pub mode: SearchMode,\n    /// Maximum results to return.\n    pub limit: Option\u003cu32\u003e,\n    /// Favour recently active notes.\n    pub temporal_boost: bool,\n}\n\n/// A search result with relevance information.\n#[derive(Debug, Clone)]\npub struct SearchResult {\n    /// The matching note.\n    pub note: IndexedNote,\n    /// Relevance score (higher = more relevant).\n    pub score: f64,\n    /// How this result was found.\n    pub match_source: MatchSource,\n    /// Staleness score if available (lower = more active).\n    pub staleness: Option\u003cf64\u003e,\n}\n\n/// How a search result was matched.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum MatchSource {\n    /// Direct text match.\n    Direct,\n    /// Linked from a direct match.\n    Linked { hops: u32 },\n    /// Referenced in a daily with a direct match.\n    Temporal { daily_path: String },\n    /// Cooccurs with a direct match.\n    Cooccurrence { shared_dailies: u32 },\n}\n\n/// Search engine using the vault index.\npub struct SearchEngine\u003c'a\u003e {\n    db: \u0026'a IndexDb,\n}\n\nimpl\u003c'a\u003e SearchEngine\u003c'a\u003e {\n    /// Create a new search engine.\n    pub fn new(db: \u0026'a IndexDb) -\u003e Self {\n        Self { db }\n    }\n\n    /// Execute a search query.\n    pub fn search(\u0026self, query: \u0026SearchQuery) -\u003e Result\u003cVec\u003cSearchResult\u003e, IndexError\u003e {\n        // Step 1: Find direct matches\n        let direct_matches = self.find_direct_matches(query)?;\n        let direct_ids: HashSet\u003ci64\u003e =\n            direct_matches.iter().filter_map(|n| n.id).collect();\n\n        let mut results: Vec\u003cSearchResult\u003e = direct_matches\n            .into_iter()\n            .map(|note| SearchResult {\n                staleness: self.get_staleness(note.id),\n                note,\n                score: 1.0,\n                match_source: MatchSource::Direct,\n            })\n            .collect();\n\n        // Step 2: Expand based on mode\n        match query.mode {\n            SearchMode::Direct =\u003e {}\n            SearchMode::Neighbourhood { hops } =\u003e {\n                let expanded = self.expand_neighbourhood(\u0026direct_ids, hops)?;\n                results.extend(expanded);\n            }\n            SearchMode::Temporal { days } =\u003e {\n                let expanded = self.expand_temporal(\u0026direct_ids, days)?;\n                results.extend(expanded);\n            }\n            SearchMode::Cooccurrence { min_shared } =\u003e {\n                let expanded = self.expand_cooccurrence(\u0026direct_ids, min_shared)?;\n                results.extend(expanded);\n            }\n            SearchMode::Full =\u003e {\n                // Combine all expansion modes\n                let neighbourhood = self.expand_neighbourhood(\u0026direct_ids, 2)?;\n                let temporal = self.expand_temporal(\u0026direct_ids, 30)?;\n                let cooccurrence = self.expand_cooccurrence(\u0026direct_ids, 2)?;\n                results.extend(neighbourhood);\n                results.extend(temporal);\n                results.extend(cooccurrence);\n            }\n        }\n\n        // Step 3: Apply temporal boost if requested\n        if query.temporal_boost {\n            for result in \u0026mut results {\n                if let Some(staleness) = result.staleness {\n                    // Boost score based on freshness (1 - staleness)\n                    result.score *= 1.0 + (1.0 - staleness) * 0.5;\n                }\n            }\n        }\n\n        // Step 4: Deduplicate and sort by score\n        results = self.deduplicate_results(results);\n        results.sort_by(|a, b| {\n            b.score.partial_cmp(\u0026a.score).unwrap_or(std::cmp::Ordering::Equal)\n        });\n\n        // Step 5: Apply limit\n        if let Some(limit) = query.limit {\n            results.truncate(limit as usize);\n        }\n\n        Ok(results)\n    }\n\n    /// Find notes directly matching the query.\n    fn find_direct_matches(\n        \u0026self,\n        query: \u0026SearchQuery,\n    ) -\u003e Result\u003cVec\u003cIndexedNote\u003e, IndexError\u003e {\n        // Build a NoteQuery from SearchQuery\n        let note_query = super::types::NoteQuery {\n            note_type: query.note_type,\n            path_prefix: query.path_prefix.as_ref().map(Into::into),\n            limit: query.limit,\n            ..Default::default()\n        };\n\n        let notes = self.db.query_notes(\u0026note_query)?;\n\n        // Filter by text if provided\n        if let Some(text) = \u0026query.text {\n            let text_lower = text.to_lowercase();\n            Ok(notes\n                .into_iter()\n                .filter(|n| {\n                    n.title.to_lowercase().contains(\u0026text_lower)\n                        || n.path.to_string_lossy().to_lowercase().contains(\u0026text_lower)\n                })\n                .collect())\n        } else {\n            Ok(notes)\n        }\n    }\n\n    /// Expand results by following links up to N hops.\n    fn expand_neighbourhood(\n        \u0026self,\n        seed_ids: \u0026HashSet\u003ci64\u003e,\n        max_hops: u32,\n    ) -\u003e Result\u003cVec\u003cSearchResult\u003e, IndexError\u003e {\n        let mut results = Vec::new();\n        let mut visited: HashSet\u003ci64\u003e = seed_ids.clone();\n        let mut frontier: HashSet\u003ci64\u003e = seed_ids.clone();\n\n        for hop in 1..=max_hops {\n            let mut next_frontier = HashSet::new();\n\n            for \u0026note_id in \u0026frontier {\n                // Get outgoing links\n                let outlinks = self.db.get_outgoing_links(note_id)?;\n                for link in outlinks {\n                    if let Some(target_id) = link.target_id\n                        \u0026\u0026 !visited.contains(\u0026target_id)\n                    {\n                        visited.insert(target_id);\n                        next_frontier.insert(target_id);\n\n                        if let Some(note) = self.db.get_note_by_id(target_id)? {\n                            results.push(SearchResult {\n                                staleness: self.get_staleness(note.id),\n                                note,\n                                score: 0.5 / (hop as f64), // Decay by distance\n                                match_source: MatchSource::Linked { hops: hop },\n                            });\n                        }\n                    }\n                }\n\n                // Get backlinks\n                let backlinks = self.db.get_backlinks(note_id)?;\n                for link in backlinks {\n                    if !visited.contains(\u0026link.source_id) {\n                        visited.insert(link.source_id);\n                        next_frontier.insert(link.source_id);\n\n                        if let Some(note) = self.db.get_note_by_id(link.source_id)? {\n                            results.push(SearchResult {\n                                staleness: self.get_staleness(note.id),\n                                note,\n                                score: 0.5 / (hop as f64),\n                                match_source: MatchSource::Linked { hops: hop },\n                            });\n                        }\n                    }\n                }\n            }\n\n            frontier = next_frontier;\n            if frontier.is_empty() {\n                break;\n            }\n        }\n\n        Ok(results)\n    }\n\n    /// Expand results by finding recent dailies referencing matches.\n    fn expand_temporal(\n        \u0026self,\n        seed_ids: \u0026HashSet\u003ci64\u003e,\n        _days: u32,\n    ) -\u003e Result\u003cVec\u003cSearchResult\u003e, IndexError\u003e {\n        let mut results = Vec::new();\n        let mut seen_dailies: HashSet\u003ci64\u003e = HashSet::new();\n\n        for \u0026note_id in seed_ids {\n            // Get backlinks to find dailies referencing this note\n            let backlinks = self.db.get_backlinks(note_id)?;\n            for link in backlinks {\n                if let Some(source_note) = self.db.get_note_by_id(link.source_id)?\n                    \u0026\u0026 source_note.note_type == NoteType::Daily\n                    \u0026\u0026 !seen_dailies.contains(\u0026link.source_id)\n                    \u0026\u0026 !seed_ids.contains(\u0026link.source_id)\n                {\n                    seen_dailies.insert(link.source_id);\n                    let path = source_note.path.to_string_lossy().to_string();\n                    results.push(SearchResult {\n                        staleness: self.get_staleness(source_note.id),\n                        note: source_note,\n                        score: 0.4,\n                        match_source: MatchSource::Temporal { daily_path: path },\n                    });\n                }\n            }\n        }\n\n        Ok(results)\n    }\n\n    /// Expand results by finding notes that cooccur with matches.\n    fn expand_cooccurrence(\n        \u0026self,\n        seed_ids: \u0026HashSet\u003ci64\u003e,\n        min_shared: u32,\n    ) -\u003e Result\u003cVec\u003cSearchResult\u003e, IndexError\u003e {\n        let mut results = Vec::new();\n        let mut seen: HashSet\u003ci64\u003e = seed_ids.clone();\n\n        for \u0026note_id in seed_ids {\n            let cooccurrent = self.db.get_cooccurrent_notes(note_id, 10)?;\n            for (note, shared_count) in cooccurrent {\n                if let Some(id) = note.id\n                    \u0026\u0026 shared_count \u003e= min_shared as i32\n                    \u0026\u0026 !seen.contains(\u0026id)\n                {\n                    seen.insert(id);\n                    results.push(SearchResult {\n                        staleness: self.get_staleness(note.id),\n                        note,\n                        score: 0.3 * (shared_count as f64 / 10.0).min(1.0),\n                        match_source: MatchSource::Cooccurrence {\n                            shared_dailies: shared_count as u32,\n                        },\n                    });\n                }\n            }\n        }\n\n        Ok(results)\n    }\n\n    /// Get staleness score for a note.\n    fn get_staleness(\u0026self, note_id: Option\u003ci64\u003e) -\u003e Option\u003cf64\u003e {\n        note_id.and_then(|id| {\n            self.db\n                .get_activity_summary(id)\n                .ok()\n                .flatten()\n                .map(|s| s.staleness_score as f64)\n        })\n    }\n\n    /// Deduplicate results, keeping highest score for each note.\n    fn deduplicate_results(\u0026self, results: Vec\u003cSearchResult\u003e) -\u003e Vec\u003cSearchResult\u003e {\n        let mut best: HashMap\u003ci64, SearchResult\u003e = HashMap::new();\n\n        for result in results {\n            if let Some(id) = result.note.id {\n                best.entry(id)\n                    .and_modify(|existing| {\n                        if result.score \u003e existing.score {\n                            *existing = result.clone();\n                        }\n                    })\n                    .or_insert(result);\n            }\n        }\n\n        best.into_values().collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::Utc;\n    use std::path::PathBuf;\n\n    fn sample_note(path: \u0026str, title: \u0026str, note_type: NoteType) -\u003e IndexedNote {\n        IndexedNote {\n            id: None,\n            path: PathBuf::from(path),\n            note_type,\n            title: title.to_string(),\n            created: Some(Utc::now()),\n            modified: Utc::now(),\n            frontmatter_json: None,\n            content_hash: format!(\"hash-{}\", path),\n        }\n    }\n\n    #[test]\n    fn test_direct_search() {\n        let db = IndexDb::open_in_memory().unwrap();\n\n        // Insert test notes\n        db.insert_note(\u0026sample_note(\n            \"tasks/task1.md\",\n            \"Fix bug in parser\",\n            NoteType::Task,\n        ))\n        .unwrap();\n        db.insert_note(\u0026sample_note(\n            \"tasks/task2.md\",\n            \"Write documentation\",\n            NoteType::Task,\n        ))\n        .unwrap();\n        db.insert_note(\u0026sample_note(\n            \"zettel/note1.md\",\n            \"Parser internals\",\n            NoteType::Zettel,\n        ))\n        .unwrap();\n\n        let engine = SearchEngine::new(\u0026db);\n\n        // Search for \"parser\"\n        let query = SearchQuery {\n            text: Some(\"parser\".to_string()),\n            mode: SearchMode::Direct,\n            ..Default::default()\n        };\n\n        let results = engine.search(\u0026query).unwrap();\n        assert_eq!(results.len(), 2);\n        assert!(results.iter().all(|r| r.match_source == MatchSource::Direct));\n    }\n\n    #[test]\n    fn test_type_filter() {\n        let db = IndexDb::open_in_memory().unwrap();\n\n        db.insert_note(\u0026sample_note(\"tasks/task1.md\", \"Task note\", NoteType::Task))\n            .unwrap();\n        db.insert_note(\u0026sample_note(\"zettel/note1.md\", \"Zettel note\", NoteType::Zettel))\n            .unwrap();\n\n        let engine = SearchEngine::new(\u0026db);\n\n        let query = SearchQuery {\n            note_type: Some(NoteType::Task),\n            mode: SearchMode::Direct,\n            ..Default::default()\n        };\n\n        let results = engine.search(\u0026query).unwrap();\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].note.note_type, NoteType::Task);\n    }\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":9}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":8}},{"line":140,"address":[],"length":0,"stats":{"Line":5}},{"line":141,"address":[],"length":0,"stats":{"Line":5}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":8}},{"line":168,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":6}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":3}},{"line":311,"address":[],"length":0,"stats":{"Line":9}},{"line":312,"address":[],"length":0,"stats":{"Line":3}},{"line":313,"address":[],"length":0,"stats":{"Line":6}},{"line":314,"address":[],"length":0,"stats":{"Line":3}},{"line":315,"address":[],"length":0,"stats":{"Line":3}},{"line":316,"address":[],"length":0,"stats":{"Line":3}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":6}},{"line":324,"address":[],"length":0,"stats":{"Line":8}},{"line":325,"address":[],"length":0,"stats":{"Line":6}},{"line":326,"address":[],"length":0,"stats":{"Line":9}},{"line":327,"address":[],"length":0,"stats":{"Line":3}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[],"length":0,"stats":{"Line":6}}],"covered":47,"coverable":139},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","types.rs"],"content":"//! Index data types for vault notes and links.\n\nuse chrono::{DateTime, NaiveDate, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse std::str::FromStr;\n\n/// Note type classification based on frontmatter `type:` field.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]\n#[serde(rename_all = \"lowercase\")]\npub enum NoteType {\n    /// Daily journal notes - temporal backbone of the vault.\n    Daily,\n    /// Weekly overview notes.\n    Weekly,\n    /// Individual actionable tasks.\n    Task,\n    /// Collections of related tasks.\n    Project,\n    /// Knowledge notes (Zettelkasten-style).\n    Zettel,\n    /// Uncategorised notes awaiting triage.\n    #[default]\n    None,\n}\n\nimpl NoteType {\n    /// Convert to database string representation.\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Daily =\u003e \"daily\",\n            Self::Weekly =\u003e \"weekly\",\n            Self::Task =\u003e \"task\",\n            Self::Project =\u003e \"project\",\n            Self::Zettel =\u003e \"zettel\",\n            Self::None =\u003e \"none\",\n        }\n    }\n}\n\nimpl FromStr for NoteType {\n    type Err = std::convert::Infallible;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        Ok(match s.to_lowercase().as_str() {\n            \"daily\" =\u003e Self::Daily,\n            \"weekly\" =\u003e Self::Weekly,\n            \"task\" =\u003e Self::Task,\n            \"project\" =\u003e Self::Project,\n            \"zettel\" | \"knowledge\" =\u003e Self::Zettel,\n            _ =\u003e Self::None,\n        })\n    }\n}\n\n/// Task status values.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\n#[serde(rename_all = \"lowercase\")]\npub enum TaskStatus {\n    #[default]\n    Open,\n    InProgress,\n    Blocked,\n    Done,\n    Cancelled,\n}\n\nimpl TaskStatus {\n    pub fn parse(s: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match s.to_lowercase().replace(['-', '_'], \"\").as_str() {\n            \"open\" =\u003e Some(Self::Open),\n            \"inprogress\" =\u003e Some(Self::InProgress),\n            \"blocked\" =\u003e Some(Self::Blocked),\n            \"done\" | \"completed\" =\u003e Some(Self::Done),\n            \"cancelled\" | \"canceled\" =\u003e Some(Self::Cancelled),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Open =\u003e \"open\",\n            Self::InProgress =\u003e \"in-progress\",\n            Self::Blocked =\u003e \"blocked\",\n            Self::Done =\u003e \"done\",\n            Self::Cancelled =\u003e \"cancelled\",\n        }\n    }\n}\n\n/// Project status values.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\n#[serde(rename_all = \"lowercase\")]\npub enum ProjectStatus {\n    #[default]\n    Planning,\n    Active,\n    Paused,\n    Completed,\n    Archived,\n}\n\nimpl ProjectStatus {\n    pub fn parse(s: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"planning\" =\u003e Some(Self::Planning),\n            \"active\" =\u003e Some(Self::Active),\n            \"paused\" =\u003e Some(Self::Paused),\n            \"completed\" | \"done\" =\u003e Some(Self::Completed),\n            \"archived\" =\u003e Some(Self::Archived),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Planning =\u003e \"planning\",\n            Self::Active =\u003e \"active\",\n            Self::Paused =\u003e \"paused\",\n            Self::Completed =\u003e \"completed\",\n            Self::Archived =\u003e \"archived\",\n        }\n    }\n}\n\n/// Type of link between notes.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum LinkType {\n    /// Wikilink: [[note]] or [[note|alias]]\n    Wikilink,\n    /// Markdown link: [text](path.md)\n    Markdown,\n    /// Frontmatter reference: project: note-name\n    Frontmatter,\n}\n\nimpl LinkType {\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Wikilink =\u003e \"wikilink\",\n            Self::Markdown =\u003e \"markdown\",\n            Self::Frontmatter =\u003e \"frontmatter\",\n        }\n    }\n\n    pub fn parse(s: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"wikilink\" =\u003e Some(Self::Wikilink),\n            \"markdown\" =\u003e Some(Self::Markdown),\n            \"frontmatter\" =\u003e Some(Self::Frontmatter),\n            _ =\u003e None,\n        }\n    }\n}\n\n/// A note in the vault index.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IndexedNote {\n    /// Database ID (None if not yet inserted).\n    pub id: Option\u003ci64\u003e,\n    /// Path relative to vault root.\n    pub path: PathBuf,\n    /// Note type from frontmatter.\n    pub note_type: NoteType,\n    /// Note title (from first heading or filename).\n    pub title: String,\n    /// File creation time.\n    pub created: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    /// File modification time.\n    pub modified: DateTime\u003cUtc\u003e,\n    /// Frontmatter as JSON string.\n    pub frontmatter_json: Option\u003cString\u003e,\n    /// Content hash for change detection.\n    pub content_hash: String,\n}\n\n/// A link between two notes.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IndexedLink {\n    /// Database ID (None if not yet inserted).\n    pub id: Option\u003ci64\u003e,\n    /// Source note ID.\n    pub source_id: i64,\n    /// Target note ID (None if broken link).\n    pub target_id: Option\u003ci64\u003e,\n    /// Raw target path from the link.\n    pub target_path: String,\n    /// Link display text (content within [[brackets]] or [text]).\n    pub link_text: Option\u003cString\u003e,\n    /// Type of link.\n    pub link_type: LinkType,\n    /// Surrounding context text.\n    pub context: Option\u003cString\u003e,\n    /// Line number in source file.\n    pub line_number: Option\u003cu32\u003e,\n}\n\n/// Temporal activity record - when a note was referenced in a daily.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TemporalActivity {\n    /// Database ID.\n    pub id: Option\u003ci64\u003e,\n    /// The note being referenced.\n    pub note_id: i64,\n    /// The daily note containing the reference.\n    pub daily_id: i64,\n    /// Date of the daily note.\n    pub activity_date: NaiveDate,\n    /// Context of the reference.\n    pub context: Option\u003cString\u003e,\n}\n\n/// Activity summary for a note (derived/cached).\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActivitySummary {\n    /// Note ID.\n    pub note_id: i64,\n    /// Last time note was referenced in a daily.\n    pub last_seen: Option\u003cNaiveDate\u003e,\n    /// Reference count in last 30 days.\n    pub access_count_30d: u32,\n    /// Reference count in last 90 days.\n    pub access_count_90d: u32,\n    /// Computed staleness score (higher = more stale).\n    pub staleness_score: f32,\n}\n\n/// Query filter for listing notes.\n#[derive(Debug, Clone, Default)]\npub struct NoteQuery {\n    /// Filter by note type.\n    pub note_type: Option\u003cNoteType\u003e,\n    /// Filter by path prefix.\n    pub path_prefix: Option\u003cPathBuf\u003e,\n    /// Modified after this date.\n    pub modified_after: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    /// Modified before this date.\n    pub modified_before: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    /// Maximum number of results.\n    pub limit: Option\u003cu32\u003e,\n    /// Offset for pagination.\n    pub offset: Option\u003cu32\u003e,\n}\n\n/// Aggregate activity data for computing summaries.\n#[derive(Debug, Clone)]\npub struct AggregateActivity {\n    /// Note ID.\n    pub note_id: i64,\n    /// Last seen date as ISO string.\n    pub last_seen: Option\u003cString\u003e,\n    /// Reference count in last 30 days.\n    pub access_count_30d: i32,\n    /// Reference count in last 90 days.\n    pub access_count_90d: i32,\n}\n\n/// A cooccurrence pair: two notes that appear together in daily notes.\n#[derive(Debug, Clone)]\npub struct CooccurrencePair {\n    /// First note ID.\n    pub note_a_id: i64,\n    /// Second note ID.\n    pub note_b_id: i64,\n    /// Number of daily notes they share.\n    pub shared_count: i32,\n    /// Most recent shared daily date.\n    pub most_recent: Option\u003cString\u003e,\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":64}},{"line":30,"address":[],"length":0,"stats":{"Line":64}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":18}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":24}},{"line":36,"address":[],"length":0,"stats":{"Line":22}},{"line":44,"address":[],"length":0,"stats":{"Line":52}},{"line":45,"address":[],"length":0,"stats":{"Line":52}},{"line":46,"address":[],"length":0,"stats":{"Line":52}},{"line":47,"address":[],"length":0,"stats":{"Line":52}},{"line":48,"address":[],"length":0,"stats":{"Line":72}},{"line":49,"address":[],"length":0,"stats":{"Line":32}},{"line":50,"address":[],"length":0,"stats":{"Line":64}},{"line":51,"address":[],"length":0,"stats":{"Line":11}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":69}},{"line":140,"address":[],"length":0,"stats":{"Line":69}},{"line":141,"address":[],"length":0,"stats":{"Line":43}},{"line":142,"address":[],"length":0,"stats":{"Line":13}},{"line":143,"address":[],"length":0,"stats":{"Line":13}},{"line":147,"address":[],"length":0,"stats":{"Line":10}},{"line":148,"address":[],"length":0,"stats":{"Line":10}},{"line":149,"address":[],"length":0,"stats":{"Line":20}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}}],"covered":21,"coverable":57},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","lib.rs"],"content":"pub fn version() -\u003e \u0026'static str {\n    env!(\"CARGO_PKG_VERSION\")\n}\n\npub fn rustc_version() -\u003e String {\n    std::env::var(\"RUSTC_VERSION\").unwrap_or_else(|_| \"unknown\".into())\n}\n\npub fn doctor_stub() -\u003e String {\n    format!(\n        \"mdvault-core v{} | rustc {} on {} \",\n        version(),\n        rustc_version(),\n        std::env::consts::OS\n    )\n}\n\npub mod captures;\npub mod config;\npub mod frontmatter;\npub mod ids;\npub mod index;\npub mod macros;\npub mod markdown_ast;\npub mod rename;\npub mod scripting;\npub mod templates;\npub mod types;\npub mod vars;\npub mod vault;\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":0}},{"line":2,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","macros","discovery.rs"],"content":"//! Macro discovery and repository.\n\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\nuse thiserror::Error;\nuse walkdir::WalkDir;\n\nuse super::types::{LoadedMacro, MacroInfo, MacroSpec};\n\n/// Error type for macro discovery.\n#[derive(Debug, Error)]\npub enum MacroDiscoveryError {\n    #[error(\"macros directory does not exist: {0}\")]\n    MissingDir(String),\n\n    #[error(\"failed to read macros directory {0}: {1}\")]\n    WalkError(String, #[source] walkdir::Error),\n}\n\n/// Error type for macro repository operations.\n#[derive(Debug, Error)]\npub enum MacroRepoError {\n    #[error(transparent)]\n    Discovery(#[from] MacroDiscoveryError),\n\n    #[error(\"macro not found: {0}\")]\n    NotFound(String),\n\n    #[error(\"failed to read macro file {path}: {source}\")]\n    Io {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    #[error(\"failed to parse macro YAML {path}: {source}\")]\n    Parse {\n        path: PathBuf,\n        #[source]\n        source: serde_yaml::Error,\n    },\n}\n\n/// Discover macro files in a directory.\n///\n/// Finds all `.yaml` files in the given directory and its subdirectories.\npub fn discover_macros(root: \u0026Path) -\u003e Result\u003cVec\u003cMacroInfo\u003e, MacroDiscoveryError\u003e {\n    let root = root\n        .canonicalize()\n        .map_err(|_| MacroDiscoveryError::MissingDir(root.display().to_string()))?;\n\n    if !root.exists() {\n        return Err(MacroDiscoveryError::MissingDir(root.display().to_string()));\n    }\n\n    let mut out = Vec::new();\n\n    for entry in WalkDir::new(\u0026root) {\n        let entry = entry\n            .map_err(|e| MacroDiscoveryError::WalkError(root.display().to_string(), e))?;\n\n        let path = entry.path();\n        if !path.is_file() {\n            continue;\n        }\n        if !is_yaml_file(path) {\n            continue;\n        }\n\n        let rel = path.strip_prefix(\u0026root).unwrap_or(path);\n        let logical = logical_name_from_relative(rel);\n\n        out.push(MacroInfo { logical_name: logical, path: path.to_path_buf() });\n    }\n\n    out.sort_by(|a, b| a.logical_name.cmp(\u0026b.logical_name));\n    Ok(out)\n}\n\nfn is_yaml_file(path: \u0026Path) -\u003e bool {\n    path.extension().and_then(|e| e.to_str()).is_some_and(|e| e == \"yaml\" || e == \"yml\")\n}\n\nfn logical_name_from_relative(rel: \u0026Path) -\u003e String {\n    let s = rel.to_string_lossy();\n    // Remove .yaml or .yml extension\n    if let Some(stripped) = s.strip_suffix(\".yaml\") {\n        return stripped.to_string();\n    }\n    if let Some(stripped) = s.strip_suffix(\".yml\") {\n        return stripped.to_string();\n    }\n    s.to_string()\n}\n\n/// Repository for discovering and loading macros.\npub struct MacroRepository {\n    pub root: PathBuf,\n    pub macros: Vec\u003cMacroInfo\u003e,\n}\n\nimpl MacroRepository {\n    /// Create a new macro repository from a directory.\n    pub fn new(root: \u0026Path) -\u003e Result\u003cSelf, MacroDiscoveryError\u003e {\n        let macros = discover_macros(root)?;\n        Ok(Self { root: root.to_path_buf(), macros })\n    }\n\n    /// List all discovered macros.\n    pub fn list_all(\u0026self) -\u003e \u0026[MacroInfo] {\n        \u0026self.macros\n    }\n\n    /// Get a macro by its logical name.\n    pub fn get_by_name(\u0026self, name: \u0026str) -\u003e Result\u003cLoadedMacro, MacroRepoError\u003e {\n        let info = self\n            .macros\n            .iter()\n            .find(|m| m.logical_name == name)\n            .ok_or_else(|| MacroRepoError::NotFound(name.to_string()))?;\n\n        let content = fs::read_to_string(\u0026info.path)\n            .map_err(|e| MacroRepoError::Io { path: info.path.clone(), source: e })?;\n\n        let spec: MacroSpec = serde_yaml::from_str(\u0026content)\n            .map_err(|e| MacroRepoError::Parse { path: info.path.clone(), source: e })?;\n\n        Ok(LoadedMacro {\n            logical_name: info.logical_name.clone(),\n            path: info.path.clone(),\n            spec,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_discover_macros() {\n        let temp = TempDir::new().unwrap();\n        let macros_dir = temp.path().join(\"macros\");\n        fs::create_dir_all(\u0026macros_dir).unwrap();\n\n        // Create some macro files\n        fs::write(\n            macros_dir.join(\"weekly-review.yaml\"),\n            \"name: weekly-review\\nsteps: []\",\n        )\n        .unwrap();\n        fs::write(macros_dir.join(\"daily-note.yml\"), \"name: daily-note\\nsteps: []\")\n            .unwrap();\n\n        // Create a subdirectory with another macro\n        let sub_dir = macros_dir.join(\"project\");\n        fs::create_dir_all(\u0026sub_dir).unwrap();\n        fs::write(sub_dir.join(\"setup.yaml\"), \"name: project-setup\\nsteps: []\").unwrap();\n\n        // Create a non-yaml file (should be ignored)\n        fs::write(macros_dir.join(\"notes.md\"), \"# Notes\").unwrap();\n\n        let macros = discover_macros(\u0026macros_dir).unwrap();\n\n        assert_eq!(macros.len(), 3);\n        assert!(macros.iter().any(|m| m.logical_name == \"daily-note\"));\n        assert!(macros.iter().any(|m| m.logical_name == \"weekly-review\"));\n        assert!(macros.iter().any(|m| m.logical_name == \"project/setup\"));\n    }\n\n    #[test]\n    fn test_macro_repository() {\n        let temp = TempDir::new().unwrap();\n        let macros_dir = temp.path().join(\"macros\");\n        fs::create_dir_all(\u0026macros_dir).unwrap();\n\n        fs::write(\n            macros_dir.join(\"test.yaml\"),\n            r#\"\nname: test\ndescription: A test macro\nsteps:\n  - template: meeting-note\n    with:\n      title: \"Test\"\n\"#,\n        )\n        .unwrap();\n\n        let repo = MacroRepository::new(\u0026macros_dir).unwrap();\n        assert_eq!(repo.list_all().len(), 1);\n\n        let loaded = repo.get_by_name(\"test\").unwrap();\n        assert_eq!(loaded.spec.name, \"test\");\n        assert_eq!(loaded.spec.description, \"A test macro\");\n        assert_eq!(loaded.spec.steps.len(), 1);\n    }\n\n    #[test]\n    fn test_macro_not_found() {\n        let temp = TempDir::new().unwrap();\n        let macros_dir = temp.path().join(\"macros\");\n        fs::create_dir_all(\u0026macros_dir).unwrap();\n\n        let repo = MacroRepository::new(\u0026macros_dir).unwrap();\n        let result = repo.get_by_name(\"nonexistent\");\n\n        assert!(matches!(result, Err(MacroRepoError::NotFound(_))));\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":24}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":24}},{"line":59,"address":[],"length":0,"stats":{"Line":53}},{"line":60,"address":[],"length":0,"stats":{"Line":58}},{"line":61,"address":[],"length":0,"stats":{"Line":29}},{"line":63,"address":[],"length":0,"stats":{"Line":87}},{"line":64,"address":[],"length":0,"stats":{"Line":29}},{"line":65,"address":[],"length":0,"stats":{"Line":13}},{"line":67,"address":[],"length":0,"stats":{"Line":16}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":90}},{"line":72,"address":[],"length":0,"stats":{"Line":45}},{"line":74,"address":[],"length":0,"stats":{"Line":60}},{"line":77,"address":[],"length":0,"stats":{"Line":36}},{"line":78,"address":[],"length":0,"stats":{"Line":12}},{"line":81,"address":[],"length":0,"stats":{"Line":16}},{"line":82,"address":[],"length":0,"stats":{"Line":114}},{"line":85,"address":[],"length":0,"stats":{"Line":15}},{"line":86,"address":[],"length":0,"stats":{"Line":45}},{"line":88,"address":[],"length":0,"stats":{"Line":29}},{"line":89,"address":[],"length":0,"stats":{"Line":28}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":11}},{"line":106,"address":[],"length":0,"stats":{"Line":33}},{"line":107,"address":[],"length":0,"stats":{"Line":22}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":13}},{"line":117,"address":[],"length":0,"stats":{"Line":24}},{"line":118,"address":[],"length":0,"stats":{"Line":13}},{"line":120,"address":[],"length":0,"stats":{"Line":41}},{"line":121,"address":[],"length":0,"stats":{"Line":19}},{"line":123,"address":[],"length":0,"stats":{"Line":33}},{"line":124,"address":[],"length":0,"stats":{"Line":11}},{"line":126,"address":[],"length":0,"stats":{"Line":44}},{"line":127,"address":[],"length":0,"stats":{"Line":11}},{"line":129,"address":[],"length":0,"stats":{"Line":11}},{"line":130,"address":[],"length":0,"stats":{"Line":33}},{"line":131,"address":[],"length":0,"stats":{"Line":22}},{"line":132,"address":[],"length":0,"stats":{"Line":11}}],"covered":44,"coverable":46},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","macros","mod.rs"],"content":"//! Macro system for multi-step workflows.\n//!\n//! Macros allow users to define sequences of template and capture operations\n//! that execute as a single workflow.\n\npub mod discovery;\npub mod runner;\npub mod types;\n\npub use discovery::{\n    MacroDiscoveryError, MacroRepoError, MacroRepository, discover_macros,\n};\npub use runner::{\n    MacroRunError, RunContext, RunOptions, StepExecutor, get_shell_commands,\n    requires_trust, run_macro,\n};\npub use types::{\n    CaptureStep, ErrorPolicy, LoadedMacro, MacroInfo, MacroResult, MacroSpec, MacroStep,\n    ShellStep, StepResult, TemplateStep,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","macros","runner.rs"],"content":"//! Macro runner for executing multi-step workflows.\n\nuse std::collections::HashMap;\n\nuse thiserror::Error;\n\nuse super::types::{\n    CaptureStep, ErrorPolicy, LoadedMacro, MacroResult, MacroSpec, MacroStep, ShellStep,\n    StepResult, TemplateStep,\n};\nuse crate::templates::engine::render_string;\n\n/// Error type for macro execution.\n#[derive(Debug, Error)]\npub enum MacroRunError {\n    #[error(\"step {step} failed: {message}\")]\n    StepFailed { step: usize, message: String },\n\n    #[error(\"shell execution requires --trust flag\")]\n    TrustRequired,\n\n    #[error(\"shell execution is disabled in config\")]\n    ShellDisabled,\n\n    #[error(\"template error: {0}\")]\n    TemplateError(String),\n\n    #[error(\"capture error: {0}\")]\n    CaptureError(String),\n\n    #[error(\"shell error: {0}\")]\n    ShellError(String),\n\n    #[error(\"variable error: {0}\")]\n    VariableError(String),\n}\n\n/// Options for macro execution.\n#[derive(Debug, Clone, Default)]\npub struct RunOptions {\n    /// Whether the --trust flag was provided.\n    pub trust: bool,\n\n    /// Whether shell execution is allowed by config.\n    pub allow_shell: bool,\n\n    /// Whether to run in dry-run mode (no actual changes).\n    pub dry_run: bool,\n}\n\n/// Context passed to step executors.\n#[derive(Debug, Clone)]\npub struct RunContext {\n    /// Current variable values (macro vars + step overrides).\n    pub vars: HashMap\u003cString, String\u003e,\n\n    /// Execution options.\n    pub options: RunOptions,\n\n    /// Results from previous steps (for chaining).\n    pub previous_results: Vec\u003cStepResult\u003e,\n}\n\nimpl RunContext {\n    /// Create a new run context with initial variables.\n    pub fn new(vars: HashMap\u003cString, String\u003e, options: RunOptions) -\u003e Self {\n        Self { vars, options, previous_results: Vec::new() }\n    }\n\n    /// Merge step-level variable overrides into context.\n    pub fn with_step_vars(\n        \u0026self,\n        step_vars: \u0026HashMap\u003cString, String\u003e,\n    ) -\u003e HashMap\u003cString, String\u003e {\n        let mut merged = self.vars.clone();\n\n        // Render step vars (they may reference macro vars)\n        for (key, value) in step_vars {\n            let rendered =\n                render_string(value, \u0026merged).unwrap_or_else(|_| value.clone());\n            merged.insert(key.clone(), rendered);\n        }\n\n        merged\n    }\n\n    /// Add a step result to the context.\n    pub fn add_result(\u0026mut self, result: StepResult) {\n        // If the step created a file, add it as a variable for subsequent steps\n        if let Some(ref path) = result.output_path {\n            let var_name = format!(\"step_{}_output\", result.step_index);\n            self.vars.insert(var_name, path.to_string_lossy().to_string());\n        }\n        self.previous_results.push(result);\n    }\n}\n\n/// Trait for executing individual macro steps.\n///\n/// This allows the CLI/TUI to provide their own implementations\n/// that integrate with their error handling and UI.\npub trait StepExecutor {\n    /// Execute a template step.\n    fn execute_template(\n        \u0026self,\n        step: \u0026TemplateStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e;\n\n    /// Execute a capture step.\n    fn execute_capture(\n        \u0026self,\n        step: \u0026CaptureStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e;\n\n    /// Execute a shell step.\n    fn execute_shell(\n        \u0026self,\n        step: \u0026ShellStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e;\n}\n\n/// Run a macro with the given executor and context.\npub fn run_macro\u003cE: StepExecutor\u003e(\n    loaded: \u0026LoadedMacro,\n    executor: \u0026E,\n    mut ctx: RunContext,\n) -\u003e MacroResult {\n    let spec = \u0026loaded.spec;\n    let mut all_success = true;\n    let mut step_results = Vec::new();\n\n    for (index, step) in spec.steps.iter().enumerate() {\n        let result = execute_step(executor, step, index, \u0026ctx);\n\n        match result {\n            Ok(step_result) =\u003e {\n                ctx.add_result(step_result.clone());\n                step_results.push(step_result);\n            }\n            Err(e) =\u003e {\n                all_success = false;\n                let error_result = StepResult {\n                    step_index: index,\n                    success: false,\n                    message: e.to_string(),\n                    output_path: None,\n                };\n                step_results.push(error_result);\n\n                // Check error policy\n                if spec.on_error == ErrorPolicy::Abort {\n                    break;\n                }\n            }\n        }\n    }\n\n    let message = if all_success {\n        format!(\"Completed {} steps successfully\", step_results.len())\n    } else {\n        let failed_count = step_results.iter().filter(|r| !r.success).count();\n        format!(\n            \"Completed with {} failures out of {} steps\",\n            failed_count,\n            step_results.len()\n        )\n    };\n\n    MacroResult {\n        macro_name: loaded.logical_name.clone(),\n        step_results,\n        success: all_success,\n        message,\n    }\n}\n\nfn execute_step\u003cE: StepExecutor\u003e(\n    executor: \u0026E,\n    step: \u0026MacroStep,\n    _index: usize,\n    ctx: \u0026RunContext,\n) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n    // Check trust requirements for shell steps\n    if step.requires_trust() {\n        if !ctx.options.trust {\n            return Err(MacroRunError::TrustRequired);\n        }\n        if !ctx.options.allow_shell {\n            return Err(MacroRunError::ShellDisabled);\n        }\n    }\n\n    match step {\n        MacroStep::Template(t) =\u003e executor.execute_template(t, ctx),\n        MacroStep::Capture(c) =\u003e executor.execute_capture(c, ctx),\n        MacroStep::Shell(s) =\u003e executor.execute_shell(s, ctx),\n    }\n}\n\n/// Check if a macro contains any steps that require trust.\npub fn requires_trust(spec: \u0026MacroSpec) -\u003e bool {\n    spec.steps.iter().any(|s| s.requires_trust())\n}\n\n/// Get descriptions of all shell commands in a macro.\npub fn get_shell_commands(spec: \u0026MacroSpec) -\u003e Vec\u003cString\u003e {\n    spec.steps\n        .iter()\n        .filter_map(|s| match s {\n            MacroStep::Shell(shell) =\u003e Some(shell.shell.clone()),\n            _ =\u003e None,\n        })\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n\n    struct MockExecutor;\n\n    impl StepExecutor for MockExecutor {\n        fn execute_template(\n            \u0026self,\n            step: \u0026TemplateStep,\n            _ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Created template: {}\", step.template),\n                output_path: Some(PathBuf::from(\"test.md\")),\n            })\n        }\n\n        fn execute_capture(\n            \u0026self,\n            step: \u0026CaptureStep,\n            _ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Executed capture: {}\", step.capture),\n                output_path: None,\n            })\n        }\n\n        fn execute_shell(\n            \u0026self,\n            step: \u0026ShellStep,\n            _ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Executed: {}\", step.shell),\n                output_path: None,\n            })\n        }\n    }\n\n    #[test]\n    fn test_run_macro_simple() {\n        let spec = MacroSpec {\n            name: \"test\".to_string(),\n            description: String::new(),\n            vars: None,\n            steps: vec![MacroStep::Template(TemplateStep {\n                template: \"meeting\".to_string(),\n                output: None,\n                vars_with: HashMap::new(),\n            })],\n            on_error: ErrorPolicy::Abort,\n        };\n\n        let loaded = LoadedMacro {\n            logical_name: \"test\".to_string(),\n            path: PathBuf::from(\"test.yaml\"),\n            spec,\n        };\n\n        let ctx = RunContext::new(HashMap::new(), RunOptions::default());\n        let result = run_macro(\u0026loaded, \u0026MockExecutor, ctx);\n\n        assert!(result.success);\n        assert_eq!(result.step_results.len(), 1);\n    }\n\n    #[test]\n    fn test_shell_requires_trust() {\n        let spec = MacroSpec {\n            name: \"test\".to_string(),\n            description: String::new(),\n            vars: None,\n            steps: vec![MacroStep::Shell(ShellStep {\n                shell: \"echo hello\".to_string(),\n                description: String::new(),\n            })],\n            on_error: ErrorPolicy::Abort,\n        };\n\n        let loaded = LoadedMacro {\n            logical_name: \"test\".to_string(),\n            path: PathBuf::from(\"test.yaml\"),\n            spec,\n        };\n\n        // Without trust\n        let ctx = RunContext::new(HashMap::new(), RunOptions::default());\n        let result = run_macro(\u0026loaded, \u0026MockExecutor, ctx);\n        assert!(!result.success);\n\n        // With trust but shell disabled\n        let ctx = RunContext::new(\n            HashMap::new(),\n            RunOptions { trust: true, allow_shell: false, dry_run: false },\n        );\n        let result = run_macro(\u0026loaded, \u0026MockExecutor, ctx);\n        assert!(!result.success);\n\n        // With trust and shell enabled\n        let ctx = RunContext::new(\n            HashMap::new(),\n            RunOptions { trust: true, allow_shell: true, dry_run: false },\n        );\n        let result = run_macro(\u0026loaded, \u0026MockExecutor, ctx);\n        assert!(result.success);\n    }\n\n    #[test]\n    fn test_requires_trust_check() {\n        let spec_with_shell = MacroSpec {\n            name: \"test\".to_string(),\n            description: String::new(),\n            vars: None,\n            steps: vec![\n                MacroStep::Template(TemplateStep {\n                    template: \"meeting\".to_string(),\n                    output: None,\n                    vars_with: HashMap::new(),\n                }),\n                MacroStep::Shell(ShellStep {\n                    shell: \"git add .\".to_string(),\n                    description: String::new(),\n                }),\n            ],\n            on_error: ErrorPolicy::Abort,\n        };\n\n        let spec_without_shell = MacroSpec {\n            name: \"test\".to_string(),\n            description: String::new(),\n            vars: None,\n            steps: vec![MacroStep::Template(TemplateStep {\n                template: \"meeting\".to_string(),\n                output: None,\n                vars_with: HashMap::new(),\n            })],\n            on_error: ErrorPolicy::Abort,\n        };\n\n        assert!(requires_trust(\u0026spec_with_shell));\n        assert!(!requires_trust(\u0026spec_without_shell));\n    }\n}\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":9}},{"line":67,"address":[],"length":0,"stats":{"Line":18}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":18}},{"line":78,"address":[],"length":0,"stats":{"Line":9}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":5}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":22}},{"line":91,"address":[],"length":0,"stats":{"Line":28}},{"line":92,"address":[],"length":0,"stats":{"Line":28}},{"line":94,"address":[],"length":0,"stats":{"Line":24}},{"line":126,"address":[],"length":0,"stats":{"Line":9}},{"line":131,"address":[],"length":0,"stats":{"Line":18}},{"line":132,"address":[],"length":0,"stats":{"Line":18}},{"line":133,"address":[],"length":0,"stats":{"Line":18}},{"line":135,"address":[],"length":0,"stats":{"Line":38}},{"line":136,"address":[],"length":0,"stats":{"Line":60}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":16}},{"line":140,"address":[],"length":0,"stats":{"Line":40}},{"line":141,"address":[],"length":0,"stats":{"Line":16}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":18}},{"line":162,"address":[],"length":0,"stats":{"Line":28}},{"line":164,"address":[],"length":0,"stats":{"Line":10}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":27}},{"line":180,"address":[],"length":0,"stats":{"Line":10}},{"line":187,"address":[],"length":0,"stats":{"Line":20}},{"line":188,"address":[],"length":0,"stats":{"Line":3}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":8}},{"line":197,"address":[],"length":0,"stats":{"Line":25}},{"line":198,"address":[],"length":0,"stats":{"Line":10}},{"line":199,"address":[],"length":0,"stats":{"Line":5}},{"line":204,"address":[],"length":0,"stats":{"Line":12}},{"line":205,"address":[],"length":0,"stats":{"Line":56}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":3}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":0}}],"covered":52,"coverable":54},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","macros","types.rs"],"content":"//! Macro specification types for multi-step workflows.\n\nuse serde::Deserialize;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\nuse crate::vars::VarsMap;\n\n/// A macro specification loaded from a YAML file.\n///\n/// Macros are multi-step workflows that can execute templates, captures,\n/// and (with trust) shell commands.\n#[derive(Debug, Clone, Deserialize)]\npub struct MacroSpec {\n    /// Logical name of the macro.\n    pub name: String,\n\n    /// Human-readable description.\n    #[serde(default)]\n    pub description: String,\n\n    /// Variable specifications with prompts and defaults.\n    #[serde(default)]\n    pub vars: Option\u003cVarsMap\u003e,\n\n    /// Steps to execute in order.\n    pub steps: Vec\u003cMacroStep\u003e,\n\n    /// Error handling policy.\n    #[serde(default)]\n    pub on_error: ErrorPolicy,\n}\n\n/// A single step in a macro workflow.\n#[derive(Debug, Clone, Deserialize)]\n#[serde(untagged)]\npub enum MacroStep {\n    /// Execute a template to create a new file.\n    Template(TemplateStep),\n    /// Execute a capture to insert content into an existing file.\n    Capture(CaptureStep),\n    /// Execute a shell command (requires --trust).\n    Shell(ShellStep),\n}\n\n/// Template step: create a new file from a template.\n#[derive(Debug, Clone, Deserialize)]\npub struct TemplateStep {\n    /// Logical template name.\n    pub template: String,\n\n    /// Output path (optional, can use template frontmatter).\n    #[serde(default)]\n    pub output: Option\u003cString\u003e,\n\n    /// Variable overrides for this step.\n    #[serde(default, rename = \"with\")]\n    pub vars_with: HashMap\u003cString, String\u003e,\n}\n\n/// Capture step: insert content into an existing file.\n#[derive(Debug, Clone, Deserialize)]\npub struct CaptureStep {\n    /// Logical capture name.\n    pub capture: String,\n\n    /// Variable overrides for this step.\n    #[serde(default, rename = \"with\")]\n    pub vars_with: HashMap\u003cString, String\u003e,\n}\n\n/// Shell step: execute a shell command.\n#[derive(Debug, Clone, Deserialize)]\npub struct ShellStep {\n    /// Shell command to execute (supports {{var}} substitution).\n    pub shell: String,\n\n    /// Human-readable description of what this command does.\n    #[serde(default)]\n    pub description: String,\n}\n\n/// Error handling policy for macro execution.\n#[derive(Debug, Clone, Default, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"lowercase\")]\npub enum ErrorPolicy {\n    /// Stop execution on first error (default).\n    #[default]\n    Abort,\n    /// Continue with remaining steps after an error.\n    Continue,\n}\n\n/// Information about a discovered macro file.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct MacroInfo {\n    /// Logical name (filename without .yaml extension).\n    pub logical_name: String,\n    /// Full path to the YAML file.\n    pub path: PathBuf,\n}\n\n/// A fully loaded macro ready for execution.\n#[derive(Debug, Clone)]\npub struct LoadedMacro {\n    pub logical_name: String,\n    pub path: PathBuf,\n    pub spec: MacroSpec,\n}\n\n/// Result of executing a single macro step.\n#[derive(Debug, Clone)]\npub struct StepResult {\n    /// Zero-based step index.\n    pub step_index: usize,\n    /// Whether the step succeeded.\n    pub success: bool,\n    /// Human-readable description of what happened.\n    pub message: String,\n    /// Output path if a file was created.\n    pub output_path: Option\u003cPathBuf\u003e,\n}\n\n/// Result of executing an entire macro.\n#[derive(Debug, Clone)]\npub struct MacroResult {\n    /// Name of the macro that was executed.\n    pub macro_name: String,\n    /// Results for each step.\n    pub step_results: Vec\u003cStepResult\u003e,\n    /// Whether all steps succeeded.\n    pub success: bool,\n    /// Summary message.\n    pub message: String,\n}\n\nimpl MacroStep {\n    /// Get a human-readable description of this step.\n    pub fn description(\u0026self) -\u003e String {\n        match self {\n            MacroStep::Template(t) =\u003e format!(\"template: {}\", t.template),\n            MacroStep::Capture(c) =\u003e format!(\"capture: {}\", c.capture),\n            MacroStep::Shell(s) =\u003e {\n                if s.description.is_empty() {\n                    format!(\"shell: {}\", s.shell)\n                } else {\n                    s.description.clone()\n                }\n            }\n        }\n    }\n\n    /// Check if this step requires trust (shell execution).\n    pub fn requires_trust(\u0026self) -\u003e bool {\n        matches!(self, MacroStep::Shell(_))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_macro_spec() {\n        let yaml = r#\"\nname: weekly-review\ndescription: Set up weekly review documents\nvars:\n  week_topic:\n    prompt: \"What's the focus this week?\"\nsteps:\n  - template: weekly-summary\n    with:\n      topic: \"{{week_topic}}\"\n  - capture: archive-tasks\n\"#;\n        let spec: MacroSpec = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(spec.name, \"weekly-review\");\n        assert_eq!(spec.steps.len(), 2);\n        assert!(spec.vars.is_some());\n    }\n\n    #[test]\n    fn test_parse_template_step() {\n        let yaml = r#\"\ntemplate: meeting-note\noutput: \"meetings/{{date}}.md\"\nwith:\n  title: \"Weekly sync\"\n\"#;\n        let step: TemplateStep = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(step.template, \"meeting-note\");\n        assert_eq!(step.output, Some(\"meetings/{{date}}.md\".to_string()));\n        assert_eq!(step.vars_with.get(\"title\"), Some(\u0026\"Weekly sync\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_capture_step() {\n        let yaml = r#\"\ncapture: inbox\nwith:\n  text: \"Review PR #42\"\n\"#;\n        let step: CaptureStep = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(step.capture, \"inbox\");\n        assert_eq!(step.vars_with.get(\"text\"), Some(\u0026\"Review PR #42\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_shell_step() {\n        let yaml = r#\"\nshell: \"git add {{file}}\"\ndescription: Stage file in git\n\"#;\n        let step: ShellStep = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(step.shell, \"git add {{file}}\");\n        assert_eq!(step.description, \"Stage file in git\");\n    }\n\n    #[test]\n    fn test_error_policy_default() {\n        let spec: MacroSpec = serde_yaml::from_str(\n            r#\"\nname: test\nsteps: []\n\"#,\n        )\n        .unwrap();\n        assert_eq!(spec.on_error, ErrorPolicy::Abort);\n    }\n\n    #[test]\n    fn test_error_policy_continue() {\n        let spec: MacroSpec = serde_yaml::from_str(\n            r#\"\nname: test\non_error: continue\nsteps: []\n\"#,\n        )\n        .unwrap();\n        assert_eq!(spec.on_error, ErrorPolicy::Continue);\n    }\n\n    #[test]\n    fn test_step_requires_trust() {\n        let template_step = MacroStep::Template(TemplateStep {\n            template: \"test\".to_string(),\n            output: None,\n            vars_with: HashMap::new(),\n        });\n        let shell_step = MacroStep::Shell(ShellStep {\n            shell: \"echo hello\".to_string(),\n            description: String::new(),\n        });\n\n        assert!(!template_step.requires_trust());\n        assert!(shell_step.requires_trust());\n    }\n}\n","traces":[{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":28}},{"line":155,"address":[],"length":0,"stats":{"Line":49}}],"covered":2,"coverable":10},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","markdown_ast","comrak.rs"],"content":"use comrak::nodes::{NodeValue, Sourcepos};\nuse comrak::{Arena, Options, parse_document};\n\nuse crate::markdown_ast::types::*;\n\n/// Information about a section's position in the document\n#[derive(Debug)]\nstruct SectionBounds {\n    /// The heading info\n    heading: HeadingInfo,\n    /// Byte offset where the heading line ends (after newline)\n    content_start: usize,\n    /// Byte offset where the section content ends (before next heading or EOF)\n    content_end: usize,\n}\n\n/// Parse markdown and insert fragment into the specified section.\n/// Uses string-based insertion to preserve original formatting (including wikilinks).\npub fn insert_into_section(\n    input: \u0026str,\n    section: \u0026SectionMatch,\n    fragment: \u0026str,\n    position: InsertPosition,\n) -\u003e Result\u003cInsertResult, MarkdownAstError\u003e {\n    let trimmed = input.trim();\n    if trimmed.is_empty() {\n        return Err(MarkdownAstError::EmptyDocument);\n    }\n\n    // Handle empty fragment (no-op)\n    if fragment.trim().is_empty() {\n        let headings = find_headings(input);\n        let matched = headings\n            .into_iter()\n            .find(|h| matches_title(\u0026h.title, \u0026section.title, section.case_sensitive))\n            .ok_or_else(|| MarkdownAstError::SectionNotFound(section.title.clone()))?;\n\n        return Ok(InsertResult { content: input.to_string(), matched_heading: matched });\n    }\n\n    // Find section bounds using comrak for parsing\n    let bounds = find_section_bounds(input, section)?;\n\n    // Perform string-based insertion\n    let content = match position {\n        InsertPosition::Begin =\u003e {\n            // Insert right after the heading line\n            let mut result = String::with_capacity(input.len() + fragment.len() + 2);\n            result.push_str(\u0026input[..bounds.content_start]);\n\n            // Add newline before fragment if needed\n            if !result.ends_with('\\n') {\n                result.push('\\n');\n            }\n\n            // Add the fragment\n            result.push_str(fragment);\n\n            // Ensure fragment ends with newline\n            if !fragment.ends_with('\\n') {\n                result.push('\\n');\n            }\n\n            // Add rest of document\n            result.push_str(\u0026input[bounds.content_start..]);\n            result\n        }\n        InsertPosition::End =\u003e {\n            // Insert at the end of the section content, but before trailing blank lines\n            // This preserves section separator formatting\n            let section_content = \u0026input[bounds.content_start..bounds.content_end];\n            let trimmed_end = find_content_end_before_blanks(section_content);\n            let insert_point = bounds.content_start + trimmed_end;\n\n            let mut result = String::with_capacity(input.len() + fragment.len() + 2);\n            result.push_str(\u0026input[..insert_point]);\n\n            // Ensure there's a newline before the fragment\n            if insert_point \u003e 0 \u0026\u0026 !input[..insert_point].ends_with('\\n') {\n                result.push('\\n');\n            }\n\n            // Add the fragment\n            result.push_str(fragment);\n\n            // Ensure fragment ends with newline\n            if !fragment.ends_with('\\n') {\n                result.push('\\n');\n            }\n\n            // Add the trailing blank lines and rest of document\n            // If there were trailing blanks, add one blank line for section separation\n            let had_trailing_blanks = trimmed_end \u003c section_content.len();\n            if had_trailing_blanks \u0026\u0026 bounds.content_end \u003c input.len() {\n                // There's a next section, add a blank line separator\n                result.push('\\n');\n            }\n\n            // Add rest of document (starting from the next section)\n            result.push_str(\u0026input[bounds.content_end..]);\n            result\n        }\n    };\n\n    Ok(InsertResult { content, matched_heading: bounds.heading })\n}\n\n/// Find the bounds of a section in the document\nfn find_section_bounds(\n    input: \u0026str,\n    section: \u0026SectionMatch,\n) -\u003e Result\u003cSectionBounds, MarkdownAstError\u003e {\n    let arena = Arena::new();\n    let options = default_options();\n    let root = parse_document(\u0026arena, input, \u0026options);\n\n    let mut target_heading: Option\u003c(HeadingInfo, Sourcepos)\u003e = None;\n    let mut headings_with_pos: Vec\u003c(HeadingInfo, Sourcepos)\u003e = Vec::new();\n\n    // Collect all headings with their source positions\n    for node in root.descendants() {\n        if let NodeValue::Heading(ref heading) = node.data.borrow().value {\n            let title = collect_text(node);\n            let sourcepos = node.data.borrow().sourcepos;\n            let info = HeadingInfo { title: title.clone(), level: heading.level };\n\n            if target_heading.is_none()\n                \u0026\u0026 matches_title(\u0026title, \u0026section.title, section.case_sensitive)\n            {\n                target_heading = Some((info.clone(), sourcepos));\n            }\n\n            headings_with_pos.push((info, sourcepos));\n        }\n    }\n\n    let (heading, heading_pos) = target_heading\n        .ok_or_else(|| MarkdownAstError::SectionNotFound(section.title.clone()))?;\n\n    // Calculate content_start: byte offset after the heading line\n    let content_start = line_end_offset(input, heading_pos.end.line);\n\n    // Calculate content_end: before the next heading of same or higher level, or EOF\n    let content_end =\n        find_section_end_offset(input, \u0026heading, \u0026headings_with_pos, heading_pos);\n\n    Ok(SectionBounds { heading, content_start, content_end })\n}\n\n/// Get the byte offset at the end of a line (after newline if present)\nfn line_end_offset(input: \u0026str, line_num: usize) -\u003e usize {\n    let mut current_line = 1;\n    let mut offset = 0;\n\n    for (i, ch) in input.char_indices() {\n        if current_line == line_num \u0026\u0026 ch == '\\n' {\n            return i + 1;\n        }\n        if ch == '\\n' {\n            current_line += 1;\n        }\n        offset = i + ch.len_utf8();\n    }\n\n    // If we reach EOF on the target line\n    offset\n}\n\n/// Find the byte offset where a section ends\nfn find_section_end_offset(\n    input: \u0026str,\n    target_heading: \u0026HeadingInfo,\n    all_headings: \u0026[(HeadingInfo, Sourcepos)],\n    target_pos: Sourcepos,\n) -\u003e usize {\n    // Find the next heading of same or higher level\n    for (heading, pos) in all_headings {\n        // Skip headings before or at the target\n        if pos.start.line \u003c= target_pos.start.line {\n            continue;\n        }\n\n        // Found a heading of same or higher level - section ends here\n        if heading.level \u003c= target_heading.level {\n            // Return the byte offset at the start of this heading's line\n            return line_start_offset(input, pos.start.line);\n        }\n    }\n\n    // Section extends to EOF\n    input.len()\n}\n\n/// Get the byte offset at the start of a line\nfn line_start_offset(input: \u0026str, line_num: usize) -\u003e usize {\n    if line_num \u003c= 1 {\n        return 0;\n    }\n\n    let mut current_line = 1;\n\n    for (i, ch) in input.char_indices() {\n        if ch == '\\n' {\n            current_line += 1;\n            if current_line == line_num {\n                return i + 1;\n            }\n        }\n    }\n\n    input.len()\n}\n\n/// Find the end of actual content, before any trailing blank lines.\n/// Returns a byte offset relative to the start of the input string.\nfn find_content_end_before_blanks(content: \u0026str) -\u003e usize {\n    // Work backwards from the end to find the last non-blank line\n    let bytes = content.as_bytes();\n    let mut end = bytes.len();\n\n    // Skip trailing whitespace/newlines\n    while end \u003e 0\n        \u0026\u0026 (bytes[end - 1] == b'\\n' || bytes[end - 1] == b' ' || bytes[end - 1] == b'\\t')\n    {\n        end -= 1;\n    }\n\n    // Now find the end of the last content line (include its newline)\n    // We want to return the position after the newline of the last content line\n    if end \u003c bytes.len() {\n        // Find the newline after the content\n        if let Some(newline_offset) = bytes[end..].iter().position(|\u0026b| b == b'\\n') {\n            return end + newline_offset + 1;\n        }\n    }\n\n    // No trailing newline found, return the trimmed position\n    end\n}\n\n/// Find all headings in the document\npub fn find_headings(input: \u0026str) -\u003e Vec\u003cHeadingInfo\u003e {\n    let arena = Arena::new();\n    let options = default_options();\n    let root = parse_document(\u0026arena, input, \u0026options);\n\n    let mut headings = Vec::new();\n\n    for node in root.descendants() {\n        if let NodeValue::Heading(ref heading) = node.data.borrow().value {\n            let title = collect_text(node);\n\n            headings.push(HeadingInfo { title, level: heading.level });\n        }\n    }\n\n    headings\n}\n\n/// Find section by match criteria (returns first match)\npub fn find_section(input: \u0026str, section: \u0026SectionMatch) -\u003e Option\u003cHeadingInfo\u003e {\n    find_headings(input)\n        .into_iter()\n        .find(|h| matches_title(\u0026h.title, \u0026section.title, section.case_sensitive))\n}\n\n// --- Internal helpers ---\n\nfn default_options() -\u003e Options\u003c'static\u003e {\n    let mut options = Options::default();\n    // Enable GFM extensions for compatibility\n    options.extension.strikethrough = true;\n    options.extension.table = true;\n    options.extension.autolink = true;\n    options.extension.tasklist = true;\n    options.extension.footnotes = true;\n    options.extension.description_lists = true;\n\n    // Parse options\n    options.parse.smart = false; // Don't convert quotes/dashes\n\n    // Render options for CommonMark output\n    options.render.hardbreaks = false;\n    options.render.github_pre_lang = true;\n    options.render.unsafe_ = true; // Allow raw HTML passthrough\n\n    options\n}\n\nfn matches_title(heading_title: \u0026str, search_title: \u0026str, case_sensitive: bool) -\u003e bool {\n    let h = heading_title.trim();\n    let s = search_title.trim();\n\n    if case_sensitive { h == s } else { h.eq_ignore_ascii_case(s) }\n}\n\nfn collect_text\u003c'a\u003e(node: \u0026'a comrak::nodes::AstNode\u003c'a\u003e) -\u003e String {\n    let mut text = String::new();\n    for child in node.descendants() {\n        if let NodeValue::Text(ref t) = child.data.borrow().value {\n            text.push_str(t);\n        }\n    }\n    text\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":57}},{"line":25,"address":[],"length":0,"stats":{"Line":171}},{"line":26,"address":[],"length":0,"stats":{"Line":114}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":106}},{"line":32,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":204}},{"line":45,"address":[],"length":0,"stats":{"Line":92}},{"line":48,"address":[],"length":0,"stats":{"Line":95}},{"line":49,"address":[],"length":0,"stats":{"Line":57}},{"line":52,"address":[],"length":0,"stats":{"Line":19}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":57}},{"line":60,"address":[],"length":0,"stats":{"Line":22}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":57}},{"line":66,"address":[],"length":0,"stats":{"Line":19}},{"line":71,"address":[],"length":0,"stats":{"Line":81}},{"line":72,"address":[],"length":0,"stats":{"Line":81}},{"line":73,"address":[],"length":0,"stats":{"Line":54}},{"line":75,"address":[],"length":0,"stats":{"Line":135}},{"line":76,"address":[],"length":0,"stats":{"Line":81}},{"line":79,"address":[],"length":0,"stats":{"Line":54}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":81}},{"line":87,"address":[],"length":0,"stats":{"Line":32}},{"line":88,"address":[],"length":0,"stats":{"Line":5}},{"line":93,"address":[],"length":0,"stats":{"Line":81}},{"line":94,"address":[],"length":0,"stats":{"Line":90}},{"line":96,"address":[],"length":0,"stats":{"Line":21}},{"line":100,"address":[],"length":0,"stats":{"Line":81}},{"line":101,"address":[],"length":0,"stats":{"Line":27}},{"line":105,"address":[],"length":0,"stats":{"Line":46}},{"line":109,"address":[],"length":0,"stats":{"Line":51}},{"line":113,"address":[],"length":0,"stats":{"Line":102}},{"line":114,"address":[],"length":0,"stats":{"Line":102}},{"line":115,"address":[],"length":0,"stats":{"Line":255}},{"line":117,"address":[],"length":0,"stats":{"Line":153}},{"line":118,"address":[],"length":0,"stats":{"Line":153}},{"line":121,"address":[],"length":0,"stats":{"Line":747}},{"line":122,"address":[],"length":0,"stats":{"Line":777}},{"line":123,"address":[],"length":0,"stats":{"Line":396}},{"line":124,"address":[],"length":0,"stats":{"Line":264}},{"line":125,"address":[],"length":0,"stats":{"Line":396}},{"line":127,"address":[],"length":0,"stats":{"Line":264}},{"line":128,"address":[],"length":0,"stats":{"Line":336}},{"line":130,"address":[],"length":0,"stats":{"Line":138}},{"line":133,"address":[],"length":0,"stats":{"Line":396}},{"line":137,"address":[],"length":0,"stats":{"Line":143}},{"line":138,"address":[],"length":0,"stats":{"Line":66}},{"line":141,"address":[],"length":0,"stats":{"Line":184}},{"line":144,"address":[],"length":0,"stats":{"Line":46}},{"line":145,"address":[],"length":0,"stats":{"Line":230}},{"line":147,"address":[],"length":0,"stats":{"Line":92}},{"line":151,"address":[],"length":0,"stats":{"Line":46}},{"line":152,"address":[],"length":0,"stats":{"Line":92}},{"line":153,"address":[],"length":0,"stats":{"Line":92}},{"line":155,"address":[],"length":0,"stats":{"Line":2802}},{"line":156,"address":[],"length":0,"stats":{"Line":1840}},{"line":157,"address":[],"length":0,"stats":{"Line":46}},{"line":159,"address":[],"length":0,"stats":{"Line":1390}},{"line":160,"address":[],"length":0,"stats":{"Line":81}},{"line":162,"address":[],"length":0,"stats":{"Line":2618}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":46}},{"line":177,"address":[],"length":0,"stats":{"Line":346}},{"line":179,"address":[],"length":0,"stats":{"Line":110}},{"line":180,"address":[],"length":0,"stats":{"Line":78}},{"line":184,"address":[],"length":0,"stats":{"Line":32}},{"line":186,"address":[],"length":0,"stats":{"Line":90}},{"line":191,"address":[],"length":0,"stats":{"Line":32}},{"line":195,"address":[],"length":0,"stats":{"Line":30}},{"line":196,"address":[],"length":0,"stats":{"Line":30}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":60}},{"line":202,"address":[],"length":0,"stats":{"Line":4178}},{"line":203,"address":[],"length":0,"stats":{"Line":2059}},{"line":204,"address":[],"length":0,"stats":{"Line":213}},{"line":205,"address":[],"length":0,"stats":{"Line":213}},{"line":206,"address":[],"length":0,"stats":{"Line":30}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":27}},{"line":218,"address":[],"length":0,"stats":{"Line":81}},{"line":219,"address":[],"length":0,"stats":{"Line":81}},{"line":222,"address":[],"length":0,"stats":{"Line":79}},{"line":223,"address":[],"length":0,"stats":{"Line":127}},{"line":225,"address":[],"length":0,"stats":{"Line":52}},{"line":230,"address":[],"length":0,"stats":{"Line":54}},{"line":232,"address":[],"length":0,"stats":{"Line":108}},{"line":233,"address":[],"length":0,"stats":{"Line":27}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":19}},{"line":243,"address":[],"length":0,"stats":{"Line":38}},{"line":244,"address":[],"length":0,"stats":{"Line":38}},{"line":245,"address":[],"length":0,"stats":{"Line":95}},{"line":247,"address":[],"length":0,"stats":{"Line":38}},{"line":249,"address":[],"length":0,"stats":{"Line":229}},{"line":250,"address":[],"length":0,"stats":{"Line":287}},{"line":251,"address":[],"length":0,"stats":{"Line":192}},{"line":253,"address":[],"length":0,"stats":{"Line":144}},{"line":257,"address":[],"length":0,"stats":{"Line":19}},{"line":261,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":8}},{"line":264,"address":[],"length":0,"stats":{"Line":20}},{"line":269,"address":[],"length":0,"stats":{"Line":70}},{"line":270,"address":[],"length":0,"stats":{"Line":140}},{"line":272,"address":[],"length":0,"stats":{"Line":70}},{"line":273,"address":[],"length":0,"stats":{"Line":70}},{"line":274,"address":[],"length":0,"stats":{"Line":70}},{"line":275,"address":[],"length":0,"stats":{"Line":70}},{"line":276,"address":[],"length":0,"stats":{"Line":70}},{"line":277,"address":[],"length":0,"stats":{"Line":70}},{"line":280,"address":[],"length":0,"stats":{"Line":70}},{"line":283,"address":[],"length":0,"stats":{"Line":70}},{"line":284,"address":[],"length":0,"stats":{"Line":70}},{"line":285,"address":[],"length":0,"stats":{"Line":70}},{"line":287,"address":[],"length":0,"stats":{"Line":70}},{"line":290,"address":[],"length":0,"stats":{"Line":90}},{"line":291,"address":[],"length":0,"stats":{"Line":270}},{"line":292,"address":[],"length":0,"stats":{"Line":270}},{"line":294,"address":[],"length":0,"stats":{"Line":352}},{"line":297,"address":[],"length":0,"stats":{"Line":180}},{"line":298,"address":[],"length":0,"stats":{"Line":360}},{"line":299,"address":[],"length":0,"stats":{"Line":720}},{"line":300,"address":[],"length":0,"stats":{"Line":720}},{"line":301,"address":[],"length":0,"stats":{"Line":360}},{"line":304,"address":[],"length":0,"stats":{"Line":180}}],"covered":125,"coverable":131},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","markdown_ast","editor.rs"],"content":"use crate::markdown_ast::comrak;\nuse crate::markdown_ast::types::*;\n\n/// High-level API for Markdown AST operations\npub struct MarkdownEditor;\n\nimpl MarkdownEditor {\n    /// Insert a fragment into a named section\n    ///\n    /// # Arguments\n    /// * `input` - The source Markdown document\n    /// * `section` - Section matching configuration\n    /// * `fragment` - Markdown content to insert\n    /// * `position` - Where in the section to insert (Begin or End)\n    ///\n    /// # Returns\n    /// The modified document and metadata about the matched section\n    ///\n    /// # Errors\n    /// * `SectionNotFound` - No heading matches the section specification\n    /// * `EmptyDocument` - Input is empty or whitespace-only\n    pub fn insert_into_section(\n        input: \u0026str,\n        section: \u0026SectionMatch,\n        fragment: \u0026str,\n        position: InsertPosition,\n    ) -\u003e Result\u003cInsertResult, MarkdownAstError\u003e {\n        comrak::insert_into_section(input, section, fragment, position)\n    }\n\n    /// Find all headings in a document\n    ///\n    /// Useful for validation, debugging, and building section selectors\n    pub fn find_headings(input: \u0026str) -\u003e Vec\u003cHeadingInfo\u003e {\n        comrak::find_headings(input)\n    }\n\n    /// Check if a section exists in the document\n    pub fn section_exists(input: \u0026str, section: \u0026SectionMatch) -\u003e bool {\n        comrak::find_section(input, section).is_some()\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":57}},{"line":28,"address":[],"length":0,"stats":{"Line":285}},{"line":34,"address":[],"length":0,"stats":{"Line":13}},{"line":35,"address":[],"length":0,"stats":{"Line":26}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":12}}],"covered":6,"coverable":6},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","markdown_ast","mod.rs"],"content":"pub mod comrak;\npub mod editor;\npub mod types;\n\n// Re-export primary API\npub use editor::MarkdownEditor;\npub use types::{\n    HeadingInfo, InsertPosition, InsertResult, MarkdownAstError, SectionMatch,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","markdown_ast","types.rs"],"content":"use thiserror::Error;\n\n/// Position within a section where content should be inserted\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum InsertPosition {\n    /// Insert immediately after the section heading\n    #[default]\n    Begin,\n    /// Insert at the end of the section, before the next heading\n    End,\n}\n\n/// Configuration for section matching\n#[derive(Debug, Clone)]\npub struct SectionMatch {\n    /// The section title to find (compared after trimming)\n    pub title: String,\n    /// Use case-sensitive matching (default: false)\n    pub case_sensitive: bool,\n}\n\nimpl SectionMatch {\n    pub fn new(title: impl Into\u003cString\u003e) -\u003e Self {\n        Self { title: title.into(), case_sensitive: false }\n    }\n\n    pub fn case_sensitive(mut self, value: bool) -\u003e Self {\n        self.case_sensitive = value;\n        self\n    }\n}\n\n/// Information about a heading found in the document\n#[derive(Debug, Clone)]\npub struct HeadingInfo {\n    /// The heading text content\n    pub title: String,\n    /// The heading level (1-6)\n    pub level: u8,\n}\n\n/// Result of an insertion operation\n#[derive(Debug, Clone)]\npub struct InsertResult {\n    /// The modified markdown content\n    pub content: String,\n    /// Information about the matched section\n    pub matched_heading: HeadingInfo,\n}\n\n#[derive(Debug, Error)]\npub enum MarkdownAstError {\n    #[error(\"section not found: {0}\")]\n    SectionNotFound(String),\n\n    #[error(\"document is empty or contains no content\")]\n    EmptyDocument,\n\n    #[error(\"failed to render markdown: {0}\")]\n    RenderError(String),\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":35}},{"line":24,"address":[],"length":0,"stats":{"Line":35}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":4}}],"covered":5,"coverable":5},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","rename","detector.rs"],"content":"//! Reference detection for rename operations.\n//!\n//! Finds all references to a note in other files, with exact byte positions\n//! for format-preserving updates.\n\nuse std::path::Path;\nuse std::sync::LazyLock;\n\nuse regex::Regex;\n\nuse crate::frontmatter;\nuse crate::rename::types::{Reference, ReferenceType, RenameError};\n\n// Regex patterns for reference detection\nstatic WIKILINK_RE: LazyLock\u003cRegex\u003e = LazyLock::new(|| {\n    // Matches [[target]] or [[target|alias]] or [[target#section]] or [[target#section|alias]]\n    // Captures:\n    // 1: target (note name/path, may include #section)\n    // 2: alias (if present)\n    Regex::new(r\"\\[\\[([^\\]|#]+(?:#[^\\]|]+)?)(?:\\|([^\\]]+))?\\]\\]\").unwrap()\n});\n\nstatic MARKDOWN_LINK_RE: LazyLock\u003cRegex\u003e = LazyLock::new(|| {\n    // Matches [text](url)\n    // Captures:\n    // 1: text\n    // 2: url\n    Regex::new(r\"\\[([^\\]]+)\\]\\(([^)]+)\\)\").unwrap()\n});\n\n/// Find all references to a target note in a file's content.\n///\n/// Returns references with exact byte positions for replacement.\npub fn find_references_in_content(\n    content: \u0026str,\n    source_path: \u0026Path,\n    target_path: \u0026Path,\n    vault_root: \u0026Path,\n) -\u003e Vec\u003cReference\u003e {\n    let mut references = Vec::new();\n\n    // Get the target's basename and relative path for matching\n    let target_basename = target_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n\n    let target_rel = target_path.strip_prefix(vault_root).unwrap_or(target_path);\n\n    // Find references in body content\n    let body_refs =\n        find_body_references(content, source_path, target_basename, target_rel);\n    references.extend(body_refs);\n\n    // Find references in frontmatter\n    let fm_refs = find_frontmatter_references(content, source_path, target_basename);\n    references.extend(fm_refs);\n\n    references\n}\n\nfn find_body_references(\n    content: \u0026str,\n    source_path: \u0026Path,\n    target_basename: \u0026str,\n    target_rel: \u0026Path,\n) -\u003e Vec\u003cReference\u003e {\n    let mut references = Vec::new();\n\n    // Track byte offset for each line\n    let mut line_start_offset = 0;\n\n    for (line_idx, line) in content.lines().enumerate() {\n        let line_number = (line_idx + 1) as u32;\n\n        // Find wikilinks in this line\n        for cap in WIKILINK_RE.captures_iter(line) {\n            let full_match = cap.get(0).unwrap();\n            let target_text = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n            let alias = cap.get(2).map(|m| m.as_str().to_string());\n\n            // Parse target (may include #section)\n            let (note_ref, section) = parse_wikilink_target(target_text);\n\n            if matches_target(note_ref, target_basename, target_rel) {\n                let start = line_start_offset + full_match.start();\n                let end = line_start_offset + full_match.end();\n                let column = (full_match.start() + 1) as u32;\n\n                let ref_type = match (\u0026section, \u0026alias) {\n                    (Some(_), Some(_)) =\u003e ReferenceType::WikilinkWithSectionAndAlias,\n                    (Some(_), None) =\u003e ReferenceType::WikilinkWithSection,\n                    (None, Some(_)) =\u003e ReferenceType::WikilinkWithAlias,\n                    (None, None) =\u003e ReferenceType::Wikilink,\n                };\n\n                references.push(Reference {\n                    source_path: source_path.to_path_buf(),\n                    line_number,\n                    column,\n                    start,\n                    end,\n                    original: full_match.as_str().to_string(),\n                    ref_type,\n                    alias,\n                    section,\n                    target_as_written: note_ref.to_string(),\n                });\n            }\n        }\n\n        // Find markdown links in this line\n        for cap in MARKDOWN_LINK_RE.captures_iter(line) {\n            let full_match = cap.get(0).unwrap();\n            let link_text = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n            let url = cap.get(2).map(|m| m.as_str()).unwrap_or(\"\");\n\n            // Skip external URLs\n            if url.starts_with(\"http://\") || url.starts_with(\"https://\") {\n                continue;\n            }\n\n            if matches_markdown_target(url, target_basename, target_rel) {\n                let start = line_start_offset + full_match.start();\n                let end = line_start_offset + full_match.end();\n                let column = (full_match.start() + 1) as u32;\n\n                references.push(Reference {\n                    source_path: source_path.to_path_buf(),\n                    line_number,\n                    column,\n                    start,\n                    end,\n                    original: full_match.as_str().to_string(),\n                    ref_type: ReferenceType::MarkdownLink,\n                    alias: Some(link_text.to_string()),\n                    section: None,\n                    target_as_written: url.to_string(),\n                });\n            }\n        }\n\n        // Move to next line (add line length + newline character)\n        line_start_offset += line.len() + 1; // +1 for \\n\n    }\n\n    references\n}\n\nfn find_frontmatter_references(\n    content: \u0026str,\n    source_path: \u0026Path,\n    target_basename: \u0026str,\n) -\u003e Vec\u003cReference\u003e {\n    let mut references = Vec::new();\n\n    // Parse frontmatter\n    let parsed = match frontmatter::parse(content) {\n        Ok(p) =\u003e p,\n        Err(_) =\u003e return references,\n    };\n\n    let fm = match parsed.frontmatter {\n        Some(fm) =\u003e fm,\n        None =\u003e return references,\n    };\n\n    // Known reference fields\n    let ref_fields = [\"project\", \"parent\", \"related\", \"blocks\", \"blocked_by\"];\n\n    // Find frontmatter section bounds\n    let fm_bounds = find_frontmatter_bounds(content);\n\n    for field in \u0026ref_fields {\n        if let Some(value) = fm.fields.get(*field) {\n            // Handle single string value\n            if let Some(s) = value.as_str()\n                \u0026\u0026 matches_frontmatter_ref(s, target_basename)\n                \u0026\u0026 let Some((start, end)) =\n                    find_frontmatter_field_value(content, field, s, \u0026fm_bounds)\n            {\n                references.push(Reference {\n                    source_path: source_path.to_path_buf(),\n                    line_number: 0, // Frontmatter\n                    column: 0,\n                    start,\n                    end,\n                    original: s.to_string(),\n                    ref_type: ReferenceType::FrontmatterField {\n                        field: field.to_string(),\n                    },\n                    alias: None,\n                    section: None,\n                    target_as_written: s.to_string(),\n                });\n            }\n\n            // Handle array of strings\n            if let Some(arr) = value.as_sequence() {\n                for (idx, item) in arr.iter().enumerate() {\n                    if let Some(s) = item.as_str()\n                        \u0026\u0026 matches_frontmatter_ref(s, target_basename)\n                        \u0026\u0026 let Some((start, end)) =\n                            find_frontmatter_list_item(content, field, s, idx, \u0026fm_bounds)\n                    {\n                        references.push(Reference {\n                            source_path: source_path.to_path_buf(),\n                            line_number: 0,\n                            column: 0,\n                            start,\n                            end,\n                            original: s.to_string(),\n                            ref_type: ReferenceType::FrontmatterList {\n                                field: field.to_string(),\n                                index: idx,\n                            },\n                            alias: None,\n                            section: None,\n                            target_as_written: s.to_string(),\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    references\n}\n\n/// Parse a wikilink target, separating the note reference from the section anchor.\nfn parse_wikilink_target(target: \u0026str) -\u003e (\u0026str, Option\u003cString\u003e) {\n    if let Some(hash_pos) = target.find('#') {\n        let note = \u0026target[..hash_pos];\n        let section = \u0026target[hash_pos + 1..];\n        (note, Some(section.to_string()))\n    } else {\n        (target, None)\n    }\n}\n\n/// Check if a wikilink reference matches the target note.\nfn matches_target(reference: \u0026str, target_basename: \u0026str, target_rel: \u0026Path) -\u003e bool {\n    let ref_lower = reference.to_lowercase();\n    let basename_lower = target_basename.to_lowercase();\n\n    // Direct basename match (most common case)\n    if ref_lower == basename_lower {\n        return true;\n    }\n\n    // Match with .md extension\n    if ref_lower == format!(\"{}.md\", basename_lower) {\n        return true;\n    }\n\n    // Match full relative path\n    let target_rel_str = target_rel.to_string_lossy().to_lowercase();\n    if ref_lower == target_rel_str {\n        return true;\n    }\n\n    // Match relative path without .md\n    let target_no_ext = target_rel_str.strip_suffix(\".md\").unwrap_or(\u0026target_rel_str);\n    if ref_lower == target_no_ext {\n        return true;\n    }\n\n    false\n}\n\n/// Check if a markdown link URL matches the target note.\nfn matches_markdown_target(url: \u0026str, target_basename: \u0026str, target_rel: \u0026Path) -\u003e bool {\n    // Normalize the URL path\n    let url_normalized = url.trim_start_matches(\"./\").trim_start_matches(\"../\");\n\n    let url_lower = url_normalized.to_lowercase();\n    let basename_lower = target_basename.to_lowercase();\n    let target_rel_str = target_rel.to_string_lossy().to_lowercase();\n\n    // Match basename with .md\n    if url_lower == format!(\"{}.md\", basename_lower) {\n        return true;\n    }\n\n    // Match relative path\n    if url_lower == target_rel_str {\n        return true;\n    }\n\n    // Check if URL ends with target path (for relative paths)\n    if url_lower.ends_with(\u0026target_rel_str) {\n        return true;\n    }\n\n    // Check basename match in URL\n    if let Some(filename) = Path::new(url_normalized).file_name() {\n        let filename_str = filename.to_string_lossy().to_lowercase();\n        if filename_str == format!(\"{}.md\", basename_lower) {\n            return true;\n        }\n    }\n\n    false\n}\n\n/// Check if a frontmatter reference matches the target note.\nfn matches_frontmatter_ref(reference: \u0026str, target_basename: \u0026str) -\u003e bool {\n    let ref_lower = reference.to_lowercase();\n    let basename_lower = target_basename.to_lowercase();\n\n    ref_lower == basename_lower || ref_lower == format!(\"{}.md\", basename_lower)\n}\n\n/// Find the bounds of the frontmatter section.\nfn find_frontmatter_bounds(content: \u0026str) -\u003e Option\u003c(usize, usize)\u003e {\n    if !content.starts_with(\"---\") {\n        return None;\n    }\n\n    let start = 4; // After \"---\\n\"\n    content[start..].find(\"\\n---\").map(|end_marker| (0, start + end_marker + 4))\n}\n\n/// Find the byte position of a frontmatter field value.\nfn find_frontmatter_field_value(\n    content: \u0026str,\n    field: \u0026str,\n    value: \u0026str,\n    bounds: \u0026Option\u003c(usize, usize)\u003e,\n) -\u003e Option\u003c(usize, usize)\u003e {\n    let (fm_start, fm_end) = bounds.as_ref()?;\n    let fm_content = \u0026content[*fm_start..*fm_end];\n\n    // Look for pattern: \"field: value\" or \"field: 'value'\" or 'field: \"value\"'\n    let patterns = [\n        format!(\"{}: {}\", field, value),\n        format!(\"{}: '{}'\", field, value),\n        format!(\"{}: \\\"{}\\\"\", field, value),\n    ];\n\n    for pattern in \u0026patterns {\n        if let Some(pos) = fm_content.find(pattern.as_str()) {\n            let value_start = pos + field.len() + 2; // +2 for \": \"\n            let start = *fm_start + value_start;\n\n            // Adjust for quotes if present\n            let actual_start = if fm_content[value_start..].starts_with('\\'')\n                || fm_content[value_start..].starts_with('\"')\n            {\n                start + 1\n            } else {\n                start\n            };\n\n            return Some((actual_start, actual_start + value.len()));\n        }\n    }\n\n    None\n}\n\n/// Find the byte position of a frontmatter list item.\nfn find_frontmatter_list_item(\n    content: \u0026str,\n    field: \u0026str,\n    value: \u0026str,\n    _index: usize,\n    bounds: \u0026Option\u003c(usize, usize)\u003e,\n) -\u003e Option\u003c(usize, usize)\u003e {\n    let (fm_start, fm_end) = bounds.as_ref()?;\n    let fm_content = \u0026content[*fm_start..*fm_end];\n\n    // Find the field first\n    let field_pattern = format!(\"{}:\", field);\n    let field_pos = fm_content.find(\u0026field_pattern)?;\n\n    // Search after the field for the value in list format\n    let after_field = \u0026fm_content[field_pos..];\n\n    // Look for \"- value\" pattern (YAML list item)\n    let list_patterns =\n        [format!(\"- {}\", value), format!(\"- '{}'\", value), format!(\"- \\\"{}\\\"\", value)];\n\n    for pattern in \u0026list_patterns {\n        if let Some(pos) = after_field.find(pattern.as_str()) {\n            let value_start = pos + 2; // +2 for \"- \"\n            let start = *fm_start + field_pos + value_start;\n\n            // Adjust for quotes\n            let actual_start = if after_field[value_start..].starts_with('\\'')\n                || after_field[value_start..].starts_with('\"')\n            {\n                start + 1\n            } else {\n                start\n            };\n\n            return Some((actual_start, actual_start + value.len()));\n        }\n    }\n\n    // Also check inline array format: [item1, item2]\n    let inline_patterns = [\n        format!(\"[{}\", value),\n        format!(\", {}\", value),\n        format!(\"['{}']\", value),\n        format!(\", '{}']\", value),\n        format!(\"[\\\"{}\\\"]\", value),\n        format!(\", \\\"{}\\\"]\", value),\n    ];\n\n    for pattern in \u0026inline_patterns {\n        if let Some(pos) = after_field.find(pattern.as_str()) {\n            // Find where the value actually starts\n            let pattern_value_offset = if pattern.starts_with('[') { 1 } else { 2 };\n            let value_start = pos + pattern_value_offset;\n            let start = *fm_start + field_pos + value_start;\n\n            // Adjust for quotes\n            let actual_start = if after_field[value_start..].starts_with('\\'')\n                || after_field[value_start..].starts_with('\"')\n            {\n                start + 1\n            } else {\n                start\n            };\n\n            return Some((actual_start, actual_start + value.len()));\n        }\n    }\n\n    None\n}\n\n/// Read a file and find all references to a target note.\n#[allow(dead_code)]\npub fn find_references_in_file(\n    source_path: \u0026Path,\n    target_path: \u0026Path,\n    vault_root: \u0026Path,\n) -\u003e Result\u003cVec\u003cReference\u003e, RenameError\u003e {\n    let content = std::fs::read_to_string(source_path).map_err(|e| {\n        RenameError::ReadError { path: source_path.to_path_buf(), source: e }\n    })?;\n\n    Ok(find_references_in_content(\u0026content, source_path, target_path, vault_root))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_find_wikilink_basic() {\n        let content = \"Here is a link to [[my-note]] in the text.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert_eq!(refs[0].original, \"[[my-note]]\");\n        assert_eq!(refs[0].ref_type, ReferenceType::Wikilink);\n        // \"Here is a link to \" = 18 chars, so [[my-note]] starts at 18\n        assert_eq!(refs[0].start, 18);\n        assert_eq!(refs[0].end, 29);\n    }\n\n    #[test]\n    fn test_find_wikilink_with_alias() {\n        let content = \"Link to [[my-note|My Note Title]] here.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert_eq!(refs[0].ref_type, ReferenceType::WikilinkWithAlias);\n        assert_eq!(refs[0].alias, Some(\"My Note Title\".to_string()));\n    }\n\n    #[test]\n    fn test_find_wikilink_with_section() {\n        let content = \"See [[my-note#section]] for details.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert_eq!(refs[0].ref_type, ReferenceType::WikilinkWithSection);\n        assert_eq!(refs[0].section, Some(\"section\".to_string()));\n    }\n\n    #[test]\n    fn test_find_markdown_link() {\n        let content = \"Check out [this note](./my-note.md) for more.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert_eq!(refs[0].ref_type, ReferenceType::MarkdownLink);\n        assert_eq!(refs[0].alias, Some(\"this note\".to_string()));\n    }\n\n    #[test]\n    fn test_find_multiple_references() {\n        let content = r#\"# Notes\n\nLink to [[my-note]] and also [[my-note|alias]].\nAnd a [markdown link](my-note.md) too.\n\"#;\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 3);\n    }\n\n    #[test]\n    fn test_case_insensitive_matching() {\n        let content = \"Link to [[My-Note]] here.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n    }\n\n    #[test]\n    fn test_no_match_different_note() {\n        let content = \"Link to [[other-note]] here.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 0);\n    }\n\n    #[test]\n    fn test_skip_external_urls() {\n        let content = \"See [example](https://example.com) for details.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/example.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 0);\n    }\n\n    #[test]\n    fn test_line_numbers() {\n        let content = \"Line 1\\nLine 2 with [[my-note]]\\nLine 3\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert_eq!(refs[0].line_number, 2);\n    }\n\n    #[test]\n    fn test_frontmatter_field_reference() {\n        let content = r#\"---\ntitle: Test\nproject: my-note\n---\n# Content\n\"#;\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert!(matches!(refs[0].ref_type, ReferenceType::FrontmatterField { .. }));\n    }\n\n    #[test]\n    fn test_frontmatter_list_reference() {\n        let content = r#\"---\ntitle: Test\nrelated:\n  - other-note\n  - my-note\n  - another-note\n---\n# Content\n\"#;\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert!(matches!(refs[0].ref_type, ReferenceType::FrontmatterList { .. }));\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":24}},{"line":43,"address":[],"length":0,"stats":{"Line":96}},{"line":45,"address":[],"length":0,"stats":{"Line":72}},{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":60}},{"line":50,"address":[],"length":0,"stats":{"Line":36}},{"line":53,"address":[],"length":0,"stats":{"Line":60}},{"line":54,"address":[],"length":0,"stats":{"Line":36}},{"line":56,"address":[],"length":0,"stats":{"Line":12}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":65,"address":[],"length":0,"stats":{"Line":24}},{"line":68,"address":[],"length":0,"stats":{"Line":24}},{"line":70,"address":[],"length":0,"stats":{"Line":96}},{"line":71,"address":[],"length":0,"stats":{"Line":60}},{"line":74,"address":[],"length":0,"stats":{"Line":99}},{"line":75,"address":[],"length":0,"stats":{"Line":36}},{"line":76,"address":[],"length":0,"stats":{"Line":72}},{"line":77,"address":[],"length":0,"stats":{"Line":40}},{"line":80,"address":[],"length":0,"stats":{"Line":27}},{"line":82,"address":[],"length":0,"stats":{"Line":36}},{"line":83,"address":[],"length":0,"stats":{"Line":24}},{"line":84,"address":[],"length":0,"stats":{"Line":24}},{"line":85,"address":[],"length":0,"stats":{"Line":16}},{"line":87,"address":[],"length":0,"stats":{"Line":24}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":5}},{"line":94,"address":[],"length":0,"stats":{"Line":24}},{"line":95,"address":[],"length":0,"stats":{"Line":24}},{"line":96,"address":[],"length":0,"stats":{"Line":16}},{"line":97,"address":[],"length":0,"stats":{"Line":16}},{"line":98,"address":[],"length":0,"stats":{"Line":16}},{"line":99,"address":[],"length":0,"stats":{"Line":16}},{"line":100,"address":[],"length":0,"stats":{"Line":24}},{"line":101,"address":[],"length":0,"stats":{"Line":16}},{"line":102,"address":[],"length":0,"stats":{"Line":16}},{"line":103,"address":[],"length":0,"stats":{"Line":16}},{"line":104,"address":[],"length":0,"stats":{"Line":8}},{"line":110,"address":[],"length":0,"stats":{"Line":93}},{"line":111,"address":[],"length":0,"stats":{"Line":12}},{"line":112,"address":[],"length":0,"stats":{"Line":24}},{"line":113,"address":[],"length":0,"stats":{"Line":24}},{"line":116,"address":[],"length":0,"stats":{"Line":12}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":10}},{"line":121,"address":[],"length":0,"stats":{"Line":8}},{"line":122,"address":[],"length":0,"stats":{"Line":8}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":30}},{"line":144,"address":[],"length":0,"stats":{"Line":12}},{"line":147,"address":[],"length":0,"stats":{"Line":12}},{"line":152,"address":[],"length":0,"stats":{"Line":24}},{"line":155,"address":[],"length":0,"stats":{"Line":24}},{"line":156,"address":[],"length":0,"stats":{"Line":24}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":14}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":10}},{"line":166,"address":[],"length":0,"stats":{"Line":8}},{"line":169,"address":[],"length":0,"stats":{"Line":6}},{"line":171,"address":[],"length":0,"stats":{"Line":22}},{"line":172,"address":[],"length":0,"stats":{"Line":22}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":3}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":3}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":187,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":197,"address":[],"length":0,"stats":{"Line":8}},{"line":198,"address":[],"length":0,"stats":{"Line":6}},{"line":199,"address":[],"length":0,"stats":{"Line":9}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":5}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":3}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":2}},{"line":208,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":3}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":9}},{"line":229,"address":[],"length":0,"stats":{"Line":10}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":8}},{"line":239,"address":[],"length":0,"stats":{"Line":9}},{"line":240,"address":[],"length":0,"stats":{"Line":27}},{"line":241,"address":[],"length":0,"stats":{"Line":27}},{"line":244,"address":[],"length":0,"stats":{"Line":9}},{"line":245,"address":[],"length":0,"stats":{"Line":8}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[],"length":0,"stats":{"Line":1}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":6}},{"line":273,"address":[],"length":0,"stats":{"Line":6}},{"line":274,"address":[],"length":0,"stats":{"Line":6}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[],"length":0,"stats":{"Line":4}},{"line":279,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":12}},{"line":306,"address":[],"length":0,"stats":{"Line":12}},{"line":308,"address":[],"length":0,"stats":{"Line":8}},{"line":312,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":2}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":4}},{"line":318,"address":[],"length":0,"stats":{"Line":8}},{"line":322,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":4}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":332,"address":[],"length":0,"stats":{"Line":2}},{"line":333,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":335,"address":[],"length":0,"stats":{"Line":1}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":3}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":344,"address":[],"length":0,"stats":{"Line":3}},{"line":345,"address":[],"length":0,"stats":{"Line":2}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":1}},{"line":352,"address":[],"length":0,"stats":{"Line":3}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":367,"address":[],"length":0,"stats":{"Line":4}},{"line":368,"address":[],"length":0,"stats":{"Line":3}},{"line":371,"address":[],"length":0,"stats":{"Line":3}},{"line":372,"address":[],"length":0,"stats":{"Line":4}},{"line":375,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":379,"address":[],"length":0,"stats":{"Line":5}},{"line":381,"address":[],"length":0,"stats":{"Line":2}},{"line":382,"address":[],"length":0,"stats":{"Line":4}},{"line":383,"address":[],"length":0,"stats":{"Line":2}},{"line":384,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":3}},{"line":388,"address":[],"length":0,"stats":{"Line":2}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":1}},{"line":395,"address":[],"length":0,"stats":{"Line":3}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}}],"covered":176,"coverable":216},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","rename","mod.rs"],"content":"//! Rename and reference management for mdvault.\n//!\n//! This module provides safe note renaming with automatic reference updates.\n//! It handles wikilinks, markdown links, and frontmatter references.\n\nmod detector;\nmod types;\nmod updater;\n\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\npub use types::*;\n\nuse crate::index::IndexDb;\n\nuse detector::find_references_in_content;\nuse updater::apply_updates;\n\n/// Generate a preview of what a rename operation would do.\n///\n/// This does not modify any files - it only calculates what changes would be made.\npub fn generate_preview(\n    db: \u0026IndexDb,\n    vault_root: \u0026Path,\n    old_path: \u0026Path,\n    new_path: \u0026Path,\n) -\u003e Result\u003cRenamePreview, RenameError\u003e {\n    // Validate paths\n    let old_abs = if old_path.is_absolute() {\n        old_path.to_path_buf()\n    } else {\n        vault_root.join(old_path)\n    };\n\n    let new_abs = if new_path.is_absolute() {\n        new_path.to_path_buf()\n    } else {\n        vault_root.join(new_path)\n    };\n\n    if !old_abs.exists() {\n        return Err(RenameError::SourceNotFound(old_abs));\n    }\n\n    if new_abs.exists() {\n        return Err(RenameError::TargetExists(new_abs));\n    }\n\n    // Find the note in the index\n    let old_rel = old_abs.strip_prefix(vault_root).unwrap_or(\u0026old_abs);\n    let note = db\n        .get_note_by_path(old_rel)\n        .map_err(|e| RenameError::IndexError(e.to_string()))?\n        .ok_or_else(|| RenameError::NoteNotInIndex(old_abs.clone()))?;\n\n    let note_id =\n        note.id.ok_or_else(|| RenameError::IndexError(\"Note has no ID\".to_string()))?;\n\n    // Get backlinks from index to find files that reference this note\n    let backlinks =\n        db.get_backlinks(note_id).map_err(|e| RenameError::IndexError(e.to_string()))?;\n\n    // Find all references by parsing the source files\n    let mut all_references = Vec::new();\n    let mut files_to_scan: HashMap\u003cPathBuf, ()\u003e = HashMap::new();\n\n    for link in \u0026backlinks {\n        if let Some(source_note) = db\n            .get_note_by_id(link.source_id)\n            .map_err(|e| RenameError::IndexError(e.to_string()))?\n        {\n            let source_path = vault_root.join(\u0026source_note.path);\n            files_to_scan.insert(source_path, ());\n        }\n    }\n\n    // Scan each file for exact reference positions\n    for source_path in files_to_scan.keys() {\n        let content = fs::read_to_string(source_path).map_err(|e| {\n            RenameError::ReadError { path: source_path.clone(), source: e }\n        })?;\n\n        let refs =\n            find_references_in_content(\u0026content, source_path, \u0026old_abs, vault_root);\n        all_references.extend(refs);\n    }\n\n    // Get the new basename for reference updates\n    let new_basename =\n        new_abs.file_stem().and_then(|s| s.to_str()).unwrap_or(\"unnamed\").to_string();\n\n    // Generate file changes\n    let mut changes = Vec::new();\n    let mut warnings = Vec::new();\n\n    // Group references by file\n    let mut refs_by_file: HashMap\u003cPathBuf, Vec\u003cReference\u003e\u003e = HashMap::new();\n    for reference in \u0026all_references {\n        refs_by_file\n            .entry(reference.source_path.clone())\n            .or_default()\n            .push(reference.clone());\n    }\n\n    for (source_path, refs) in refs_by_file {\n        let content = fs::read_to_string(\u0026source_path).map_err(|e| {\n            RenameError::ReadError { path: source_path.clone(), source: e }\n        })?;\n\n        let new_content = apply_updates(\u0026content, \u0026refs, \u0026new_basename);\n\n        changes.push(FileChange {\n            path: source_path,\n            original_content: content,\n            new_content,\n            references: refs,\n        });\n    }\n\n    // Check for potential ambiguity (multiple notes with same basename)\n    let new_basename_lower = new_basename.to_lowercase();\n    if let Ok(notes) = db.query_notes(\u0026Default::default()) {\n        let conflicts: Vec\u003c_\u003e = notes\n            .iter()\n            .filter(|n| {\n                let basename = n.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n                basename.to_lowercase() == new_basename_lower \u0026\u0026 n.path != old_rel\n            })\n            .collect();\n\n        if !conflicts.is_empty() {\n            warnings.push(format!(\n                \"Warning: {} existing note(s) have the same basename '{}'. \\\n                 This may cause ambiguous wikilink references.\",\n                conflicts.len(),\n                new_basename\n            ));\n        }\n    }\n\n    Ok(RenamePreview {\n        old_path: old_abs,\n        new_path: new_abs,\n        references: all_references,\n        changes,\n        warnings,\n    })\n}\n\n/// Execute a rename operation.\n///\n/// This modifies files on disk and updates the index.\npub fn execute_rename(\n    db: \u0026IndexDb,\n    vault_root: \u0026Path,\n    old_path: \u0026Path,\n    new_path: \u0026Path,\n) -\u003e Result\u003cRenameResult, RenameError\u003e {\n    // Generate preview first to get all the info\n    let preview = generate_preview(db, vault_root, old_path, new_path)?;\n\n    // Apply changes to all affected files\n    let mut files_modified = Vec::new();\n    let mut references_updated = 0;\n\n    for change in \u0026preview.changes {\n        fs::write(\u0026change.path, \u0026change.new_content).map_err(|e| {\n            RenameError::WriteError { path: change.path.clone(), source: e }\n        })?;\n\n        files_modified.push(change.path.clone());\n        references_updated += change.references.len();\n    }\n\n    // Create parent directory for new path if needed\n    if let Some(parent) = preview.new_path.parent()\n        \u0026\u0026 !parent.exists()\n    {\n        fs::create_dir_all(parent).map_err(|e| RenameError::WriteError {\n            path: parent.to_path_buf(),\n            source: e,\n        })?;\n    }\n\n    // Rename the file itself\n    fs::rename(\u0026preview.old_path, \u0026preview.new_path).map_err(RenameError::RenameError)?;\n\n    // Update the index\n    let old_rel = preview.old_path.strip_prefix(vault_root).unwrap_or(\u0026preview.old_path);\n    let new_rel = preview.new_path.strip_prefix(vault_root).unwrap_or(\u0026preview.new_path);\n\n    update_note_path(db, old_rel, new_rel)\n        .map_err(|e| RenameError::IndexError(e.to_string()))?;\n\n    // Re-resolve link targets after the rename\n    db.resolve_link_targets().map_err(|e| RenameError::IndexError(e.to_string()))?;\n\n    Ok(RenameResult {\n        old_path: preview.old_path,\n        new_path: preview.new_path,\n        files_modified,\n        references_updated,\n        warnings: preview.warnings,\n    })\n}\n\n/// Update a note's path in the index.\nfn update_note_path(\n    db: \u0026IndexDb,\n    old_path: \u0026Path,\n    new_path: \u0026Path,\n) -\u003e Result\u003c(), crate::index::IndexError\u003e {\n    let conn = db.connection();\n\n    // Update the notes table\n    conn.execute(\n        \"UPDATE notes SET path = ?1 WHERE path = ?2\",\n        rusqlite::params![new_path.to_string_lossy(), old_path.to_string_lossy(),],\n    )?;\n\n    // Update target_path in links table where it matches the old path\n    let old_basename = old_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let new_basename = new_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n\n    // Update exact matches\n    conn.execute(\n        \"UPDATE links SET target_path = ?1 WHERE target_path = ?2\",\n        rusqlite::params![new_path.to_string_lossy(), old_path.to_string_lossy(),],\n    )?;\n\n    // Update basename-only matches\n    conn.execute(\n        \"UPDATE links SET target_path = ?1 WHERE target_path = ?2\",\n        rusqlite::params![new_basename, old_basename],\n    )?;\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::index::types::{IndexedNote, NoteType};\n    use chrono::Utc;\n    use std::path::PathBuf;\n    use tempfile::TempDir;\n\n    fn setup_test_vault() -\u003e (TempDir, IndexDb) {\n        let temp_dir = TempDir::new().unwrap();\n        let db = IndexDb::open_in_memory().unwrap();\n        (temp_dir, db)\n    }\n\n    fn create_note(dir: \u0026Path, name: \u0026str, content: \u0026str) -\u003e PathBuf {\n        let path = dir.join(name);\n        if let Some(parent) = path.parent() {\n            fs::create_dir_all(parent).unwrap();\n        }\n        fs::write(\u0026path, content).unwrap();\n        path\n    }\n\n    fn sample_note(path: \u0026str) -\u003e IndexedNote {\n        IndexedNote {\n            id: None,\n            path: PathBuf::from(path),\n            note_type: NoteType::None,\n            title: \"Test\".to_string(),\n            created: Some(Utc::now()),\n            modified: Utc::now(),\n            frontmatter_json: None,\n            content_hash: \"hash\".to_string(),\n        }\n    }\n\n    #[test]\n    fn test_generate_preview_source_not_found() {\n        let (temp_dir, db) = setup_test_vault();\n        let result = generate_preview(\n            \u0026db,\n            temp_dir.path(),\n            Path::new(\"nonexistent.md\"),\n            Path::new(\"new.md\"),\n        );\n\n        assert!(matches!(result, Err(RenameError::SourceNotFound(_))));\n    }\n\n    #[test]\n    fn test_generate_preview_target_exists() {\n        let (temp_dir, db) = setup_test_vault();\n\n        create_note(temp_dir.path(), \"old.md\", \"# Old\");\n        create_note(temp_dir.path(), \"new.md\", \"# New\");\n\n        db.insert_note(\u0026sample_note(\"old.md\")).unwrap();\n\n        let result = generate_preview(\n            \u0026db,\n            temp_dir.path(),\n            Path::new(\"old.md\"),\n            Path::new(\"new.md\"),\n        );\n\n        assert!(matches!(result, Err(RenameError::TargetExists(_))));\n    }\n\n    #[test]\n    fn test_generate_preview_no_references() {\n        let (temp_dir, db) = setup_test_vault();\n\n        create_note(temp_dir.path(), \"old.md\", \"# Old Note\\n\\nContent here.\");\n        db.insert_note(\u0026sample_note(\"old.md\")).unwrap();\n\n        let preview = generate_preview(\n            \u0026db,\n            temp_dir.path(),\n            Path::new(\"old.md\"),\n            Path::new(\"new.md\"),\n        )\n        .unwrap();\n\n        assert_eq!(preview.references.len(), 0);\n        assert_eq!(preview.changes.len(), 0);\n    }\n\n    #[test]\n    fn test_execute_rename_simple() {\n        let (temp_dir, db) = setup_test_vault();\n\n        create_note(temp_dir.path(), \"old.md\", \"# Old Note\\n\\nContent.\");\n        db.insert_note(\u0026sample_note(\"old.md\")).unwrap();\n\n        let result = execute_rename(\n            \u0026db,\n            temp_dir.path(),\n            Path::new(\"old.md\"),\n            Path::new(\"new.md\"),\n        )\n        .unwrap();\n\n        // Old file should not exist\n        assert!(!temp_dir.path().join(\"old.md\").exists());\n\n        // New file should exist\n        assert!(temp_dir.path().join(\"new.md\").exists());\n\n        // Index should be updated\n        assert!(db.get_note_by_path(Path::new(\"old.md\")).unwrap().is_none());\n        assert!(db.get_note_by_path(Path::new(\"new.md\")).unwrap().is_some());\n\n        assert_eq!(result.references_updated, 0);\n    }\n\n    #[test]\n    fn test_execute_rename_with_references() {\n        let (temp_dir, db) = setup_test_vault();\n\n        // Create target note\n        create_note(temp_dir.path(), \"old.md\", \"# Old Note\\n\\nContent.\");\n        let old_id = db.insert_note(\u0026sample_note(\"old.md\")).unwrap();\n\n        // Create source note with reference\n        create_note(temp_dir.path(), \"source.md\", \"# Source\\n\\nSee [[old]] for details.\");\n        let source_id = db.insert_note(\u0026sample_note(\"source.md\")).unwrap();\n\n        // Add link in index\n        db.insert_link(\u0026crate::index::types::IndexedLink {\n            id: None,\n            source_id,\n            target_id: Some(old_id),\n            target_path: \"old\".to_string(),\n            link_text: None,\n            link_type: crate::index::types::LinkType::Wikilink,\n            context: None,\n            line_number: Some(3),\n        })\n        .unwrap();\n\n        // Execute rename\n        let result = execute_rename(\n            \u0026db,\n            temp_dir.path(),\n            Path::new(\"old.md\"),\n            Path::new(\"new.md\"),\n        )\n        .unwrap();\n\n        // Check reference was updated\n        assert_eq!(result.references_updated, 1);\n        assert_eq!(result.files_modified.len(), 1);\n\n        // Verify file content was updated\n        let source_content =\n            fs::read_to_string(temp_dir.path().join(\"source.md\")).unwrap();\n        assert!(source_content.contains(\"[[new]]\"));\n        assert!(!source_content.contains(\"[[old]]\"));\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":15}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":15}},{"line":37,"address":[],"length":0,"stats":{"Line":15}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":15}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":15}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":12}},{"line":66,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":9}},{"line":69,"address":[],"length":0,"stats":{"Line":5}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":7}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":5}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":21}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":9}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":5}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":9}},{"line":125,"address":[],"length":0,"stats":{"Line":9}},{"line":127,"address":[],"length":0,"stats":{"Line":7}},{"line":128,"address":[],"length":0,"stats":{"Line":28}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":3}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":6}},{"line":146,"address":[],"length":0,"stats":{"Line":6}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":12}},{"line":165,"address":[],"length":0,"stats":{"Line":4}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":8}},{"line":191,"address":[],"length":0,"stats":{"Line":10}},{"line":192,"address":[],"length":0,"stats":{"Line":10}},{"line":194,"address":[],"length":0,"stats":{"Line":8}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":6}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":4}},{"line":202,"address":[],"length":0,"stats":{"Line":4}},{"line":203,"address":[],"length":0,"stats":{"Line":4}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":6}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":220,"address":[],"length":0,"stats":{"Line":10}},{"line":224,"address":[],"length":0,"stats":{"Line":16}},{"line":225,"address":[],"length":0,"stats":{"Line":16}},{"line":228,"address":[],"length":0,"stats":{"Line":4}},{"line":230,"address":[],"length":0,"stats":{"Line":10}},{"line":234,"address":[],"length":0,"stats":{"Line":4}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":2}}],"covered":94,"coverable":107},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","rename","types.rs"],"content":"//! Data structures for the rename and reference management system.\n\nuse std::path::PathBuf;\nuse thiserror::Error;\n\n/// Errors that can occur during rename operations\n#[derive(Debug, Error)]\npub enum RenameError {\n    #[error(\"source file not found: {0}\")]\n    SourceNotFound(PathBuf),\n\n    #[error(\"target file already exists: {0}\")]\n    TargetExists(PathBuf),\n\n    #[error(\"failed to read file {path}: {source}\")]\n    ReadError {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    #[error(\"failed to write file {path}: {source}\")]\n    WriteError {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    #[error(\"failed to rename file: {0}\")]\n    RenameError(#[source] std::io::Error),\n\n    #[error(\"index error: {0}\")]\n    IndexError(String),\n\n    #[error(\"note not found in index: {0}\")]\n    NoteNotInIndex(PathBuf),\n}\n\n/// Type of reference found in a file\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ReferenceType {\n    /// Basic wikilink: [[note]] or [[path/note]]\n    Wikilink,\n    /// Wikilink with display alias: [[note|Display Text]]\n    WikilinkWithAlias,\n    /// Wikilink with section anchor: [[note#section]]\n    WikilinkWithSection,\n    /// Wikilink with both alias and section: [[note#section|Display Text]]\n    WikilinkWithSectionAndAlias,\n    /// Standard markdown link: [text](path.md)\n    MarkdownLink,\n    /// Frontmatter scalar field: project: note-name\n    FrontmatterField { field: String },\n    /// Frontmatter list item: related: [note1, note2]\n    FrontmatterList { field: String, index: usize },\n}\n\n/// A reference to a note found in a file\n#[derive(Debug, Clone)]\npub struct Reference {\n    /// File containing the reference\n    pub source_path: PathBuf,\n    /// Line number (1-based, 0 for frontmatter)\n    pub line_number: u32,\n    /// Column number (1-based)\n    pub column: u32,\n    /// Byte offset start in file\n    pub start: usize,\n    /// Byte offset end in file\n    pub end: usize,\n    /// Original text of the reference (e.g., \"[[old-note|Alias]]\")\n    pub original: String,\n    /// Reference type\n    pub ref_type: ReferenceType,\n    /// For wikilinks with aliases, the alias text\n    pub alias: Option\u003cString\u003e,\n    /// For wikilinks with sections, the section anchor\n    pub section: Option\u003cString\u003e,\n    /// The link target as written (may be basename or full path)\n    pub target_as_written: String,\n}\n\nimpl Reference {\n    /// Returns true if this is a wikilink-style reference\n    pub fn is_wikilink(\u0026self) -\u003e bool {\n        matches!(\n            self.ref_type,\n            ReferenceType::Wikilink\n                | ReferenceType::WikilinkWithAlias\n                | ReferenceType::WikilinkWithSection\n                | ReferenceType::WikilinkWithSectionAndAlias\n        )\n    }\n\n    /// Returns true if this is a markdown link reference\n    pub fn is_markdown_link(\u0026self) -\u003e bool {\n        matches!(self.ref_type, ReferenceType::MarkdownLink)\n    }\n\n    /// Returns true if this is a frontmatter reference\n    pub fn is_frontmatter(\u0026self) -\u003e bool {\n        matches!(\n            self.ref_type,\n            ReferenceType::FrontmatterField { .. }\n                | ReferenceType::FrontmatterList { .. }\n        )\n    }\n\n    /// Returns true if the original reference used a full path (not just basename)\n    pub fn uses_full_path(\u0026self) -\u003e bool {\n        self.target_as_written.contains('/')\n    }\n}\n\n/// A change to be made to a file\n#[derive(Debug, Clone)]\npub struct FileChange {\n    /// Path to the file\n    pub path: PathBuf,\n    /// Original content of the file\n    pub original_content: String,\n    /// New content after applying updates\n    pub new_content: String,\n    /// References in this file that will be updated\n    pub references: Vec\u003cReference\u003e,\n}\n\n/// Preview of what a rename operation would do\n#[derive(Debug)]\npub struct RenamePreview {\n    /// Original path of the note\n    pub old_path: PathBuf,\n    /// New path for the note\n    pub new_path: PathBuf,\n    /// All references found across the vault\n    pub references: Vec\u003cReference\u003e,\n    /// Changes that would be made to each file\n    pub changes: Vec\u003cFileChange\u003e,\n    /// Warnings about potential issues\n    pub warnings: Vec\u003cString\u003e,\n}\n\nimpl RenamePreview {\n    /// Total number of references that would be updated\n    pub fn total_references(\u0026self) -\u003e usize {\n        self.references.len()\n    }\n\n    /// Number of files that would be modified\n    pub fn files_affected(\u0026self) -\u003e usize {\n        self.changes.len()\n    }\n}\n\n/// Result of a successful rename operation\n#[derive(Debug)]\npub struct RenameResult {\n    /// Original path of the note\n    pub old_path: PathBuf,\n    /// New path of the note\n    pub new_path: PathBuf,\n    /// Files that were modified\n    pub files_modified: Vec\u003cPathBuf\u003e,\n    /// Number of references updated\n    pub references_updated: usize,\n    /// Warnings about potential issues\n    pub warnings: Vec\u003cString\u003e,\n}\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":8}},{"line":111,"address":[],"length":0,"stats":{"Line":8}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":14},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","rename","updater.rs"],"content":"//! Reference update logic for rename operations.\n//!\n//! Updates references in files while preserving their original format.\n\nuse std::path::Path;\n\nuse crate::rename::types::{Reference, ReferenceType};\n\n/// Generate the updated text for a reference.\n///\n/// Preserves the original format (wikilink style, alias, section, etc.)\n/// while updating the target path.\npub fn update_reference(reference: \u0026Reference, new_basename: \u0026str) -\u003e String {\n    match \u0026reference.ref_type {\n        ReferenceType::Wikilink =\u003e {\n            if reference.uses_full_path() {\n                // Preserve path structure: [[path/old]] -\u003e [[path/new]]\n                let new_path =\n                    update_path_in_reference(\u0026reference.target_as_written, new_basename);\n                format!(\"[[{}]]\", new_path)\n            } else {\n                format!(\"[[{}]]\", new_basename)\n            }\n        }\n\n        ReferenceType::WikilinkWithAlias =\u003e {\n            let alias = reference.alias.as_deref().unwrap_or(\"\");\n            if reference.uses_full_path() {\n                let new_path =\n                    update_path_in_reference(\u0026reference.target_as_written, new_basename);\n                format!(\"[[{}|{}]]\", new_path, alias)\n            } else {\n                format!(\"[[{}|{}]]\", new_basename, alias)\n            }\n        }\n\n        ReferenceType::WikilinkWithSection =\u003e {\n            let section = reference.section.as_deref().unwrap_or(\"\");\n            if reference.uses_full_path() {\n                let new_path =\n                    update_path_in_reference(\u0026reference.target_as_written, new_basename);\n                format!(\"[[{}#{}]]\", new_path, section)\n            } else {\n                format!(\"[[{}#{}]]\", new_basename, section)\n            }\n        }\n\n        ReferenceType::WikilinkWithSectionAndAlias =\u003e {\n            let section = reference.section.as_deref().unwrap_or(\"\");\n            let alias = reference.alias.as_deref().unwrap_or(\"\");\n            if reference.uses_full_path() {\n                let new_path =\n                    update_path_in_reference(\u0026reference.target_as_written, new_basename);\n                format!(\"[[{}#{}|{}]]\", new_path, section, alias)\n            } else {\n                format!(\"[[{}#{}|{}]]\", new_basename, section, alias)\n            }\n        }\n\n        ReferenceType::MarkdownLink =\u003e {\n            let link_text = reference.alias.as_deref().unwrap_or(\"\");\n            let new_url = update_markdown_url(\u0026reference.target_as_written, new_basename);\n            format!(\"[{}]({})\", link_text, new_url)\n        }\n\n        ReferenceType::FrontmatterField { .. }\n        | ReferenceType::FrontmatterList { .. } =\u003e {\n            // Frontmatter references are just the basename\n            new_basename.to_string()\n        }\n    }\n}\n\n/// Update a path-style reference, preserving the directory structure.\nfn update_path_in_reference(original: \u0026str, new_basename: \u0026str) -\u003e String {\n    if let Some(slash_pos) = original.rfind('/') {\n        // Preserve directory path\n        let dir = \u0026original[..=slash_pos];\n        format!(\"{}{}\", dir, new_basename)\n    } else {\n        new_basename.to_string()\n    }\n}\n\n/// Update a markdown URL, preserving relative path structure and .md extension.\nfn update_markdown_url(original: \u0026str, new_basename: \u0026str) -\u003e String {\n    // Preserve leading ./ or ../\n    let prefix = if original.starts_with(\"./\") {\n        \"./\"\n    } else if original.starts_with(\"../\") {\n        // Count how many ../ there are\n        let mut prefix = String::new();\n        let mut remaining = original;\n        while remaining.starts_with(\"../\") {\n            prefix.push_str(\"../\");\n            remaining = \u0026remaining[3..];\n        }\n        // Return the prefix portion for use\n        return format!(\"{}{}\", prefix, update_path_portion(remaining, new_basename));\n    } else {\n        \"\"\n    };\n\n    let without_prefix = original.strip_prefix(prefix).unwrap_or(original);\n    let new_path = update_path_portion(without_prefix, new_basename);\n\n    format!(\"{}{}\", prefix, new_path)\n}\n\n/// Update the path portion of a URL (after any leading ./ or ../).\nfn update_path_portion(path: \u0026str, new_basename: \u0026str) -\u003e String {\n    if let Some(slash_pos) = path.rfind('/') {\n        // Preserve directory structure\n        let dir = \u0026path[..=slash_pos];\n        format!(\"{}{}.md\", dir, new_basename)\n    } else {\n        // Just the filename\n        format!(\"{}.md\", new_basename)\n    }\n}\n\n/// Apply reference updates to file content.\n///\n/// References must be sorted by start position (will be processed in reverse order).\npub fn apply_updates(\n    content: \u0026str,\n    references: \u0026[Reference],\n    new_basename: \u0026str,\n) -\u003e String {\n    // Sort references by start position (descending) to apply from end to start\n    let mut sorted_refs: Vec\u003c_\u003e = references.iter().collect();\n    sorted_refs.sort_by(|a, b| b.start.cmp(\u0026a.start));\n\n    let mut result = content.to_string();\n\n    for reference in sorted_refs {\n        let replacement = update_reference(reference, new_basename);\n\n        // Verify bounds are valid\n        if reference.start \u003c= result.len() \u0026\u0026 reference.end \u003c= result.len() {\n            result.replace_range(reference.start..reference.end, \u0026replacement);\n        }\n    }\n\n    result\n}\n\n/// Compute the new relative path for a markdown link when the target moves.\n///\n/// This handles the case where we need to recalculate relative paths.\n#[allow(dead_code)]\npub fn compute_relative_path(\n    source_path: \u0026Path,\n    _old_target: \u0026Path,\n    new_target: \u0026Path,\n    vault_root: \u0026Path,\n) -\u003e String {\n    // Get paths relative to vault root\n    let source_rel = source_path.strip_prefix(vault_root).unwrap_or(source_path);\n    let new_target_rel = new_target.strip_prefix(vault_root).unwrap_or(new_target);\n\n    // Get parent directories\n    let source_dir = source_rel.parent().unwrap_or(Path::new(\"\"));\n    let target_dir = new_target_rel.parent().unwrap_or(Path::new(\"\"));\n\n    // If same directory, just use filename\n    if source_dir == target_dir {\n        return format!(\n            \"./{}.md\",\n            new_target_rel.file_stem().unwrap_or_default().to_string_lossy()\n        );\n    }\n\n    // Calculate relative path\n    let mut prefix = String::new();\n    let mut source_components: Vec\u003c_\u003e = source_dir.components().collect();\n    let mut target_components: Vec\u003c_\u003e = target_dir.components().collect();\n\n    // Find common prefix\n    while !source_components.is_empty()\n        \u0026\u0026 !target_components.is_empty()\n        \u0026\u0026 source_components[0] == target_components[0]\n    {\n        source_components.remove(0);\n        target_components.remove(0);\n    }\n\n    // Add ../ for each remaining source component\n    for _ in \u0026source_components {\n        prefix.push_str(\"../\");\n    }\n\n    // Add remaining target components\n    for comp in \u0026target_components {\n        prefix.push_str(\u0026comp.as_os_str().to_string_lossy());\n        prefix.push('/');\n    }\n\n    format!(\n        \"{}{}.md\",\n        prefix,\n        new_target_rel.file_stem().unwrap_or_default().to_string_lossy()\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n\n    fn make_reference(\n        original: \u0026str,\n        ref_type: ReferenceType,\n        start: usize,\n        end: usize,\n    ) -\u003e Reference {\n        Reference {\n            source_path: PathBuf::from(\"source.md\"),\n            line_number: 1,\n            column: 1,\n            start,\n            end,\n            original: original.to_string(),\n            ref_type,\n            alias: None,\n            section: None,\n            target_as_written: extract_target(original),\n        }\n    }\n\n    fn extract_target(original: \u0026str) -\u003e String {\n        // Simple extraction for tests\n        original\n            .trim_start_matches(\"[[\")\n            .trim_end_matches(\"]]\")\n            .split('|')\n            .next()\n            .unwrap_or(\"\")\n            .split('#')\n            .next()\n            .unwrap_or(\"\")\n            .to_string()\n    }\n\n    #[test]\n    fn test_update_basic_wikilink() {\n        let reference = make_reference(\"[[old-note]]\", ReferenceType::Wikilink, 0, 12);\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[[new-note]]\");\n    }\n\n    #[test]\n    fn test_update_wikilink_with_alias() {\n        let mut reference = make_reference(\n            \"[[old-note|My Alias]]\",\n            ReferenceType::WikilinkWithAlias,\n            0,\n            21,\n        );\n        reference.alias = Some(\"My Alias\".to_string());\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[[new-note|My Alias]]\");\n    }\n\n    #[test]\n    fn test_update_wikilink_with_section() {\n        let mut reference = make_reference(\n            \"[[old-note#section]]\",\n            ReferenceType::WikilinkWithSection,\n            0,\n            20,\n        );\n        reference.section = Some(\"section\".to_string());\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[[new-note#section]]\");\n    }\n\n    #[test]\n    fn test_update_wikilink_preserves_path() {\n        let mut reference =\n            make_reference(\"[[tasks/old-note]]\", ReferenceType::Wikilink, 0, 18);\n        reference.target_as_written = \"tasks/old-note\".to_string();\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[[tasks/new-note]]\");\n    }\n\n    #[test]\n    fn test_update_markdown_link() {\n        let mut reference = make_reference(\n            \"[link text](./old-note.md)\",\n            ReferenceType::MarkdownLink,\n            0,\n            26,\n        );\n        reference.alias = Some(\"link text\".to_string());\n        reference.target_as_written = \"./old-note.md\".to_string();\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[link text](./new-note.md)\");\n    }\n\n    #[test]\n    fn test_update_markdown_link_relative() {\n        let mut reference = make_reference(\n            \"[text](../tasks/old-note.md)\",\n            ReferenceType::MarkdownLink,\n            0,\n            28,\n        );\n        reference.alias = Some(\"text\".to_string());\n        reference.target_as_written = \"../tasks/old-note.md\".to_string();\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[text](../tasks/new-note.md)\");\n    }\n\n    #[test]\n    fn test_update_frontmatter_field() {\n        let reference = Reference {\n            source_path: PathBuf::from(\"source.md\"),\n            line_number: 0,\n            column: 0,\n            start: 20,\n            end: 28,\n            original: \"old-note\".to_string(),\n            ref_type: ReferenceType::FrontmatterField { field: \"project\".to_string() },\n            alias: None,\n            section: None,\n            target_as_written: \"old-note\".to_string(),\n        };\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"new-note\");\n    }\n\n    #[test]\n    fn test_apply_updates_single() {\n        let content = \"Link to [[old-note]] here.\";\n        let reference = make_reference(\"[[old-note]]\", ReferenceType::Wikilink, 8, 20);\n\n        let result = apply_updates(content, \u0026[reference], \"new-note\");\n        assert_eq!(result, \"Link to [[new-note]] here.\");\n    }\n\n    #[test]\n    fn test_apply_updates_multiple() {\n        let content = \"First [[old-note]] and second [[old-note|alias]].\";\n        let ref1 = make_reference(\"[[old-note]]\", ReferenceType::Wikilink, 6, 18);\n        let mut ref2 = make_reference(\n            \"[[old-note|alias]]\",\n            ReferenceType::WikilinkWithAlias,\n            30,\n            48,\n        );\n        ref2.alias = Some(\"alias\".to_string());\n\n        let result = apply_updates(content, \u0026[ref1, ref2], \"new-note\");\n        assert_eq!(result, \"First [[new-note]] and second [[new-note|alias]].\");\n    }\n\n    #[test]\n    fn test_compute_relative_path_same_dir() {\n        let source = Path::new(\"/vault/notes/source.md\");\n        let old = Path::new(\"/vault/notes/old.md\");\n        let new = Path::new(\"/vault/notes/new.md\");\n        let vault = Path::new(\"/vault\");\n\n        let result = compute_relative_path(source, old, new, vault);\n        assert_eq!(result, \"./new.md\");\n    }\n\n    #[test]\n    fn test_compute_relative_path_parent_dir() {\n        let source = Path::new(\"/vault/notes/subdir/source.md\");\n        let old = Path::new(\"/vault/notes/old.md\");\n        let new = Path::new(\"/vault/notes/new.md\");\n        let vault = Path::new(\"/vault\");\n\n        let result = compute_relative_path(source, old, new, vault);\n        assert_eq!(result, \"../new.md\");\n    }\n\n    #[test]\n    fn test_compute_relative_path_different_branch() {\n        let source = Path::new(\"/vault/notes/source.md\");\n        let old = Path::new(\"/vault/tasks/old.md\");\n        let new = Path::new(\"/vault/tasks/new.md\");\n        let vault = Path::new(\"/vault\");\n\n        let result = compute_relative_path(source, old, new, vault);\n        assert_eq!(result, \"../tasks/new.md\");\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":11}},{"line":14,"address":[],"length":0,"stats":{"Line":11}},{"line":16,"address":[],"length":0,"stats":{"Line":10}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":3}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":10}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":5}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":10}},{"line":62,"address":[],"length":0,"stats":{"Line":8}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":5}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":5}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":5}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":15}},{"line":132,"address":[],"length":0,"stats":{"Line":9}},{"line":134,"address":[],"length":0,"stats":{"Line":9}},{"line":136,"address":[],"length":0,"stats":{"Line":11}},{"line":137,"address":[],"length":0,"stats":{"Line":16}},{"line":140,"address":[],"length":0,"stats":{"Line":20}},{"line":141,"address":[],"length":0,"stats":{"Line":12}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":18}},{"line":160,"address":[],"length":0,"stats":{"Line":18}},{"line":163,"address":[],"length":0,"stats":{"Line":15}},{"line":164,"address":[],"length":0,"stats":{"Line":15}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":4}},{"line":176,"address":[],"length":0,"stats":{"Line":10}},{"line":177,"address":[],"length":0,"stats":{"Line":10}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":3}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":6}},{"line":190,"address":[],"length":0,"stats":{"Line":4}},{"line":194,"address":[],"length":0,"stats":{"Line":5}},{"line":195,"address":[],"length":0,"stats":{"Line":4}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":6}}],"covered":72,"coverable":87},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","bindings.rs"],"content":"//! Lua bindings for mdvault functionality.\n//!\n//! This module provides the `mdv` global table with bindings to\n//! mdvault's date math and template rendering engines.\n\nuse mlua::{Function, Lua, Result as LuaResult, Table, Value};\nuse std::collections::HashMap;\n\nuse crate::templates::engine::{RenderContext, render_string};\nuse crate::vars::datemath::{evaluate_date_expr, is_date_expr, parse_date_expr};\n\n/// Register the `mdv` global table with all bindings.\n///\n/// After calling this function, Lua scripts can use:\n/// - `mdv.date(expr, format?)` - Evaluate date math expressions\n/// - `mdv.render(template, context)` - Render templates with variables\n/// - `mdv.is_date_expr(str)` - Check if string is a date expression\npub fn register_mdv_table(lua: \u0026Lua) -\u003e LuaResult\u003c()\u003e {\n    let mdv = lua.create_table()?;\n\n    mdv.set(\"date\", create_date_fn(lua)?)?;\n    mdv.set(\"render\", create_render_fn(lua)?)?;\n    mdv.set(\"is_date_expr\", create_is_date_expr_fn(lua)?)?;\n\n    lua.globals().set(\"mdv\", mdv)?;\n    Ok(())\n}\n\n/// Create the `mdv.date(expr, format?)` function.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// mdv.date(\"today\")           -- \"2025-12-29\"\n/// mdv.date(\"today + 7d\")      -- \"2026-01-05\"\n/// mdv.date(\"today\", \"%B %d\")  -- \"December 29\"\n/// mdv.date(\"now\", \"%H:%M\")    -- \"14:30\"\n/// ```\nfn create_date_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|_, args: (String, Option\u003cString\u003e)| {\n        let (expr, format_override) = args;\n\n        // Parse the expression\n        let mut parsed =\n            parse_date_expr(\u0026expr).map_err(|e| mlua::Error::runtime(e.to_string()))?;\n\n        // Override format if provided as second argument\n        if let Some(fmt) = format_override {\n            parsed.format = Some(fmt);\n        }\n\n        Ok(evaluate_date_expr(\u0026parsed))\n    })\n}\n\n/// Create the `mdv.render(template, context)` function.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// mdv.render(\"Hello {{name}}\", { name = \"World\" })  -- \"Hello World\"\n/// mdv.render(\"Count: {{n}}\", { n = 42 })            -- \"Count: 42\"\n/// ```\nfn create_render_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|_, args: (String, Table)| {\n        let (template, ctx_table) = args;\n\n        // Convert Lua table to RenderContext (HashMap\u003cString, String\u003e)\n        let mut ctx: RenderContext = HashMap::new();\n\n        for pair in ctx_table.pairs::\u003cString, Value\u003e() {\n            let (key, value) = pair?;\n            let str_value = lua_value_to_string(\u0026key, value)?;\n            ctx.insert(key, str_value);\n        }\n\n        render_string(\u0026template, \u0026ctx).map_err(|e| mlua::Error::runtime(e.to_string()))\n    })\n}\n\n/// Create the `mdv.is_date_expr(str)` function.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// mdv.is_date_expr(\"today + 1d\")  -- true\n/// mdv.is_date_expr(\"hello\")       -- false\n/// ```\nfn create_is_date_expr_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|_, s: String| Ok(is_date_expr(\u0026s)))\n}\n\n/// Convert a Lua value to a string for use in template context.\nfn lua_value_to_string(key: \u0026str, value: Value) -\u003e LuaResult\u003cString\u003e {\n    match value {\n        Value::String(s) =\u003e Ok(s.to_str()?.to_string()),\n        Value::Integer(i) =\u003e Ok(i.to_string()),\n        Value::Number(n) =\u003e Ok(n.to_string()),\n        Value::Boolean(b) =\u003e Ok(b.to_string()),\n        Value::Nil =\u003e Ok(String::new()),\n        _ =\u003e Err(mlua::Error::runtime(format!(\n            \"context value for '{}' must be string, number, boolean, or nil\",\n            key\n        ))),\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":46}},{"line":19,"address":[],"length":0,"stats":{"Line":138}},{"line":21,"address":[],"length":0,"stats":{"Line":184}},{"line":22,"address":[],"length":0,"stats":{"Line":184}},{"line":23,"address":[],"length":0,"stats":{"Line":184}},{"line":25,"address":[],"length":0,"stats":{"Line":138}},{"line":26,"address":[],"length":0,"stats":{"Line":46}},{"line":39,"address":[],"length":0,"stats":{"Line":46}},{"line":40,"address":[],"length":0,"stats":{"Line":138}},{"line":41,"address":[],"length":0,"stats":{"Line":138}},{"line":44,"address":[],"length":0,"stats":{"Line":45}},{"line":45,"address":[],"length":0,"stats":{"Line":142}},{"line":48,"address":[],"length":0,"stats":{"Line":63}},{"line":49,"address":[],"length":0,"stats":{"Line":9}},{"line":52,"address":[],"length":0,"stats":{"Line":45}},{"line":64,"address":[],"length":0,"stats":{"Line":46}},{"line":65,"address":[],"length":0,"stats":{"Line":96}},{"line":66,"address":[],"length":0,"stats":{"Line":12}},{"line":69,"address":[],"length":0,"stats":{"Line":12}},{"line":71,"address":[],"length":0,"stats":{"Line":12}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":16}},{"line":74,"address":[],"length":0,"stats":{"Line":16}},{"line":77,"address":[],"length":0,"stats":{"Line":16}},{"line":89,"address":[],"length":0,"stats":{"Line":46}},{"line":90,"address":[],"length":0,"stats":{"Line":98}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}}],"covered":30,"coverable":36},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","engine.rs"],"content":"//! Lua scripting engine with sandboxing.\n//!\n//! This module provides a sandboxed Lua execution environment for\n//! running user-defined scripts safely.\n\nuse mlua::{Lua, Result as LuaResult, StdLib, Value};\n\nuse super::bindings::register_mdv_table;\nuse super::index_bindings::register_index_bindings;\nuse super::types::{SandboxConfig, ScriptingError};\nuse super::vault_bindings::register_vault_bindings;\nuse super::vault_context::VaultContext;\n\n/// A sandboxed Lua execution environment.\n///\n/// The engine provides access to mdvault functionality through the `mdv`\n/// global table while restricting dangerous operations like file I/O\n/// and shell execution.\n///\n/// # Example\n///\n/// ```rust\n/// use mdvault_core::scripting::LuaEngine;\n///\n/// let engine = LuaEngine::sandboxed().unwrap();\n/// let result = engine.eval_string(r#\"mdv.date(\"today + 7d\")\"#).unwrap();\n/// println!(\"One week from now: {}\", result);\n/// ```\npub struct LuaEngine {\n    lua: Lua,\n    #[allow(dead_code)]\n    config: SandboxConfig,\n}\n\nimpl LuaEngine {\n    /// Create a new Lua engine with the given sandbox configuration.\n    pub fn new(config: SandboxConfig) -\u003e Result\u003cSelf, ScriptingError\u003e {\n        // Create Lua with restricted standard library\n        // Note: base functions (print, type, tostring, etc.) are always available\n        // We add: table, string, utf8, math\n        let libs = StdLib::TABLE | StdLib::STRING | StdLib::UTF8 | StdLib::MATH;\n\n        let lua = Lua::new_with(libs, mlua::LuaOptions::default())?;\n\n        // Apply memory limit if configured\n        if config.memory_limit \u003e 0 {\n            lua.set_memory_limit(config.memory_limit)?;\n        }\n\n        // Remove dangerous globals\n        Self::apply_sandbox(\u0026lua)?;\n\n        // Register mdv bindings\n        register_mdv_table(\u0026lua)?;\n\n        Ok(Self { lua, config })\n    }\n\n    /// Create a new engine with default restrictive sandbox.\n    pub fn sandboxed() -\u003e Result\u003cSelf, ScriptingError\u003e {\n        Self::new(SandboxConfig::restricted())\n    }\n\n    /// Create a new Lua engine with vault context for hook execution.\n    ///\n    /// This provides access to `mdv.template()`, `mdv.capture()`, `mdv.macro()`\n    /// and index query functions in addition to the standard sandboxed bindings.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// use mdvault_core::scripting::{LuaEngine, VaultContext, SandboxConfig};\n    ///\n    /// let vault_ctx = VaultContext::new(config, templates, captures, macros, types);\n    /// let engine = LuaEngine::with_vault_context(SandboxConfig::restricted(), vault_ctx)?;\n    ///\n    /// // Now Lua scripts can use vault operations\n    /// engine.eval_string(r#\"\n    ///     local ok, err = mdv.capture(\"log-to-daily\", { text = \"Hello\" })\n    /// \"#)?;\n    ///\n    /// // And query the index (if available)\n    /// engine.eval_string(r#\"\n    ///     local tasks = mdv.query({ type = \"task\" })\n    /// \"#)?;\n    /// ```\n    pub fn with_vault_context(\n        config: SandboxConfig,\n        vault_ctx: VaultContext,\n    ) -\u003e Result\u003cSelf, ScriptingError\u003e {\n        // Create Lua with restricted standard library\n        let libs = StdLib::TABLE | StdLib::STRING | StdLib::UTF8 | StdLib::MATH;\n        let lua = Lua::new_with(libs, mlua::LuaOptions::default())?;\n\n        // Apply memory limit if configured\n        if config.memory_limit \u003e 0 {\n            lua.set_memory_limit(config.memory_limit)?;\n        }\n\n        // Remove dangerous globals\n        Self::apply_sandbox(\u0026lua)?;\n\n        // Register standard mdv bindings\n        register_mdv_table(\u0026lua)?;\n\n        // Register vault operation bindings\n        register_vault_bindings(\u0026lua, vault_ctx)?;\n\n        // Register index query bindings (uses VaultContext from app_data)\n        register_index_bindings(\u0026lua)?;\n\n        Ok(Self { lua, config })\n    }\n\n    /// Execute a Lua script and return the result.\n    ///\n    /// Returns `None` if the script returns nil or no value.\n    pub fn eval(\u0026self, script: \u0026str) -\u003e Result\u003cOption\u003cString\u003e, ScriptingError\u003e {\n        let value: Value = self.lua.load(script).eval()?;\n\n        match value {\n            Value::Nil =\u003e Ok(None),\n            Value::String(s) =\u003e Ok(Some(s.to_str()?.to_string())),\n            Value::Integer(i) =\u003e Ok(Some(i.to_string())),\n            Value::Number(n) =\u003e Ok(Some(n.to_string())),\n            Value::Boolean(b) =\u003e Ok(Some(b.to_string())),\n            _ =\u003e Ok(Some(format!(\"{:?}\", value))),\n        }\n    }\n\n    /// Execute a Lua script that must return a string value.\n    ///\n    /// Returns an error if the script returns nil.\n    pub fn eval_string(\u0026self, script: \u0026str) -\u003e Result\u003cString, ScriptingError\u003e {\n        self.eval(script)?.ok_or_else(|| {\n            ScriptingError::Lua(mlua::Error::runtime(\"script returned nil\"))\n        })\n    }\n\n    /// Execute a Lua script that returns a boolean.\n    pub fn eval_bool(\u0026self, script: \u0026str) -\u003e Result\u003cbool, ScriptingError\u003e {\n        let value: Value = self.lua.load(script).eval()?;\n        match value {\n            Value::Boolean(b) =\u003e Ok(b),\n            Value::Nil =\u003e Ok(false),\n            _ =\u003e {\n                Err(ScriptingError::Lua(mlua::Error::runtime(\"expected boolean result\")))\n            }\n        }\n    }\n\n    /// Get a reference to the underlying Lua state (for advanced usage).\n    pub fn lua(\u0026self) -\u003e \u0026Lua {\n        \u0026self.lua\n    }\n\n    /// Apply sandbox restrictions by removing dangerous globals.\n    fn apply_sandbox(lua: \u0026Lua) -\u003e LuaResult\u003c()\u003e {\n        let globals = lua.globals();\n\n        // Remove dangerous functions that could:\n        // - Execute arbitrary code: load, loadfile, dofile\n        // - Access the filesystem: io\n        // - Execute system commands: os\n        // - Load external modules: require, package\n        // - Inspect/modify internals: debug\n        // - Cause resource exhaustion: collectgarbage\n\n        globals.set(\"dofile\", Value::Nil)?;\n        globals.set(\"loadfile\", Value::Nil)?;\n        globals.set(\"load\", Value::Nil)?;\n        globals.set(\"require\", Value::Nil)?;\n        globals.set(\"package\", Value::Nil)?;\n        globals.set(\"io\", Value::Nil)?;\n        globals.set(\"os\", Value::Nil)?;\n        globals.set(\"debug\", Value::Nil)?;\n        globals.set(\"collectgarbage\", Value::Nil)?;\n\n        Ok(())\n    }\n}\n\nimpl Default for LuaEngine {\n    fn default() -\u003e Self {\n        Self::sandboxed().expect(\"failed to create default Lua engine\")\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_date_basic() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"mdv.date(\"today\")\"#).unwrap();\n        // Should be in YYYY-MM-DD format\n        assert_eq!(result.len(), 10);\n        assert_eq!(result.chars().nth(4), Some('-'));\n        assert_eq!(result.chars().nth(7), Some('-'));\n    }\n\n    #[test]\n    fn test_date_with_offset() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        // Just verify it doesn't error - exact value depends on current date\n        let result = engine.eval_string(r#\"mdv.date(\"today + 1d\")\"#);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_date_with_format() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"mdv.date(\"today\", \"%A\")\"#).unwrap();\n        // Should be a weekday name\n        let valid_days = [\n            \"Monday\",\n            \"Tuesday\",\n            \"Wednesday\",\n            \"Thursday\",\n            \"Friday\",\n            \"Saturday\",\n            \"Sunday\",\n        ];\n        assert!(valid_days.contains(\u0026result.as_str()));\n    }\n\n    #[test]\n    fn test_date_week() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"mdv.date(\"week\")\"#).unwrap();\n        // Should be a number between 1 and 53\n        let week: u32 = result.parse().expect(\"week should be a number\");\n        assert!((1..=53).contains(\u0026week));\n    }\n\n    #[test]\n    fn test_date_year() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"mdv.date(\"year\")\"#).unwrap();\n        // Should be a 4-digit year\n        assert_eq!(result.len(), 4);\n        let year: u32 = result.parse().expect(\"year should be a number\");\n        assert!(year \u003e= 2020);\n    }\n\n    #[test]\n    fn test_render_basic() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine\n            .eval_string(r#\"mdv.render(\"Hello {{name}}\", { name = \"World\" })\"#)\n            .unwrap();\n        assert_eq!(result, \"Hello World\");\n    }\n\n    #[test]\n    fn test_render_multiple_vars() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine\n            .eval_string(r#\"mdv.render(\"{{greeting}}, {{name}}!\", { greeting = \"Hi\", name = \"Lua\" })\"#)\n            .unwrap();\n        assert_eq!(result, \"Hi, Lua!\");\n    }\n\n    #[test]\n    fn test_render_with_numbers() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result =\n            engine.eval_string(r#\"mdv.render(\"Count: {{n}}\", { n = 42 })\"#).unwrap();\n        assert_eq!(result, \"Count: 42\");\n    }\n\n    #[test]\n    fn test_render_with_date_expr() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        // Template engine should handle date expressions in templates\n        let result = engine.eval_string(r#\"mdv.render(\"Date: {{today}}\", {})\"#).unwrap();\n        // Should contain \"Date: \" followed by a date\n        assert!(result.starts_with(\"Date: \"));\n        assert_eq!(result.len(), 16); // \"Date: \" + \"YYYY-MM-DD\"\n    }\n\n    #[test]\n    fn test_is_date_expr_true() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_bool(r#\"mdv.is_date_expr(\"today + 1d\")\"#).unwrap();\n        assert!(result);\n    }\n\n    #[test]\n    fn test_is_date_expr_false() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_bool(r#\"mdv.is_date_expr(\"hello\")\"#).unwrap();\n        assert!(!result);\n    }\n\n    #[test]\n    fn test_is_date_expr_week() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_bool(r#\"mdv.is_date_expr(\"week/start\")\"#).unwrap();\n        assert!(result);\n    }\n\n    #[test]\n    fn test_sandbox_no_io() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"io\"#).unwrap();\n        assert!(result.is_none(), \"io should be nil in sandbox\");\n    }\n\n    #[test]\n    fn test_sandbox_no_os() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"os\"#).unwrap();\n        assert!(result.is_none(), \"os should be nil in sandbox\");\n    }\n\n    #[test]\n    fn test_sandbox_no_require() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"require\"#).unwrap();\n        assert!(result.is_none(), \"require should be nil in sandbox\");\n    }\n\n    #[test]\n    fn test_sandbox_no_load() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"load\"#).unwrap();\n        assert!(result.is_none(), \"load should be nil in sandbox\");\n    }\n\n    #[test]\n    fn test_sandbox_no_debug() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"debug\"#).unwrap();\n        assert!(result.is_none(), \"debug should be nil in sandbox\");\n    }\n\n    #[test]\n    fn test_date_error_handling() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"mdv.date(\"invalid_expr\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_pure_lua_math() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"tostring(1 + 2)\"#).unwrap();\n        assert_eq!(result, \"3\");\n    }\n\n    #[test]\n    fn test_pure_lua_string() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"string.upper(\"hello\")\"#).unwrap();\n        assert_eq!(result, \"HELLO\");\n    }\n\n    #[test]\n    fn test_pure_lua_table() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result =\n            engine.eval_string(r#\"local t = {1, 2, 3}; return tostring(#t)\"#).unwrap();\n        assert_eq!(result, \"3\");\n    }\n\n    #[test]\n    fn test_pure_lua_math_functions() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"tostring(math.floor(3.7))\"#).unwrap();\n        assert_eq!(result, \"3\");\n    }\n\n    #[test]\n    fn test_eval_returns_none_for_nil() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"nil\"#).unwrap();\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_eval_returns_none_for_no_return() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"local x = 1\"#).unwrap();\n        assert!(result.is_none());\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":46}},{"line":41,"address":[],"length":0,"stats":{"Line":92}},{"line":43,"address":[],"length":0,"stats":{"Line":184}},{"line":46,"address":[],"length":0,"stats":{"Line":46}},{"line":47,"address":[],"length":0,"stats":{"Line":138}},{"line":51,"address":[],"length":0,"stats":{"Line":92}},{"line":54,"address":[],"length":0,"stats":{"Line":92}},{"line":56,"address":[],"length":0,"stats":{"Line":46}},{"line":60,"address":[],"length":0,"stats":{"Line":46}},{"line":61,"address":[],"length":0,"stats":{"Line":92}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":21}},{"line":119,"address":[],"length":0,"stats":{"Line":125}},{"line":121,"address":[],"length":0,"stats":{"Line":20}},{"line":122,"address":[],"length":0,"stats":{"Line":7}},{"line":123,"address":[],"length":0,"stats":{"Line":52}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":14}},{"line":135,"address":[],"length":0,"stats":{"Line":56}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":18}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":22}},{"line":154,"address":[],"length":0,"stats":{"Line":22}},{"line":158,"address":[],"length":0,"stats":{"Line":46}},{"line":159,"address":[],"length":0,"stats":{"Line":138}},{"line":169,"address":[],"length":0,"stats":{"Line":138}},{"line":170,"address":[],"length":0,"stats":{"Line":138}},{"line":171,"address":[],"length":0,"stats":{"Line":138}},{"line":172,"address":[],"length":0,"stats":{"Line":138}},{"line":173,"address":[],"length":0,"stats":{"Line":138}},{"line":174,"address":[],"length":0,"stats":{"Line":138}},{"line":175,"address":[],"length":0,"stats":{"Line":138}},{"line":176,"address":[],"length":0,"stats":{"Line":138}},{"line":177,"address":[],"length":0,"stats":{"Line":138}},{"line":179,"address":[],"length":0,"stats":{"Line":46}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}}],"covered":35,"coverable":54},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","hook_runner.rs"],"content":"//! Hook execution for lifecycle events.\n//!\n//! This module provides functions to run lifecycle hooks defined in type definitions.\n\nuse super::engine::LuaEngine;\nuse super::hooks::{HookError, NoteContext};\nuse super::types::SandboxConfig;\nuse super::vault_context::VaultContext;\nuse crate::types::definition::TypeDefinition;\nuse crate::types::validation::yaml_to_lua_table;\n\n/// Result of running a hook that may modify the note.\n#[derive(Debug)]\npub struct HookResult {\n    /// Whether the hook made changes to the note.\n    pub modified: bool,\n    /// The updated frontmatter (if modified).\n    pub frontmatter: Option\u003cserde_yaml::Value\u003e,\n    /// The updated content (if modified).\n    pub content: Option\u003cString\u003e,\n}\n\n/// Alias for backwards compatibility.\npub type UpdateHookResult = HookResult;\n\n/// Run the `on_create` hook for a type definition.\n///\n/// This function is called after a note is created to allow the type definition\n/// to perform additional operations like logging to daily notes, updating indexes,\n/// or modifying the note's frontmatter.\n///\n/// # Arguments\n///\n/// * `typedef` - The type definition containing the hook\n/// * `note_ctx` - Context about the created note\n/// * `vault_ctx` - Vault context with access to repositories\n///\n/// # Returns\n///\n/// * `Ok(HookResult)` with any modifications from the hook\n/// * `Err(HookError)` on failure\n///\n/// # Example\n///\n/// ```ignore\n/// use mdvault_core::scripting::{run_on_create_hook, NoteContext, VaultContext};\n///\n/// let note_ctx = NoteContext::new(path, \"task\".into(), frontmatter, content);\n/// let result = run_on_create_hook(\u0026typedef, \u0026note_ctx, vault_ctx)?;\n/// if result.modified {\n///     // Write back the updated content\n/// }\n/// ```\npub fn run_on_create_hook(\n    typedef: \u0026TypeDefinition,\n    note_ctx: \u0026NoteContext,\n    vault_ctx: VaultContext,\n) -\u003e Result\u003cHookResult, HookError\u003e {\n    // Skip if no hook defined\n    if !typedef.has_on_create_hook {\n        return Ok(HookResult { modified: false, frontmatter: None, content: None });\n    }\n\n    // Create engine with vault context\n    let engine = LuaEngine::with_vault_context(SandboxConfig::restricted(), vault_ctx)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    let lua = engine.lua();\n\n    // Load and evaluate the type definition to get the table\n    let typedef_table: mlua::Table =\n        lua.load(\u0026typedef.lua_source).eval().map_err(|e| {\n            HookError::LuaError(format!(\"failed to load type definition: {}\", e))\n        })?;\n\n    // Build note table for the hook\n    let note_table =\n        lua.create_table().map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"path\", note_ctx.path.to_string_lossy().to_string())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"type\", note_ctx.note_type.clone())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"content\", note_ctx.content.clone())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    // Convert frontmatter to Lua table\n    let fm_table = yaml_to_lua_table(lua, \u0026note_ctx.frontmatter)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"frontmatter\", fm_table)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    // Get on_create function\n    let on_create_fn: mlua::Function = typedef_table.get(\"on_create\").map_err(|e| {\n        HookError::LuaError(format!(\"on_create function not found: {}\", e))\n    })?;\n\n    // Call the hook - it may return a modified note table\n    let result: mlua::Value = on_create_fn\n        .call(note_table)\n        .map_err(|e| HookError::Execution(format!(\"on_create hook failed: {}\", e)))?;\n\n    // Check if hook returned a modified note\n    match result {\n        mlua::Value::Table(returned_note) =\u003e {\n            // Extract frontmatter and content if present\n            let frontmatter: Option\u003cserde_yaml::Value\u003e =\n                if let Ok(fm_table) = returned_note.get::\u003cmlua::Table\u003e(\"frontmatter\") {\n                    Some(lua_table_to_yaml(\u0026fm_table)?)\n                } else {\n                    None\n                };\n\n            let content: Option\u003cString\u003e = returned_note.get(\"content\").ok();\n\n            let modified = frontmatter.is_some() || content.is_some();\n            Ok(HookResult { modified, frontmatter, content })\n        }\n        mlua::Value::Nil =\u003e {\n            // Hook returned nil, no modifications\n            Ok(HookResult { modified: false, frontmatter: None, content: None })\n        }\n        _ =\u003e {\n            // Unexpected return type\n            Ok(HookResult { modified: false, frontmatter: None, content: None })\n        }\n    }\n}\n\n/// Run the `on_update` hook for a type definition.\n///\n/// This function is called after a note is modified (via capture operations) to allow\n/// the type definition to perform additional operations like updating timestamps.\n///\n/// Unlike `on_create`, this hook can return a modified note which will be written back.\n///\n/// # Arguments\n///\n/// * `typedef` - The type definition containing the hook\n/// * `note_ctx` - Context about the updated note\n/// * `vault_ctx` - Vault context with access to repositories\n///\n/// # Returns\n///\n/// * `Ok(UpdateHookResult)` with any modifications from the hook\n/// * `Err(HookError)` on failure\n///\n/// # Example\n///\n/// ```ignore\n/// use mdvault_core::scripting::{run_on_update_hook, NoteContext, VaultContext};\n///\n/// let note_ctx = NoteContext::new(path, \"task\".into(), frontmatter, content);\n/// let result = run_on_update_hook(\u0026typedef, \u0026note_ctx, vault_ctx)?;\n/// if result.modified {\n///     // Write back the updated content\n/// }\n/// ```\npub fn run_on_update_hook(\n    typedef: \u0026TypeDefinition,\n    note_ctx: \u0026NoteContext,\n    vault_ctx: VaultContext,\n) -\u003e Result\u003cUpdateHookResult, HookError\u003e {\n    // Skip if no hook defined\n    if !typedef.has_on_update_hook {\n        return Ok(UpdateHookResult {\n            modified: false,\n            frontmatter: None,\n            content: None,\n        });\n    }\n\n    // Create engine with vault context\n    let engine = LuaEngine::with_vault_context(SandboxConfig::restricted(), vault_ctx)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    let lua = engine.lua();\n\n    // Load and evaluate the type definition to get the table\n    let typedef_table: mlua::Table =\n        lua.load(\u0026typedef.lua_source).eval().map_err(|e| {\n            HookError::LuaError(format!(\"failed to load type definition: {}\", e))\n        })?;\n\n    // Build note table for the hook\n    let note_table =\n        lua.create_table().map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"path\", note_ctx.path.to_string_lossy().to_string())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"type\", note_ctx.note_type.clone())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"content\", note_ctx.content.clone())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    // Convert frontmatter to Lua table\n    let fm_table = yaml_to_lua_table(lua, \u0026note_ctx.frontmatter)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"frontmatter\", fm_table)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    // Get on_update function\n    let on_update_fn: mlua::Function = typedef_table.get(\"on_update\").map_err(|e| {\n        HookError::LuaError(format!(\"on_update function not found: {}\", e))\n    })?;\n\n    // Call the hook - it may return a modified note table\n    let result: mlua::Value = on_update_fn\n        .call(note_table)\n        .map_err(|e| HookError::Execution(format!(\"on_update hook failed: {}\", e)))?;\n\n    // Check if hook returned a modified note\n    match result {\n        mlua::Value::Table(returned_note) =\u003e {\n            // Extract frontmatter and content if present\n            let frontmatter: Option\u003cserde_yaml::Value\u003e =\n                if let Ok(fm_table) = returned_note.get::\u003cmlua::Table\u003e(\"frontmatter\") {\n                    Some(lua_table_to_yaml(\u0026fm_table)?)\n                } else {\n                    None\n                };\n\n            let content: Option\u003cString\u003e = returned_note.get(\"content\").ok();\n\n            let modified = frontmatter.is_some() || content.is_some();\n            Ok(UpdateHookResult { modified, frontmatter, content })\n        }\n        mlua::Value::Nil =\u003e {\n            // Hook returned nil, no modifications\n            Ok(UpdateHookResult { modified: false, frontmatter: None, content: None })\n        }\n        _ =\u003e {\n            // Unexpected return type\n            Ok(UpdateHookResult { modified: false, frontmatter: None, content: None })\n        }\n    }\n}\n\n/// Convert a Lua table to serde_yaml::Value.\nfn lua_table_to_yaml(table: \u0026mlua::Table) -\u003e Result\u003cserde_yaml::Value, HookError\u003e {\n    let mut map = serde_yaml::Mapping::new();\n\n    for pair in table.pairs::\u003cmlua::Value, mlua::Value\u003e() {\n        let (key, value) = pair.map_err(|e| HookError::LuaError(e.to_string()))?;\n\n        let yaml_key = match key {\n            mlua::Value::String(s) =\u003e {\n                let str_val =\n                    s.to_str().map_err(|e| HookError::LuaError(e.to_string()))?;\n                serde_yaml::Value::String(str_val.to_string())\n            }\n            mlua::Value::Integer(i) =\u003e serde_yaml::Value::Number(i.into()),\n            _ =\u003e continue, // Skip non-string/integer keys\n        };\n\n        let yaml_value = lua_value_to_yaml(value)?;\n        map.insert(yaml_key, yaml_value);\n    }\n\n    Ok(serde_yaml::Value::Mapping(map))\n}\n\n/// Convert a single Lua value to serde_yaml::Value.\nfn lua_value_to_yaml(value: mlua::Value) -\u003e Result\u003cserde_yaml::Value, HookError\u003e {\n    match value {\n        mlua::Value::Nil =\u003e Ok(serde_yaml::Value::Null),\n        mlua::Value::Boolean(b) =\u003e Ok(serde_yaml::Value::Bool(b)),\n        mlua::Value::Integer(i) =\u003e Ok(serde_yaml::Value::Number(i.into())),\n        mlua::Value::Number(n) =\u003e {\n            Ok(serde_yaml::Value::Number(serde_yaml::Number::from(n)))\n        }\n        mlua::Value::String(s) =\u003e {\n            let str_val = s.to_str().map_err(|e| HookError::LuaError(e.to_string()))?;\n            Ok(serde_yaml::Value::String(str_val.to_string()))\n        }\n        mlua::Value::Table(t) =\u003e {\n            // Check if it's an array or a map\n            if is_lua_array(\u0026t) {\n                let mut seq = Vec::new();\n                for pair in t.pairs::\u003ci64, mlua::Value\u003e() {\n                    let (_, v) = pair.map_err(|e| HookError::LuaError(e.to_string()))?;\n                    seq.push(lua_value_to_yaml(v)?);\n                }\n                Ok(serde_yaml::Value::Sequence(seq))\n            } else {\n                lua_table_to_yaml(\u0026t)\n            }\n        }\n        _ =\u003e Ok(serde_yaml::Value::Null),\n    }\n}\n\n/// Check if a Lua table is an array (sequential integer keys starting from 1).\nfn is_lua_array(table: \u0026mlua::Table) -\u003e bool {\n    let len = table.raw_len();\n    if len == 0 {\n        // Could be empty table, check for any keys\n        table.pairs::\u003cmlua::Value, mlua::Value\u003e().next().is_none()\n    } else {\n        // Check if keys are 1..=len\n        for i in 1..=len {\n            if table.raw_get::\u003cmlua::Value\u003e(i).is_err() {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use std::path::PathBuf;\n\n    fn make_typedef_with_hook(lua_source: \u0026str) -\u003e TypeDefinition {\n        TypeDefinition {\n            name: \"test\".to_string(),\n            description: None,\n            source_path: PathBuf::new(),\n            schema: HashMap::new(),\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: true,\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: lua_source.to_string(),\n        }\n    }\n\n    fn make_note_ctx() -\u003e NoteContext {\n        NoteContext {\n            path: PathBuf::from(\"test.md\"),\n            note_type: \"test\".to_string(),\n            frontmatter: serde_yaml::Value::Mapping(serde_yaml::Mapping::new()),\n            content: \"# Test\".to_string(),\n        }\n    }\n\n    #[test]\n    fn test_skip_if_no_hook() {\n        let typedef = TypeDefinition {\n            name: \"test\".to_string(),\n            description: None,\n            source_path: PathBuf::new(),\n            schema: HashMap::new(),\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: false, // No hook\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: String::new(),\n        };\n\n        // Create a minimal vault context - this won't be used since there's no hook\n        // We can't easily create a VaultContext in tests without real repositories,\n        // but since has_on_create_hook is false, it will return early\n        let _note_ctx = make_note_ctx();\n\n        // This test verifies that when has_on_create_hook is false,\n        // the function returns Ok(()) without trying to access vault_ctx\n        // However, we need a VaultContext to call the function...\n        // For now, just test the hook detection logic works.\n        assert!(!typedef.has_on_create_hook);\n    }\n\n    #[test]\n    fn test_hook_receives_note_context() {\n        // This test verifies the Lua hook structure works\n        // We create a hook that just returns true without vault operations\n        let lua_source = r#\"\n            return {\n                on_create = function(note)\n                    -- Just verify we can access note fields\n                    local _ = note.path\n                    local _ = note.type\n                    local _ = note.content\n                    local _ = note.frontmatter\n                    return note\n                end\n            }\n        \"#;\n\n        let _typedef = make_typedef_with_hook(lua_source);\n        let _note_ctx = make_note_ctx();\n\n        // Create a sandboxed engine to test the Lua code directly\n        let engine = LuaEngine::sandboxed().unwrap();\n        let lua = engine.lua();\n\n        // Load the typedef\n        let typedef_table: mlua::Table = lua.load(lua_source).eval().unwrap();\n\n        // Build note table\n        let note_table = lua.create_table().unwrap();\n        note_table.set(\"path\", \"test.md\").unwrap();\n        note_table.set(\"type\", \"test\").unwrap();\n        note_table.set(\"content\", \"# Test\").unwrap();\n        let fm = lua.create_table().unwrap();\n        note_table.set(\"frontmatter\", fm).unwrap();\n\n        // Call on_create\n        let on_create: mlua::Function = typedef_table.get(\"on_create\").unwrap();\n        let result = on_create.call::\u003cmlua::Value\u003e(note_table);\n\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":126},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","hooks.rs"],"content":"//! Hook types and errors.\n//!\n//! This module provides types for hook execution, including the note context\n//! passed to hooks and error types for hook failures.\n\nuse std::path::PathBuf;\n\nuse thiserror::Error;\n\n/// Note context passed to Lua hooks.\n///\n/// Contains all information about a note that hooks might need to access.\n#[derive(Debug, Clone)]\npub struct NoteContext {\n    /// Path to the note file (relative to vault root).\n    pub path: PathBuf,\n    /// Note type from frontmatter (e.g., \"task\", \"meeting\").\n    pub note_type: String,\n    /// Parsed frontmatter as YAML value.\n    pub frontmatter: serde_yaml::Value,\n    /// Full content of the note (including frontmatter).\n    pub content: String,\n}\n\nimpl NoteContext {\n    /// Create a new NoteContext.\n    pub fn new(\n        path: PathBuf,\n        note_type: String,\n        frontmatter: serde_yaml::Value,\n        content: String,\n    ) -\u003e Self {\n        Self { path, note_type, frontmatter, content }\n    }\n}\n\n/// Errors that can occur during hook execution.\n#[derive(Debug, Error)]\npub enum HookError {\n    /// Template not found.\n    #[error(\"template not found: {0}\")]\n    TemplateNotFound(String),\n\n    /// Capture not found.\n    #[error(\"capture not found: {0}\")]\n    CaptureNotFound(String),\n\n    /// Macro not found.\n    #[error(\"macro not found: {0}\")]\n    MacroNotFound(String),\n\n    /// Hook execution failed.\n    #[error(\"hook execution failed: {0}\")]\n    Execution(String),\n\n    /// Lua runtime error.\n    #[error(\"Lua error: {0}\")]\n    LuaError(String),\n\n    /// Template rendering error.\n    #[error(\"template render error: {0}\")]\n    TemplateRender(String),\n\n    /// Capture execution error.\n    #[error(\"capture execution error: {0}\")]\n    CaptureExecution(String),\n\n    /// Macro execution error.\n    #[error(\"macro execution error: {0}\")]\n    MacroExecution(String),\n\n    /// IO error during hook execution.\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","index_bindings.rs"],"content":"//! Index query bindings for Lua.\n//!\n//! This module provides Lua bindings for querying the vault index:\n//! - `mdv.current_note()` - Get the current note being processed\n//! - `mdv.backlinks(path)` - Get notes linking to a path\n//! - `mdv.outlinks(path)` - Get notes a path links to\n//! - `mdv.query(opts)` - Query the vault index\n\nuse std::path::Path;\n\nuse mlua::{Function, Lua, Result as LuaResult, Table, Value};\n\nuse super::vault_context::VaultContext;\nuse crate::index::NoteQuery;\nuse crate::types::validation::yaml_to_lua_table;\n\n/// Register index query bindings on an existing mdv table.\n///\n/// This adds `mdv.current_note()`, `mdv.backlinks()`, `mdv.outlinks()`, and\n/// `mdv.query()` functions that have access to the vault index.\npub fn register_index_bindings(lua: \u0026Lua) -\u003e LuaResult\u003c()\u003e {\n    let mdv: Table = lua.globals().get(\"mdv\")?;\n\n    mdv.set(\"current_note\", create_current_note_fn(lua)?)?;\n    mdv.set(\"backlinks\", create_backlinks_fn(lua)?)?;\n    mdv.set(\"outlinks\", create_outlinks_fn(lua)?)?;\n    mdv.set(\"query\", create_query_fn(lua)?)?;\n\n    Ok(())\n}\n\n/// Create the `mdv.current_note()` function.\n///\n/// Returns the current note being processed, or nil if not available.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local note = mdv.current_note()\n/// if note then\n///     print(\"Processing: \" .. note.path)\n///     print(\"Type: \" .. note.type)\n/// end\n/// ```\nfn create_current_note_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, ()| {\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        let current = match \u0026ctx.current_note {\n            Some(note) =\u003e note,\n            None =\u003e return Ok(Value::Nil),\n        };\n\n        // Build note table\n        let note_table = lua.create_table()?;\n        note_table.set(\"path\", current.path.as_str())?;\n        note_table.set(\"type\", current.note_type.as_str())?;\n        note_table.set(\"content\", current.content.as_str())?;\n\n        if let Some(title) = \u0026current.title {\n            note_table.set(\"title\", title.as_str())?;\n        }\n\n        if let Some(fm) = \u0026current.frontmatter {\n            let fm_table = yaml_to_lua_table(lua, fm)?;\n            note_table.set(\"frontmatter\", fm_table)?;\n        }\n\n        Ok(Value::Table(note_table))\n    })\n}\n\n/// Create the `mdv.backlinks(path)` function.\n///\n/// Returns a list of notes that link to the specified path.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local links = mdv.backlinks(\"projects/my-project.md\")\n/// for _, link in ipairs(links) do\n///     print(link.source_path .. \" links to this note\")\n/// end\n/// ```\nfn create_backlinks_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, path: String| {\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        let db = match \u0026ctx.index_db {\n            Some(db) =\u003e db,\n            None =\u003e {\n                return Err(mlua::Error::runtime(\n                    \"Index database not available. Run 'mdv reindex' first.\",\n                ));\n            }\n        };\n\n        // Resolve path\n        let resolved_path = resolve_note_path(\u0026ctx.vault_root, \u0026path);\n\n        // Get note ID\n        let note = match db.get_note_by_path(Path::new(\u0026resolved_path)) {\n            Ok(Some(n)) =\u003e n,\n            Ok(None) =\u003e {\n                // Return empty table if note not found\n                return Ok(Value::Table(lua.create_table()?));\n            }\n            Err(e) =\u003e return Err(mlua::Error::runtime(format!(\"Index error: {}\", e))),\n        };\n\n        let note_id = match note.id {\n            Some(id) =\u003e id,\n            None =\u003e return Ok(Value::Table(lua.create_table()?)),\n        };\n\n        // Get backlinks\n        let backlinks = db\n            .get_backlinks(note_id)\n            .map_err(|e| mlua::Error::runtime(format!(\"Index error: {}\", e)))?;\n\n        // Convert to Lua table\n        let result = lua.create_table()?;\n        for (i, link) in backlinks.iter().enumerate() {\n            let link_table = lua.create_table()?;\n\n            // Get source note path\n            if let Ok(Some(source_note)) = db.get_note_by_id(link.source_id) {\n                link_table\n                    .set(\"source_path\", source_note.path.to_string_lossy().to_string())?;\n                link_table.set(\"source_title\", source_note.title)?;\n                link_table.set(\"source_type\", source_note.note_type.as_str())?;\n            }\n\n            if let Some(text) = \u0026link.link_text {\n                link_table.set(\"link_text\", text.as_str())?;\n            }\n            if let Some(context) = \u0026link.context {\n                link_table.set(\"context\", context.as_str())?;\n            }\n            link_table.set(\"link_type\", link.link_type.as_str())?;\n\n            result.set(i + 1, link_table)?;\n        }\n\n        Ok(Value::Table(result))\n    })\n}\n\n/// Create the `mdv.outlinks(path)` function.\n///\n/// Returns a list of notes that the specified path links to.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local links = mdv.outlinks(\"projects/my-project.md\")\n/// for _, link in ipairs(links) do\n///     print(\"Links to: \" .. link.target_path)\n/// end\n/// ```\nfn create_outlinks_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, path: String| {\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        let db = match \u0026ctx.index_db {\n            Some(db) =\u003e db,\n            None =\u003e {\n                return Err(mlua::Error::runtime(\n                    \"Index database not available. Run 'mdv reindex' first.\",\n                ));\n            }\n        };\n\n        // Resolve path\n        let resolved_path = resolve_note_path(\u0026ctx.vault_root, \u0026path);\n\n        // Get note ID\n        let note = match db.get_note_by_path(Path::new(\u0026resolved_path)) {\n            Ok(Some(n)) =\u003e n,\n            Ok(None) =\u003e {\n                // Return empty table if note not found\n                return Ok(Value::Table(lua.create_table()?));\n            }\n            Err(e) =\u003e return Err(mlua::Error::runtime(format!(\"Index error: {}\", e))),\n        };\n\n        let note_id = match note.id {\n            Some(id) =\u003e id,\n            None =\u003e return Ok(Value::Table(lua.create_table()?)),\n        };\n\n        // Get outgoing links\n        let outlinks = db\n            .get_outgoing_links(note_id)\n            .map_err(|e| mlua::Error::runtime(format!(\"Index error: {}\", e)))?;\n\n        // Convert to Lua table\n        let result = lua.create_table()?;\n        for (i, link) in outlinks.iter().enumerate() {\n            let link_table = lua.create_table()?;\n\n            link_table.set(\"target_path\", link.target_path.as_str())?;\n\n            // Get target note info if resolved\n            if let Some(target_id) = link.target_id {\n                if let Ok(Some(target_note)) = db.get_note_by_id(target_id) {\n                    link_table.set(\"target_title\", target_note.title)?;\n                    link_table.set(\"target_type\", target_note.note_type.as_str())?;\n                    link_table.set(\"resolved\", true)?;\n                } else {\n                    link_table.set(\"resolved\", false)?;\n                }\n            } else {\n                link_table.set(\"resolved\", false)?;\n            }\n\n            if let Some(text) = \u0026link.link_text {\n                link_table.set(\"link_text\", text.as_str())?;\n            }\n            link_table.set(\"link_type\", link.link_type.as_str())?;\n\n            result.set(i + 1, link_table)?;\n        }\n\n        Ok(Value::Table(result))\n    })\n}\n\n/// Create the `mdv.query(opts)` function.\n///\n/// Query the vault index with filters.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// -- Find all open tasks\n/// local tasks = mdv.query({ type = \"task\" })\n/// for _, note in ipairs(tasks) do\n///     print(note.path .. \": \" .. note.title)\n/// end\n///\n/// -- Find recent notes\n/// local recent = mdv.query({ limit = 10 })\n/// ```\nfn create_query_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, opts: Option\u003cTable\u003e| {\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        let db = match \u0026ctx.index_db {\n            Some(db) =\u003e db,\n            None =\u003e {\n                return Err(mlua::Error::runtime(\n                    \"Index database not available. Run 'mdv reindex' first.\",\n                ));\n            }\n        };\n\n        // Build query from options\n        let mut query = NoteQuery::default();\n\n        if let Some(opts) = opts {\n            // Type filter\n            if let Ok(type_str) = opts.get::\u003cString\u003e(\"type\") {\n                query.note_type = Some(type_str.parse().unwrap_or_default());\n            }\n\n            // Path prefix filter\n            if let Ok(prefix) = opts.get::\u003cString\u003e(\"path_prefix\") {\n                query.path_prefix = Some(std::path::PathBuf::from(prefix));\n            }\n\n            // Limit\n            if let Ok(limit) = opts.get::\u003ci64\u003e(\"limit\") {\n                query.limit = Some(limit as u32);\n            }\n\n            // Offset\n            if let Ok(offset) = opts.get::\u003ci64\u003e(\"offset\") {\n                query.offset = Some(offset as u32);\n            }\n        }\n\n        // Execute query\n        let notes = db\n            .query_notes(\u0026query)\n            .map_err(|e| mlua::Error::runtime(format!(\"Query error: {}\", e)))?;\n\n        // Convert to Lua table\n        let result = lua.create_table()?;\n        for (i, note) in notes.iter().enumerate() {\n            let note_table = lua.create_table()?;\n            note_table.set(\"path\", note.path.to_string_lossy().to_string())?;\n            note_table.set(\"type\", note.note_type.as_str())?;\n            note_table.set(\"title\", note.title.clone())?;\n            note_table.set(\"modified\", note.modified.to_rfc3339())?;\n\n            if let Some(created) = note.created {\n                note_table.set(\"created\", created.to_rfc3339())?;\n            }\n\n            // Parse and include frontmatter if available\n            if let Some(fm_json) = \u0026note.frontmatter_json\n                \u0026\u0026 let Ok(fm) = serde_json::from_str::\u003cserde_json::Value\u003e(fm_json)\n            {\n                let fm_yaml = json_to_yaml(\u0026fm);\n                let fm_lua = yaml_to_lua_table(lua, \u0026fm_yaml)?;\n                note_table.set(\"frontmatter\", fm_lua)?;\n            }\n\n            result.set(i + 1, note_table)?;\n        }\n\n        Ok(Value::Table(result))\n    })\n}\n\n/// Resolve a note path relative to vault root.\nfn resolve_note_path(_vault_root: \u0026std::path::Path, path: \u0026str) -\u003e String {\n    // If path doesn't end with .md, append it\n    if path.ends_with(\".md\") { path.to_string() } else { format!(\"{}.md\", path) }\n}\n\n/// Convert serde_json::Value to serde_yaml::Value.\nfn json_to_yaml(json: \u0026serde_json::Value) -\u003e serde_yaml::Value {\n    match json {\n        serde_json::Value::Null =\u003e serde_yaml::Value::Null,\n        serde_json::Value::Bool(b) =\u003e serde_yaml::Value::Bool(*b),\n        serde_json::Value::Number(n) =\u003e {\n            if let Some(i) = n.as_i64() {\n                serde_yaml::Value::Number(i.into())\n            } else if let Some(f) = n.as_f64() {\n                serde_yaml::Value::Number(serde_yaml::Number::from(f))\n            } else {\n                serde_yaml::Value::Null\n            }\n        }\n        serde_json::Value::String(s) =\u003e serde_yaml::Value::String(s.clone()),\n        serde_json::Value::Array(arr) =\u003e {\n            serde_yaml::Value::Sequence(arr.iter().map(json_to_yaml).collect())\n        }\n        serde_json::Value::Object(obj) =\u003e {\n            let mut map = serde_yaml::Mapping::new();\n            for (k, v) in obj {\n                map.insert(serde_yaml::Value::String(k.clone()), json_to_yaml(v));\n            }\n            serde_yaml::Value::Mapping(map)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_resolve_note_path_with_extension() {\n        let vault_root = std::path::Path::new(\"/vault\");\n        let result = resolve_note_path(vault_root, \"notes/test.md\");\n        assert_eq!(result, \"notes/test.md\");\n    }\n\n    #[test]\n    fn test_resolve_note_path_without_extension() {\n        let vault_root = std::path::Path::new(\"/vault\");\n        let result = resolve_note_path(vault_root, \"notes/test\");\n        assert_eq!(result, \"notes/test.md\");\n    }\n\n    #[test]\n    fn test_json_to_yaml() {\n        let json = serde_json::json!({\n            \"string\": \"value\",\n            \"number\": 42,\n            \"bool\": true,\n            \"array\": [1, 2, 3]\n        });\n\n        let yaml = json_to_yaml(\u0026json);\n\n        if let serde_yaml::Value::Mapping(map) = yaml {\n            assert!(map.contains_key(serde_yaml::Value::String(\"string\".into())));\n            assert!(map.contains_key(serde_yaml::Value::String(\"number\".into())));\n        } else {\n            panic!(\"Expected mapping\");\n        }\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":8}},{"line":332,"address":[],"length":0,"stats":{"Line":8}},{"line":333,"address":[],"length":0,"stats":{"Line":8}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":2}},{"line":336,"address":[],"length":0,"stats":{"Line":4}},{"line":337,"address":[],"length":0,"stats":{"Line":8}},{"line":338,"address":[],"length":0,"stats":{"Line":4}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":2}},{"line":346,"address":[],"length":0,"stats":{"Line":1}},{"line":347,"address":[],"length":0,"stats":{"Line":2}},{"line":349,"address":[],"length":0,"stats":{"Line":1}},{"line":350,"address":[],"length":0,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":17}},{"line":352,"address":[],"length":0,"stats":{"Line":16}},{"line":354,"address":[],"length":0,"stats":{"Line":1}}],"covered":16,"coverable":154},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","mod.rs"],"content":"//! Lua scripting support for mdvault.\n//!\n//! This module provides a sandboxed Lua environment with access to\n//! mdvault's date math and template rendering engines.\n//!\n//! # Overview\n//!\n//! The scripting layer allows users to define custom validation logic,\n//! type definitions, and automation rules in Lua while having access\n//! to mdvault's core functionality.\n//!\n//! # Example\n//!\n//! ```rust\n//! use mdvault_core::scripting::LuaEngine;\n//!\n//! let engine = LuaEngine::sandboxed().unwrap();\n//!\n//! // Use date math\n//! let date = engine.eval_string(r#\"mdv.date(\"today + 7d\")\"#).unwrap();\n//! println!(\"One week from now: {}\", date);\n//!\n//! // Render templates\n//! let greeting = engine.eval_string(\n//!     r#\"mdv.render(\"Hello {{name}}!\", { name = \"World\" })\"#\n//! ).unwrap();\n//! println!(\"{}\", greeting);\n//! ```\n//!\n//! # Available Lua Functions\n//!\n//! The `mdv` global table provides:\n//!\n//! - `mdv.date(expr, format?)` - Evaluate date math expressions\n//! - `mdv.render(template, context)` - Render templates with variables\n//! - `mdv.is_date_expr(str)` - Check if a string is a date expression\n//!\n//! With vault context (via `LuaEngine::with_vault_context`):\n//! - `mdv.template(name, vars?)` - Render a template by name\n//! - `mdv.capture(name, vars?)` - Execute a capture workflow\n//! - `mdv.macro(name, vars?)` - Execute a macro workflow\n//! - `mdv.read_note(path)` - Read a note's content and frontmatter\n//! - `mdv.current_note()` - Get the current note being processed\n//! - `mdv.backlinks(path)` - Get notes linking to a path\n//! - `mdv.outlinks(path)` - Get notes a path links to\n//! - `mdv.query(opts)` - Query the vault index\n//!\n//! # Security\n//!\n//! By default, the Lua environment is sandboxed to prevent:\n//! - File system access (`io` library removed)\n//! - Shell command execution (`os` library removed)\n//! - Loading external modules (`require` removed)\n//! - Arbitrary code loading (`load`, `loadfile`, `dofile` removed)\n//! - Debug library access (`debug` removed)\n\npub mod bindings;\npub mod engine;\npub mod hook_runner;\npub mod hooks;\npub mod index_bindings;\npub mod types;\npub mod vault_bindings;\npub mod vault_context;\n\npub use engine::LuaEngine;\npub use hook_runner::{\n    HookResult, UpdateHookResult, run_on_create_hook, run_on_update_hook,\n};\npub use hooks::{HookError, NoteContext};\npub use types::{SandboxConfig, ScriptingError};\npub use vault_context::{CurrentNote, VaultContext};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","types.rs"],"content":"//! Scripting types and error definitions.\n\nuse thiserror::Error;\n\n/// Errors that can occur during Lua script execution.\n#[derive(Debug, Error)]\npub enum ScriptingError {\n    /// Error from the Lua runtime.\n    #[error(\"Lua error: {0}\")]\n    Lua(#[from] mlua::Error),\n\n    /// Error evaluating a date math expression.\n    #[error(\"date math error: {0}\")]\n    DateMath(String),\n\n    /// Error rendering a template.\n    #[error(\"template render error: {0}\")]\n    TemplateRender(String),\n\n    /// Sandbox security violation.\n    #[error(\"sandbox violation: {0}\")]\n    SandboxViolation(String),\n}\n\n/// Configuration for the Lua sandbox.\n#[derive(Debug, Clone)]\npub struct SandboxConfig {\n    /// Maximum memory the Lua VM can allocate (in bytes). 0 = unlimited.\n    pub memory_limit: usize,\n\n    /// Maximum instructions before timeout. 0 = unlimited.\n    pub instruction_limit: u32,\n\n    /// Whether to allow `require` for loading modules.\n    pub allow_require: bool,\n}\n\nimpl Default for SandboxConfig {\n    fn default() -\u003e Self {\n        Self::restricted()\n    }\n}\n\nimpl SandboxConfig {\n    /// A restrictive sandbox suitable for user scripts.\n    pub fn restricted() -\u003e Self {\n        Self {\n            memory_limit: 10 * 1024 * 1024, // 10 MB\n            instruction_limit: 100_000,\n            allow_require: false,\n        }\n    }\n\n    /// An unrestricted configuration (use with caution).\n    pub fn unrestricted() -\u003e Self {\n        Self { memory_limit: 0, instruction_limit: 0, allow_require: true }\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":46}},{"line":48,"address":[],"length":0,"stats":{"Line":46}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":5},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","vault_bindings.rs"],"content":"//! Vault operation bindings for Lua.\n//!\n//! This module provides Lua bindings for vault operations:\n//! - `mdv.template(name, vars?)` - Render a template by name\n//! - `mdv.capture(name, vars?)` - Execute a capture workflow\n//! - `mdv.macro(name, vars?)` - Execute a macro workflow\n//! - `mdv.read_note(path)` - Read a note's content and frontmatter\n\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\nuse chrono::Local;\nuse mlua::{Function, Lua, MultiValue, Result as LuaResult, Table, Value};\n\nuse super::vault_context::VaultContext;\nuse crate::captures::CaptureSpec;\nuse crate::config::types::ResolvedConfig;\nuse crate::frontmatter::{apply_ops, parse, serialize};\nuse crate::macros::runner::{MacroRunError, RunContext, RunOptions, StepExecutor};\nuse crate::macros::types::{CaptureStep, ShellStep, StepResult, TemplateStep};\nuse crate::markdown_ast::{MarkdownEditor, SectionMatch};\nuse crate::templates::engine::render_string;\nuse crate::types::validation::yaml_to_lua_table;\n\n/// Register vault operation bindings on an existing mdv table.\n///\n/// This adds `mdv.template()`, `mdv.capture()`, and `mdv.macro()` functions\n/// that have access to the vault context for executing operations.\npub fn register_vault_bindings(lua: \u0026Lua, ctx: VaultContext) -\u003e LuaResult\u003c()\u003e {\n    // Store context in Lua app data\n    lua.set_app_data(ctx);\n\n    let mdv: Table = lua.globals().get(\"mdv\")?;\n\n    mdv.set(\"template\", create_template_fn(lua)?)?;\n    mdv.set(\"capture\", create_capture_fn(lua)?)?;\n    mdv.set(\"macro\", create_macro_fn(lua)?)?;\n    mdv.set(\"read_note\", create_read_note_fn(lua)?)?;\n\n    Ok(())\n}\n\n/// Create the `mdv.template(name, vars?)` function.\n///\n/// Returns: `(content, nil)` on success, `(nil, error)` on failure.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local content, err = mdv.template(\"meeting\", { title = \"Standup\" })\n/// if err then\n///     print(\"Error: \" .. err)\n/// else\n///     print(content)\n/// end\n/// ```\nfn create_template_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, args: (String, Option\u003cTable\u003e)| {\n        let (template_name, vars_table) = args;\n\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        // Load template\n        let loaded = match ctx.template_repo.get_by_name(\u0026template_name) {\n            Ok(t) =\u003e t,\n            Err(e) =\u003e {\n                return Ok(MultiValue::from_vec(vec![\n                    Value::Nil,\n                    Value::String(lua.create_string(format!(\n                        \"template '{}' not found: {}\",\n                        template_name, e\n                    ))?),\n                ]));\n            }\n        };\n\n        // Build render context\n        let mut render_ctx = build_base_context(\u0026ctx.config);\n        if let Some(table) = vars_table {\n            for pair in table.pairs::\u003cString, Value\u003e() {\n                let (key, value) = pair?;\n                let str_value = lua_value_to_string(\u0026key, value)?;\n                render_ctx.insert(key, str_value);\n            }\n        }\n\n        // Render template body\n        match render_string(\u0026loaded.body, \u0026render_ctx) {\n            Ok(rendered) =\u003e Ok(MultiValue::from_vec(vec![\n                Value::String(lua.create_string(\u0026rendered)?),\n                Value::Nil,\n            ])),\n            Err(e) =\u003e Ok(MultiValue::from_vec(vec![\n                Value::Nil,\n                Value::String(\n                    lua.create_string(format!(\"template render error: {}\", e))?,\n                ),\n            ])),\n        }\n    })\n}\n\n/// Create the `mdv.capture(name, vars?)` function.\n///\n/// Returns: `(true, nil)` on success, `(false, error)` on failure.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local ok, err = mdv.capture(\"log-to-daily\", { text = \"Created note\" })\n/// if not ok then\n///     print(\"Error: \" .. err)\n/// end\n/// ```\nfn create_capture_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, args: (String, Option\u003cTable\u003e)| {\n        let (capture_name, vars_table) = args;\n\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        // Load capture\n        let loaded = match ctx.capture_repo.get_by_name(\u0026capture_name) {\n            Ok(c) =\u003e c,\n            Err(e) =\u003e {\n                return Ok(MultiValue::from_vec(vec![\n                    Value::Boolean(false),\n                    Value::String(lua.create_string(format!(\n                        \"capture '{}' not found: {}\",\n                        capture_name, e\n                    ))?),\n                ]));\n            }\n        };\n\n        // Build context\n        let mut vars = build_base_context(\u0026ctx.config);\n        if let Some(table) = vars_table {\n            for pair in table.pairs::\u003cString, Value\u003e() {\n                let (key, value) = pair?;\n                let str_value = lua_value_to_string(\u0026key, value)?;\n                vars.insert(key, str_value);\n            }\n        }\n\n        // Execute capture\n        match execute_capture(\u0026ctx.config, \u0026loaded.spec, \u0026vars) {\n            Ok(_) =\u003e Ok(MultiValue::from_vec(vec![Value::Boolean(true), Value::Nil])),\n            Err(e) =\u003e Ok(MultiValue::from_vec(vec![\n                Value::Boolean(false),\n                Value::String(lua.create_string(\u0026e)?),\n            ])),\n        }\n    })\n}\n\n/// Create the `mdv.macro(name, vars?)` function.\n///\n/// Returns: `(true, nil)` on success, `(false, error)` on failure.\n///\n/// Note: Shell steps in macros are NOT executed from hooks (no --trust context).\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local ok, err = mdv.macro(\"on-task-created\", { task_path = note.path })\n/// if not ok then\n///     print(\"Error: \" .. err)\n/// end\n/// ```\nfn create_macro_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, args: (String, Option\u003cTable\u003e)| {\n        let (macro_name, vars_table) = args;\n\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        // Load macro\n        let loaded = match ctx.macro_repo.get_by_name(\u0026macro_name) {\n            Ok(m) =\u003e m,\n            Err(e) =\u003e {\n                return Ok(MultiValue::from_vec(vec![\n                    Value::Boolean(false),\n                    Value::String(lua.create_string(format!(\n                        \"macro '{}' not found: {}\",\n                        macro_name, e\n                    ))?),\n                ]));\n            }\n        };\n\n        // Build context\n        let mut vars = build_base_context(\u0026ctx.config);\n        if let Some(table) = vars_table {\n            for pair in table.pairs::\u003cString, Value\u003e() {\n                let (key, value) = pair?;\n                let str_value = lua_value_to_string(\u0026key, value)?;\n                vars.insert(key, str_value);\n            }\n        }\n\n        // Create a hook step executor (no shell support)\n        let executor = HookStepExecutor {\n            config: ctx.config.clone(),\n            template_repo: ctx.template_repo.clone(),\n            capture_repo: ctx.capture_repo.clone(),\n        };\n\n        // Run macro with shell disabled (no --trust in hooks)\n        let run_ctx = RunContext::new(\n            vars,\n            RunOptions { trust: false, allow_shell: false, dry_run: false },\n        );\n\n        let result = crate::macros::runner::run_macro(\u0026loaded, \u0026executor, run_ctx);\n\n        if result.success {\n            Ok(MultiValue::from_vec(vec![Value::Boolean(true), Value::Nil]))\n        } else {\n            Ok(MultiValue::from_vec(vec![\n                Value::Boolean(false),\n                Value::String(lua.create_string(\u0026result.message)?),\n            ]))\n        }\n    })\n}\n\n/// Create the `mdv.read_note(path)` function.\n///\n/// Reads a note from the vault and returns its content and frontmatter.\n///\n/// Returns: `(note_table, nil)` on success, `(nil, error)` on failure.\n///\n/// The note table contains:\n/// - `path`: The resolved path to the note\n/// - `content`: The full file content including frontmatter\n/// - `body`: The note body without frontmatter\n/// - `frontmatter`: A table with frontmatter fields (if present)\n/// - `title`: The title from frontmatter (if present)\n/// - `type`: The note type from frontmatter (if present)\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local note, err = mdv.read_note(\"projects/my-project.md\")\n/// if err then\n///     print(\"Error: \" .. err)\n/// else\n///     print(\"Title: \" .. (note.title or \"untitled\"))\n///     if note.frontmatter then\n///         print(\"Status: \" .. (note.frontmatter.status or \"unknown\"))\n///     end\n/// end\n/// ```\nfn create_read_note_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, path: String| {\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        // Resolve path relative to vault root\n        let resolved_path =\n            if path.ends_with(\".md\") { path.clone() } else { format!(\"{}.md\", path) };\n\n        let full_path = if Path::new(\u0026resolved_path).is_absolute() {\n            std::path::PathBuf::from(\u0026resolved_path)\n        } else {\n            ctx.vault_root.join(\u0026resolved_path)\n        };\n\n        // Read file content\n        let content = match fs::read_to_string(\u0026full_path) {\n            Ok(c) =\u003e c,\n            Err(e) =\u003e {\n                return Ok(MultiValue::from_vec(vec![\n                    Value::Nil,\n                    Value::String(lua.create_string(format!(\n                        \"failed to read '{}': {}\",\n                        full_path.display(),\n                        e\n                    ))?),\n                ]));\n            }\n        };\n\n        // Parse frontmatter\n        let parsed = match parse(\u0026content) {\n            Ok(p) =\u003e p,\n            Err(e) =\u003e {\n                return Ok(MultiValue::from_vec(vec![\n                    Value::Nil,\n                    Value::String(\n                        lua.create_string(format!(\"failed to parse frontmatter: {}\", e))?,\n                    ),\n                ]));\n            }\n        };\n\n        // Build note table\n        let note_table = lua.create_table()?;\n        note_table.set(\"path\", resolved_path)?;\n        note_table.set(\"content\", content)?;\n        note_table.set(\"body\", parsed.body.clone())?;\n\n        // Add frontmatter if present\n        if let Some(ref fm) = parsed.frontmatter {\n            // Convert frontmatter to serde_yaml::Value for yaml_to_lua_table\n            let fm_yaml = serde_yaml::to_value(fm).map_err(|e| {\n                mlua::Error::runtime(format!(\"failed to serialize frontmatter: {}\", e))\n            })?;\n\n            let fm_table = yaml_to_lua_table(lua, \u0026fm_yaml)?;\n            note_table.set(\"frontmatter\", fm_table)?;\n\n            // Extract common fields for convenience\n            if let Some(title) = fm.fields.get(\"title\").and_then(|v| v.as_str()) {\n                note_table.set(\"title\", title)?;\n            }\n            if let Some(note_type) = fm.fields.get(\"type\").and_then(|v| v.as_str()) {\n                note_table.set(\"type\", note_type)?;\n            }\n        }\n\n        Ok(MultiValue::from_vec(vec![Value::Table(note_table), Value::Nil]))\n    })\n}\n\n/// Build base context with date/time and config paths.\nfn build_base_context(config: \u0026ResolvedConfig) -\u003e HashMap\u003cString, String\u003e {\n    let mut ctx = HashMap::new();\n    let now = Local::now();\n\n    // Date/time\n    ctx.insert(\"date\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"time\".into(), now.format(\"%H:%M\").to_string());\n    ctx.insert(\"datetime\".into(), now.to_rfc3339());\n    ctx.insert(\"today\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"now\".into(), now.format(\"%Y-%m-%dT%H:%M:%S\").to_string());\n\n    // Config paths\n    ctx.insert(\"vault_root\".into(), config.vault_root.to_string_lossy().to_string());\n    ctx.insert(\n        \"templates_dir\".into(),\n        config.templates_dir.to_string_lossy().to_string(),\n    );\n    ctx.insert(\"captures_dir\".into(), config.captures_dir.to_string_lossy().to_string());\n    ctx.insert(\"macros_dir\".into(), config.macros_dir.to_string_lossy().to_string());\n\n    ctx\n}\n\n/// Convert a Lua value to a string.\nfn lua_value_to_string(key: \u0026str, value: Value) -\u003e LuaResult\u003cString\u003e {\n    match value {\n        Value::String(s) =\u003e Ok(s.to_str()?.to_string()),\n        Value::Integer(i) =\u003e Ok(i.to_string()),\n        Value::Number(n) =\u003e Ok(n.to_string()),\n        Value::Boolean(b) =\u003e Ok(b.to_string()),\n        Value::Nil =\u003e Ok(String::new()),\n        _ =\u003e Err(mlua::Error::runtime(format!(\n            \"context value for '{}' must be string, number, boolean, or nil\",\n            key\n        ))),\n    }\n}\n\n/// Execute a capture operation.\nfn execute_capture(\n    config: \u0026ResolvedConfig,\n    spec: \u0026CaptureSpec,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(), String\u003e {\n    // Render target file path\n    let target_file_raw =\n        render_string(\u0026spec.target.file, vars).map_err(|e| e.to_string())?;\n    let target_file = resolve_target_path(\u0026config.vault_root, \u0026target_file_raw);\n\n    // Read existing file or create if missing\n    let existing_content = match fs::read_to_string(\u0026target_file) {\n        Ok(content) =\u003e content,\n        Err(e)\n            if e.kind() == std::io::ErrorKind::NotFound\n                \u0026\u0026 spec.target.create_if_missing =\u003e\n        {\n            // Create the file with minimal structure\n            let content = create_minimal_note(vars, spec.target.section.as_deref());\n\n            // Ensure parent directory exists\n            if let Some(parent) = target_file.parent() {\n                fs::create_dir_all(parent).map_err(|e| {\n                    format!(\"failed to create directory {}: {}\", parent.display(), e)\n                })?;\n            }\n\n            // Write the new file\n            fs::write(\u0026target_file, \u0026content).map_err(|e| {\n                format!(\"failed to create target file {}: {}\", target_file.display(), e)\n            })?;\n\n            content\n        }\n        Err(e) =\u003e {\n            return Err(format!(\n                \"failed to read target file {}: {}\",\n                target_file.display(),\n                e\n            ));\n        }\n    };\n\n    // Execute capture operations\n    let (result_content, _section_info) =\n        execute_capture_operations(\u0026existing_content, spec, vars)?;\n\n    // Write back to file\n    fs::write(\u0026target_file, \u0026result_content)\n        .map_err(|e| format!(\"failed to write to {}: {}\", target_file.display(), e))?;\n\n    Ok(())\n}\n\n/// Create a minimal note structure for auto-created files.\nfn create_minimal_note(vars: \u0026HashMap\u003cString, String\u003e, section: Option\u003c\u0026str\u003e) -\u003e String {\n    let date = vars.get(\"date\").map(|s| s.as_str()).unwrap_or(\"unknown\");\n    let title = vars.get(\"title\").map(|s| s.as_str()).unwrap_or(date);\n\n    let mut content = format!(\"---\\ntype: daily\\ndate: {}\\n---\\n\\n# {}\\n\", date, title);\n\n    // Add the target section if specified\n    if let Some(section_name) = section {\n        content.push_str(\u0026format!(\"\\n## {}\\n\", section_name));\n    }\n\n    content\n}\n\n/// Execute capture operations: frontmatter modification and/or content insertion.\nfn execute_capture_operations(\n    existing_content: \u0026str,\n    spec: \u0026CaptureSpec,\n    ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(String, Option\u003c(String, u8)\u003e), String\u003e {\n    // Parse frontmatter from existing content\n    let mut parsed = parse(existing_content)\n        .map_err(|e| format!(\"failed to parse frontmatter: {}\", e))?;\n    let mut section_info = None;\n\n    // Apply frontmatter operations if specified\n    if let Some(fm_ops) = \u0026spec.frontmatter {\n        parsed = apply_ops(parsed, fm_ops, ctx)\n            .map_err(|e| format!(\"failed to apply frontmatter ops: {}\", e))?;\n    }\n\n    // Insert content if specified\n    if let Some(content_template) = \u0026spec.content {\n        let section = spec.target.section.as_ref().ok_or_else(|| {\n            \"capture has content but no target section specified\".to_string()\n        })?;\n\n        let rendered_section = render_string(section, ctx).map_err(|e| e.to_string())?;\n        let rendered_content =\n            render_string(content_template, ctx).map_err(|e| e.to_string())?;\n\n        let section_match = SectionMatch::new(\u0026rendered_section);\n        let position = spec.target.position.clone().into();\n\n        let result = MarkdownEditor::insert_into_section(\n            \u0026parsed.body,\n            \u0026section_match,\n            \u0026rendered_content,\n            position,\n        )\n        .map_err(|e| format!(\"section insertion failed: {}\", e))?;\n\n        section_info = Some((result.matched_heading.title, result.matched_heading.level));\n        parsed.body = result.content;\n    }\n\n    // Serialize the document\n    let final_content = serialize(\u0026parsed);\n    Ok((final_content, section_info))\n}\n\nfn resolve_target_path(vault_root: \u0026Path, target: \u0026str) -\u003e std::path::PathBuf {\n    let path = Path::new(target);\n    if path.is_absolute() { path.to_path_buf() } else { vault_root.join(path) }\n}\n\n/// Step executor for hooks (no shell support).\nstruct HookStepExecutor {\n    config: std::sync::Arc\u003cResolvedConfig\u003e,\n    template_repo: std::sync::Arc\u003ccrate::templates::repository::TemplateRepository\u003e,\n    capture_repo: std::sync::Arc\u003ccrate::captures::CaptureRepository\u003e,\n}\n\nimpl StepExecutor for HookStepExecutor {\n    fn execute_template(\n        \u0026self,\n        step: \u0026TemplateStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        // Load template\n        let loaded = self\n            .template_repo\n            .get_by_name(\u0026step.template)\n            .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n        // Merge step vars\n        let vars = ctx.with_step_vars(\u0026step.vars_with);\n\n        // Resolve output path\n        let output_path = if let Some(output) = step.output.as_ref() {\n            let rendered = render_string(output, \u0026vars)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n            resolve_target_path(\u0026self.config.vault_root, \u0026rendered)\n        } else if let Some(fm) = loaded.frontmatter.as_ref() {\n            if let Some(output) = fm.output.as_ref() {\n                let rendered = render_string(output, \u0026vars)\n                    .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n                resolve_target_path(\u0026self.config.vault_root, \u0026rendered)\n            } else {\n                return Err(MacroRunError::TemplateError(\n                    \"template has no output path and none specified in step\".to_string(),\n                ));\n            }\n        } else {\n            return Err(MacroRunError::TemplateError(\n                \"template has no output path and none specified in step\".to_string(),\n            ));\n        };\n\n        // Render template\n        let rendered = render_string(\u0026loaded.body, \u0026vars)\n            .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n        // Create parent directories if needed\n        if let Some(parent) = output_path.parent() {\n            fs::create_dir_all(parent).map_err(|e| {\n                MacroRunError::TemplateError(format!(\"failed to create directory: {}\", e))\n            })?;\n        }\n\n        // Write file\n        fs::write(\u0026output_path, \u0026rendered).map_err(|e| {\n            MacroRunError::TemplateError(format!(\n                \"failed to write {}: {}\",\n                output_path.display(),\n                e\n            ))\n        })?;\n\n        Ok(StepResult {\n            step_index: 0,\n            success: true,\n            message: format!(\"Created {}\", output_path.display()),\n            output_path: Some(output_path),\n        })\n    }\n\n    fn execute_capture(\n        \u0026self,\n        step: \u0026CaptureStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        // Load capture\n        let loaded = self\n            .capture_repo\n            .get_by_name(\u0026step.capture)\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n        // Merge step vars\n        let vars = ctx.with_step_vars(\u0026step.vars_with);\n\n        // Execute capture\n        execute_capture(\u0026self.config, \u0026loaded.spec, \u0026vars)\n            .map_err(MacroRunError::CaptureError)?;\n\n        Ok(StepResult {\n            step_index: 0,\n            success: true,\n            message: format!(\"Executed capture: {}\", step.capture),\n            output_path: None,\n        })\n    }\n\n    fn execute_shell(\n        \u0026self,\n        _step: \u0026ShellStep,\n        _ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        // Shell steps are not supported in hooks\n        Err(MacroRunError::TrustRequired)\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":262},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","vault_context.rs"],"content":"//! Vault context for Lua scripting.\n//!\n//! This module provides the `VaultContext` struct which holds references\n//! to all vault repositories needed for executing vault operations from Lua.\n\nuse std::path::PathBuf;\nuse std::sync::Arc;\n\nuse crate::captures::CaptureRepository;\nuse crate::config::types::ResolvedConfig;\nuse crate::index::IndexDb;\nuse crate::macros::MacroRepository;\nuse crate::templates::repository::TemplateRepository;\nuse crate::types::TypeRegistry;\n\n/// Information about the current note being processed.\n///\n/// This is set when validating or processing a specific note,\n/// allowing Lua hooks to access note metadata.\n#[derive(Clone, Debug)]\npub struct CurrentNote {\n    /// Path to the note relative to vault root.\n    pub path: String,\n    /// Note type from frontmatter.\n    pub note_type: String,\n    /// Note title.\n    pub title: Option\u003cString\u003e,\n    /// Frontmatter as YAML value.\n    pub frontmatter: Option\u003cserde_yaml::Value\u003e,\n    /// Note content.\n    pub content: String,\n}\n\n/// Context for vault operations accessible from Lua hooks.\n///\n/// This struct holds Arc references to avoid cloning large repositories.\n/// It's designed to be passed to Lua bindings for template/capture/macro execution.\n#[derive(Clone)]\npub struct VaultContext {\n    /// Resolved configuration with paths.\n    pub config: Arc\u003cResolvedConfig\u003e,\n    /// Template repository for loading templates.\n    pub template_repo: Arc\u003cTemplateRepository\u003e,\n    /// Capture repository for loading captures.\n    pub capture_repo: Arc\u003cCaptureRepository\u003e,\n    /// Macro repository for loading macros.\n    pub macro_repo: Arc\u003cMacroRepository\u003e,\n    /// Type registry for type definitions.\n    pub type_registry: Arc\u003cTypeRegistry\u003e,\n    /// Optional index database for query operations.\n    pub index_db: Option\u003cArc\u003cIndexDb\u003e\u003e,\n    /// Optional current note being processed.\n    pub current_note: Option\u003cCurrentNote\u003e,\n    /// Vault root path for resolving relative paths.\n    pub vault_root: PathBuf,\n}\n\nimpl VaultContext {\n    /// Create a new VaultContext from owned values.\n    pub fn new(\n        config: ResolvedConfig,\n        template_repo: TemplateRepository,\n        capture_repo: CaptureRepository,\n        macro_repo: MacroRepository,\n        type_registry: TypeRegistry,\n    ) -\u003e Self {\n        let vault_root = config.vault_root.clone();\n        Self {\n            config: Arc::new(config),\n            template_repo: Arc::new(template_repo),\n            capture_repo: Arc::new(capture_repo),\n            macro_repo: Arc::new(macro_repo),\n            type_registry: Arc::new(type_registry),\n            index_db: None,\n            current_note: None,\n            vault_root,\n        }\n    }\n\n    /// Create a new VaultContext from Arc references.\n    pub fn from_arcs(\n        config: Arc\u003cResolvedConfig\u003e,\n        template_repo: Arc\u003cTemplateRepository\u003e,\n        capture_repo: Arc\u003cCaptureRepository\u003e,\n        macro_repo: Arc\u003cMacroRepository\u003e,\n        type_registry: Arc\u003cTypeRegistry\u003e,\n    ) -\u003e Self {\n        let vault_root = config.vault_root.clone();\n        Self {\n            config,\n            template_repo,\n            capture_repo,\n            macro_repo,\n            type_registry,\n            index_db: None,\n            current_note: None,\n            vault_root,\n        }\n    }\n\n    /// Set the index database for query operations.\n    pub fn with_index(mut self, index_db: Arc\u003cIndexDb\u003e) -\u003e Self {\n        self.index_db = Some(index_db);\n        self\n    }\n\n    /// Set the current note being processed.\n    pub fn with_current_note(mut self, note: CurrentNote) -\u003e Self {\n        self.current_note = Some(note);\n        self\n    }\n}\n","traces":[{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","templates","discovery.rs"],"content":"use std::path::{Path, PathBuf};\nuse thiserror::Error;\nuse walkdir::WalkDir;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct TemplateInfo {\n    pub logical_name: String,\n    pub path: PathBuf,\n}\n\n#[derive(Debug, Error)]\npub enum TemplateDiscoveryError {\n    #[error(\"templates directory does not exist: {0}\")]\n    MissingDir(String),\n\n    #[error(\"failed to read templates directory {0} : {1}\")]\n    WalkError(String, #[source] walkdir::Error),\n}\n\npub fn discover_templates(\n    root: \u0026Path,\n) -\u003e Result\u003cVec\u003cTemplateInfo\u003e, TemplateDiscoveryError\u003e {\n    let root = root\n        .canonicalize()\n        .map_err(|_| TemplateDiscoveryError::MissingDir(root.display().to_string()))?;\n\n    if !root.exists() {\n        return Err(TemplateDiscoveryError::MissingDir(root.display().to_string()));\n    }\n\n    let mut out = Vec::new();\n\n    for entry in WalkDir::new(\u0026root) {\n        let entry = entry.map_err(|e| {\n            TemplateDiscoveryError::WalkError(root.display().to_string(), e)\n        })?;\n\n        let path = entry.path();\n        if !path.is_file() {\n            continue;\n        }\n        if !is_markdown_file(path) {\n            continue;\n        }\n\n        let rel = path.strip_prefix(\u0026root).unwrap_or(path);\n        let logical = logical_name_from_relative(rel);\n\n        out.push(TemplateInfo { logical_name: logical, path: path.to_path_buf() });\n    }\n\n    out.sort_by(|a, b| a.logical_name.cmp(\u0026b.logical_name));\n    Ok(out)\n}\n\nfn is_markdown_file(path: \u0026Path) -\u003e bool {\n    let name = path.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    name.ends_with(\".md\") \u0026\u0026 !(name.ends_with(\".tpl.md\") || name.ends_with(\".tmpl.md\"))\n}\n\nfn logical_name_from_relative(rel: \u0026Path) -\u003e String {\n    let s = rel.to_string_lossy();\n    let suffix = \".md\";\n    if s.ends_with(suffix) {\n        let cut = s.len() - suffix.len();\n        return s[..cut].to_string();\n    }\n    s.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs::File;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_discover_templates_simple() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        File::create(root.join(\"daily.md\")).unwrap();\n        File::create(root.join(\"meeting.md\")).unwrap();\n        File::create(root.join(\"readme.txt\")).unwrap(); // Should be ignored\n\n        let templates = discover_templates(root).unwrap();\n\n        assert_eq!(templates.len(), 2);\n        assert_eq!(templates[0].logical_name, \"daily\");\n        assert_eq!(templates[1].logical_name, \"meeting\");\n    }\n\n    #[test]\n    fn test_discover_templates_ignores_partials() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        File::create(root.join(\"valid.md\")).unwrap();\n        File::create(root.join(\"partial.tpl.md\")).unwrap();\n        File::create(root.join(\"other.tmpl.md\")).unwrap();\n\n        let templates = discover_templates(root).unwrap();\n\n        assert_eq!(templates.len(), 1);\n        assert_eq!(templates[0].logical_name, \"valid\");\n    }\n\n    #[test]\n    fn test_discover_templates_nested() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        std::fs::create_dir(root.join(\"work\")).unwrap();\n        File::create(root.join(\"work/report.md\")).unwrap();\n\n        let templates = discover_templates(root).unwrap();\n\n        assert_eq!(templates.len(), 1);\n        assert_eq!(templates[0].logical_name, \"work/report\");\n    }\n\n    #[test]\n    fn test_discover_templates_missing_dir() {\n        let dir = tempdir().unwrap();\n        let missing = dir.path().join(\"missing\");\n\n        let result = discover_templates(\u0026missing);\n        assert!(matches!(result, Err(TemplateDiscoveryError::MissingDir(_))));\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":22}},{"line":23,"address":[],"length":0,"stats":{"Line":43}},{"line":25,"address":[],"length":0,"stats":{"Line":25}},{"line":27,"address":[],"length":0,"stats":{"Line":21}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":42}},{"line":33,"address":[],"length":0,"stats":{"Line":103}},{"line":34,"address":[],"length":0,"stats":{"Line":183}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":183}},{"line":39,"address":[],"length":0,"stats":{"Line":61}},{"line":40,"address":[],"length":0,"stats":{"Line":27}},{"line":42,"address":[],"length":0,"stats":{"Line":34}},{"line":43,"address":[],"length":0,"stats":{"Line":10}},{"line":46,"address":[],"length":0,"stats":{"Line":144}},{"line":47,"address":[],"length":0,"stats":{"Line":72}},{"line":49,"address":[],"length":0,"stats":{"Line":96}},{"line":52,"address":[],"length":0,"stats":{"Line":54}},{"line":53,"address":[],"length":0,"stats":{"Line":21}},{"line":56,"address":[],"length":0,"stats":{"Line":34}},{"line":57,"address":[],"length":0,"stats":{"Line":272}},{"line":58,"address":[],"length":0,"stats":{"Line":176}},{"line":61,"address":[],"length":0,"stats":{"Line":24}},{"line":62,"address":[],"length":0,"stats":{"Line":72}},{"line":63,"address":[],"length":0,"stats":{"Line":48}},{"line":64,"address":[],"length":0,"stats":{"Line":48}},{"line":65,"address":[],"length":0,"stats":{"Line":72}},{"line":66,"address":[],"length":0,"stats":{"Line":48}},{"line":68,"address":[],"length":0,"stats":{"Line":0}}],"covered":26,"coverable":29},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","templates","engine.rs"],"content":"use regex::Regex;\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\n\nuse chrono::Local;\nuse serde_yaml::Value;\nuse thiserror::Error;\n\nuse crate::config::types::ResolvedConfig;\nuse crate::vars::datemath::{evaluate_date_expr, is_date_expr, parse_date_expr};\n\nuse super::discovery::TemplateInfo;\nuse super::repository::LoadedTemplate;\n\n#[derive(Debug, Error)]\npub enum TemplateRenderError {\n    #[error(\"invalid regex for template placeholder: {0}\")]\n    Regex(String),\n}\n\npub type RenderContext = HashMap\u003cString, String\u003e;\n\n/// Build a minimal render context with date/time and config variables.\n///\n/// This is useful for resolving template output paths from frontmatter\n/// before the actual output path is known.\npub fn build_minimal_context(\n    cfg: \u0026ResolvedConfig,\n    template: \u0026TemplateInfo,\n) -\u003e RenderContext {\n    let mut ctx = RenderContext::new();\n\n    // Date/time (basic versions - date math expressions are handled separately)\n    let now = Local::now();\n    ctx.insert(\"date\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"time\".into(), now.format(\"%H:%M\").to_string());\n    ctx.insert(\"datetime\".into(), now.to_rfc3339());\n    // Add today/now as aliases\n    ctx.insert(\"today\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"now\".into(), now.to_rfc3339());\n\n    // From config\n    ctx.insert(\"vault_root\".into(), cfg.vault_root.to_string_lossy().to_string());\n    ctx.insert(\"templates_dir\".into(), cfg.templates_dir.to_string_lossy().to_string());\n    ctx.insert(\"captures_dir\".into(), cfg.captures_dir.to_string_lossy().to_string());\n    ctx.insert(\"macros_dir\".into(), cfg.macros_dir.to_string_lossy().to_string());\n\n    // Template info\n    ctx.insert(\"template_name\".into(), template.logical_name.clone());\n    ctx.insert(\"template_path\".into(), template.path.to_string_lossy().to_string());\n\n    ctx\n}\n\npub fn build_render_context(\n    cfg: \u0026ResolvedConfig,\n    template: \u0026TemplateInfo,\n    output_path: \u0026Path,\n) -\u003e RenderContext {\n    let mut ctx = build_minimal_context(cfg, template);\n\n    // Output info\n    let output_abs = absolutize(output_path);\n    ctx.insert(\"output_path\".into(), output_abs.to_string_lossy().to_string());\n    if let Some(name) = output_abs.file_name().and_then(|s| s.to_str()) {\n        ctx.insert(\"output_filename\".into(), name.to_string());\n    }\n    if let Some(parent) = output_abs.parent() {\n        ctx.insert(\"output_dir\".into(), parent.to_string_lossy().to_string());\n    }\n\n    ctx\n}\n\nfn absolutize(path: \u0026Path) -\u003e PathBuf {\n    if path.is_absolute() {\n        path.to_path_buf()\n    } else {\n        std::env::current_dir().unwrap_or_else(|_| PathBuf::from(\".\")).join(path)\n    }\n}\n\npub fn render(\n    template: \u0026LoadedTemplate,\n    ctx: \u0026RenderContext,\n) -\u003e Result\u003cString, TemplateRenderError\u003e {\n    let rendered_body = render_string(\u0026template.body, ctx)?;\n\n    // Check if template has extra frontmatter fields to include in output\n    // Note: can't use let chains (Rust 2024) so we nest the if statements\n    #[allow(clippy::collapsible_if)]\n    if let Some(ref fm) = template.frontmatter {\n        if !fm.extra.is_empty() {\n            // Render variable placeholders in frontmatter values\n            let rendered_fm = render_frontmatter_values(\u0026fm.extra, ctx)?;\n            // Serialize as YAML frontmatter\n            let yaml = serde_yaml::to_string(\u0026rendered_fm).unwrap_or_default();\n            return Ok(format!(\"---\\n{}---\\n\\n{}\", yaml, rendered_body));\n        }\n    }\n\n    Ok(rendered_body)\n}\n\n/// Render variable placeholders in frontmatter values.\nfn render_frontmatter_values(\n    fields: \u0026HashMap\u003cString, Value\u003e,\n    ctx: \u0026RenderContext,\n) -\u003e Result\u003cHashMap\u003cString, Value\u003e, TemplateRenderError\u003e {\n    let mut rendered = HashMap::new();\n    for (key, value) in fields {\n        let rendered_value = render_yaml_value(value, ctx)?;\n        rendered.insert(key.clone(), rendered_value);\n    }\n    Ok(rendered)\n}\n\n/// Recursively render variable placeholders in a YAML value.\nfn render_yaml_value(\n    value: \u0026Value,\n    ctx: \u0026RenderContext,\n) -\u003e Result\u003cValue, TemplateRenderError\u003e {\n    match value {\n        Value::String(s) =\u003e {\n            let rendered = render_string(s, ctx)?;\n            Ok(Value::String(rendered))\n        }\n        Value::Sequence(seq) =\u003e {\n            let rendered: Result\u003cVec\u003cValue\u003e, _\u003e =\n                seq.iter().map(|v| render_yaml_value(v, ctx)).collect();\n            Ok(Value::Sequence(rendered?))\n        }\n        Value::Mapping(map) =\u003e {\n            let mut rendered_map = serde_yaml::Mapping::new();\n            for (k, v) in map {\n                let rendered_v = render_yaml_value(v, ctx)?;\n                rendered_map.insert(k.clone(), rendered_v);\n            }\n            Ok(Value::Mapping(rendered_map))\n        }\n        // Other types (numbers, bools, null) pass through unchanged\n        _ =\u003e Ok(value.clone()),\n    }\n}\n\n/// Render a string template with variable substitution.\n///\n/// Supports:\n/// - Simple variables: `{{var_name}}`\n/// - Date math expressions: `{{today + 1d}}`, `{{now - 2h}}`, `{{today | %Y-%m-%d}}`\n/// - Filters: `{{var_name | filter}}` (currently supports: slugify)\npub fn render_string(\n    template: \u0026str,\n    ctx: \u0026RenderContext,\n) -\u003e Result\u003cString, TemplateRenderError\u003e {\n    // Match both simple vars and date math expressions\n    // Captures everything between {{ and }} that looks like a valid expression\n    let re = Regex::new(r\"\\{\\{([^{}]+)\\}\\}\")\n        .map_err(|e| TemplateRenderError::Regex(e.to_string()))?;\n\n    let result = re.replace_all(template, |caps: \u0026regex::Captures\u003c'_\u003e| {\n        let expr = caps[1].trim();\n\n        // First, check if it's a date math expression\n        if is_date_expr(expr)\n            \u0026\u0026 let Ok(parsed) = parse_date_expr(expr)\n        {\n            return evaluate_date_expr(\u0026parsed);\n        }\n\n        // Check for filter syntax: \"var_name | filter\"\n        if let Some((var_name, filter)) = parse_filter_expr(expr) {\n            if let Some(value) = ctx.get(var_name) {\n                return apply_filter(value, filter);\n            }\n            // Variable not found, return original\n            return caps[0].to_string();\n        }\n\n        // Otherwise, try simple variable lookup\n        ctx.get(expr).cloned().unwrap_or_else(|| caps[0].to_string())\n    });\n\n    Ok(result.into_owned())\n}\n\n/// Parse a filter expression like \"var_name | filter_name\".\n/// Returns (var_name, filter_name) if valid, None otherwise.\nfn parse_filter_expr(expr: \u0026str) -\u003e Option\u003c(\u0026str, \u0026str)\u003e {\n    // Don't parse date expressions with format as filters (e.g., \"today | %Y-%m-%d\")\n    if is_date_expr(expr) {\n        return None;\n    }\n\n    let parts: Vec\u003c\u0026str\u003e = expr.splitn(2, '|').collect();\n    if parts.len() == 2 {\n        let var_name = parts[0].trim();\n        let filter = parts[1].trim();\n        if !var_name.is_empty() \u0026\u0026 !filter.is_empty() {\n            return Some((var_name, filter));\n        }\n    }\n    None\n}\n\n/// Apply a filter to a value.\nfn apply_filter(value: \u0026str, filter: \u0026str) -\u003e String {\n    match filter {\n        \"slugify\" =\u003e slugify(value),\n        \"lowercase\" | \"lower\" =\u003e value.to_lowercase(),\n        \"uppercase\" | \"upper\" =\u003e value.to_uppercase(),\n        \"trim\" =\u003e value.trim().to_string(),\n        _ =\u003e value.to_string(), // Unknown filter, return unchanged\n    }\n}\n\n/// Convert a string to a URL-friendly slug.\n///\n/// - Converts to lowercase\n/// - Replaces spaces and underscores with hyphens\n/// - Removes non-alphanumeric characters (except hyphens)\n/// - Collapses multiple hyphens into one\n/// - Trims leading/trailing hyphens\nfn slugify(s: \u0026str) -\u003e String {\n    let mut result = String::with_capacity(s.len());\n\n    for c in s.chars() {\n        if c.is_ascii_alphanumeric() {\n            result.push(c.to_ascii_lowercase());\n        } else if c == ' ' || c == '_' || c == '-' {\n            // Only add hyphen if last char wasn't already a hyphen\n            if !result.ends_with('-') {\n                result.push('-');\n            }\n        }\n        // Other characters are skipped\n    }\n\n    // Trim leading/trailing hyphens\n    result.trim_matches('-').to_string()\n}\n\n/// Resolve the output path for a template.\n///\n/// If the template has frontmatter with an `output` field, render it with the context.\n/// Otherwise, return None.\npub fn resolve_template_output_path(\n    template: \u0026LoadedTemplate,\n    cfg: \u0026ResolvedConfig,\n    ctx: \u0026RenderContext,\n) -\u003e Result\u003cOption\u003cPathBuf\u003e, TemplateRenderError\u003e {\n    if let Some(ref fm) = template.frontmatter\n        \u0026\u0026 let Some(ref output) = fm.output\n    {\n        let rendered = render_string(output, ctx)?;\n        let path = cfg.vault_root.join(\u0026rendered);\n        return Ok(Some(path));\n    }\n    Ok(None)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_slugify_basic() {\n        assert_eq!(slugify(\"Hello World\"), \"hello-world\");\n        assert_eq!(slugify(\"Test Task\"), \"test-task\");\n    }\n\n    #[test]\n    fn test_slugify_special_chars() {\n        assert_eq!(slugify(\"Hello, World!\"), \"hello-world\");\n        assert_eq!(slugify(\"What's up?\"), \"whats-up\");\n        assert_eq!(slugify(\"foo@bar.com\"), \"foobarcom\");\n    }\n\n    #[test]\n    fn test_slugify_underscores() {\n        assert_eq!(slugify(\"hello_world\"), \"hello-world\");\n        assert_eq!(slugify(\"foo_bar_baz\"), \"foo-bar-baz\");\n    }\n\n    #[test]\n    fn test_slugify_multiple_spaces() {\n        assert_eq!(slugify(\"hello   world\"), \"hello-world\");\n        assert_eq!(slugify(\"  leading and trailing  \"), \"leading-and-trailing\");\n    }\n\n    #[test]\n    fn test_slugify_mixed() {\n        assert_eq!(slugify(\"My Task: Do Something!\"), \"my-task-do-something\");\n        assert_eq!(slugify(\"2024-01-15 Meeting Notes\"), \"2024-01-15-meeting-notes\");\n    }\n\n    #[test]\n    fn test_render_string_with_slugify_filter() {\n        let mut ctx = RenderContext::new();\n        ctx.insert(\"title\".into(), \"Hello World\".into());\n\n        let result = render_string(\"{{title | slugify}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"hello-world\");\n    }\n\n    #[test]\n    fn test_render_string_with_lowercase_filter() {\n        let mut ctx = RenderContext::new();\n        ctx.insert(\"name\".into(), \"HELLO\".into());\n\n        let result = render_string(\"{{name | lowercase}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"hello\");\n\n        let result = render_string(\"{{name | lower}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"hello\");\n    }\n\n    #[test]\n    fn test_render_string_with_uppercase_filter() {\n        let mut ctx = RenderContext::new();\n        ctx.insert(\"name\".into(), \"hello\".into());\n\n        let result = render_string(\"{{name | uppercase}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"HELLO\");\n    }\n\n    #[test]\n    fn test_render_string_filter_in_path() {\n        let mut ctx = RenderContext::new();\n        ctx.insert(\"vault_root\".into(), \"/vault\".into());\n        ctx.insert(\"title\".into(), \"My New Task\".into());\n\n        let result =\n            render_string(\"{{vault_root}}/tasks/{{title | slugify}}.md\", \u0026ctx).unwrap();\n        assert_eq!(result, \"/vault/tasks/my-new-task.md\");\n    }\n\n    #[test]\n    fn test_render_string_unknown_filter() {\n        let mut ctx = RenderContext::new();\n        ctx.insert(\"name\".into(), \"hello\".into());\n\n        // Unknown filter returns value unchanged\n        let result = render_string(\"{{name | unknown}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"hello\");\n    }\n\n    #[test]\n    fn test_render_string_missing_var_with_filter() {\n        let ctx = RenderContext::new();\n\n        // Missing variable with filter returns original placeholder\n        let result = render_string(\"{{missing | slugify}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"{{missing | slugify}}\");\n    }\n\n    #[test]\n    fn test_date_format_not_parsed_as_filter() {\n        let ctx = RenderContext::new();\n\n        // Date expressions with format should still work\n        let result = render_string(\"{{today | %Y-%m-%d}}\", \u0026ctx).unwrap();\n        // Should be a date, not \"today\" with filter \"%Y-%m-%d\"\n        assert!(result.contains('-'));\n        assert!(!result.contains(\"today\"));\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":14}},{"line":31,"address":[],"length":0,"stats":{"Line":28}},{"line":34,"address":[],"length":0,"stats":{"Line":28}},{"line":35,"address":[],"length":0,"stats":{"Line":98}},{"line":36,"address":[],"length":0,"stats":{"Line":98}},{"line":37,"address":[],"length":0,"stats":{"Line":84}},{"line":39,"address":[],"length":0,"stats":{"Line":98}},{"line":40,"address":[],"length":0,"stats":{"Line":84}},{"line":43,"address":[],"length":0,"stats":{"Line":84}},{"line":44,"address":[],"length":0,"stats":{"Line":84}},{"line":45,"address":[],"length":0,"stats":{"Line":84}},{"line":46,"address":[],"length":0,"stats":{"Line":84}},{"line":49,"address":[],"length":0,"stats":{"Line":84}},{"line":50,"address":[],"length":0,"stats":{"Line":84}},{"line":52,"address":[],"length":0,"stats":{"Line":14}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":13}},{"line":87,"address":[],"length":0,"stats":{"Line":52}},{"line":92,"address":[],"length":0,"stats":{"Line":18}},{"line":93,"address":[],"length":0,"stats":{"Line":5}},{"line":95,"address":[],"length":0,"stats":{"Line":8}},{"line":97,"address":[],"length":0,"stats":{"Line":8}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":11}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":14}},{"line":112,"address":[],"length":0,"stats":{"Line":16}},{"line":113,"address":[],"length":0,"stats":{"Line":20}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":5}},{"line":125,"address":[],"length":0,"stats":{"Line":20}},{"line":126,"address":[],"length":0,"stats":{"Line":5}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":9}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":67}},{"line":158,"address":[],"length":0,"stats":{"Line":201}},{"line":159,"address":[],"length":0,"stats":{"Line":67}},{"line":161,"address":[],"length":0,"stats":{"Line":335}},{"line":162,"address":[],"length":0,"stats":{"Line":201}},{"line":165,"address":[],"length":0,"stats":{"Line":134}},{"line":166,"address":[],"length":0,"stats":{"Line":46}},{"line":168,"address":[],"length":0,"stats":{"Line":46}},{"line":172,"address":[],"length":0,"stats":{"Line":58}},{"line":173,"address":[],"length":0,"stats":{"Line":20}},{"line":174,"address":[],"length":0,"stats":{"Line":18}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":189}},{"line":184,"address":[],"length":0,"stats":{"Line":67}},{"line":189,"address":[],"length":0,"stats":{"Line":44}},{"line":191,"address":[],"length":0,"stats":{"Line":88}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":220}},{"line":196,"address":[],"length":0,"stats":{"Line":44}},{"line":197,"address":[],"length":0,"stats":{"Line":21}},{"line":198,"address":[],"length":0,"stats":{"Line":21}},{"line":199,"address":[],"length":0,"stats":{"Line":14}},{"line":200,"address":[],"length":0,"stats":{"Line":7}},{"line":203,"address":[],"length":0,"stats":{"Line":37}},{"line":207,"address":[],"length":0,"stats":{"Line":6}},{"line":208,"address":[],"length":0,"stats":{"Line":6}},{"line":209,"address":[],"length":0,"stats":{"Line":10}},{"line":210,"address":[],"length":0,"stats":{"Line":11}},{"line":211,"address":[],"length":0,"stats":{"Line":5}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":13}},{"line":225,"address":[],"length":0,"stats":{"Line":52}},{"line":227,"address":[],"length":0,"stats":{"Line":207}},{"line":228,"address":[],"length":0,"stats":{"Line":509}},{"line":229,"address":[],"length":0,"stats":{"Line":441}},{"line":230,"address":[],"length":0,"stats":{"Line":204}},{"line":232,"address":[],"length":0,"stats":{"Line":48}},{"line":233,"address":[],"length":0,"stats":{"Line":22}},{"line":240,"address":[],"length":0,"stats":{"Line":26}},{"line":247,"address":[],"length":0,"stats":{"Line":9}},{"line":252,"address":[],"length":0,"stats":{"Line":17}},{"line":253,"address":[],"length":0,"stats":{"Line":16}},{"line":255,"address":[],"length":0,"stats":{"Line":32}},{"line":256,"address":[],"length":0,"stats":{"Line":24}},{"line":257,"address":[],"length":0,"stats":{"Line":8}},{"line":259,"address":[],"length":0,"stats":{"Line":1}}],"covered":84,"coverable":105},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","templates","mod.rs"],"content":"pub mod discovery;\npub mod engine;\npub mod repository;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","templates","repository.rs"],"content":"use std::fs;\nuse std::path::{Path, PathBuf};\n\nuse thiserror::Error;\n\nuse crate::frontmatter::{\n    FrontmatterParseError, TemplateFrontmatter, parse_template_frontmatter,\n};\nuse crate::templates::discovery::{\n    TemplateDiscoveryError, TemplateInfo, discover_templates,\n};\n\n#[derive(Debug, Error)]\npub enum TemplateRepoError {\n    #[error(transparent)]\n    Discovery(#[from] TemplateDiscoveryError),\n\n    #[error(\"template not found: {0}\")]\n    NotFound(String),\n\n    #[error(\"failed to read template file {path}: {source}\")]\n    Io {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    #[error(\"failed to parse frontmatter in {path}: {source}\")]\n    FrontmatterParse {\n        path: PathBuf,\n        #[source]\n        source: FrontmatterParseError,\n    },\n}\n\n#[derive(Debug, Clone)]\npub struct LoadedTemplate {\n    pub logical_name: String,\n    pub path: PathBuf,\n    /// Raw content (includes frontmatter if present).\n    pub content: String,\n    /// Parsed template frontmatter (if present).\n    pub frontmatter: Option\u003cTemplateFrontmatter\u003e,\n    /// Body content (excludes frontmatter).\n    pub body: String,\n}\n\npub struct TemplateRepository {\n    pub root: PathBuf,\n    pub templates: Vec\u003cTemplateInfo\u003e,\n}\n\nimpl TemplateRepository {\n    pub fn new(root: \u0026Path) -\u003e Result\u003cSelf, TemplateDiscoveryError\u003e {\n        let templates = discover_templates(root)?;\n        Ok(Self { root: root.to_path_buf(), templates })\n    }\n\n    pub fn list_all(\u0026self) -\u003e \u0026[TemplateInfo] {\n        \u0026self.templates\n    }\n\n    pub fn get_by_name(\u0026self, name: \u0026str) -\u003e Result\u003cLoadedTemplate, TemplateRepoError\u003e {\n        let info = self\n            .templates\n            .iter()\n            .find(|t| t.logical_name == name)\n            .ok_or_else(|| TemplateRepoError::NotFound(name.to_lowercase()))?;\n\n        let content = fs::read_to_string(\u0026info.path)\n            .map_err(|e| TemplateRepoError::Io { path: info.path.clone(), source: e })?;\n\n        let (frontmatter, body) = parse_template_frontmatter(\u0026content).map_err(|e| {\n            TemplateRepoError::FrontmatterParse { path: info.path.clone(), source: e }\n        })?;\n\n        Ok(LoadedTemplate {\n            logical_name: info.logical_name.clone(),\n            path: info.path.clone(),\n            content,\n            frontmatter,\n            body,\n        })\n    }\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":15}},{"line":55,"address":[],"length":0,"stats":{"Line":45}},{"line":56,"address":[],"length":0,"stats":{"Line":30}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":14}},{"line":64,"address":[],"length":0,"stats":{"Line":28}},{"line":65,"address":[],"length":0,"stats":{"Line":14}},{"line":67,"address":[],"length":0,"stats":{"Line":42}},{"line":68,"address":[],"length":0,"stats":{"Line":14}},{"line":70,"address":[],"length":0,"stats":{"Line":42}},{"line":71,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":70}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":14}},{"line":78,"address":[],"length":0,"stats":{"Line":42}},{"line":79,"address":[],"length":0,"stats":{"Line":42}},{"line":80,"address":[],"length":0,"stats":{"Line":28}},{"line":81,"address":[],"length":0,"stats":{"Line":14}},{"line":82,"address":[],"length":0,"stats":{"Line":14}}],"covered":17,"coverable":20},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","autofix.rs"],"content":"//! Auto-fix functionality for note validation issues.\n//!\n//! Provides safe auto-corrections for common validation errors:\n//! - Adding missing required fields with default values\n//! - Normalizing enum value case\n//! - Adding missing frontmatter block\n\nuse std::collections::HashMap;\nuse std::path::Path;\n\nuse super::definition::TypeDefinition;\nuse super::errors::ValidationError;\nuse super::registry::TypeRegistry;\nuse crate::frontmatter::{Frontmatter, ParsedDocument, parse as parse_frontmatter};\n\n/// Result of attempting to fix a note.\n#[derive(Debug)]\npub struct FixResult {\n    /// Whether any fixes were applied.\n    pub fixed: bool,\n    /// Description of fixes applied.\n    pub fixes: Vec\u003cString\u003e,\n    /// The corrected content (if fixes were applied).\n    pub content: Option\u003cString\u003e,\n}\n\nimpl FixResult {\n    pub fn no_fix() -\u003e Self {\n        Self { fixed: false, fixes: Vec::new(), content: None }\n    }\n}\n\n/// Attempt to auto-fix validation errors in a note.\n///\n/// Returns a FixResult with the corrected content if fixes were applied.\npub fn try_fix_note(\n    registry: \u0026TypeRegistry,\n    note_type: \u0026str,\n    content: \u0026str,\n    errors: \u0026[ValidationError],\n) -\u003e FixResult {\n    let typedef = match registry.get(note_type) {\n        Some(td) =\u003e td,\n        None =\u003e return FixResult::no_fix(),\n    };\n\n    // Parse existing frontmatter\n    let parsed = match parse_frontmatter(content) {\n        Ok(p) =\u003e p,\n        Err(_) =\u003e return FixResult::no_fix(),\n    };\n\n    let mut frontmatter = parsed.frontmatter.map(|fm| fm.fields).unwrap_or_default();\n    let mut fixes = Vec::new();\n\n    for error in errors {\n        match error {\n            ValidationError::MissingRequired { field } =\u003e {\n                if let Some(fix) = fix_missing_required(\u0026typedef, field, \u0026mut frontmatter)\n                {\n                    fixes.push(fix);\n                }\n            }\n            ValidationError::EnumViolation { field, value, allowed } =\u003e {\n                if let Some(fix) = fix_enum_case(field, value, allowed, \u0026mut frontmatter)\n                {\n                    fixes.push(fix);\n                }\n            }\n            _ =\u003e {} // Other errors can't be auto-fixed\n        }\n    }\n\n    if fixes.is_empty() {\n        return FixResult::no_fix();\n    }\n\n    // Reconstruct the document with fixed frontmatter\n    let new_doc = ParsedDocument {\n        frontmatter: Some(Frontmatter { fields: frontmatter }),\n        body: parsed.body,\n    };\n    let new_content = crate::frontmatter::serialize(\u0026new_doc);\n\n    FixResult { fixed: true, fixes, content: Some(new_content) }\n}\n\n/// Fix a missing required field by adding its default value.\nfn fix_missing_required(\n    typedef: \u0026TypeDefinition,\n    field: \u0026str,\n    frontmatter: \u0026mut HashMap\u003cString, serde_yaml::Value\u003e,\n) -\u003e Option\u003cString\u003e {\n    let schema = typedef.schema.get(field)?;\n\n    // Only fix if there's a default value\n    let default = schema.default.as_ref()?;\n\n    frontmatter.insert(field.to_string(), default.clone());\n\n    let default_str = match default {\n        serde_yaml::Value::String(s) =\u003e s.clone(),\n        serde_yaml::Value::Number(n) =\u003e n.to_string(),\n        serde_yaml::Value::Bool(b) =\u003e b.to_string(),\n        _ =\u003e format!(\"{:?}\", default),\n    };\n\n    Some(format!(\"Added missing field '{}' with default '{}'\", field, default_str))\n}\n\n/// Fix enum case mismatch by normalizing to the correct case.\nfn fix_enum_case(\n    field: \u0026str,\n    value: \u0026str,\n    allowed: \u0026[String],\n    frontmatter: \u0026mut HashMap\u003cString, serde_yaml::Value\u003e,\n) -\u003e Option\u003cString\u003e {\n    // Find a case-insensitive match\n    let lowercase_value = value.to_lowercase();\n    let correct_value = allowed.iter().find(|v| v.to_lowercase() == lowercase_value)?;\n\n    if correct_value == value {\n        return None; // No fix needed\n    }\n\n    frontmatter\n        .insert(field.to_string(), serde_yaml::Value::String(correct_value.clone()));\n\n    Some(format!(\"Fixed case for '{}': '{}' -\u003e '{}'\", field, value, correct_value))\n}\n\n/// Apply fixes to a note file.\npub fn apply_fixes(path: \u0026Path, content: \u0026str) -\u003e Result\u003c(), String\u003e {\n    std::fs::write(path, content)\n        .map_err(|e| format!(\"Failed to write {}: {}\", path.display(), e))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::schema::{FieldSchema, FieldType};\n\n    fn make_typedef_with_defaults() -\u003e TypeDefinition {\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"status\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                enum_values: Some(vec![\"open\".to_string(), \"done\".to_string()]),\n                default: Some(serde_yaml::Value::String(\"open\".to_string())),\n                ..Default::default()\n            },\n        );\n        schema.insert(\n            \"priority\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: false,\n                enum_values: Some(vec![\n                    \"low\".to_string(),\n                    \"medium\".to_string(),\n                    \"high\".to_string(),\n                ]),\n                default: Some(serde_yaml::Value::String(\"medium\".to_string())),\n                ..Default::default()\n            },\n        );\n\n        TypeDefinition {\n            name: \"task\".to_string(),\n            description: None,\n            source_path: std::path::PathBuf::new(),\n            schema,\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: false,\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: String::new(),\n        }\n    }\n\n    #[test]\n    fn test_fix_missing_required_with_default() {\n        let mut registry = TypeRegistry::new();\n        registry.register(make_typedef_with_defaults()).unwrap();\n\n        let content = \"---\\ntype: task\\ntitle: Test\\n---\\n\\n# Test\\n\";\n        let errors =\n            vec![ValidationError::MissingRequired { field: \"status\".to_string() }];\n\n        let result = try_fix_note(\u0026registry, \"task\", content, \u0026errors);\n        assert!(result.fixed);\n        assert_eq!(result.fixes.len(), 1);\n        assert!(result.fixes[0].contains(\"status\"));\n        assert!(result.content.unwrap().contains(\"status: open\"));\n    }\n\n    #[test]\n    fn test_fix_enum_case() {\n        let mut registry = TypeRegistry::new();\n        registry.register(make_typedef_with_defaults()).unwrap();\n\n        let content = \"---\\ntype: task\\nstatus: OPEN\\n---\\n\\n# Test\\n\";\n        let errors = vec![ValidationError::EnumViolation {\n            field: \"status\".to_string(),\n            value: \"OPEN\".to_string(),\n            allowed: vec![\"open\".to_string(), \"done\".to_string()],\n        }];\n\n        let result = try_fix_note(\u0026registry, \"task\", content, \u0026errors);\n        assert!(result.fixed);\n        assert!(result.fixes[0].contains(\"OPEN\"));\n        assert!(result.fixes[0].contains(\"open\"));\n    }\n\n    #[test]\n    fn test_no_fix_without_default() {\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"project\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                default: None, // No default\n                ..Default::default()\n            },\n        );\n\n        let typedef = TypeDefinition {\n            name: \"task\".to_string(),\n            description: None,\n            source_path: std::path::PathBuf::new(),\n            schema,\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: false,\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: String::new(),\n        };\n\n        let mut registry = TypeRegistry::new();\n        registry.register(typedef).unwrap();\n\n        let content = \"---\\ntype: task\\n---\\n\\n# Test\\n\";\n        let errors =\n            vec![ValidationError::MissingRequired { field: \"project\".to_string() }];\n\n        let result = try_fix_note(\u0026registry, \"task\", content, \u0026errors);\n        assert!(!result.fixed);\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":9}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":56,"address":[],"length":0,"stats":{"Line":9}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":7}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":5}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":8}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":5}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}}],"covered":37,"coverable":47},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","definition.rs"],"content":"//! Type definition structures.\n\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\nuse super::schema::FieldSchema;\n\n/// A loaded type definition from a Lua file.\n#[derive(Debug, Clone)]\npub struct TypeDefinition {\n    /// Type name (from filename).\n    pub name: String,\n\n    /// Human-readable description.\n    pub description: Option\u003cString\u003e,\n\n    /// Path to the source .lua file.\n    pub source_path: PathBuf,\n\n    /// Field schemas for frontmatter validation.\n    pub schema: HashMap\u003cString, FieldSchema\u003e,\n\n    /// Output path template (supports {{var}} placeholders).\n    pub output: Option\u003cString\u003e,\n\n    /// Whether this type has a custom validate() function.\n    pub has_validate_fn: bool,\n\n    /// Whether this type has an on_create() hook.\n    pub has_on_create_hook: bool,\n\n    /// Whether this type has an on_update() hook.\n    pub has_on_update_hook: bool,\n\n    /// Whether this overrides a built-in type.\n    pub is_builtin_override: bool,\n\n    /// Raw Lua source (for re-execution of hooks).\n    pub lua_source: String,\n}\n\nimpl TypeDefinition {\n    /// Create an empty type definition (for testing).\n    pub fn empty(name: \u0026str) -\u003e Self {\n        Self {\n            name: name.to_string(),\n            description: None,\n            source_path: PathBuf::new(),\n            schema: HashMap::new(),\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: false,\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: String::new(),\n        }\n    }\n\n    /// Check if this type has any hooks.\n    pub fn has_hooks(\u0026self) -\u003e bool {\n        self.has_validate_fn || self.has_on_create_hook || self.has_on_update_hook\n    }\n\n    /// Get a list of required fields.\n    pub fn required_fields(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        self.schema\n            .iter()\n            .filter(|(_, schema)| schema.required)\n            .map(|(name, _)| name.as_str())\n            .collect()\n    }\n\n    /// Check if the type has a schema for a given field.\n    pub fn has_field(\u0026self, name: \u0026str) -\u003e bool {\n        self.schema.contains_key(name)\n    }\n\n    /// Get the schema for a field.\n    pub fn get_field(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026FieldSchema\u003e {\n        self.schema.get(name)\n    }\n}\n\n/// Information about a discovered type definition file.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct TypedefInfo {\n    /// Type name (filename without .lua extension).\n    pub name: String,\n\n    /// Full path to the .lua file.\n    pub path: PathBuf,\n}\n\nimpl TypedefInfo {\n    /// Create new typedef info.\n    pub fn new(name: String, path: PathBuf) -\u003e Self {\n        Self { name, path }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::schema::FieldType;\n\n    #[test]\n    fn test_empty_typedef() {\n        let td = TypeDefinition::empty(\"test\");\n        assert_eq!(td.name, \"test\");\n        assert!(td.schema.is_empty());\n        assert!(!td.has_hooks());\n    }\n\n    #[test]\n    fn test_required_fields() {\n        let mut td = TypeDefinition::empty(\"test\");\n        td.schema.insert(\n            \"title\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                ..Default::default()\n            },\n        );\n        td.schema.insert(\n            \"description\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: false,\n                ..Default::default()\n            },\n        );\n\n        let required = td.required_fields();\n        assert_eq!(required.len(), 1);\n        assert!(required.contains(\u0026\"title\"));\n    }\n\n    #[test]\n    fn test_has_hooks() {\n        let mut td = TypeDefinition::empty(\"test\");\n        assert!(!td.has_hooks());\n\n        td.has_validate_fn = true;\n        assert!(td.has_hooks());\n    }\n\n    #[test]\n    fn test_typedef_info() {\n        let info = TypedefInfo::new(\n            \"meeting\".to_string(),\n            PathBuf::from(\"/path/to/meeting.lua\"),\n        );\n        assert_eq!(info.name, \"meeting\");\n        assert_eq!(info.path, PathBuf::from(\"/path/to/meeting.lua\"));\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":14}},{"line":46,"address":[],"length":0,"stats":{"Line":42}},{"line":48,"address":[],"length":0,"stats":{"Line":28}},{"line":49,"address":[],"length":0,"stats":{"Line":28}},{"line":55,"address":[],"length":0,"stats":{"Line":14}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":7}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":24}}],"covered":12,"coverable":16},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","discovery.rs"],"content":"//! Type definition discovery and loading.\n\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\nuse walkdir::WalkDir;\n\nuse super::definition::{TypeDefinition, TypedefInfo};\nuse super::errors::TypedefError;\nuse super::schema::{FieldSchema, FieldType};\nuse crate::scripting::LuaEngine;\n\n/// Built-in type names that can be overridden by Lua definitions.\nconst BUILTIN_TYPES: \u0026[\u0026str] = \u0026[\"daily\", \"weekly\", \"task\", \"project\", \"zettel\"];\n\n/// Discover type definition files in a directory.\n///\n/// Finds all `.lua` files in the given directory (non-recursive).\n/// Returns an empty list if the directory doesn't exist.\npub fn discover_typedefs(root: \u0026Path) -\u003e Result\u003cVec\u003cTypedefInfo\u003e, TypedefError\u003e {\n    // Gracefully handle missing directory\n    if !root.exists() {\n        return Ok(vec![]);\n    }\n\n    let root = root\n        .canonicalize()\n        .map_err(|_| TypedefError::MissingDir(root.display().to_string()))?;\n\n    let mut out = Vec::new();\n\n    // Only look at direct children (max_depth = 1)\n    for entry in WalkDir::new(\u0026root).max_depth(1) {\n        let entry =\n            entry.map_err(|e| TypedefError::WalkError(root.display().to_string(), e))?;\n\n        let path = entry.path();\n        if !path.is_file() {\n            continue;\n        }\n        if !is_lua_file(path) {\n            continue;\n        }\n\n        let name = path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\").to_string();\n\n        if !name.is_empty() {\n            out.push(TypedefInfo::new(name, path.to_path_buf()));\n        }\n    }\n\n    out.sort_by(|a, b| a.name.cmp(\u0026b.name));\n    Ok(out)\n}\n\nfn is_lua_file(path: \u0026Path) -\u003e bool {\n    path.extension().and_then(|e| e.to_str()) == Some(\"lua\")\n}\n\n/// Repository for discovering and loading type definitions.\npub struct TypedefRepository {\n    /// Root directory for type definitions.\n    pub root: PathBuf,\n    /// Discovered type definition files.\n    pub typedefs: Vec\u003cTypedefInfo\u003e,\n}\n\nimpl TypedefRepository {\n    /// Create a new repository from a directory.\n    ///\n    /// Returns an empty repository if the directory doesn't exist.\n    pub fn new(root: \u0026Path) -\u003e Result\u003cSelf, TypedefError\u003e {\n        let typedefs = discover_typedefs(root)?;\n        Ok(Self { root: root.to_path_buf(), typedefs })\n    }\n\n    /// List all discovered type definitions.\n    pub fn list_all(\u0026self) -\u003e \u0026[TypedefInfo] {\n        \u0026self.typedefs\n    }\n\n    /// Check if a type definition exists.\n    pub fn has_typedef(\u0026self, name: \u0026str) -\u003e bool {\n        self.typedefs.iter().any(|t| t.name == name)\n    }\n\n    /// Load a type definition by name.\n    pub fn load_typedef(\u0026self, name: \u0026str) -\u003e Result\u003cTypeDefinition, TypedefError\u003e {\n        let info = self\n            .typedefs\n            .iter()\n            .find(|t| t.name == name)\n            .ok_or_else(|| TypedefError::NotFound(name.to_string()))?;\n\n        load_typedef_from_file(\u0026info.path)\n    }\n\n    /// Load all type definitions.\n    pub fn load_all(\u0026self) -\u003e Result\u003cVec\u003cTypeDefinition\u003e, TypedefError\u003e {\n        let mut result = Vec::new();\n        for info in \u0026self.typedefs {\n            result.push(load_typedef_from_file(\u0026info.path)?);\n        }\n        Ok(result)\n    }\n}\n\n/// Load and parse a type definition from a Lua file.\npub fn load_typedef_from_file(path: \u0026Path) -\u003e Result\u003cTypeDefinition, TypedefError\u003e {\n    let source = fs::read_to_string(path)\n        .map_err(|e| TypedefError::Io { path: path.to_path_buf(), source: e })?;\n\n    let name = path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"unknown\").to_string();\n\n    parse_typedef(\u0026name, \u0026source, path)\n}\n\n/// Parse a type definition from Lua source.\nfn parse_typedef(\n    name: \u0026str,\n    source: \u0026str,\n    path: \u0026Path,\n) -\u003e Result\u003cTypeDefinition, TypedefError\u003e {\n    let engine = LuaEngine::sandboxed()\n        .map_err(|e| TypedefError::LuaParse { path: path.to_path_buf(), source: e })?;\n\n    let lua = engine.lua();\n\n    // Execute the Lua file - it should return a table\n    let value: mlua::Value =\n        lua.load(source).eval().map_err(|e| TypedefError::LuaParse {\n            path: path.to_path_buf(),\n            source: crate::scripting::ScriptingError::Lua(e),\n        })?;\n\n    let table = match value {\n        mlua::Value::Table(t) =\u003e t,\n        _ =\u003e {\n            return Err(TypedefError::InvalidDefinition {\n                path: path.to_path_buf(),\n                message: \"Type definition must return a table\".to_string(),\n            });\n        }\n    };\n\n    // Extract optional description\n    let description: Option\u003cString\u003e = table.get(\"description\").ok();\n\n    // Extract output path template\n    let output: Option\u003cString\u003e = table.get(\"output\").ok();\n\n    // Extract schema\n    let schema = extract_schema(\u0026table, path)?;\n\n    // Check for hook functions\n    let has_validate_fn = table.get::\u003cmlua::Function\u003e(\"validate\").is_ok();\n    let has_on_create_hook = table.get::\u003cmlua::Function\u003e(\"on_create\").is_ok();\n    let has_on_update_hook = table.get::\u003cmlua::Function\u003e(\"on_update\").is_ok();\n\n    // Check if this overrides a built-in\n    let is_builtin_override = BUILTIN_TYPES.contains(\u0026name);\n\n    Ok(TypeDefinition {\n        name: name.to_string(),\n        description,\n        source_path: path.to_path_buf(),\n        schema,\n        output,\n        has_validate_fn,\n        has_on_create_hook,\n        has_on_update_hook,\n        is_builtin_override,\n        lua_source: source.to_string(),\n    })\n}\n\n/// Extract schema from Lua table.\nfn extract_schema(\n    table: \u0026mlua::Table,\n    path: \u0026Path,\n) -\u003e Result\u003cHashMap\u003cString, FieldSchema\u003e, TypedefError\u003e {\n    let mut schema = HashMap::new();\n\n    let schema_table: mlua::Table = match table.get(\"schema\") {\n        Ok(t) =\u003e t,\n        Err(_) =\u003e return Ok(schema), // No schema defined is valid\n    };\n\n    for pair in schema_table.pairs::\u003cString, mlua::Table\u003e() {\n        let (field_name, field_def) = pair.map_err(|e| TypedefError::LuaParse {\n            path: path.to_path_buf(),\n            source: crate::scripting::ScriptingError::Lua(e),\n        })?;\n\n        let field_schema = parse_field_schema(\u0026field_def, \u0026field_name, path)?;\n        schema.insert(field_name, field_schema);\n    }\n\n    Ok(schema)\n}\n\n/// Parse a field schema from a Lua table.\nfn parse_field_schema(\n    table: \u0026mlua::Table,\n    field_name: \u0026str,\n    _path: \u0026Path,\n) -\u003e Result\u003cFieldSchema, TypedefError\u003e {\n    // Get field type\n    let field_type: Option\u003cFieldType\u003e =\n        table.get::\u003cString\u003e(\"type\").ok().and_then(|s| s.parse().ok());\n\n    // Get required flag\n    let required: bool = table.get(\"required\").unwrap_or(false);\n\n    // Get description\n    let description: Option\u003cString\u003e = table.get(\"description\").ok();\n\n    // Get default value (convert Lua value to serde_yaml::Value)\n    let default: Option\u003cserde_yaml::Value\u003e =\n        table.get::\u003cmlua::Value\u003e(\"default\").ok().and_then(|v| lua_to_yaml_value(\u0026v));\n\n    // Get enum values\n    let enum_values: Option\u003cVec\u003cString\u003e\u003e =\n        table.get::\u003cmlua::Table\u003e(\"enum\").ok().map(|t| {\n            t.pairs::\u003ci64, String\u003e().filter_map(|r| r.ok()).map(|(_, v)| v).collect()\n        });\n\n    // Get string constraints\n    let pattern: Option\u003cString\u003e = table.get(\"pattern\").ok();\n    let min_length: Option\u003cusize\u003e =\n        table.get::\u003ci64\u003e(\"min_length\").ok().map(|v| v as usize);\n    let max_length: Option\u003cusize\u003e =\n        table.get::\u003ci64\u003e(\"max_length\").ok().map(|v| v as usize);\n\n    // Get number constraints\n    let min: Option\u003cf64\u003e = table.get(\"min\").ok();\n    let max: Option\u003cf64\u003e = table.get(\"max\").ok();\n    let integer: Option\u003cbool\u003e = table.get(\"integer\").ok();\n\n    // Get list constraints\n    let min_items: Option\u003cusize\u003e = table.get::\u003ci64\u003e(\"min_items\").ok().map(|v| v as usize);\n    let max_items: Option\u003cusize\u003e = table.get::\u003ci64\u003e(\"max_items\").ok().map(|v| v as usize);\n\n    // Get nested items schema (for lists)\n    let items: Option\u003cBox\u003cFieldSchema\u003e\u003e = table\n        .get::\u003cmlua::Table\u003e(\"items\")\n        .ok()\n        .map(|t| parse_field_schema(\u0026t, \u0026format!(\"{}[]\", field_name), _path))\n        .transpose()?\n        .map(Box::new);\n\n    // Get reference constraint\n    let note_type: Option\u003cString\u003e = table.get(\"note_type\").ok();\n\n    // Get prompt text for interactive input\n    let prompt: Option\u003cString\u003e = table.get(\"prompt\").ok();\n\n    // Get core flag (whether this is a Rust-managed field)\n    let core: bool = table.get(\"core\").unwrap_or(false);\n\n    // Get multiline flag for string fields\n    let multiline: bool = table.get(\"multiline\").unwrap_or(false);\n\n    Ok(FieldSchema {\n        field_type,\n        required,\n        description,\n        default,\n        enum_values,\n        pattern,\n        min_length,\n        max_length,\n        min,\n        max,\n        integer,\n        items,\n        min_items,\n        max_items,\n        note_type,\n        prompt,\n        core,\n        multiline,\n    })\n}\n\n/// Convert a Lua value to a serde_yaml::Value.\n/// Returns None for Nil (missing values in Lua).\nfn lua_to_yaml_value(value: \u0026mlua::Value) -\u003e Option\u003cserde_yaml::Value\u003e {\n    match value {\n        mlua::Value::Nil =\u003e None, // Nil means \"no value\" in Lua\n        mlua::Value::Boolean(b) =\u003e Some(serde_yaml::Value::Bool(*b)),\n        mlua::Value::Integer(i) =\u003e Some(serde_yaml::Value::Number((*i).into())),\n        mlua::Value::Number(n) =\u003e {\n            // Convert float to integer if it's a whole number, otherwise use string representation\n            if n.fract() == 0.0 {\n                Some(serde_yaml::Value::Number((*n as i64).into()))\n            } else {\n                Some(serde_yaml::Value::String(n.to_string()))\n            }\n        }\n        mlua::Value::String(s) =\u003e {\n            s.to_str().ok().map(|s| serde_yaml::Value::String(s.to_string()))\n        }\n        _ =\u003e None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_discover_typedefs_empty_dir() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        let typedefs = discover_typedefs(\u0026types_dir).unwrap();\n        assert!(typedefs.is_empty());\n    }\n\n    #[test]\n    fn test_discover_typedefs_missing_dir() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"nonexistent\");\n\n        // Should return empty list, not error\n        let typedefs = discover_typedefs(\u0026types_dir).unwrap();\n        assert!(typedefs.is_empty());\n    }\n\n    #[test]\n    fn test_discover_typedefs() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        // Create some type definition files\n        fs::write(types_dir.join(\"meeting.lua\"), \"return { schema = {} }\").unwrap();\n        fs::write(types_dir.join(\"project.lua\"), \"return { schema = {} }\").unwrap();\n\n        // Create a non-lua file (should be ignored)\n        fs::write(types_dir.join(\"readme.md\"), \"# Types\").unwrap();\n\n        let typedefs = discover_typedefs(\u0026types_dir).unwrap();\n\n        assert_eq!(typedefs.len(), 2);\n        assert!(typedefs.iter().any(|t| t.name == \"meeting\"));\n        assert!(typedefs.iter().any(|t| t.name == \"project\"));\n    }\n\n    #[test]\n    fn test_load_simple_typedef() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        fs::write(\n            types_dir.join(\"meeting.lua\"),\n            r#\"\nreturn {\n    description = \"Meeting notes\",\n    schema = {\n        title = { type = \"string\", required = true },\n        date = { type = \"date\", required = true },\n        attendees = { type = \"list\" },\n    }\n}\n\"#,\n        )\n        .unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let typedef = repo.load_typedef(\"meeting\").unwrap();\n\n        assert_eq!(typedef.name, \"meeting\");\n        assert_eq!(typedef.description, Some(\"Meeting notes\".to_string()));\n        assert_eq!(typedef.schema.len(), 3);\n        assert!(typedef.schema.contains_key(\"title\"));\n        assert!(typedef.schema.get(\"title\").unwrap().required);\n        assert!(!typedef.has_validate_fn);\n        assert!(!typedef.has_on_create_hook);\n    }\n\n    #[test]\n    fn test_load_typedef_with_hooks() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        fs::write(\n            types_dir.join(\"task.lua\"),\n            r#\"\nreturn {\n    schema = {\n        status = { type = \"string\", enum = { \"open\", \"done\" } },\n    },\n    validate = function(note)\n        return true\n    end,\n    on_create = function(note)\n        return note\n    end,\n    on_update = function(note, previous)\n        return note\n    end\n}\n\"#,\n        )\n        .unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let typedef = repo.load_typedef(\"task\").unwrap();\n\n        assert!(typedef.has_validate_fn);\n        assert!(typedef.has_on_create_hook);\n        assert!(typedef.has_on_update_hook);\n        assert!(typedef.is_builtin_override); // \"task\" is a built-in\n    }\n\n    #[test]\n    fn test_load_typedef_with_enum() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        fs::write(\n            types_dir.join(\"status.lua\"),\n            r#\"\nreturn {\n    schema = {\n        priority = {\n            type = \"string\",\n            enum = { \"low\", \"medium\", \"high\" },\n            default = \"medium\"\n        },\n    }\n}\n\"#,\n        )\n        .unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let typedef = repo.load_typedef(\"status\").unwrap();\n\n        let priority = typedef.schema.get(\"priority\").unwrap();\n        assert_eq!(\n            priority.enum_values,\n            Some(vec![\"low\".to_string(), \"medium\".to_string(), \"high\".to_string()])\n        );\n        assert_eq!(\n            priority.default,\n            Some(serde_yaml::Value::String(\"medium\".to_string()))\n        );\n    }\n\n    #[test]\n    fn test_load_typedef_with_number_constraints() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        fs::write(\n            types_dir.join(\"meeting.lua\"),\n            r#\"\nreturn {\n    schema = {\n        duration_minutes = {\n            type = \"number\",\n            min = 1,\n            max = 480,\n            integer = true\n        },\n    }\n}\n\"#,\n        )\n        .unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let typedef = repo.load_typedef(\"meeting\").unwrap();\n\n        let duration = typedef.schema.get(\"duration_minutes\").unwrap();\n        assert_eq!(duration.min, Some(1.0));\n        assert_eq!(duration.max, Some(480.0));\n        assert_eq!(duration.integer, Some(true));\n    }\n\n    #[test]\n    fn test_typedef_not_found() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let result = repo.load_typedef(\"nonexistent\");\n\n        assert!(matches!(result, Err(TypedefError::NotFound(_))));\n    }\n\n    #[test]\n    fn test_invalid_typedef_not_table() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        fs::write(types_dir.join(\"invalid.lua\"), r#\"return \"not a table\"\"#).unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let result = repo.load_typedef(\"invalid\");\n\n        assert!(matches!(result, Err(TypedefError::InvalidDefinition { .. })));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":13}},{"line":23,"address":[],"length":0,"stats":{"Line":13}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":27,"address":[],"length":0,"stats":{"Line":24}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":31,"address":[],"length":0,"stats":{"Line":24}},{"line":34,"address":[],"length":0,"stats":{"Line":72}},{"line":35,"address":[],"length":0,"stats":{"Line":36}},{"line":36,"address":[],"length":0,"stats":{"Line":72}},{"line":38,"address":[],"length":0,"stats":{"Line":108}},{"line":39,"address":[],"length":0,"stats":{"Line":36}},{"line":40,"address":[],"length":0,"stats":{"Line":12}},{"line":42,"address":[],"length":0,"stats":{"Line":24}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":207}},{"line":48,"address":[],"length":0,"stats":{"Line":46}},{"line":49,"address":[],"length":0,"stats":{"Line":115}},{"line":53,"address":[],"length":0,"stats":{"Line":99}},{"line":54,"address":[],"length":0,"stats":{"Line":12}},{"line":57,"address":[],"length":0,"stats":{"Line":24}},{"line":58,"address":[],"length":0,"stats":{"Line":144}},{"line":73,"address":[],"length":0,"stats":{"Line":10}},{"line":74,"address":[],"length":0,"stats":{"Line":30}},{"line":75,"address":[],"length":0,"stats":{"Line":20}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":22}},{"line":90,"address":[],"length":0,"stats":{"Line":43}},{"line":91,"address":[],"length":0,"stats":{"Line":22}},{"line":93,"address":[],"length":0,"stats":{"Line":112}},{"line":94,"address":[],"length":0,"stats":{"Line":25}},{"line":96,"address":[],"length":0,"stats":{"Line":42}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":21}},{"line":111,"address":[],"length":0,"stats":{"Line":63}},{"line":112,"address":[],"length":0,"stats":{"Line":21}},{"line":114,"address":[],"length":0,"stats":{"Line":189}},{"line":116,"address":[],"length":0,"stats":{"Line":84}},{"line":120,"address":[],"length":0,"stats":{"Line":21}},{"line":125,"address":[],"length":0,"stats":{"Line":42}},{"line":126,"address":[],"length":0,"stats":{"Line":21}},{"line":128,"address":[],"length":0,"stats":{"Line":63}},{"line":131,"address":[],"length":0,"stats":{"Line":42}},{"line":132,"address":[],"length":0,"stats":{"Line":105}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":41}},{"line":138,"address":[],"length":0,"stats":{"Line":40}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":100}},{"line":151,"address":[],"length":0,"stats":{"Line":100}},{"line":154,"address":[],"length":0,"stats":{"Line":80}},{"line":157,"address":[],"length":0,"stats":{"Line":60}},{"line":158,"address":[],"length":0,"stats":{"Line":60}},{"line":159,"address":[],"length":0,"stats":{"Line":60}},{"line":162,"address":[],"length":0,"stats":{"Line":80}},{"line":164,"address":[],"length":0,"stats":{"Line":20}},{"line":165,"address":[],"length":0,"stats":{"Line":60}},{"line":166,"address":[],"length":0,"stats":{"Line":40}},{"line":167,"address":[],"length":0,"stats":{"Line":60}},{"line":168,"address":[],"length":0,"stats":{"Line":40}},{"line":169,"address":[],"length":0,"stats":{"Line":40}},{"line":170,"address":[],"length":0,"stats":{"Line":40}},{"line":171,"address":[],"length":0,"stats":{"Line":40}},{"line":172,"address":[],"length":0,"stats":{"Line":40}},{"line":173,"address":[],"length":0,"stats":{"Line":40}},{"line":174,"address":[],"length":0,"stats":{"Line":20}},{"line":179,"address":[],"length":0,"stats":{"Line":20}},{"line":183,"address":[],"length":0,"stats":{"Line":40}},{"line":185,"address":[],"length":0,"stats":{"Line":60}},{"line":186,"address":[],"length":0,"stats":{"Line":40}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":130}},{"line":191,"address":[],"length":0,"stats":{"Line":360}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":450}},{"line":197,"address":[],"length":0,"stats":{"Line":360}},{"line":200,"address":[],"length":0,"stats":{"Line":20}},{"line":204,"address":[],"length":0,"stats":{"Line":90}},{"line":210,"address":[],"length":0,"stats":{"Line":180}},{"line":211,"address":[],"length":0,"stats":{"Line":540}},{"line":214,"address":[],"length":0,"stats":{"Line":450}},{"line":217,"address":[],"length":0,"stats":{"Line":450}},{"line":220,"address":[],"length":0,"stats":{"Line":180}},{"line":221,"address":[],"length":0,"stats":{"Line":540}},{"line":224,"address":[],"length":0,"stats":{"Line":180}},{"line":225,"address":[],"length":0,"stats":{"Line":370}},{"line":226,"address":[],"length":0,"stats":{"Line":140}},{"line":230,"address":[],"length":0,"stats":{"Line":450}},{"line":231,"address":[],"length":0,"stats":{"Line":180}},{"line":232,"address":[],"length":0,"stats":{"Line":360}},{"line":233,"address":[],"length":0,"stats":{"Line":180}},{"line":234,"address":[],"length":0,"stats":{"Line":360}},{"line":237,"address":[],"length":0,"stats":{"Line":450}},{"line":238,"address":[],"length":0,"stats":{"Line":450}},{"line":239,"address":[],"length":0,"stats":{"Line":450}},{"line":242,"address":[],"length":0,"stats":{"Line":540}},{"line":243,"address":[],"length":0,"stats":{"Line":540}},{"line":246,"address":[],"length":0,"stats":{"Line":270}},{"line":249,"address":[],"length":0,"stats":{"Line":90}},{"line":251,"address":[],"length":0,"stats":{"Line":90}},{"line":254,"address":[],"length":0,"stats":{"Line":450}},{"line":257,"address":[],"length":0,"stats":{"Line":450}},{"line":260,"address":[],"length":0,"stats":{"Line":450}},{"line":263,"address":[],"length":0,"stats":{"Line":450}},{"line":265,"address":[],"length":0,"stats":{"Line":90}},{"line":266,"address":[],"length":0,"stats":{"Line":180}},{"line":267,"address":[],"length":0,"stats":{"Line":180}},{"line":268,"address":[],"length":0,"stats":{"Line":180}},{"line":269,"address":[],"length":0,"stats":{"Line":180}},{"line":270,"address":[],"length":0,"stats":{"Line":180}},{"line":271,"address":[],"length":0,"stats":{"Line":180}},{"line":272,"address":[],"length":0,"stats":{"Line":180}},{"line":273,"address":[],"length":0,"stats":{"Line":180}},{"line":274,"address":[],"length":0,"stats":{"Line":180}},{"line":275,"address":[],"length":0,"stats":{"Line":180}},{"line":276,"address":[],"length":0,"stats":{"Line":180}},{"line":277,"address":[],"length":0,"stats":{"Line":180}},{"line":278,"address":[],"length":0,"stats":{"Line":180}},{"line":279,"address":[],"length":0,"stats":{"Line":180}},{"line":280,"address":[],"length":0,"stats":{"Line":180}},{"line":281,"address":[],"length":0,"stats":{"Line":180}},{"line":282,"address":[],"length":0,"stats":{"Line":90}},{"line":283,"address":[],"length":0,"stats":{"Line":90}},{"line":289,"address":[],"length":0,"stats":{"Line":90}},{"line":290,"address":[],"length":0,"stats":{"Line":90}},{"line":291,"address":[],"length":0,"stats":{"Line":21}},{"line":292,"address":[],"length":0,"stats":{"Line":32}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":53}},{"line":303,"address":[],"length":0,"stats":{"Line":318}},{"line":305,"address":[],"length":0,"stats":{"Line":0}}],"covered":127,"coverable":145},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","errors.rs"],"content":"//! Error types for type definitions and validation.\n\nuse std::path::PathBuf;\nuse thiserror::Error;\n\n/// Errors that can occur when loading type definitions.\n#[derive(Debug, Error)]\npub enum TypedefError {\n    /// Type definitions directory does not exist.\n    #[error(\"type definitions directory does not exist: {0}\")]\n    MissingDir(String),\n\n    /// Error walking the type definitions directory.\n    #[error(\"failed to read types directory {0}: {1}\")]\n    WalkError(String, #[source] walkdir::Error),\n\n    /// Error reading a type definition file.\n    #[error(\"failed to read type definition file {path}: {source}\")]\n    Io {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    /// Error parsing a Lua type definition.\n    #[error(\"failed to parse type definition {path}: {source}\")]\n    LuaParse {\n        path: PathBuf,\n        #[source]\n        source: crate::scripting::ScriptingError,\n    },\n\n    /// Invalid type definition structure.\n    #[error(\"invalid type definition in {path}: {message}\")]\n    InvalidDefinition { path: PathBuf, message: String },\n\n    /// Type not found.\n    #[error(\"type not found: {0}\")]\n    NotFound(String),\n\n    /// Duplicate type definition.\n    #[error(\"duplicate type definition: {0}\")]\n    Duplicate(String),\n}\n\n/// Errors that occur during note validation.\n#[derive(Debug, Clone, Error)]\npub enum ValidationError {\n    /// A required field is missing.\n    #[error(\"missing required field: {field}\")]\n    MissingRequired { field: String },\n\n    /// Field value has wrong type.\n    #[error(\"invalid type for field '{field}': expected {expected}, got {actual}\")]\n    TypeMismatch { field: String, expected: String, actual: String },\n\n    /// Field value is invalid.\n    #[error(\"invalid value for field '{field}': {message}\")]\n    InvalidValue { field: String, message: String },\n\n    /// Enum constraint violated.\n    #[error(\"enum constraint violated for '{field}': '{value}' not in {allowed:?}\")]\n    EnumViolation { field: String, value: String, allowed: Vec\u003cString\u003e },\n\n    /// Custom validation function failed.\n    #[error(\"custom validation failed: {message}\")]\n    CustomValidation { message: String },\n\n    /// Lua execution error during validation.\n    #[error(\"Lua error during validation: {0}\")]\n    LuaError(String),\n}\n\n/// Result of validating a note against its type definition.\n#[derive(Debug, Clone, Default)]\npub struct ValidationResult {\n    /// Whether the note is valid.\n    pub valid: bool,\n    /// Validation errors (empty if valid).\n    pub errors: Vec\u003cValidationError\u003e,\n    /// Non-fatal warnings.\n    pub warnings: Vec\u003cString\u003e,\n}\n\nimpl ValidationResult {\n    /// Create a successful validation result.\n    pub fn success() -\u003e Self {\n        Self { valid: true, errors: vec![], warnings: vec![] }\n    }\n\n    /// Create a failed validation result.\n    pub fn failure(errors: Vec\u003cValidationError\u003e) -\u003e Self {\n        Self { valid: false, errors, warnings: vec![] }\n    }\n\n    /// Create a failed validation result with a single error.\n    pub fn single_error(error: ValidationError) -\u003e Self {\n        Self::failure(vec![error])\n    }\n\n    /// Add an error to the result.\n    pub fn add_error(\u0026mut self, error: ValidationError) {\n        self.errors.push(error);\n        self.valid = false;\n    }\n\n    /// Add a warning to the result.\n    pub fn add_warning(\u0026mut self, warning: String) {\n        self.warnings.push(warning);\n    }\n\n    /// Merge another validation result into this one.\n    pub fn merge(\u0026mut self, other: ValidationResult) {\n        self.errors.extend(other.errors);\n        self.warnings.extend(other.warnings);\n        if !other.valid {\n            self.valid = false;\n        }\n    }\n}\n","traces":[{"line":87,"address":[],"length":0,"stats":{"Line":45}},{"line":88,"address":[],"length":0,"stats":{"Line":45}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":9}},{"line":103,"address":[],"length":0,"stats":{"Line":27}},{"line":104,"address":[],"length":0,"stats":{"Line":9}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":29}},{"line":114,"address":[],"length":0,"stats":{"Line":87}},{"line":115,"address":[],"length":0,"stats":{"Line":87}},{"line":116,"address":[],"length":0,"stats":{"Line":46}},{"line":117,"address":[],"length":0,"stats":{"Line":17}}],"covered":10,"coverable":16},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","mod.rs"],"content":"//! Lua-based type definitions for note validation.\n//!\n//! This module provides a system for defining custom note types with:\n//! - Field schemas (required fields, types, constraints)\n//! - Custom validation functions\n//! - Lifecycle hooks (on_create, on_update)\n//!\n//! Type definitions are loaded from Lua files in `~/.config/mdvault/types/`.\n//!\n//! # Example Type Definition\n//!\n//! ```lua\n//! -- ~/.config/mdvault/types/meeting.lua\n//! return {\n//!     name = \"meeting\",\n//!     description = \"Meeting notes with attendees\",\n//!\n//!     schema = {\n//!         attendees = { type = \"list\", required = true },\n//!         status = { type = \"string\", enum = { \"scheduled\", \"completed\" } },\n//!     },\n//!\n//!     validate = function(note)\n//!         if note.frontmatter.status == \"completed\" and not note.frontmatter.summary then\n//!             return false, \"Completed meetings must have a summary\"\n//!         end\n//!         return true\n//!     end,\n//! }\n//! ```\n\npub mod autofix;\npub mod definition;\npub mod discovery;\npub mod errors;\npub mod registry;\npub mod scaffolding;\npub mod schema;\npub mod validation;\n\n// Re-export commonly used types\npub use autofix::{FixResult, apply_fixes, try_fix_note};\npub use definition::{TypeDefinition, TypedefInfo};\npub use discovery::TypedefRepository;\npub use errors::{TypedefError, ValidationError, ValidationResult};\npub use registry::TypeRegistry;\npub use scaffolding::{\n    default_output_path, generate_scaffolding, get_missing_required_fields,\n};\npub use schema::{FieldSchema, FieldType};\npub use validation::{\n    BrokenLink, LinkIntegrityResult, add_link_integrity_warnings, check_link_integrity,\n    validate_note,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","registry.rs"],"content":"//! Type registry for managing note type definitions.\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse super::definition::TypeDefinition;\nuse super::discovery::TypedefRepository;\nuse super::errors::TypedefError;\nuse crate::index::types::NoteType;\n\n/// Registry of all known note types (built-in + custom).\n///\n/// The registry maintains:\n/// - Custom type definitions loaded from Lua files\n/// - Overrides for built-in types (when a Lua file matches a built-in name)\n#[derive(Debug, Default)]\npub struct TypeRegistry {\n    /// Custom type definitions loaded from Lua.\n    custom_types: HashMap\u003cString, Arc\u003cTypeDefinition\u003e\u003e,\n\n    /// Built-in type overrides (Lua files that extend built-in types).\n    builtin_overrides: HashMap\u003cNoteType, Arc\u003cTypeDefinition\u003e\u003e,\n}\n\nimpl TypeRegistry {\n    /// Create an empty registry.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Create a registry from a TypedefRepository.\n    pub fn from_repository(repo: \u0026TypedefRepository) -\u003e Result\u003cSelf, TypedefError\u003e {\n        let mut registry = Self::new();\n\n        for info in repo.list_all() {\n            let typedef = repo.load_typedef(\u0026info.name)?;\n            registry.register(typedef)?;\n        }\n\n        Ok(registry)\n    }\n\n    /// Register a type definition.\n    pub fn register(\u0026mut self, typedef: TypeDefinition) -\u003e Result\u003c(), TypedefError\u003e {\n        let name = typedef.name.clone();\n        let typedef = Arc::new(typedef);\n\n        // Check if it's a built-in type override\n        if let Some(builtin) = Self::parse_builtin(\u0026name) {\n            self.builtin_overrides.insert(builtin, typedef);\n            return Ok(());\n        }\n\n        // Otherwise, register as custom type\n        if self.custom_types.contains_key(\u0026name) {\n            return Err(TypedefError::Duplicate(name));\n        }\n        self.custom_types.insert(name, typedef);\n        Ok(())\n    }\n\n    /// Get a type definition by name.\n    ///\n    /// Returns custom types and built-in overrides.\n    pub fn get(\u0026self, name: \u0026str) -\u003e Option\u003cArc\u003cTypeDefinition\u003e\u003e {\n        // First check custom types\n        if let Some(td) = self.custom_types.get(name) {\n            return Some(Arc::clone(td));\n        }\n\n        // Then check built-in overrides\n        Self::parse_builtin(name)\n            .and_then(|builtin| self.builtin_overrides.get(\u0026builtin).cloned())\n    }\n\n    /// Get override for a built-in type (if any).\n    pub fn get_builtin_override(\n        \u0026self,\n        note_type: NoteType,\n    ) -\u003e Option\u003cArc\u003cTypeDefinition\u003e\u003e {\n        self.builtin_overrides.get(\u0026note_type).cloned()\n    }\n\n    /// Check if a type name is known (built-in or custom).\n    pub fn is_known_type(\u0026self, name: \u0026str) -\u003e bool {\n        // Check custom types\n        if self.custom_types.contains_key(name) {\n            return true;\n        }\n\n        // Check if it's a valid built-in type\n        Self::parse_builtin(name).is_some()\n    }\n\n    /// Check if there's a definition for a type (custom or override).\n    pub fn has_definition(\u0026self, name: \u0026str) -\u003e bool {\n        self.get(name).is_some()\n    }\n\n    /// List all custom type names.\n    pub fn list_custom_types(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        self.custom_types.keys().map(|s| s.as_str()).collect()\n    }\n\n    /// List all overridden built-in types.\n    pub fn list_overridden_builtins(\u0026self) -\u003e Vec\u003cNoteType\u003e {\n        self.builtin_overrides.keys().copied().collect()\n    }\n\n    /// List all types (built-in names + custom names).\n    pub fn list_all_types(\u0026self) -\u003e Vec\u003cString\u003e {\n        let mut types: Vec\u003cString\u003e = vec![\n            \"daily\".to_string(),\n            \"weekly\".to_string(),\n            \"task\".to_string(),\n            \"project\".to_string(),\n            \"zettel\".to_string(),\n        ];\n        types.extend(self.custom_types.keys().cloned());\n        types.sort();\n        types.dedup();\n        types\n    }\n\n    /// Get the number of custom types registered.\n    pub fn custom_type_count(\u0026self) -\u003e usize {\n        self.custom_types.len()\n    }\n\n    /// Get the number of builtin overrides registered.\n    pub fn override_count(\u0026self) -\u003e usize {\n        self.builtin_overrides.len()\n    }\n\n    /// Parse a type name to a built-in NoteType, excluding None.\n    fn parse_builtin(name: \u0026str) -\u003e Option\u003cNoteType\u003e {\n        match name.to_lowercase().as_str() {\n            \"daily\" =\u003e Some(NoteType::Daily),\n            \"weekly\" =\u003e Some(NoteType::Weekly),\n            \"task\" =\u003e Some(NoteType::Task),\n            \"project\" =\u003e Some(NoteType::Project),\n            \"zettel\" | \"knowledge\" =\u003e Some(NoteType::Zettel),\n            _ =\u003e None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::schema::{FieldSchema, FieldType};\n\n    fn make_typedef(name: \u0026str) -\u003e TypeDefinition {\n        TypeDefinition::empty(name)\n    }\n\n    #[test]\n    fn test_empty_registry() {\n        let registry = TypeRegistry::new();\n        assert_eq!(registry.custom_type_count(), 0);\n        assert_eq!(registry.override_count(), 0);\n        assert!(!registry.has_definition(\"anything\"));\n    }\n\n    #[test]\n    fn test_register_custom_type() {\n        let mut registry = TypeRegistry::new();\n        let typedef = make_typedef(\"meeting\");\n\n        registry.register(typedef).unwrap();\n\n        assert_eq!(registry.custom_type_count(), 1);\n        assert!(registry.has_definition(\"meeting\"));\n        assert!(registry.is_known_type(\"meeting\"));\n    }\n\n    #[test]\n    fn test_register_builtin_override() {\n        let mut registry = TypeRegistry::new();\n        let typedef = make_typedef(\"task\");\n\n        registry.register(typedef).unwrap();\n\n        // Should be an override, not a custom type\n        assert_eq!(registry.custom_type_count(), 0);\n        assert_eq!(registry.override_count(), 1);\n        assert!(registry.has_definition(\"task\"));\n        assert!(registry.get_builtin_override(NoteType::Task).is_some());\n    }\n\n    #[test]\n    fn test_duplicate_custom_type() {\n        let mut registry = TypeRegistry::new();\n        registry.register(make_typedef(\"meeting\")).unwrap();\n\n        let result = registry.register(make_typedef(\"meeting\"));\n        assert!(matches!(result, Err(TypedefError::Duplicate(_))));\n    }\n\n    #[test]\n    fn test_builtin_override_replaces() {\n        let mut registry = TypeRegistry::new();\n\n        let mut first = make_typedef(\"task\");\n        first.description = Some(\"First\".to_string());\n        registry.register(first).unwrap();\n\n        let mut second = make_typedef(\"task\");\n        second.description = Some(\"Second\".to_string());\n        registry.register(second).unwrap();\n\n        // Second should replace first (no duplicate error for overrides)\n        let td = registry.get(\"task\").unwrap();\n        assert_eq!(td.description, Some(\"Second\".to_string()));\n    }\n\n    #[test]\n    fn test_is_known_type() {\n        let registry = TypeRegistry::new();\n\n        // Built-ins are always known\n        assert!(registry.is_known_type(\"daily\"));\n        assert!(registry.is_known_type(\"weekly\"));\n        assert!(registry.is_known_type(\"task\"));\n        assert!(registry.is_known_type(\"project\"));\n        assert!(registry.is_known_type(\"zettel\"));\n\n        // Unknown types\n        assert!(!registry.is_known_type(\"meeting\"));\n        assert!(!registry.is_known_type(\"custom\"));\n    }\n\n    #[test]\n    fn test_list_all_types() {\n        let mut registry = TypeRegistry::new();\n        registry.register(make_typedef(\"meeting\")).unwrap();\n        registry.register(make_typedef(\"agenda\")).unwrap();\n\n        let types = registry.list_all_types();\n\n        // Should include all built-ins and custom types\n        assert!(types.contains(\u0026\"daily\".to_string()));\n        assert!(types.contains(\u0026\"task\".to_string()));\n        assert!(types.contains(\u0026\"meeting\".to_string()));\n        assert!(types.contains(\u0026\"agenda\".to_string()));\n    }\n\n    #[test]\n    fn test_list_custom_types() {\n        let mut registry = TypeRegistry::new();\n        registry.register(make_typedef(\"meeting\")).unwrap();\n        registry.register(make_typedef(\"task\")).unwrap(); // Override\n\n        let custom = registry.list_custom_types();\n\n        assert_eq!(custom.len(), 1);\n        assert!(custom.contains(\u0026\"meeting\"));\n    }\n\n    #[test]\n    fn test_get_with_schema() {\n        let mut registry = TypeRegistry::new();\n\n        let mut typedef = make_typedef(\"meeting\");\n        typedef.schema.insert(\n            \"attendees\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::List),\n                required: true,\n                ..Default::default()\n            },\n        );\n\n        registry.register(typedef).unwrap();\n\n        let td = registry.get(\"meeting\").unwrap();\n        assert!(td.schema.contains_key(\"attendees\"));\n        assert!(td.schema.get(\"attendees\").unwrap().required);\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":25}},{"line":28,"address":[],"length":0,"stats":{"Line":25}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":8}},{"line":35,"address":[],"length":0,"stats":{"Line":24}},{"line":36,"address":[],"length":0,"stats":{"Line":64}},{"line":37,"address":[],"length":0,"stats":{"Line":48}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":38}},{"line":45,"address":[],"length":0,"stats":{"Line":114}},{"line":46,"address":[],"length":0,"stats":{"Line":114}},{"line":49,"address":[],"length":0,"stats":{"Line":61}},{"line":50,"address":[],"length":0,"stats":{"Line":92}},{"line":51,"address":[],"length":0,"stats":{"Line":23}},{"line":55,"address":[],"length":0,"stats":{"Line":45}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":56}},{"line":59,"address":[],"length":0,"stats":{"Line":14}},{"line":65,"address":[],"length":0,"stats":{"Line":24}},{"line":67,"address":[],"length":0,"stats":{"Line":65}},{"line":68,"address":[],"length":0,"stats":{"Line":17}},{"line":72,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":27}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":24}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":14}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":9}},{"line":101,"address":[],"length":0,"stats":{"Line":5}},{"line":102,"address":[],"length":0,"stats":{"Line":22}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":5}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":52}},{"line":137,"address":[],"length":0,"stats":{"Line":52}},{"line":138,"address":[],"length":0,"stats":{"Line":57}},{"line":139,"address":[],"length":0,"stats":{"Line":52}},{"line":140,"address":[],"length":0,"stats":{"Line":59}},{"line":141,"address":[],"length":0,"stats":{"Line":30}},{"line":142,"address":[],"length":0,"stats":{"Line":40}},{"line":143,"address":[],"length":0,"stats":{"Line":19}}],"covered":56,"coverable":58},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","scaffolding.rs"],"content":"//! Scaffolding generation for note creation.\n//!\n//! This module provides functions to generate note content based on type schemas.\n\nuse std::collections::HashMap;\n\nuse chrono::Local;\n\nuse super::definition::TypeDefinition;\nuse super::schema::FieldType;\n\n/// Generate scaffolding content for a new note.\n///\n/// Creates frontmatter with:\n/// - `type` field set to the type name\n/// - `title` field if provided\n/// - `created` field with current date\n/// - Fields from schema with provided values or defaults\n///\n/// # Arguments\n///\n/// * `type_name` - The note type (e.g., \"task\", \"project\")\n/// * `typedef` - Optional type definition with schema\n/// * `title` - The note title\n/// * `vars` - User-provided field values\n///\n/// # Returns\n///\n/// The complete note content with frontmatter and body.\npub fn generate_scaffolding(\n    type_name: \u0026str,\n    typedef: Option\u003c\u0026TypeDefinition\u003e,\n    title: \u0026str,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e String {\n    let mut frontmatter = serde_yaml::Mapping::new();\n\n    // Always include type\n    frontmatter.insert(\n        serde_yaml::Value::String(\"type\".to_string()),\n        serde_yaml::Value::String(type_name.to_string()),\n    );\n\n    // Always include title\n    frontmatter.insert(\n        serde_yaml::Value::String(\"title\".to_string()),\n        serde_yaml::Value::String(title.to_string()),\n    );\n\n    // Add fields from schema\n    if let Some(td) = typedef {\n        for (field, schema) in \u0026td.schema {\n            // Skip if already set (type, title)\n            if field == \"type\" || field == \"title\" {\n                continue;\n            }\n\n            let value = if let Some(v) = vars.get(field) {\n                // User provided value\n                Some(string_to_yaml_value(v, schema.field_type))\n            } else {\n                // Schema default\n                schema.default.clone()\n            };\n\n            if let Some(v) = value {\n                frontmatter.insert(serde_yaml::Value::String(field.clone()), v);\n            }\n        }\n    }\n\n    // Add any extra vars not in schema\n    for (key, value) in vars {\n        if key == \"type\" || key == \"title\" {\n            continue;\n        }\n        // Only add if not already in frontmatter\n        let key_value = serde_yaml::Value::String(key.clone());\n        if !frontmatter.contains_key(\u0026key_value) {\n            frontmatter.insert(key_value, serde_yaml::Value::String(value.clone()));\n        }\n    }\n\n    // Add created date\n    let today = Local::now().format(\"%Y-%m-%d\").to_string();\n    frontmatter.insert(\n        serde_yaml::Value::String(\"created\".to_string()),\n        serde_yaml::Value::String(today),\n    );\n\n    // Serialize frontmatter\n    let yaml = serde_yaml::to_string(\u0026frontmatter).unwrap_or_default();\n\n    format!(\"---\\n{}---\\n\\n# {}\\n\\n\", yaml, title)\n}\n\n/// Convert a string value to appropriate YAML type based on field type.\nfn string_to_yaml_value(s: \u0026str, field_type: Option\u003cFieldType\u003e) -\u003e serde_yaml::Value {\n    match field_type {\n        Some(FieldType::Number) =\u003e {\n            if let Ok(n) = s.parse::\u003ci64\u003e() {\n                serde_yaml::Value::Number(n.into())\n            } else if let Ok(n) = s.parse::\u003cf64\u003e() {\n                serde_yaml::Value::Number(serde_yaml::Number::from(n))\n            } else {\n                serde_yaml::Value::String(s.to_string())\n            }\n        }\n        Some(FieldType::Boolean) =\u003e {\n            serde_yaml::Value::Bool(s.eq_ignore_ascii_case(\"true\") || s == \"1\")\n        }\n        Some(FieldType::List) =\u003e {\n            // Parse comma-separated values\n            let items: Vec\u003cserde_yaml::Value\u003e = s\n                .split(',')\n                .map(|item| serde_yaml::Value::String(item.trim().to_string()))\n                .collect();\n            serde_yaml::Value::Sequence(items)\n        }\n        _ =\u003e serde_yaml::Value::String(s.to_string()),\n    }\n}\n\n/// Get required fields that are missing from the provided vars.\n///\n/// Returns a list of (field_name, field_schema) for fields that:\n/// - Are marked as required in the schema\n/// - Have no default value\n/// - Are not provided in vars\npub fn get_missing_required_fields\u003c'a\u003e(\n    typedef: \u0026'a TypeDefinition,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Vec\u003c(\u0026'a String, \u0026'a super::schema::FieldSchema)\u003e {\n    typedef\n        .schema\n        .iter()\n        .filter(|(field, schema)| {\n            schema.required\n                \u0026\u0026 schema.default.is_none()\n                \u0026\u0026 !vars.contains_key(*field)\n                \u0026\u0026 *field != \"title\"\n                \u0026\u0026 *field != \"type\"\n        })\n        .collect()\n}\n\n/// Generate default output path for a note.\n///\n/// Pattern: `\u003ctype\u003es/\u003ctitle-slugified\u003e.md`\n/// Examples:\n/// - task, \"Fix bug\" -\u003e \"tasks/fix-bug.md\"\n/// - project, \"My Project\" -\u003e \"projects/my-project.md\"\npub fn default_output_path(type_name: \u0026str, title: \u0026str) -\u003e String {\n    let slug = slugify(title);\n    format!(\"{}s/{}.md\", type_name, slug)\n}\n\n/// Convert a string to a URL-friendly slug.\nfn slugify(s: \u0026str) -\u003e String {\n    let mut result = String::with_capacity(s.len());\n\n    for c in s.chars() {\n        if c.is_ascii_alphanumeric() {\n            result.push(c.to_ascii_lowercase());\n        } else if (c == ' ' || c == '_' || c == '-') \u0026\u0026 !result.ends_with('-') {\n            result.push('-');\n        }\n    }\n\n    result.trim_matches('-').to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_generate_scaffolding_minimal() {\n        let content = generate_scaffolding(\"task\", None, \"My Task\", \u0026HashMap::new());\n\n        assert!(content.contains(\"type: task\"));\n        assert!(content.contains(\"title: My Task\"));\n        assert!(content.contains(\"# My Task\"));\n        assert!(content.contains(\"created:\"));\n    }\n\n    #[test]\n    fn test_generate_scaffolding_with_vars() {\n        let mut vars = HashMap::new();\n        vars.insert(\"status\".to_string(), \"open\".to_string());\n        vars.insert(\"project\".to_string(), \"myproject\".to_string());\n\n        let content = generate_scaffolding(\"task\", None, \"My Task\", \u0026vars);\n\n        assert!(content.contains(\"status: open\"));\n        assert!(content.contains(\"project: myproject\"));\n    }\n\n    #[test]\n    fn test_default_output_path() {\n        assert_eq!(default_output_path(\"task\", \"Fix bug\"), \"tasks/fix-bug.md\");\n        assert_eq!(\n            default_output_path(\"project\", \"My New Project\"),\n            \"projects/my-new-project.md\"\n        );\n        assert_eq!(\n            default_output_path(\"zettel\", \"Random Thought!\"),\n            \"zettels/random-thought.md\"\n        );\n    }\n\n    #[test]\n    fn test_slugify() {\n        assert_eq!(slugify(\"Hello World\"), \"hello-world\");\n        assert_eq!(slugify(\"My Task: Do Something!\"), \"my-task-do-something\");\n        assert_eq!(slugify(\"  spaced  out  \"), \"spaced-out\");\n    }\n\n    #[test]\n    fn test_string_to_yaml_value_number() {\n        let v = string_to_yaml_value(\"42\", Some(FieldType::Number));\n        assert_eq!(v, serde_yaml::Value::Number(42.into()));\n    }\n\n    #[test]\n    fn test_string_to_yaml_value_boolean() {\n        let v = string_to_yaml_value(\"true\", Some(FieldType::Boolean));\n        assert_eq!(v, serde_yaml::Value::Bool(true));\n\n        let v = string_to_yaml_value(\"false\", Some(FieldType::Boolean));\n        assert_eq!(v, serde_yaml::Value::Bool(false));\n    }\n\n    #[test]\n    fn test_string_to_yaml_value_list() {\n        let v = string_to_yaml_value(\"a, b, c\", Some(FieldType::List));\n        if let serde_yaml::Value::Sequence(items) = v {\n            assert_eq!(items.len(), 3);\n            assert_eq!(items[0], serde_yaml::Value::String(\"a\".to_string()));\n            assert_eq!(items[1], serde_yaml::Value::String(\"b\".to_string()));\n            assert_eq!(items[2], serde_yaml::Value::String(\"c\".to_string()));\n        } else {\n            panic!(\"Expected sequence\");\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":8}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":7}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":7}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":9}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":159,"address":[],"length":0,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":24}},{"line":162,"address":[],"length":0,"stats":{"Line":96}},{"line":163,"address":[],"length":0,"stats":{"Line":235}},{"line":164,"address":[],"length":0,"stats":{"Line":201}},{"line":165,"address":[],"length":0,"stats":{"Line":115}},{"line":166,"address":[],"length":0,"stats":{"Line":11}},{"line":170,"address":[],"length":0,"stats":{"Line":12}}],"covered":39,"coverable":61},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","schema.rs"],"content":"//! Field type and schema definitions for type definitions.\n\nuse serde::{Deserialize, Serialize};\n\n/// Type of a frontmatter field.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum FieldType {\n    /// String value.\n    String,\n    /// Numeric value (integer or float).\n    Number,\n    /// Boolean value.\n    Boolean,\n    /// Date in YYYY-MM-DD format.\n    Date,\n    /// ISO 8601 datetime.\n    Datetime,\n    /// Array of values.\n    List,\n    /// Link to another note.\n    Reference,\n}\n\nimpl FieldType {\n    /// Get the display name for this field type.\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::String =\u003e \"string\",\n            Self::Number =\u003e \"number\",\n            Self::Boolean =\u003e \"boolean\",\n            Self::Date =\u003e \"date\",\n            Self::Datetime =\u003e \"datetime\",\n            Self::List =\u003e \"list\",\n            Self::Reference =\u003e \"reference\",\n        }\n    }\n}\n\nimpl std::fmt::Display for FieldType {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl std::str::FromStr for FieldType {\n    type Err = String;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s.to_lowercase().as_str() {\n            \"string\" | \"str\" =\u003e Ok(Self::String),\n            \"number\" | \"num\" | \"int\" | \"integer\" | \"float\" =\u003e Ok(Self::Number),\n            \"boolean\" | \"bool\" =\u003e Ok(Self::Boolean),\n            \"date\" =\u003e Ok(Self::Date),\n            \"datetime\" =\u003e Ok(Self::Datetime),\n            \"list\" | \"array\" =\u003e Ok(Self::List),\n            \"reference\" | \"ref\" | \"link\" | \"wikilink\" =\u003e Ok(Self::Reference),\n            _ =\u003e Err(format!(\"unknown field type: {}\", s)),\n        }\n    }\n}\n\n/// Schema definition for a single frontmatter field.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct FieldSchema {\n    /// Field type.\n    #[serde(rename = \"type\")]\n    pub field_type: Option\u003cFieldType\u003e,\n\n    /// Whether the field is required.\n    #[serde(default)]\n    pub required: bool,\n\n    /// Human-readable description.\n    #[serde(default)]\n    pub description: Option\u003cString\u003e,\n\n    /// Default value (as serde_yaml::Value for flexibility).\n    #[serde(default)]\n    pub default: Option\u003cserde_yaml::Value\u003e,\n\n    /// Prompt text for interactive input.\n    /// If set, user will be prompted for this field during note creation.\n    #[serde(default)]\n    pub prompt: Option\u003cString\u003e,\n\n    /// Whether this is a core field managed by Rust (not user-modifiable).\n    #[serde(default)]\n    pub core: bool,\n\n    /// Whether to allow multiline input for string fields.\n    #[serde(default)]\n    pub multiline: bool,\n\n    // String constraints\n    /// Allowed values for enum fields.\n    #[serde(default, rename = \"enum\")]\n    pub enum_values: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Regex pattern for validation.\n    #[serde(default)]\n    pub pattern: Option\u003cString\u003e,\n\n    /// Minimum string length.\n    #[serde(default)]\n    pub min_length: Option\u003cusize\u003e,\n\n    /// Maximum string length.\n    #[serde(default)]\n    pub max_length: Option\u003cusize\u003e,\n\n    // Number constraints\n    /// Minimum numeric value.\n    #[serde(default)]\n    pub min: Option\u003cf64\u003e,\n\n    /// Maximum numeric value.\n    #[serde(default)]\n    pub max: Option\u003cf64\u003e,\n\n    /// Whether the number must be an integer.\n    #[serde(default)]\n    pub integer: Option\u003cbool\u003e,\n\n    // List constraints\n    /// Schema for list items.\n    #[serde(default)]\n    pub items: Option\u003cBox\u003cFieldSchema\u003e\u003e,\n\n    /// Minimum number of items.\n    #[serde(default)]\n    pub min_items: Option\u003cusize\u003e,\n\n    /// Maximum number of items.\n    #[serde(default)]\n    pub max_items: Option\u003cusize\u003e,\n\n    // Reference constraints\n    /// Restrict to notes of a specific type.\n    #[serde(default)]\n    pub note_type: Option\u003cString\u003e,\n}\n\nimpl FieldSchema {\n    /// Create a new required string field.\n    pub fn required_string() -\u003e Self {\n        Self { field_type: Some(FieldType::String), required: true, ..Default::default() }\n    }\n\n    /// Create a new optional string field.\n    pub fn optional_string() -\u003e Self {\n        Self {\n            field_type: Some(FieldType::String),\n            required: false,\n            ..Default::default()\n        }\n    }\n\n    /// Create a new required field with an enum constraint.\n    pub fn required_enum(values: Vec\u003cString\u003e) -\u003e Self {\n        Self {\n            field_type: Some(FieldType::String),\n            required: true,\n            enum_values: Some(values),\n            ..Default::default()\n        }\n    }\n\n    /// Get the effective field type, defaulting to String if not specified.\n    pub fn effective_type(\u0026self) -\u003e FieldType {\n        self.field_type.unwrap_or(FieldType::String)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_field_type_from_str() {\n        assert_eq!(\"string\".parse::\u003cFieldType\u003e().unwrap(), FieldType::String);\n        assert_eq!(\"number\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Number);\n        assert_eq!(\"boolean\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Boolean);\n        assert_eq!(\"date\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Date);\n        assert_eq!(\"datetime\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Datetime);\n        assert_eq!(\"list\".parse::\u003cFieldType\u003e().unwrap(), FieldType::List);\n        assert_eq!(\"reference\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Reference);\n        // Aliases\n        assert_eq!(\"bool\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Boolean);\n        assert_eq!(\"array\".parse::\u003cFieldType\u003e().unwrap(), FieldType::List);\n        assert_eq!(\"wikilink\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Reference);\n    }\n\n    #[test]\n    fn test_field_type_display() {\n        assert_eq!(FieldType::String.to_string(), \"string\");\n        assert_eq!(FieldType::Number.to_string(), \"number\");\n    }\n\n    #[test]\n    fn test_field_schema_defaults() {\n        let schema = FieldSchema::default();\n        assert!(!schema.required);\n        assert!(schema.field_type.is_none());\n        assert!(schema.enum_values.is_none());\n    }\n\n    #[test]\n    fn test_required_string() {\n        let schema = FieldSchema::required_string();\n        assert!(schema.required);\n        assert_eq!(schema.effective_type(), FieldType::String);\n    }\n\n    #[test]\n    fn test_required_enum() {\n        let schema = FieldSchema::required_enum(vec![\"a\".to_string(), \"b\".to_string()]);\n        assert!(schema.required);\n        assert_eq!(schema.enum_values, Some(vec![\"a\".to_string(), \"b\".to_string()]));\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":20}},{"line":49,"address":[],"length":0,"stats":{"Line":100}},{"line":50,"address":[],"length":0,"stats":{"Line":100}},{"line":51,"address":[],"length":0,"stats":{"Line":200}},{"line":52,"address":[],"length":0,"stats":{"Line":314}},{"line":53,"address":[],"length":0,"stats":{"Line":125}},{"line":54,"address":[],"length":0,"stats":{"Line":70}},{"line":55,"address":[],"length":0,"stats":{"Line":27}},{"line":56,"address":[],"length":0,"stats":{"Line":19}},{"line":57,"address":[],"length":0,"stats":{"Line":15}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":15}},{"line":171,"address":[],"length":0,"stats":{"Line":45}}],"covered":23,"coverable":30},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","validation.rs"],"content":"//! Note validation against type definitions.\n\nuse std::path::Path;\n\nuse regex::Regex;\n\nuse super::definition::TypeDefinition;\nuse super::errors::{ValidationError, ValidationResult};\nuse super::registry::TypeRegistry;\nuse super::schema::{FieldSchema, FieldType};\nuse crate::index::IndexDb;\nuse crate::scripting::LuaEngine;\n\n/// Validate a note's frontmatter against its type definition.\n///\n/// Returns a ValidationResult with any errors and warnings found.\npub fn validate_note(\n    registry: \u0026TypeRegistry,\n    note_type: \u0026str,\n    note_path: \u0026str,\n    frontmatter: \u0026serde_yaml::Value,\n    content: \u0026str,\n) -\u003e ValidationResult {\n    // Get type definition (if any)\n    let typedef = match registry.get(note_type) {\n        Some(td) =\u003e td,\n        None =\u003e return ValidationResult::success(), // Unknown types pass by default\n    };\n\n    let mut result = ValidationResult::success();\n\n    // Phase 1: Schema validation\n    if let serde_yaml::Value::Mapping(map) = frontmatter {\n        let schema_result = validate_schema(\u0026typedef, map);\n        result.merge(schema_result);\n    }\n\n    // Phase 2: Custom validate() function\n    if typedef.has_validate_fn {\n        match run_validate_hook(\u0026typedef, note_type, note_path, frontmatter, content) {\n            Ok((valid, message)) =\u003e {\n                if !valid {\n                    result.add_error(ValidationError::CustomValidation {\n                        message: message\n                            .unwrap_or_else(|| \"Custom validation failed\".to_string()),\n                    });\n                }\n            }\n            Err(e) =\u003e result.add_error(e),\n        }\n    }\n\n    result\n}\n\n/// Validate frontmatter against schema.\nfn validate_schema(\n    typedef: \u0026TypeDefinition,\n    frontmatter: \u0026serde_yaml::Mapping,\n) -\u003e ValidationResult {\n    let mut result = ValidationResult::success();\n\n    for (field_name, schema) in \u0026typedef.schema {\n        let value = frontmatter.get(serde_yaml::Value::String(field_name.clone()));\n\n        // Check required fields\n        if schema.required \u0026\u0026 value.is_none() {\n            result.add_error(ValidationError::MissingRequired {\n                field: field_name.clone(),\n            });\n            continue;\n        }\n\n        // Validate value if present\n        if let Some(val) = value {\n            let field_result = validate_field(field_name, schema, val);\n            result.merge(field_result);\n        }\n    }\n\n    result\n}\n\n/// Validate a single field value against its schema.\nfn validate_field(\n    field: \u0026str,\n    schema: \u0026FieldSchema,\n    value: \u0026serde_yaml::Value,\n) -\u003e ValidationResult {\n    let mut result = ValidationResult::success();\n\n    let expected_type = schema.effective_type();\n\n    // Type checking\n    let type_ok = match (\u0026expected_type, value) {\n        (FieldType::String, serde_yaml::Value::String(_)) =\u003e true,\n        (FieldType::Number, serde_yaml::Value::Number(_)) =\u003e true,\n        (FieldType::Boolean, serde_yaml::Value::Bool(_)) =\u003e true,\n        (FieldType::List, serde_yaml::Value::Sequence(_)) =\u003e true,\n        (FieldType::Date, serde_yaml::Value::String(s)) =\u003e is_valid_date(s),\n        (FieldType::Datetime, serde_yaml::Value::String(s)) =\u003e is_valid_datetime(s),\n        (FieldType::Reference, serde_yaml::Value::String(_)) =\u003e true,\n        _ =\u003e false,\n    };\n\n    if !type_ok {\n        result.add_error(ValidationError::TypeMismatch {\n            field: field.to_string(),\n            expected: expected_type.to_string(),\n            actual: yaml_type_name(value),\n        });\n        return result;\n    }\n\n    // Enum constraint\n    if let (Some(enum_values), serde_yaml::Value::String(s)) =\n        (\u0026schema.enum_values, value)\n        \u0026\u0026 !enum_values.contains(s)\n    {\n        result.add_error(ValidationError::EnumViolation {\n            field: field.to_string(),\n            value: s.clone(),\n            allowed: enum_values.clone(),\n        });\n    }\n\n    // Number constraints\n    if let serde_yaml::Value::Number(n) = value\n        \u0026\u0026 let Some(f) = n.as_f64()\n    {\n        if let Some(min) = schema.min\n            \u0026\u0026 f \u003c min\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"value {} is less than minimum {}\", f, min),\n            });\n        }\n        if let Some(max) = schema.max\n            \u0026\u0026 f \u003e max\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"value {} is greater than maximum {}\", f, max),\n            });\n        }\n        if let Some(true) = schema.integer\n            \u0026\u0026 f.fract() != 0.0\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"value {} must be an integer\", f),\n            });\n        }\n    }\n\n    // String length constraints\n    if let serde_yaml::Value::String(s) = value {\n        if let Some(min) = schema.min_length\n            \u0026\u0026 s.len() \u003c min\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\n                    \"string length {} is less than minimum {}\",\n                    s.len(),\n                    min\n                ),\n            });\n        }\n        if let Some(max) = schema.max_length\n            \u0026\u0026 s.len() \u003e max\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\n                    \"string length {} is greater than maximum {}\",\n                    s.len(),\n                    max\n                ),\n            });\n        }\n        if let Some(pattern) = \u0026schema.pattern\n            \u0026\u0026 let Ok(re) = Regex::new(pattern)\n            \u0026\u0026 !re.is_match(s)\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"value '{}' does not match pattern '{}'\", s, pattern),\n            });\n        }\n    }\n\n    // List constraints\n    if let serde_yaml::Value::Sequence(seq) = value {\n        if let Some(min) = schema.min_items\n            \u0026\u0026 seq.len() \u003c min\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"list has {} items, minimum is {}\", seq.len(), min),\n            });\n        }\n        if let Some(max) = schema.max_items\n            \u0026\u0026 seq.len() \u003e max\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"list has {} items, maximum is {}\", seq.len(), max),\n            });\n        }\n\n        // Validate items if schema provided\n        if let Some(item_schema) = \u0026schema.items {\n            for (i, item) in seq.iter().enumerate() {\n                let item_field = format!(\"{}[{}]\", field, i);\n                let item_result = validate_field(\u0026item_field, item_schema, item);\n                result.merge(item_result);\n            }\n        }\n    }\n\n    result\n}\n\n/// Check if a string is a valid date (YYYY-MM-DD format).\nfn is_valid_date(s: \u0026str) -\u003e bool {\n    // Simple validation: YYYY-MM-DD\n    if s.len() != 10 {\n        return false;\n    }\n    let parts: Vec\u003c\u0026str\u003e = s.split('-').collect();\n    if parts.len() != 3 {\n        return false;\n    }\n    parts[0].len() == 4\n        \u0026\u0026 parts[1].len() == 2\n        \u0026\u0026 parts[2].len() == 2\n        \u0026\u0026 parts[0].chars().all(|c| c.is_ascii_digit())\n        \u0026\u0026 parts[1].chars().all(|c| c.is_ascii_digit())\n        \u0026\u0026 parts[2].chars().all(|c| c.is_ascii_digit())\n}\n\n/// Check if a string is a valid datetime (ISO 8601 format).\nfn is_valid_datetime(s: \u0026str) -\u003e bool {\n    // Accept various ISO 8601 formats\n    // YYYY-MM-DDTHH:MM:SS or YYYY-MM-DD HH:MM:SS or YYYY-MM-DDTHH:MM:SSZ\n    chrono::DateTime::parse_from_rfc3339(s).is_ok()\n        || chrono::NaiveDateTime::parse_from_str(s, \"%Y-%m-%dT%H:%M:%S\").is_ok()\n        || chrono::NaiveDateTime::parse_from_str(s, \"%Y-%m-%d %H:%M:%S\").is_ok()\n}\n\n/// Get a human-readable type name for a YAML value.\nfn yaml_type_name(value: \u0026serde_yaml::Value) -\u003e String {\n    match value {\n        serde_yaml::Value::Null =\u003e \"null\".to_string(),\n        serde_yaml::Value::Bool(_) =\u003e \"boolean\".to_string(),\n        serde_yaml::Value::Number(_) =\u003e \"number\".to_string(),\n        serde_yaml::Value::String(_) =\u003e \"string\".to_string(),\n        serde_yaml::Value::Sequence(_) =\u003e \"list\".to_string(),\n        serde_yaml::Value::Mapping(_) =\u003e \"mapping\".to_string(),\n        serde_yaml::Value::Tagged(_) =\u003e \"tagged\".to_string(),\n    }\n}\n\n/// Run custom validate() Lua hook.\nfn run_validate_hook(\n    typedef: \u0026TypeDefinition,\n    note_type: \u0026str,\n    note_path: \u0026str,\n    frontmatter: \u0026serde_yaml::Value,\n    content: \u0026str,\n) -\u003e Result\u003c(bool, Option\u003cString\u003e), ValidationError\u003e {\n    let engine =\n        LuaEngine::sandboxed().map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    let lua = engine.lua();\n\n    // Load the type definition\n    lua.load(\u0026typedef.lua_source)\n        .exec()\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    // Build note table for validation\n    let note_table =\n        lua.create_table().map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"type\", note_type)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n    note_table\n        .set(\"path\", note_path)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n    note_table\n        .set(\"content\", content)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    // Convert frontmatter to Lua table\n    let fm_table = yaml_to_lua_table(lua, frontmatter)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n    note_table\n        .set(\"frontmatter\", fm_table)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    // Get the type definition table by re-evaluating\n    let typedef_table: mlua::Table = lua\n        .load(\u0026typedef.lua_source)\n        .eval()\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    // Call validate function\n    let validate_fn: mlua::Function = typedef_table\n        .get(\"validate\")\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    let result = validate_fn\n        .call::\u003cmlua::MultiValue\u003e(note_table)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    // Parse result: (true) or (false, \"error message\")\n    let values: Vec\u003cmlua::Value\u003e = result.into_iter().collect();\n    match values.as_slice() {\n        [mlua::Value::Boolean(true)] | [mlua::Value::Boolean(true), _] =\u003e {\n            Ok((true, None))\n        }\n        [mlua::Value::Boolean(false)] =\u003e Ok((false, None)),\n        [mlua::Value::Boolean(false), mlua::Value::String(msg)] =\u003e {\n            let msg_str = msg.to_str().map(|s| s.to_string()).unwrap_or_default();\n            Ok((false, Some(msg_str)))\n        }\n        [mlua::Value::Nil] =\u003e Ok((true, None)), // nil treated as success\n        [] =\u003e Ok((true, None)),                 // no return treated as success\n        _ =\u003e Ok((true, None)),\n    }\n}\n\n/// Convert a serde_yaml::Value to a Lua value.\n///\n/// This is used to pass frontmatter data to Lua hooks.\npub fn yaml_to_lua_table(\n    lua: \u0026mlua::Lua,\n    value: \u0026serde_yaml::Value,\n) -\u003e mlua::Result\u003cmlua::Value\u003e {\n    match value {\n        serde_yaml::Value::Null =\u003e Ok(mlua::Value::Nil),\n        serde_yaml::Value::Bool(b) =\u003e Ok(mlua::Value::Boolean(*b)),\n        serde_yaml::Value::Number(n) =\u003e {\n            if let Some(i) = n.as_i64() {\n                Ok(mlua::Value::Integer(i))\n            } else if let Some(f) = n.as_f64() {\n                Ok(mlua::Value::Number(f))\n            } else {\n                Ok(mlua::Value::Nil)\n            }\n        }\n        serde_yaml::Value::String(s) =\u003e Ok(mlua::Value::String(lua.create_string(s)?)),\n        serde_yaml::Value::Sequence(seq) =\u003e {\n            let table = lua.create_table()?;\n            for (i, item) in seq.iter().enumerate() {\n                table.set(i + 1, yaml_to_lua_table(lua, item)?)?;\n            }\n            Ok(mlua::Value::Table(table))\n        }\n        serde_yaml::Value::Mapping(map) =\u003e {\n            let table = lua.create_table()?;\n            for (k, v) in map {\n                if let serde_yaml::Value::String(key) = k {\n                    table.set(key.as_str(), yaml_to_lua_table(lua, v)?)?;\n                }\n            }\n            Ok(mlua::Value::Table(table))\n        }\n        serde_yaml::Value::Tagged(tagged) =\u003e yaml_to_lua_table(lua, \u0026tagged.value),\n    }\n}\n\n/// Result of link integrity check.\n#[derive(Debug, Clone, Default)]\npub struct LinkIntegrityResult {\n    /// Total number of outgoing links checked.\n    pub total_links: usize,\n    /// Number of broken links (unresolved targets).\n    pub broken_links: usize,\n    /// List of broken link details: (target_path, link_text, link_type).\n    pub broken_details: Vec\u003cBrokenLink\u003e,\n}\n\n/// Information about a broken link.\n#[derive(Debug, Clone)]\npub struct BrokenLink {\n    /// The target path that doesn't exist.\n    pub target_path: String,\n    /// The display text of the link (if any).\n    pub link_text: Option\u003cString\u003e,\n    /// The type of link (wikilink, markdown, frontmatter).\n    pub link_type: String,\n}\n\n/// Check link integrity for a note.\n///\n/// This function checks all outgoing links from a note and reports which ones\n/// point to non-existent targets. Broken links are returned as part of the result\n/// so they can be added as warnings to the validation output.\n///\n/// # Arguments\n///\n/// * `db` - The vault index database\n/// * `note_path` - Path to the note (relative to vault root)\n///\n/// # Returns\n///\n/// A `LinkIntegrityResult` containing the total links checked and any broken links found.\npub fn check_link_integrity(db: \u0026IndexDb, note_path: \u0026Path) -\u003e LinkIntegrityResult {\n    let mut result = LinkIntegrityResult::default();\n\n    // Get the note from the index\n    let note = match db.get_note_by_path(note_path) {\n        Ok(Some(n)) =\u003e n,\n        Ok(None) =\u003e return result, // Note not in index\n        Err(_) =\u003e return result,   // DB error, skip\n    };\n\n    let note_id = match note.id {\n        Some(id) =\u003e id,\n        None =\u003e return result,\n    };\n\n    // Get all outgoing links\n    let links = match db.get_outgoing_links(note_id) {\n        Ok(l) =\u003e l,\n        Err(_) =\u003e return result,\n    };\n\n    result.total_links = links.len();\n\n    // Check each link for resolution\n    for link in links {\n        if link.target_id.is_none() {\n            // This link is unresolved (broken)\n            result.broken_links += 1;\n            result.broken_details.push(BrokenLink {\n                target_path: link.target_path.clone(),\n                link_text: link.link_text.clone(),\n                link_type: link.link_type.as_str().to_string(),\n            });\n        }\n    }\n\n    result\n}\n\n/// Add link integrity warnings to a validation result.\n///\n/// This is a convenience function that checks link integrity and adds\n/// any broken links as warnings to the validation result.\npub fn add_link_integrity_warnings(\n    result: \u0026mut ValidationResult,\n    db: \u0026IndexDb,\n    note_path: \u0026Path,\n) {\n    let integrity = check_link_integrity(db, note_path);\n\n    for broken in integrity.broken_details {\n        let warning = if let Some(text) = broken.link_text {\n            format!(\n                \"broken {} link '{}' -\u003e '{}' (target does not exist)\",\n                broken.link_type, text, broken.target_path\n            )\n        } else {\n            format!(\n                \"broken {} link to '{}' (target does not exist)\",\n                broken.link_type, broken.target_path\n            )\n        };\n        result.add_warning(warning);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::definition::TypeDefinition;\n    use std::collections::HashMap;\n\n    fn make_frontmatter(fields: \u0026[(\u0026str, serde_yaml::Value)]) -\u003e serde_yaml::Value {\n        let mut map = serde_yaml::Mapping::new();\n        for (k, v) in fields {\n            map.insert(serde_yaml::Value::String(k.to_string()), v.clone());\n        }\n        serde_yaml::Value::Mapping(map)\n    }\n\n    fn make_typedef_with_schema(schema: HashMap\u003cString, FieldSchema\u003e) -\u003e TypeDefinition {\n        TypeDefinition {\n            name: \"test\".to_string(),\n            description: None,\n            source_path: std::path::PathBuf::new(),\n            schema,\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: false,\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: String::new(),\n        }\n    }\n\n    #[test]\n    fn test_validate_required_field_present() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"title\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        let frontmatter =\n            make_frontmatter(\u0026[(\"title\", serde_yaml::Value::String(\"Hello\".into()))]);\n\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n        assert!(result.errors.is_empty());\n    }\n\n    #[test]\n    fn test_validate_required_field_missing() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"title\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        let frontmatter = make_frontmatter(\u0026[]);\n\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n        assert_eq!(result.errors.len(), 1);\n        assert!(\n            matches!(\u0026result.errors[0], ValidationError::MissingRequired { field } if field == \"title\")\n        );\n    }\n\n    #[test]\n    fn test_validate_type_mismatch() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"count\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::Number),\n                required: true,\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        let frontmatter = make_frontmatter(\u0026[(\n            \"count\",\n            serde_yaml::Value::String(\"not a number\".into()),\n        )]);\n\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n        assert!(matches!(\u0026result.errors[0], ValidationError::TypeMismatch { .. }));\n    }\n\n    #[test]\n    fn test_validate_enum() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"status\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                enum_values: Some(vec![\"open\".to_string(), \"done\".to_string()]),\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        // Valid enum value\n        let frontmatter =\n            make_frontmatter(\u0026[(\"status\", serde_yaml::Value::String(\"open\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n\n        // Invalid enum value\n        let frontmatter =\n            make_frontmatter(\u0026[(\"status\", serde_yaml::Value::String(\"invalid\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n        assert!(matches!(\u0026result.errors[0], ValidationError::EnumViolation { .. }));\n    }\n\n    #[test]\n    fn test_validate_number_range() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"priority\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::Number),\n                required: true,\n                min: Some(1.0),\n                max: Some(5.0),\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        // Valid range\n        let frontmatter =\n            make_frontmatter(\u0026[(\"priority\", serde_yaml::Value::Number(3.into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n\n        // Below minimum\n        let frontmatter =\n            make_frontmatter(\u0026[(\"priority\", serde_yaml::Value::Number(0.into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n\n        // Above maximum\n        let frontmatter =\n            make_frontmatter(\u0026[(\"priority\", serde_yaml::Value::Number(10.into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n    }\n\n    #[test]\n    fn test_validate_string_length() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"code\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                min_length: Some(3),\n                max_length: Some(10),\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        // Valid length\n        let frontmatter =\n            make_frontmatter(\u0026[(\"code\", serde_yaml::Value::String(\"ABC123\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n\n        // Too short\n        let frontmatter =\n            make_frontmatter(\u0026[(\"code\", serde_yaml::Value::String(\"AB\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n\n        // Too long\n        let frontmatter = make_frontmatter(\u0026[(\n            \"code\",\n            serde_yaml::Value::String(\"ABCDEFGHIJK\".into()),\n        )]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n    }\n\n    #[test]\n    fn test_validate_list_items() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"tags\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::List),\n                required: true,\n                min_items: Some(1),\n                max_items: Some(5),\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        // Valid list\n        let frontmatter = make_frontmatter(\u0026[(\n            \"tags\",\n            serde_yaml::Value::Sequence(vec![\n                serde_yaml::Value::String(\"a\".into()),\n                serde_yaml::Value::String(\"b\".into()),\n            ]),\n        )]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n\n        // Empty list (below minimum)\n        let frontmatter =\n            make_frontmatter(\u0026[(\"tags\", serde_yaml::Value::Sequence(vec![]))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n    }\n\n    #[test]\n    fn test_validate_date_format() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"due\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::Date),\n                required: true,\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        // Valid date\n        let frontmatter =\n            make_frontmatter(\u0026[(\"due\", serde_yaml::Value::String(\"2025-12-29\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n\n        // Invalid date format\n        let frontmatter =\n            make_frontmatter(\u0026[(\"due\", serde_yaml::Value::String(\"29-12-2025\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n    }\n\n    #[test]\n    fn test_validate_unknown_type() {\n        let registry = TypeRegistry::new();\n\n        // Unknown types should pass\n        let frontmatter =\n            make_frontmatter(\u0026[(\"anything\", serde_yaml::Value::String(\"value\".into()))]);\n        let result = validate_note(\u0026registry, \"unknown\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n    }\n\n    #[test]\n    fn test_is_valid_date() {\n        assert!(is_valid_date(\"2025-12-29\"));\n        assert!(is_valid_date(\"2000-01-01\"));\n        assert!(!is_valid_date(\"2025-1-29\")); // Month not zero-padded\n        assert!(!is_valid_date(\"25-12-29\")); // Year not 4 digits\n        assert!(!is_valid_date(\"2025/12/29\")); // Wrong separator\n        assert!(!is_valid_date(\"not a date\"));\n    }\n\n    #[test]\n    fn test_is_valid_datetime() {\n        assert!(is_valid_datetime(\"2025-12-29T14:30:00Z\"));\n        assert!(is_valid_datetime(\"2025-12-29T14:30:00+00:00\"));\n        assert!(is_valid_datetime(\"2025-12-29T14:30:00\"));\n        assert!(!is_valid_datetime(\"not a datetime\"));\n        assert!(!is_valid_datetime(\"2025-12-29\")); // Just a date\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":16}},{"line":25,"address":[],"length":0,"stats":{"Line":47}},{"line":26,"address":[],"length":0,"stats":{"Line":30}},{"line":27,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":30}},{"line":33,"address":[],"length":0,"stats":{"Line":45}},{"line":34,"address":[],"length":0,"stats":{"Line":75}},{"line":35,"address":[],"length":0,"stats":{"Line":30}},{"line":39,"address":[],"length":0,"stats":{"Line":15}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":15}},{"line":57,"address":[],"length":0,"stats":{"Line":15}},{"line":61,"address":[],"length":0,"stats":{"Line":30}},{"line":63,"address":[],"length":0,"stats":{"Line":60}},{"line":64,"address":[],"length":0,"stats":{"Line":60}},{"line":67,"address":[],"length":0,"stats":{"Line":45}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":42}},{"line":76,"address":[],"length":0,"stats":{"Line":84}},{"line":77,"address":[],"length":0,"stats":{"Line":28}},{"line":81,"address":[],"length":0,"stats":{"Line":15}},{"line":85,"address":[],"length":0,"stats":{"Line":14}},{"line":90,"address":[],"length":0,"stats":{"Line":28}},{"line":92,"address":[],"length":0,"stats":{"Line":42}},{"line":95,"address":[],"length":0,"stats":{"Line":42}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":14}},{"line":107,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":6}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":24}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":3}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":15}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":134,"address":[],"length":0,"stats":{"Line":3}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":6}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":19}},{"line":159,"address":[],"length":0,"stats":{"Line":10}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":10}},{"line":172,"address":[],"length":0,"stats":{"Line":6}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":3}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":7}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":14}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":4}},{"line":199,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":3}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":205,"address":[],"length":0,"stats":{"Line":4}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":12}},{"line":227,"address":[],"length":0,"stats":{"Line":8}},{"line":229,"address":[],"length":0,"stats":{"Line":8}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":30}},{"line":233,"address":[],"length":0,"stats":{"Line":6}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":4}},{"line":237,"address":[],"length":0,"stats":{"Line":3}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":30}},{"line":240,"address":[],"length":0,"stats":{"Line":18}},{"line":241,"address":[],"length":0,"stats":{"Line":18}},{"line":245,"address":[],"length":0,"stats":{"Line":5}},{"line":248,"address":[],"length":0,"stats":{"Line":10}},{"line":249,"address":[],"length":0,"stats":{"Line":9}},{"line":250,"address":[],"length":0,"stats":{"Line":6}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[],"length":0,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}}],"covered":104,"coverable":228},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vars","datemath.rs"],"content":"//! Date math expression parser and evaluator.\n//!\n//! Supports expressions like:\n//! - `{{today}}`, `{{now}}`, `{{time}}`, `{{week}}`, `{{year}}`\n//! - `{{today + 1d}}`, `{{today - 1w}}`, `{{now + 2h}}`\n//! - `{{today | %Y-%m-%d}}` (with format specifier)\n//! - `{{today - monday}}`, `{{today + friday}}` (relative weekday)\n//! - `{{week}}` returns ISO week number (1-53), `{{week | %Y-W%V}}` for \"2025-W51\"\n\nuse chrono::{\n    Datelike, Duration, IsoWeek, Local, NaiveDate, NaiveDateTime, NaiveTime, Timelike,\n    Weekday,\n};\nuse regex::Regex;\nuse thiserror::Error;\n\n/// Error type for date math parsing and evaluation.\n#[derive(Debug, Error, PartialEq, Eq)]\npub enum DateMathError {\n    #[error(\"invalid date math expression: {0}\")]\n    InvalidExpression(String),\n\n    #[error(\"invalid duration unit: {0}\")]\n    InvalidUnit(String),\n\n    #[error(\"invalid number in expression: {0}\")]\n    InvalidNumber(String),\n\n    #[error(\"invalid weekday: {0}\")]\n    InvalidWeekday(String),\n}\n\n/// A parsed date/time base value.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum DateBase {\n    /// Current date (YYYY-MM-DD)\n    Today,\n    /// Current datetime (ISO 8601)\n    Now,\n    /// Current time (HH:MM)\n    Time,\n    /// Current date (alias for today)\n    Date,\n    /// Current ISO week number (1-53)\n    Week,\n    /// Current year (YYYY)\n    Year,\n    /// Literal date (e.g., 2025-01-15)\n    Literal(NaiveDate),\n    /// Monday of current week\n    WeekStart,\n    /// Sunday of current week\n    WeekEnd,\n    /// ISO week notation (e.g., 2025-W01) - resolves to Monday of that week\n    IsoWeek { year: i32, week: u32 },\n}\n\n/// A duration offset to apply.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum DateOffset {\n    /// No offset\n    None,\n    /// Duration: +/- N units (days, weeks, months, hours, minutes)\n    Duration { amount: i64, unit: DurationUnit },\n    /// Relative weekday: previous/next Monday, Tuesday, etc.\n    Weekday { weekday: Weekday, direction: Direction },\n}\n\n/// Units for duration offsets.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum DurationUnit {\n    Minutes,\n    Hours,\n    Days,\n    Weeks,\n    Months,\n    Years,\n}\n\n/// Direction for relative weekday.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Direction {\n    Previous, // - (go back to previous weekday)\n    Next,     // + (go forward to next weekday)\n}\n\n/// A fully parsed date math expression.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct DateExpr {\n    pub base: DateBase,\n    pub offset: DateOffset,\n    pub format: Option\u003cString\u003e,\n}\n\n/// Parse a date math expression.\n///\n/// Examples:\n/// - `today` -\u003e DateExpr { base: Today, offset: None, format: None }\n/// - `today + 1d` -\u003e DateExpr { base: Today, offset: Duration { amount: 1, unit: Days }, format: None }\n/// - `now | %H:%M` -\u003e DateExpr { base: Now, offset: None, format: Some(\"%H:%M\") }\n/// - `today - monday` -\u003e DateExpr { base: Today, offset: Weekday { weekday: Monday, direction: Previous }, format: None }\npub fn parse_date_expr(input: \u0026str) -\u003e Result\u003cDateExpr, DateMathError\u003e {\n    let input = input.trim();\n\n    // Split by format specifier first\n    let (expr_part, format) = if let Some(idx) = input.find('|') {\n        let (e, f) = input.split_at(idx);\n        (e.trim(), Some(f[1..].trim().to_string()))\n    } else {\n        (input, None)\n    };\n\n    // Parse base and offset\n    // The base can be a keyword (today, now, etc.) or an ISO date (2025-01-15)\n    // ISO dates contain hyphens, so we need a more flexible pattern\n    let re = Regex::new(r\"^([\\w-]+)\\s*([+-])?\\s*(\\w+)?$\").expect(\"valid regex\");\n\n    if let Some(caps) = re.captures(expr_part) {\n        let base_str = \u0026caps[1];\n        let base = parse_base(base_str)?;\n\n        let offset = if let (Some(op), Some(operand)) = (caps.get(2), caps.get(3)) {\n            let op_str = op.as_str();\n            let operand_str = operand.as_str();\n            parse_offset(op_str, operand_str)?\n        } else {\n            DateOffset::None\n        };\n\n        Ok(DateExpr { base, offset, format })\n    } else {\n        Err(DateMathError::InvalidExpression(input.to_string()))\n    }\n}\n\nfn parse_base(s: \u0026str) -\u003e Result\u003cDateBase, DateMathError\u003e {\n    match s.to_lowercase().as_str() {\n        \"today\" =\u003e Ok(DateBase::Today),\n        \"now\" =\u003e Ok(DateBase::Now),\n        \"time\" =\u003e Ok(DateBase::Time),\n        \"date\" =\u003e Ok(DateBase::Date),\n        \"week\" =\u003e Ok(DateBase::Week),\n        \"year\" =\u003e Ok(DateBase::Year),\n        \"week_start\" =\u003e Ok(DateBase::WeekStart),\n        \"week_end\" =\u003e Ok(DateBase::WeekEnd),\n        _ =\u003e {\n            // Try parsing as ISO week notation (YYYY-Www or YYYY-Ww)\n            if let Some(iso_week) = parse_iso_week_notation(s) {\n                return Ok(iso_week);\n            }\n            // Try parsing as ISO 8601 date literal (YYYY-MM-DD)\n            if let Ok(date) = NaiveDate::parse_from_str(s, \"%Y-%m-%d\") {\n                return Ok(DateBase::Literal(date));\n            }\n            Err(DateMathError::InvalidExpression(format!(\"unknown base: {s}\")))\n        }\n    }\n}\n\n/// Parse ISO week notation (e.g., 2025-W01, 2025-W1)\nfn parse_iso_week_notation(s: \u0026str) -\u003e Option\u003cDateBase\u003e {\n    let re = Regex::new(r\"^(\\d{4})-[Ww](\\d{1,2})$\").expect(\"valid regex\");\n    if let Some(caps) = re.captures(s) {\n        let year: i32 = caps[1].parse().ok()?;\n        let week: u32 = caps[2].parse().ok()?;\n        // Validate week number (1-53)\n        if (1..=53).contains(\u0026week) {\n            return Some(DateBase::IsoWeek { year, week });\n        }\n    }\n    None\n}\n\nfn parse_offset(op: \u0026str, operand: \u0026str) -\u003e Result\u003cDateOffset, DateMathError\u003e {\n    let direction = match op {\n        \"+\" =\u003e Direction::Next,\n        \"-\" =\u003e Direction::Previous,\n        _ =\u003e {\n            return Err(DateMathError::InvalidExpression(format!(\n                \"invalid operator: {op}\"\n            )));\n        }\n    };\n\n    // Try parsing as weekday first\n    if let Ok(weekday) = parse_weekday(operand) {\n        return Ok(DateOffset::Weekday { weekday, direction });\n    }\n\n    // Try parsing as duration (e.g., \"1d\", \"2w\", \"3M\")\n    let re = Regex::new(r\"^(\\d+)([dmMyhwY])$\").expect(\"valid regex\");\n    if let Some(caps) = re.captures(operand) {\n        let amount: i64 = caps[1]\n            .parse()\n            .map_err(|_| DateMathError::InvalidNumber(caps[1].to_string()))?;\n\n        let unit = match \u0026caps[2] {\n            \"m\" =\u003e DurationUnit::Minutes,\n            \"h\" =\u003e DurationUnit::Hours,\n            \"d\" =\u003e DurationUnit::Days,\n            \"w\" =\u003e DurationUnit::Weeks,\n            \"M\" =\u003e DurationUnit::Months,\n            \"y\" | \"Y\" =\u003e DurationUnit::Years,\n            u =\u003e return Err(DateMathError::InvalidUnit(u.to_string())),\n        };\n\n        let signed_amount = match direction {\n            Direction::Next =\u003e amount,\n            Direction::Previous =\u003e -amount,\n        };\n\n        return Ok(DateOffset::Duration { amount: signed_amount, unit });\n    }\n\n    Err(DateMathError::InvalidExpression(format!(\"invalid offset: {operand}\")))\n}\n\nfn parse_weekday(s: \u0026str) -\u003e Result\u003cWeekday, DateMathError\u003e {\n    match s.to_lowercase().as_str() {\n        \"monday\" | \"mon\" =\u003e Ok(Weekday::Mon),\n        \"tuesday\" | \"tue\" =\u003e Ok(Weekday::Tue),\n        \"wednesday\" | \"wed\" =\u003e Ok(Weekday::Wed),\n        \"thursday\" | \"thu\" =\u003e Ok(Weekday::Thu),\n        \"friday\" | \"fri\" =\u003e Ok(Weekday::Fri),\n        \"saturday\" | \"sat\" =\u003e Ok(Weekday::Sat),\n        \"sunday\" | \"sun\" =\u003e Ok(Weekday::Sun),\n        _ =\u003e Err(DateMathError::InvalidWeekday(s.to_string())),\n    }\n}\n\n/// Evaluate a date expression and return the formatted result.\npub fn evaluate_date_expr(expr: \u0026DateExpr) -\u003e String {\n    let now = Local::now();\n    let today = now.date_naive();\n    let current_time = now.time();\n\n    match expr.base {\n        DateBase::Today | DateBase::Date =\u003e {\n            let date = apply_date_offset(today, \u0026expr.offset);\n            format_date(date, expr.format.as_deref())\n        }\n        DateBase::Now =\u003e {\n            let datetime = apply_datetime_offset(now.naive_local(), \u0026expr.offset);\n            format_datetime(datetime, expr.format.as_deref())\n        }\n        DateBase::Time =\u003e {\n            let time = apply_time_offset(current_time, \u0026expr.offset);\n            format_time(time, expr.format.as_deref())\n        }\n        DateBase::Week =\u003e {\n            let date = apply_date_offset(today, \u0026expr.offset);\n            format_week(date.iso_week(), expr.format.as_deref())\n        }\n        DateBase::Year =\u003e {\n            let date = apply_date_offset(today, \u0026expr.offset);\n            format_year(date, expr.format.as_deref())\n        }\n        DateBase::Literal(base_date) =\u003e {\n            let date = apply_date_offset(base_date, \u0026expr.offset);\n            format_date(date, expr.format.as_deref())\n        }\n        DateBase::WeekStart =\u003e {\n            let monday = get_week_start(today);\n            let date = apply_date_offset(monday, \u0026expr.offset);\n            format_date(date, expr.format.as_deref())\n        }\n        DateBase::WeekEnd =\u003e {\n            let sunday = get_week_end(today);\n            let date = apply_date_offset(sunday, \u0026expr.offset);\n            format_date(date, expr.format.as_deref())\n        }\n        DateBase::IsoWeek { year, week } =\u003e {\n            // Get Monday of the specified ISO week\n            let monday =\n                NaiveDate::from_isoywd_opt(year, week, Weekday::Mon).unwrap_or(today);\n            let date = apply_date_offset(monday, \u0026expr.offset);\n            format_date(date, expr.format.as_deref())\n        }\n    }\n}\n\n/// Get the Monday of the week containing the given date.\nfn get_week_start(date: NaiveDate) -\u003e NaiveDate {\n    let days_from_monday = date.weekday().num_days_from_monday() as i64;\n    date - Duration::days(days_from_monday)\n}\n\n/// Get the Sunday of the week containing the given date.\nfn get_week_end(date: NaiveDate) -\u003e NaiveDate {\n    let days_to_sunday = 6 - date.weekday().num_days_from_monday() as i64;\n    date + Duration::days(days_to_sunday)\n}\n\nfn apply_date_offset(date: NaiveDate, offset: \u0026DateOffset) -\u003e NaiveDate {\n    match offset {\n        DateOffset::None =\u003e date,\n        DateOffset::Duration { amount, unit } =\u003e match unit {\n            DurationUnit::Days =\u003e date + Duration::days(*amount),\n            DurationUnit::Weeks =\u003e date + Duration::weeks(*amount),\n            DurationUnit::Months =\u003e add_months(date, *amount),\n            DurationUnit::Years =\u003e add_months(date, amount * 12),\n            DurationUnit::Hours | DurationUnit::Minutes =\u003e date, // hours/minutes don't affect date\n        },\n        DateOffset::Weekday { weekday, direction } =\u003e {\n            find_relative_weekday(date, *weekday, *direction)\n        }\n    }\n}\n\nfn apply_datetime_offset(dt: NaiveDateTime, offset: \u0026DateOffset) -\u003e NaiveDateTime {\n    match offset {\n        DateOffset::None =\u003e dt,\n        DateOffset::Duration { amount, unit } =\u003e match unit {\n            DurationUnit::Minutes =\u003e dt + Duration::minutes(*amount),\n            DurationUnit::Hours =\u003e dt + Duration::hours(*amount),\n            DurationUnit::Days =\u003e dt + Duration::days(*amount),\n            DurationUnit::Weeks =\u003e dt + Duration::weeks(*amount),\n            DurationUnit::Months =\u003e {\n                let new_date = add_months(dt.date(), *amount);\n                NaiveDateTime::new(new_date, dt.time())\n            }\n            DurationUnit::Years =\u003e {\n                let new_date = add_months(dt.date(), amount * 12);\n                NaiveDateTime::new(new_date, dt.time())\n            }\n        },\n        DateOffset::Weekday { weekday, direction } =\u003e {\n            let new_date = find_relative_weekday(dt.date(), *weekday, *direction);\n            NaiveDateTime::new(new_date, dt.time())\n        }\n    }\n}\n\nfn apply_time_offset(time: NaiveTime, offset: \u0026DateOffset) -\u003e NaiveTime {\n    match offset {\n        DateOffset::None =\u003e time,\n        DateOffset::Duration { amount, unit } =\u003e match unit {\n            DurationUnit::Minutes =\u003e {\n                let secs = time.num_seconds_from_midnight() as i64 + amount * 60;\n                let normalized = secs.rem_euclid(86400) as u32;\n                NaiveTime::from_num_seconds_from_midnight_opt(normalized, 0)\n                    .unwrap_or(time)\n            }\n            DurationUnit::Hours =\u003e {\n                let secs = time.num_seconds_from_midnight() as i64 + amount * 3600;\n                let normalized = secs.rem_euclid(86400) as u32;\n                NaiveTime::from_num_seconds_from_midnight_opt(normalized, 0)\n                    .unwrap_or(time)\n            }\n            _ =\u003e time, // days/weeks/months don't affect time\n        },\n        DateOffset::Weekday { .. } =\u003e time, // weekdays don't affect time\n    }\n}\n\nfn add_months(date: NaiveDate, months: i64) -\u003e NaiveDate {\n    let year = date.year() as i64;\n    let month = date.month() as i64;\n    let day = date.day();\n\n    let total_months = year * 12 + month - 1 + months;\n    let new_year = (total_months / 12) as i32;\n    let new_month = (total_months % 12 + 1) as u32;\n\n    // Handle day overflow (e.g., Jan 31 + 1 month = Feb 28/29)\n    let max_day = days_in_month(new_year, new_month);\n    let new_day = day.min(max_day);\n\n    NaiveDate::from_ymd_opt(new_year, new_month, new_day).unwrap_or(date)\n}\n\nfn days_in_month(year: i32, month: u32) -\u003e u32 {\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 =\u003e 31,\n        4 | 6 | 9 | 11 =\u003e 30,\n        2 =\u003e {\n            if year % 4 == 0 \u0026\u0026 (year % 100 != 0 || year % 400 == 0) {\n                29\n            } else {\n                28\n            }\n        }\n        _ =\u003e 30,\n    }\n}\n\nfn find_relative_weekday(\n    date: NaiveDate,\n    target: Weekday,\n    direction: Direction,\n) -\u003e NaiveDate {\n    let current = date.weekday();\n\n    match direction {\n        Direction::Previous =\u003e {\n            // Find the previous occurrence (or today if it's the target)\n            let days_diff = (current.num_days_from_monday() as i64\n                - target.num_days_from_monday() as i64\n                + 7)\n                % 7;\n            let days_back = if days_diff == 0 { 7 } else { days_diff };\n            date - Duration::days(days_back)\n        }\n        Direction::Next =\u003e {\n            // Find the next occurrence (or today if it's the target)\n            let days_diff = (target.num_days_from_monday() as i64\n                - current.num_days_from_monday() as i64\n                + 7)\n                % 7;\n            let days_forward = if days_diff == 0 { 7 } else { days_diff };\n            date + Duration::days(days_forward)\n        }\n    }\n}\n\nfn format_date(date: NaiveDate, format: Option\u003c\u0026str\u003e) -\u003e String {\n    let fmt = format.unwrap_or(\"%Y-%m-%d\");\n    date.format(fmt).to_string()\n}\n\nfn format_datetime(dt: NaiveDateTime, format: Option\u003c\u0026str\u003e) -\u003e String {\n    let fmt = format.unwrap_or(\"%Y-%m-%dT%H:%M:%S\");\n    dt.format(fmt).to_string()\n}\n\nfn format_time(time: NaiveTime, format: Option\u003c\u0026str\u003e) -\u003e String {\n    let fmt = format.unwrap_or(\"%H:%M\");\n    time.format(fmt).to_string()\n}\n\nfn format_week(week: IsoWeek, format: Option\u003c\u0026str\u003e) -\u003e String {\n    match format {\n        // If a format is provided, apply it to a date in that week\n        // This allows formats like \"%Y-W%V\" to produce \"2025-W51\"\n        Some(fmt) =\u003e {\n            // Get a date in this week (Monday)\n            let date = NaiveDate::from_isoywd_opt(week.year(), week.week(), Weekday::Mon)\n                .unwrap_or_else(|| Local::now().date_naive());\n            date.format(fmt).to_string()\n        }\n        // Default: just the week number\n        None =\u003e week.week().to_string(),\n    }\n}\n\nfn format_year(date: NaiveDate, format: Option\u003c\u0026str\u003e) -\u003e String {\n    let fmt = format.unwrap_or(\"%Y\");\n    date.format(fmt).to_string()\n}\n\n/// Check if a string looks like an ISO 8601 date (YYYY-MM-DD).\nfn looks_like_iso_date(s: \u0026str) -\u003e bool {\n    // Quick check: must be at least 10 chars and match pattern\n    if s.len() \u003c 10 {\n        return false;\n    }\n    let bytes = s.as_bytes();\n    // Check pattern: DDDD-DD-DD where D is digit\n    bytes[0].is_ascii_digit()\n        \u0026\u0026 bytes[1].is_ascii_digit()\n        \u0026\u0026 bytes[2].is_ascii_digit()\n        \u0026\u0026 bytes[3].is_ascii_digit()\n        \u0026\u0026 bytes[4] == b'-'\n        \u0026\u0026 bytes[5].is_ascii_digit()\n        \u0026\u0026 bytes[6].is_ascii_digit()\n        \u0026\u0026 bytes[7] == b'-'\n        \u0026\u0026 bytes[8].is_ascii_digit()\n        \u0026\u0026 bytes[9].is_ascii_digit()\n}\n\n/// Check if a string looks like an ISO week notation (YYYY-Www or YYYY-Ww).\nfn looks_like_iso_week(s: \u0026str) -\u003e bool {\n    // Pattern: YYYY-Wxx or YYYY-Wx (7-8 chars minimum)\n    if s.len() \u003c 7 {\n        return false;\n    }\n    let bytes = s.as_bytes();\n    // Check: 4 digits, hyphen, W/w, 1-2 digits\n    bytes[0].is_ascii_digit()\n        \u0026\u0026 bytes[1].is_ascii_digit()\n        \u0026\u0026 bytes[2].is_ascii_digit()\n        \u0026\u0026 bytes[3].is_ascii_digit()\n        \u0026\u0026 bytes[4] == b'-'\n        \u0026\u0026 (bytes[5] == b'W' || bytes[5] == b'w')\n        \u0026\u0026 bytes[6].is_ascii_digit()\n        \u0026\u0026 (s.len() == 7 || (s.len() \u003e= 8 \u0026\u0026 bytes[7].is_ascii_digit()))\n}\n\n/// Check if a string looks like a date math expression.\n///\n/// Returns true for strings like \"today\", \"now + 1d\", \"time - 2h\", \"week\", \"year\",\n/// \"week_start\", \"week_end\", ISO date literals like \"2025-01-15\",\n/// or ISO week notation like \"2025-W01\".\npub fn is_date_expr(s: \u0026str) -\u003e bool {\n    let s = s.trim();\n    let lower = s.to_lowercase();\n\n    // Check for keyword-based expressions\n    // Note: \"week\" matches week, week_start, week_end\n    if lower.starts_with(\"today\")\n        || lower.starts_with(\"now\")\n        || lower.starts_with(\"time\")\n        || lower.starts_with(\"date\")\n        || lower.starts_with(\"week\")\n        || lower.starts_with(\"year\")\n    {\n        return true;\n    }\n\n    // Extract the base part (before any + or - operator with space, or format specifier)\n    let base_part = if let Some(idx) = s.find(['+', '|']) {\n        s[..idx].trim()\n    } else if let Some(idx) = s.rfind(\" -\") {\n        // Use rfind for \" -\" to avoid matching the hyphens in the date/week\n        s[..idx].trim()\n    } else {\n        s\n    };\n\n    // Check for ISO date literal or ISO week notation\n    looks_like_iso_date(base_part) || looks_like_iso_week(base_part)\n}\n\n/// Evaluate a date expression string if it is one, otherwise return None.\npub fn try_evaluate_date_expr(s: \u0026str) -\u003e Option\u003cString\u003e {\n    if is_date_expr(s) {\n        parse_date_expr(s).ok().map(|e| evaluate_date_expr(\u0026e))\n    } else {\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_simple_today() {\n        let expr = parse_date_expr(\"today\").unwrap();\n        assert_eq!(expr.base, DateBase::Today);\n        assert_eq!(expr.offset, DateOffset::None);\n        assert!(expr.format.is_none());\n    }\n\n    #[test]\n    fn test_parse_today_plus_days() {\n        let expr = parse_date_expr(\"today + 1d\").unwrap();\n        assert_eq!(expr.base, DateBase::Today);\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 1, unit: DurationUnit::Days }\n        );\n    }\n\n    #[test]\n    fn test_parse_today_minus_weeks() {\n        let expr = parse_date_expr(\"today - 2w\").unwrap();\n        assert_eq!(expr.base, DateBase::Today);\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: -2, unit: DurationUnit::Weeks }\n        );\n    }\n\n    #[test]\n    fn test_parse_now_with_format() {\n        let expr = parse_date_expr(\"now | %H:%M\").unwrap();\n        assert_eq!(expr.base, DateBase::Now);\n        assert_eq!(expr.format, Some(\"%H:%M\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_weekday_previous() {\n        let expr = parse_date_expr(\"today - monday\").unwrap();\n        assert_eq!(expr.base, DateBase::Today);\n        assert_eq!(\n            expr.offset,\n            DateOffset::Weekday { weekday: Weekday::Mon, direction: Direction::Previous }\n        );\n    }\n\n    #[test]\n    fn test_parse_weekday_next() {\n        let expr = parse_date_expr(\"today + friday\").unwrap();\n        assert_eq!(expr.base, DateBase::Today);\n        assert_eq!(\n            expr.offset,\n            DateOffset::Weekday { weekday: Weekday::Fri, direction: Direction::Next }\n        );\n    }\n\n    #[test]\n    fn test_parse_months() {\n        let expr = parse_date_expr(\"today + 3M\").unwrap();\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 3, unit: DurationUnit::Months }\n        );\n    }\n\n    #[test]\n    fn test_parse_hours() {\n        let expr = parse_date_expr(\"now + 2h\").unwrap();\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 2, unit: DurationUnit::Hours }\n        );\n    }\n\n    #[test]\n    fn test_evaluate_today() {\n        let expr =\n            DateExpr { base: DateBase::Today, offset: DateOffset::None, format: None };\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be in YYYY-MM-DD format\n        assert!(result.len() == 10);\n        assert!(result.chars().nth(4) == Some('-'));\n    }\n\n    #[test]\n    fn test_evaluate_today_plus_one_day() {\n        let expr = parse_date_expr(\"today + 1d\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n\n        let today = Local::now().date_naive();\n        let tomorrow = today + Duration::days(1);\n        assert_eq!(result, tomorrow.format(\"%Y-%m-%d\").to_string());\n    }\n\n    #[test]\n    fn test_evaluate_with_format() {\n        let expr = parse_date_expr(\"today | %A\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be a day name like \"Monday\", \"Tuesday\", etc.\n        let valid_days = [\n            \"Monday\",\n            \"Tuesday\",\n            \"Wednesday\",\n            \"Thursday\",\n            \"Friday\",\n            \"Saturday\",\n            \"Sunday\",\n        ];\n        assert!(valid_days.contains(\u0026result.as_str()));\n    }\n\n    #[test]\n    fn test_add_months_overflow() {\n        // Jan 31 + 1 month should be Feb 28 (non-leap year)\n        let date = NaiveDate::from_ymd_opt(2023, 1, 31).unwrap();\n        let result = add_months(date, 1);\n        assert_eq!(result, NaiveDate::from_ymd_opt(2023, 2, 28).unwrap());\n    }\n\n    #[test]\n    fn test_add_months_leap_year() {\n        // Jan 31 + 1 month in leap year should be Feb 29\n        let date = NaiveDate::from_ymd_opt(2024, 1, 31).unwrap();\n        let result = add_months(date, 1);\n        assert_eq!(result, NaiveDate::from_ymd_opt(2024, 2, 29).unwrap());\n    }\n\n    #[test]\n    fn test_is_date_expr() {\n        assert!(is_date_expr(\"today\"));\n        assert!(is_date_expr(\"TODAY\"));\n        assert!(is_date_expr(\"today + 1d\"));\n        assert!(is_date_expr(\"now\"));\n        assert!(is_date_expr(\"time - 2h\"));\n        assert!(!is_date_expr(\"some_var\"));\n        assert!(!is_date_expr(\"{{today}}\"));\n    }\n\n    #[test]\n    fn test_try_evaluate() {\n        assert!(try_evaluate_date_expr(\"today\").is_some());\n        assert!(try_evaluate_date_expr(\"not_a_date\").is_none());\n    }\n\n    #[test]\n    fn test_parse_week() {\n        let expr = parse_date_expr(\"week\").unwrap();\n        assert_eq!(expr.base, DateBase::Week);\n        assert_eq!(expr.offset, DateOffset::None);\n    }\n\n    #[test]\n    fn test_evaluate_week() {\n        let expr = parse_date_expr(\"week\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be a number between 1 and 53\n        let week_num: u32 = result.parse().unwrap();\n        assert!((1..=53).contains(\u0026week_num));\n    }\n\n    #[test]\n    fn test_evaluate_week_with_format() {\n        let expr = parse_date_expr(\"week | %Y-W%V\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be like \"2025-W51\"\n        assert!(result.contains(\"-W\"));\n        assert!(result.len() \u003e= 8); // \"YYYY-WNN\"\n    }\n\n    #[test]\n    fn test_week_with_offset() {\n        let expr = parse_date_expr(\"week + 1w\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be a valid week number\n        let week_num: u32 = result.parse().unwrap();\n        assert!((1..=53).contains(\u0026week_num));\n    }\n\n    #[test]\n    fn test_parse_year() {\n        let expr = parse_date_expr(\"year\").unwrap();\n        assert_eq!(expr.base, DateBase::Year);\n    }\n\n    #[test]\n    fn test_evaluate_year() {\n        let expr = parse_date_expr(\"year\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be a 4-digit year\n        assert_eq!(result.len(), 4);\n        let year: i32 = result.parse().unwrap();\n        assert!((2020..=2100).contains(\u0026year));\n    }\n\n    #[test]\n    fn test_is_date_expr_week_year() {\n        assert!(is_date_expr(\"week\"));\n        assert!(is_date_expr(\"WEEK\"));\n        assert!(is_date_expr(\"week + 1w\"));\n        assert!(is_date_expr(\"year\"));\n        assert!(is_date_expr(\"year - 1y\"));\n    }\n\n    // Tests for ISO date literals\n\n    #[test]\n    fn test_parse_iso_date_literal() {\n        let expr = parse_date_expr(\"2025-01-15\").unwrap();\n        assert_eq!(\n            expr.base,\n            DateBase::Literal(NaiveDate::from_ymd_opt(2025, 1, 15).unwrap())\n        );\n        assert_eq!(expr.offset, DateOffset::None);\n        assert!(expr.format.is_none());\n    }\n\n    #[test]\n    fn test_parse_iso_date_with_offset() {\n        let expr = parse_date_expr(\"2025-01-15 + 7d\").unwrap();\n        assert_eq!(\n            expr.base,\n            DateBase::Literal(NaiveDate::from_ymd_opt(2025, 1, 15).unwrap())\n        );\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 7, unit: DurationUnit::Days }\n        );\n    }\n\n    #[test]\n    fn test_parse_iso_date_minus_offset() {\n        let expr = parse_date_expr(\"2025-01-15 - 3d\").unwrap();\n        assert_eq!(\n            expr.base,\n            DateBase::Literal(NaiveDate::from_ymd_opt(2025, 1, 15).unwrap())\n        );\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: -3, unit: DurationUnit::Days }\n        );\n    }\n\n    #[test]\n    fn test_parse_iso_date_with_weekday() {\n        let expr = parse_date_expr(\"2025-01-15 - monday\").unwrap();\n        assert_eq!(\n            expr.base,\n            DateBase::Literal(NaiveDate::from_ymd_opt(2025, 1, 15).unwrap())\n        );\n        assert_eq!(\n            expr.offset,\n            DateOffset::Weekday { weekday: Weekday::Mon, direction: Direction::Previous }\n        );\n    }\n\n    #[test]\n    fn test_parse_iso_date_with_format() {\n        let expr = parse_date_expr(\"2025-01-15 | %A\").unwrap();\n        assert_eq!(\n            expr.base,\n            DateBase::Literal(NaiveDate::from_ymd_opt(2025, 1, 15).unwrap())\n        );\n        assert_eq!(expr.format, Some(\"%A\".to_string()));\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_literal() {\n        let expr = parse_date_expr(\"2025-01-15\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-15\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_plus_days() {\n        let expr = parse_date_expr(\"2025-01-15 + 7d\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-22\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_minus_days() {\n        let expr = parse_date_expr(\"2025-01-15 - 5d\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-10\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_plus_weeks() {\n        let expr = parse_date_expr(\"2025-01-15 + 2w\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-29\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_plus_months() {\n        let expr = parse_date_expr(\"2025-01-15 + 1M\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-02-15\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_with_format() {\n        let expr = parse_date_expr(\"2025-01-15 | %A\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"Wednesday\"); // 2025-01-15 is a Wednesday\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_weekday_offset() {\n        // 2025-01-15 is Wednesday, previous Monday is 2025-01-13\n        let expr = parse_date_expr(\"2025-01-15 - monday\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-13\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_next_weekday() {\n        // 2025-01-15 is Wednesday, next Friday is 2025-01-17\n        let expr = parse_date_expr(\"2025-01-15 + friday\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-17\");\n    }\n\n    #[test]\n    fn test_is_date_expr_iso_literal() {\n        assert!(is_date_expr(\"2025-01-15\"));\n        assert!(is_date_expr(\"2025-01-15 + 7d\"));\n        assert!(is_date_expr(\"2025-01-15 - 3d\"));\n        assert!(is_date_expr(\"2025-01-15 | %A\"));\n        assert!(is_date_expr(\"1999-12-31\"));\n        assert!(!is_date_expr(\"2025-1-15\")); // Invalid format (single digit month)\n        assert!(!is_date_expr(\"25-01-15\")); // Invalid format (2-digit year)\n    }\n\n    #[test]\n    fn test_try_evaluate_iso_date() {\n        assert_eq!(try_evaluate_date_expr(\"2025-01-15\"), Some(\"2025-01-15\".to_string()));\n        assert_eq!(\n            try_evaluate_date_expr(\"2025-01-15 + 1d\"),\n            Some(\"2025-01-16\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_invalid_iso_date() {\n        // Invalid date should fail parsing\n        assert!(parse_date_expr(\"2025-13-45\").is_err());\n        assert!(parse_date_expr(\"not-a-date\").is_err());\n    }\n\n    // Tests for week_start and week_end\n\n    #[test]\n    fn test_parse_week_start() {\n        let expr = parse_date_expr(\"week_start\").unwrap();\n        assert_eq!(expr.base, DateBase::WeekStart);\n        assert_eq!(expr.offset, DateOffset::None);\n    }\n\n    #[test]\n    fn test_parse_week_end() {\n        let expr = parse_date_expr(\"week_end\").unwrap();\n        assert_eq!(expr.base, DateBase::WeekEnd);\n        assert_eq!(expr.offset, DateOffset::None);\n    }\n\n    #[test]\n    fn test_parse_week_start_with_offset() {\n        let expr = parse_date_expr(\"week_start + 1w\").unwrap();\n        assert_eq!(expr.base, DateBase::WeekStart);\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 1, unit: DurationUnit::Weeks }\n        );\n    }\n\n    #[test]\n    fn test_evaluate_week_start() {\n        // Test that week_start returns a Monday\n        let expr = parse_date_expr(\"week_start\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        let date = NaiveDate::parse_from_str(\u0026result, \"%Y-%m-%d\").unwrap();\n        assert_eq!(date.weekday(), Weekday::Mon);\n    }\n\n    #[test]\n    fn test_evaluate_week_end() {\n        // Test that week_end returns a Sunday\n        let expr = parse_date_expr(\"week_end\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        let date = NaiveDate::parse_from_str(\u0026result, \"%Y-%m-%d\").unwrap();\n        assert_eq!(date.weekday(), Weekday::Sun);\n    }\n\n    #[test]\n    fn test_week_start_and_end_same_week() {\n        // week_start and week_end should be 6 days apart\n        let start_expr = parse_date_expr(\"week_start\").unwrap();\n        let end_expr = parse_date_expr(\"week_end\").unwrap();\n        let start =\n            NaiveDate::parse_from_str(\u0026evaluate_date_expr(\u0026start_expr), \"%Y-%m-%d\")\n                .unwrap();\n        let end = NaiveDate::parse_from_str(\u0026evaluate_date_expr(\u0026end_expr), \"%Y-%m-%d\")\n            .unwrap();\n        assert_eq!((end - start).num_days(), 6);\n    }\n\n    #[test]\n    fn test_week_start_next_week() {\n        // week_start + 1w should be 7 days after week_start\n        let this_week = parse_date_expr(\"week_start\").unwrap();\n        let next_week = parse_date_expr(\"week_start + 1w\").unwrap();\n        let this_monday =\n            NaiveDate::parse_from_str(\u0026evaluate_date_expr(\u0026this_week), \"%Y-%m-%d\")\n                .unwrap();\n        let next_monday =\n            NaiveDate::parse_from_str(\u0026evaluate_date_expr(\u0026next_week), \"%Y-%m-%d\")\n                .unwrap();\n        assert_eq!((next_monday - this_monday).num_days(), 7);\n    }\n\n    // Tests for ISO week notation\n\n    #[test]\n    fn test_parse_iso_week_notation() {\n        let expr = parse_date_expr(\"2025-W01\").unwrap();\n        assert_eq!(expr.base, DateBase::IsoWeek { year: 2025, week: 1 });\n        assert_eq!(expr.offset, DateOffset::None);\n    }\n\n    #[test]\n    fn test_parse_iso_week_notation_lowercase() {\n        let expr = parse_date_expr(\"2025-w15\").unwrap();\n        assert_eq!(expr.base, DateBase::IsoWeek { year: 2025, week: 15 });\n    }\n\n    #[test]\n    fn test_parse_iso_week_with_offset() {\n        let expr = parse_date_expr(\"2025-W01 + 6d\").unwrap();\n        assert_eq!(expr.base, DateBase::IsoWeek { year: 2025, week: 1 });\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 6, unit: DurationUnit::Days }\n        );\n    }\n\n    #[test]\n    fn test_evaluate_iso_week_monday() {\n        // 2025-W01 should resolve to Monday of that week\n        let expr = parse_date_expr(\"2025-W01\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        let date = NaiveDate::parse_from_str(\u0026result, \"%Y-%m-%d\").unwrap();\n        assert_eq!(date.weekday(), Weekday::Mon);\n        // Week 1 of 2025 starts on 2024-12-30 (ISO week definition)\n        assert_eq!(result, \"2024-12-30\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_week_sunday() {\n        // 2025-W01 + 6d should give Sunday of that week\n        let expr = parse_date_expr(\"2025-W01 + 6d\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        let date = NaiveDate::parse_from_str(\u0026result, \"%Y-%m-%d\").unwrap();\n        assert_eq!(date.weekday(), Weekday::Sun);\n        assert_eq!(result, \"2025-01-05\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_week_specific() {\n        // 2025-W03 should start on 2025-01-13 (Monday)\n        let expr = parse_date_expr(\"2025-W03\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-13\");\n    }\n\n    #[test]\n    fn test_iso_week_all_days() {\n        // Test generating all days of a week\n        let monday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03\").unwrap());\n        let tuesday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 1d\").unwrap());\n        let wednesday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 2d\").unwrap());\n        let thursday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 3d\").unwrap());\n        let friday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 4d\").unwrap());\n        let saturday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 5d\").unwrap());\n        let sunday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 6d\").unwrap());\n\n        assert_eq!(monday, \"2025-01-13\");\n        assert_eq!(tuesday, \"2025-01-14\");\n        assert_eq!(wednesday, \"2025-01-15\");\n        assert_eq!(thursday, \"2025-01-16\");\n        assert_eq!(friday, \"2025-01-17\");\n        assert_eq!(saturday, \"2025-01-18\");\n        assert_eq!(sunday, \"2025-01-19\");\n    }\n\n    #[test]\n    fn test_iso_week_with_format() {\n        let expr = parse_date_expr(\"2025-W03 | %A\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"Monday\");\n    }\n\n    #[test]\n    fn test_is_date_expr_week_start_end() {\n        assert!(is_date_expr(\"week_start\"));\n        assert!(is_date_expr(\"week_end\"));\n        assert!(is_date_expr(\"week_start + 1w\"));\n        assert!(is_date_expr(\"week_end - 1d\"));\n    }\n\n    #[test]\n    fn test_is_date_expr_iso_week() {\n        assert!(is_date_expr(\"2025-W01\"));\n        assert!(is_date_expr(\"2025-w15\"));\n        assert!(is_date_expr(\"2025-W01 + 6d\"));\n        assert!(is_date_expr(\"2025-W52 | %A\"));\n        assert!(!is_date_expr(\"2025-W\")); // incomplete\n        assert!(!is_date_expr(\"W01\")); // missing year\n    }\n\n    #[test]\n    fn test_try_evaluate_iso_week() {\n        assert_eq!(try_evaluate_date_expr(\"2025-W03\"), Some(\"2025-01-13\".to_string()));\n        assert_eq!(\n            try_evaluate_date_expr(\"2025-W03 + 6d\"),\n            Some(\"2025-01-19\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_invalid_iso_week() {\n        // Week 0 is invalid\n        assert!(parse_date_expr(\"2025-W00\").is_err());\n        // Week 54+ is invalid\n        assert!(parse_date_expr(\"2025-W54\").is_err());\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":132}},{"line":103,"address":[],"length":0,"stats":{"Line":396}},{"line":106,"address":[],"length":0,"stats":{"Line":406}},{"line":107,"address":[],"length":0,"stats":{"Line":40}},{"line":108,"address":[],"length":0,"stats":{"Line":30}},{"line":110,"address":[],"length":0,"stats":{"Line":122}},{"line":116,"address":[],"length":0,"stats":{"Line":660}},{"line":118,"address":[],"length":0,"stats":{"Line":396}},{"line":119,"address":[],"length":0,"stats":{"Line":264}},{"line":120,"address":[],"length":0,"stats":{"Line":396}},{"line":122,"address":[],"length":0,"stats":{"Line":707}},{"line":123,"address":[],"length":0,"stats":{"Line":108}},{"line":124,"address":[],"length":0,"stats":{"Line":108}},{"line":125,"address":[],"length":0,"stats":{"Line":108}},{"line":127,"address":[],"length":0,"stats":{"Line":91}},{"line":130,"address":[],"length":0,"stats":{"Line":254}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":132}},{"line":137,"address":[],"length":0,"stats":{"Line":132}},{"line":138,"address":[],"length":0,"stats":{"Line":177}},{"line":139,"address":[],"length":0,"stats":{"Line":113}},{"line":140,"address":[],"length":0,"stats":{"Line":61}},{"line":141,"address":[],"length":0,"stats":{"Line":69}},{"line":142,"address":[],"length":0,"stats":{"Line":58}},{"line":143,"address":[],"length":0,"stats":{"Line":51}},{"line":144,"address":[],"length":0,"stats":{"Line":51}},{"line":145,"address":[],"length":0,"stats":{"Line":42}},{"line":148,"address":[],"length":0,"stats":{"Line":52}},{"line":149,"address":[],"length":0,"stats":{"Line":16}},{"line":152,"address":[],"length":0,"stats":{"Line":55}},{"line":153,"address":[],"length":0,"stats":{"Line":15}},{"line":155,"address":[],"length":0,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":36}},{"line":162,"address":[],"length":0,"stats":{"Line":180}},{"line":163,"address":[],"length":0,"stats":{"Line":90}},{"line":164,"address":[],"length":0,"stats":{"Line":90}},{"line":165,"address":[],"length":0,"stats":{"Line":90}},{"line":167,"address":[],"length":0,"stats":{"Line":54}},{"line":168,"address":[],"length":0,"stats":{"Line":16}},{"line":171,"address":[],"length":0,"stats":{"Line":20}},{"line":174,"address":[],"length":0,"stats":{"Line":36}},{"line":175,"address":[],"length":0,"stats":{"Line":72}},{"line":176,"address":[],"length":0,"stats":{"Line":64}},{"line":177,"address":[],"length":0,"stats":{"Line":16}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":43}},{"line":187,"address":[],"length":0,"stats":{"Line":7}},{"line":191,"address":[],"length":0,"stats":{"Line":145}},{"line":192,"address":[],"length":0,"stats":{"Line":87}},{"line":193,"address":[],"length":0,"stats":{"Line":87}},{"line":195,"address":[],"length":0,"stats":{"Line":29}},{"line":197,"address":[],"length":0,"stats":{"Line":58}},{"line":198,"address":[],"length":0,"stats":{"Line":29}},{"line":199,"address":[],"length":0,"stats":{"Line":30}},{"line":200,"address":[],"length":0,"stats":{"Line":48}},{"line":201,"address":[],"length":0,"stats":{"Line":14}},{"line":202,"address":[],"length":0,"stats":{"Line":4}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":58}},{"line":208,"address":[],"length":0,"stats":{"Line":25}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":29}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":36}},{"line":219,"address":[],"length":0,"stats":{"Line":36}},{"line":220,"address":[],"length":0,"stats":{"Line":72}},{"line":221,"address":[],"length":0,"stats":{"Line":64}},{"line":222,"address":[],"length":0,"stats":{"Line":64}},{"line":223,"address":[],"length":0,"stats":{"Line":64}},{"line":224,"address":[],"length":0,"stats":{"Line":64}},{"line":225,"address":[],"length":0,"stats":{"Line":58}},{"line":226,"address":[],"length":0,"stats":{"Line":58}},{"line":227,"address":[],"length":0,"stats":{"Line":29}},{"line":232,"address":[],"length":0,"stats":{"Line":107}},{"line":233,"address":[],"length":0,"stats":{"Line":214}},{"line":234,"address":[],"length":0,"stats":{"Line":321}},{"line":235,"address":[],"length":0,"stats":{"Line":321}},{"line":237,"address":[],"length":0,"stats":{"Line":107}},{"line":239,"address":[],"length":0,"stats":{"Line":192}},{"line":240,"address":[],"length":0,"stats":{"Line":192}},{"line":243,"address":[],"length":0,"stats":{"Line":120}},{"line":244,"address":[],"length":0,"stats":{"Line":96}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":16}},{"line":252,"address":[],"length":0,"stats":{"Line":20}},{"line":255,"address":[],"length":0,"stats":{"Line":8}},{"line":256,"address":[],"length":0,"stats":{"Line":8}},{"line":258,"address":[],"length":0,"stats":{"Line":10}},{"line":259,"address":[],"length":0,"stats":{"Line":40}},{"line":260,"address":[],"length":0,"stats":{"Line":40}},{"line":263,"address":[],"length":0,"stats":{"Line":12}},{"line":264,"address":[],"length":0,"stats":{"Line":16}},{"line":265,"address":[],"length":0,"stats":{"Line":16}},{"line":268,"address":[],"length":0,"stats":{"Line":6}},{"line":269,"address":[],"length":0,"stats":{"Line":8}},{"line":270,"address":[],"length":0,"stats":{"Line":8}},{"line":272,"address":[],"length":0,"stats":{"Line":26}},{"line":274,"address":[],"length":0,"stats":{"Line":13}},{"line":275,"address":[],"length":0,"stats":{"Line":78}},{"line":276,"address":[],"length":0,"stats":{"Line":52}},{"line":277,"address":[],"length":0,"stats":{"Line":52}},{"line":283,"address":[],"length":0,"stats":{"Line":4}},{"line":284,"address":[],"length":0,"stats":{"Line":8}},{"line":285,"address":[],"length":0,"stats":{"Line":8}},{"line":289,"address":[],"length":0,"stats":{"Line":2}},{"line":290,"address":[],"length":0,"stats":{"Line":4}},{"line":291,"address":[],"length":0,"stats":{"Line":4}},{"line":294,"address":[],"length":0,"stats":{"Line":83}},{"line":295,"address":[],"length":0,"stats":{"Line":83}},{"line":296,"address":[],"length":0,"stats":{"Line":58}},{"line":297,"address":[],"length":0,"stats":{"Line":63}},{"line":298,"address":[],"length":0,"stats":{"Line":32}},{"line":299,"address":[],"length":0,"stats":{"Line":8}},{"line":300,"address":[],"length":0,"stats":{"Line":3}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":8}},{"line":305,"address":[],"length":0,"stats":{"Line":16}},{"line":310,"address":[],"length":0,"stats":{"Line":24}},{"line":311,"address":[],"length":0,"stats":{"Line":24}},{"line":312,"address":[],"length":0,"stats":{"Line":24}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":3}},{"line":357,"address":[],"length":0,"stats":{"Line":6}},{"line":358,"address":[],"length":0,"stats":{"Line":6}},{"line":359,"address":[],"length":0,"stats":{"Line":9}},{"line":361,"address":[],"length":0,"stats":{"Line":6}},{"line":362,"address":[],"length":0,"stats":{"Line":6}},{"line":363,"address":[],"length":0,"stats":{"Line":6}},{"line":366,"address":[],"length":0,"stats":{"Line":12}},{"line":367,"address":[],"length":0,"stats":{"Line":12}},{"line":369,"address":[],"length":0,"stats":{"Line":18}},{"line":372,"address":[],"length":0,"stats":{"Line":3}},{"line":373,"address":[],"length":0,"stats":{"Line":3}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":4}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":380,"address":[],"length":0,"stats":{"Line":2}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":4}},{"line":392,"address":[],"length":0,"stats":{"Line":12}},{"line":394,"address":[],"length":0,"stats":{"Line":4}},{"line":397,"address":[],"length":0,"stats":{"Line":6}},{"line":398,"address":[],"length":0,"stats":{"Line":2}},{"line":399,"address":[],"length":0,"stats":{"Line":2}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":401,"address":[],"length":0,"stats":{"Line":6}},{"line":402,"address":[],"length":0,"stats":{"Line":4}},{"line":406,"address":[],"length":0,"stats":{"Line":6}},{"line":407,"address":[],"length":0,"stats":{"Line":2}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":409,"address":[],"length":0,"stats":{"Line":2}},{"line":410,"address":[],"length":0,"stats":{"Line":6}},{"line":411,"address":[],"length":0,"stats":{"Line":4}},{"line":416,"address":[],"length":0,"stats":{"Line":77}},{"line":417,"address":[],"length":0,"stats":{"Line":308}},{"line":418,"address":[],"length":0,"stats":{"Line":231}},{"line":421,"address":[],"length":0,"stats":{"Line":24}},{"line":422,"address":[],"length":0,"stats":{"Line":96}},{"line":423,"address":[],"length":0,"stats":{"Line":72}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":4}},{"line":432,"address":[],"length":0,"stats":{"Line":4}},{"line":435,"address":[],"length":0,"stats":{"Line":1}},{"line":437,"address":[],"length":0,"stats":{"Line":7}},{"line":438,"address":[],"length":0,"stats":{"Line":1}},{"line":439,"address":[],"length":0,"stats":{"Line":3}},{"line":442,"address":[],"length":0,"stats":{"Line":6}},{"line":446,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":8}},{"line":448,"address":[],"length":0,"stats":{"Line":6}},{"line":452,"address":[],"length":0,"stats":{"Line":111}},{"line":454,"address":[],"length":0,"stats":{"Line":111}},{"line":455,"address":[],"length":0,"stats":{"Line":89}},{"line":457,"address":[],"length":0,"stats":{"Line":66}},{"line":459,"address":[],"length":0,"stats":{"Line":44}},{"line":460,"address":[],"length":0,"stats":{"Line":14}},{"line":461,"address":[],"length":0,"stats":{"Line":14}},{"line":462,"address":[],"length":0,"stats":{"Line":14}},{"line":463,"address":[],"length":0,"stats":{"Line":7}},{"line":464,"address":[],"length":0,"stats":{"Line":14}},{"line":465,"address":[],"length":0,"stats":{"Line":14}},{"line":466,"address":[],"length":0,"stats":{"Line":7}},{"line":467,"address":[],"length":0,"stats":{"Line":14}},{"line":468,"address":[],"length":0,"stats":{"Line":14}},{"line":472,"address":[],"length":0,"stats":{"Line":104}},{"line":474,"address":[],"length":0,"stats":{"Line":104}},{"line":475,"address":[],"length":0,"stats":{"Line":63}},{"line":477,"address":[],"length":0,"stats":{"Line":123}},{"line":479,"address":[],"length":0,"stats":{"Line":82}},{"line":480,"address":[],"length":0,"stats":{"Line":16}},{"line":481,"address":[],"length":0,"stats":{"Line":16}},{"line":482,"address":[],"length":0,"stats":{"Line":14}},{"line":483,"address":[],"length":0,"stats":{"Line":7}},{"line":484,"address":[],"length":0,"stats":{"Line":9}},{"line":485,"address":[],"length":0,"stats":{"Line":12}},{"line":486,"address":[],"length":0,"stats":{"Line":24}},{"line":494,"address":[],"length":0,"stats":{"Line":153}},{"line":495,"address":[],"length":0,"stats":{"Line":459}},{"line":496,"address":[],"length":0,"stats":{"Line":459}},{"line":500,"address":[],"length":0,"stats":{"Line":153}},{"line":501,"address":[],"length":0,"stats":{"Line":131}},{"line":502,"address":[],"length":0,"stats":{"Line":130}},{"line":503,"address":[],"length":0,"stats":{"Line":129}},{"line":504,"address":[],"length":0,"stats":{"Line":121}},{"line":505,"address":[],"length":0,"stats":{"Line":113}},{"line":507,"address":[],"length":0,"stats":{"Line":42}},{"line":511,"address":[],"length":0,"stats":{"Line":353}},{"line":512,"address":[],"length":0,"stats":{"Line":40}},{"line":513,"address":[],"length":0,"stats":{"Line":92}},{"line":515,"address":[],"length":0,"stats":{"Line":2}},{"line":517,"address":[],"length":0,"stats":{"Line":90}},{"line":521,"address":[],"length":0,"stats":{"Line":430}},{"line":525,"address":[],"length":0,"stats":{"Line":10}},{"line":526,"address":[],"length":0,"stats":{"Line":20}},{"line":527,"address":[],"length":0,"stats":{"Line":42}},{"line":529,"address":[],"length":0,"stats":{"Line":3}}],"covered":206,"coverable":248},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vars","mod.rs"],"content":"//! Variable specification and metadata for templates, captures, and macros.\n//!\n//! This module defines the schema for declaring variables with:\n//! - Prompts (human-readable text shown when collecting input)\n//! - Defaults (static or computed with date math)\n//! - Required/optional status\n//!\n//! Variables can be extracted from frontmatter in templates/captures/macros.\n\npub mod datemath;\npub mod types;\n\npub use datemath::{\n    DateBase, DateExpr, DateMathError, DateOffset, Direction, DurationUnit,\n    evaluate_date_expr, is_date_expr, parse_date_expr, try_evaluate_date_expr,\n};\npub use types::{\n    VarMetadata, VarSpec, VarsMap, collect_all_variables, extract_variable_names,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vars","types.rs"],"content":"//! Variable specification types.\n\nuse serde::Deserialize;\nuse std::collections::HashMap;\n\n/// A map of variable names to their specifications.\npub type VarsMap = HashMap\u003cString, VarSpec\u003e;\n\n/// Specification for a single variable.\n///\n/// Variables can be specified in two forms in YAML:\n///\n/// Simple form (just the prompt string):\n/// ```yaml\n/// vars:\n///   title: \"Meeting title\"\n/// ```\n///\n/// Full form (with metadata):\n/// ```yaml\n/// vars:\n///   title:\n///     prompt: \"Meeting title\"\n///     required: true\n///   date:\n///     prompt: \"Meeting date\"\n///     default: \"{{today}}\"\n/// ```\n#[derive(Debug, Clone, Deserialize)]\n#[serde(untagged)]\npub enum VarSpec {\n    /// Simple form: just the prompt string\n    Simple(String),\n    /// Full form: detailed metadata\n    Full(VarMetadata),\n}\n\nimpl VarSpec {\n    /// Get the prompt text for this variable.\n    #[must_use]\n    pub fn prompt(\u0026self) -\u003e \u0026str {\n        match self {\n            VarSpec::Simple(s) =\u003e s,\n            VarSpec::Full(m) =\u003e m.prompt.as_deref().unwrap_or(\"\"),\n        }\n    }\n\n    /// Get the default value, if any.\n    #[must_use]\n    pub fn default(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match self {\n            VarSpec::Simple(_) =\u003e None,\n            VarSpec::Full(m) =\u003e m.default.as_deref(),\n        }\n    }\n\n    /// Check if this variable is required.\n    ///\n    /// A variable is required if:\n    /// - It uses the simple form (no default possible)\n    /// - It uses the full form with `required: true` or no default\n    #[must_use]\n    pub fn is_required(\u0026self) -\u003e bool {\n        match self {\n            VarSpec::Simple(_) =\u003e true,\n            VarSpec::Full(m) =\u003e m.required.unwrap_or_else(|| m.default.is_none()),\n        }\n    }\n\n    /// Get the description, if any.\n    #[must_use]\n    pub fn description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match self {\n            VarSpec::Simple(_) =\u003e None,\n            VarSpec::Full(m) =\u003e m.description.as_deref(),\n        }\n    }\n}\n\n/// Full metadata for a variable specification.\n#[derive(Debug, Clone, Default, Deserialize)]\npub struct VarMetadata {\n    /// Human-readable prompt shown when collecting input.\n    pub prompt: Option\u003cString\u003e,\n\n    /// Longer description for help text.\n    pub description: Option\u003cString\u003e,\n\n    /// Whether this variable is required.\n    /// Default: true if no default is provided.\n    pub required: Option\u003cbool\u003e,\n\n    /// Default value (static string or computed expression like \"{{today}}\").\n    pub default: Option\u003cString\u003e,\n    // Future extensions:\n    // pub options: Option\u003cVec\u003cString\u003e\u003e,  // Selection/dropdown prompt\n    // pub validate: Option\u003cString\u003e,       // Regex validation pattern\n    // pub var_type: Option\u003cVarType\u003e,      // Type hints (string, date, number)\n}\n\n/// Extract variable names from a template string.\n///\n/// Finds all `{{var_name}}` patterns and returns the unique variable names.\n/// Does not include built-in variables like `date`, `time`, `today`, etc.\npub fn extract_variable_names(template: \u0026str) -\u003e Vec\u003cString\u003e {\n    use regex::Regex;\n\n    // Built-in variables that shouldn't be prompted for\n    const BUILTINS: \u0026[\u0026str] = \u0026[\n        \"date\",\n        \"time\",\n        \"datetime\",\n        \"today\",\n        \"now\",\n        \"vault_root\",\n        \"templates_dir\",\n        \"captures_dir\",\n        \"macros_dir\",\n        \"template_name\",\n        \"template_path\",\n        \"output_path\",\n        \"output_filename\",\n        \"output_dir\",\n    ];\n\n    let re = Regex::new(r\"\\{\\{([a-zA-Z_][a-zA-Z0-9_]*)\\}\\}\").expect(\"valid regex\");\n    let mut seen = std::collections::HashSet::new();\n    let mut vars = Vec::new();\n\n    for cap in re.captures_iter(template) {\n        let name = \u0026cap[1];\n        if !BUILTINS.contains(\u0026name) \u0026\u0026 seen.insert(name.to_string()) {\n            vars.push(name.to_string());\n        }\n    }\n\n    vars\n}\n\n/// Collect all variable names needed by a template/capture.\n///\n/// Combines:\n/// - Variables declared in `vars` metadata\n/// - Variables found in template content via `{{var}}` patterns\n///\n/// Returns variable names in order: declared vars first, then extracted vars.\npub fn collect_all_variables(\n    vars_map: Option\u003c\u0026VarsMap\u003e,\n    content: \u0026str,\n) -\u003e Vec\u003c(String, Option\u003cVarSpec\u003e)\u003e {\n    let mut result = Vec::new();\n    let mut seen = std::collections::HashSet::new();\n\n    // First add declared variables (in iteration order)\n    if let Some(vars) = vars_map {\n        for (name, spec) in vars {\n            seen.insert(name.clone());\n            result.push((name.clone(), Some(spec.clone())));\n        }\n    }\n\n    // Then add any variables found in content that weren't declared\n    for name in extract_variable_names(content) {\n        if !seen.contains(\u0026name) {\n            seen.insert(name.clone());\n            result.push((name, None));\n        }\n    }\n\n    result\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_extract_variable_names() {\n        let template = \"# {{title}}\\nDate: {{date}}\\nBy: {{author}}\\n{{title}} again\";\n        let vars = extract_variable_names(template);\n        // date is a builtin, title appears twice but should be unique\n        assert_eq!(vars, vec![\"title\", \"author\"]);\n    }\n\n    #[test]\n    fn test_extract_ignores_builtins() {\n        let template = \"{{today}} {{now}} {{time}} {{custom_var}}\";\n        let vars = extract_variable_names(template);\n        assert_eq!(vars, vec![\"custom_var\"]);\n    }\n\n    #[test]\n    fn test_varspec_simple() {\n        let spec = VarSpec::Simple(\"Enter title\".to_string());\n        assert_eq!(spec.prompt(), \"Enter title\");\n        assert!(spec.default().is_none());\n        assert!(spec.is_required());\n    }\n\n    #[test]\n    fn test_varspec_full_required() {\n        let spec = VarSpec::Full(VarMetadata {\n            prompt: Some(\"Enter title\".to_string()),\n            required: Some(true),\n            ..Default::default()\n        });\n        assert_eq!(spec.prompt(), \"Enter title\");\n        assert!(spec.is_required());\n    }\n\n    #[test]\n    fn test_varspec_full_with_default() {\n        let spec = VarSpec::Full(VarMetadata {\n            prompt: Some(\"Enter date\".to_string()),\n            default: Some(\"{{today}}\".to_string()),\n            ..Default::default()\n        });\n        assert_eq!(spec.prompt(), \"Enter date\");\n        assert_eq!(spec.default(), Some(\"{{today}}\"));\n        assert!(!spec.is_required()); // has default, so not required\n    }\n\n    #[test]\n    fn test_varspec_deserialize_simple() {\n        let yaml = r#\"\"Enter your name\"\"#;\n        let spec: VarSpec = serde_yaml::from_str(yaml).unwrap();\n        assert!(matches!(spec, VarSpec::Simple(_)));\n        assert_eq!(spec.prompt(), \"Enter your name\");\n    }\n\n    #[test]\n    fn test_varspec_deserialize_full() {\n        let yaml = r#\"\nprompt: \"Enter date\"\ndefault: \"{{today}}\"\ndescription: \"The meeting date\"\n\"#;\n        let spec: VarSpec = serde_yaml::from_str(yaml).unwrap();\n        assert!(matches!(spec, VarSpec::Full(_)));\n        assert_eq!(spec.prompt(), \"Enter date\");\n        assert_eq!(spec.default(), Some(\"{{today}}\"));\n        assert_eq!(spec.description(), Some(\"The meeting date\"));\n    }\n\n    #[test]\n    fn test_collect_all_variables() {\n        let mut vars_map = VarsMap::new();\n        vars_map.insert(\"title\".to_string(), VarSpec::Simple(\"Enter title\".to_string()));\n\n        let content = \"# {{title}}\\nBy: {{author}}\";\n        let all = collect_all_variables(Some(\u0026vars_map), content);\n\n        assert_eq!(all.len(), 2);\n        assert_eq!(all[0].0, \"title\");\n        assert!(all[0].1.is_some());\n        assert_eq!(all[1].0, \"author\");\n        assert!(all[1].1.is_none()); // not declared, just extracted\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":5}},{"line":42,"address":[],"length":0,"stats":{"Line":5}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":12}},{"line":50,"address":[],"length":0,"stats":{"Line":11}},{"line":51,"address":[],"length":0,"stats":{"Line":11}},{"line":52,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":18}},{"line":63,"address":[],"length":0,"stats":{"Line":5}},{"line":64,"address":[],"length":0,"stats":{"Line":5}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":18}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":21}},{"line":126,"address":[],"length":0,"stats":{"Line":105}},{"line":127,"address":[],"length":0,"stats":{"Line":42}},{"line":128,"address":[],"length":0,"stats":{"Line":42}},{"line":130,"address":[],"length":0,"stats":{"Line":89}},{"line":131,"address":[],"length":0,"stats":{"Line":52}},{"line":132,"address":[],"length":0,"stats":{"Line":156}},{"line":133,"address":[],"length":0,"stats":{"Line":60}},{"line":137,"address":[],"length":0,"stats":{"Line":21}},{"line":147,"address":[],"length":0,"stats":{"Line":19}},{"line":151,"address":[],"length":0,"stats":{"Line":38}},{"line":152,"address":[],"length":0,"stats":{"Line":38}},{"line":155,"address":[],"length":0,"stats":{"Line":27}},{"line":156,"address":[],"length":0,"stats":{"Line":48}},{"line":157,"address":[],"length":0,"stats":{"Line":50}},{"line":158,"address":[],"length":0,"stats":{"Line":50}},{"line":163,"address":[],"length":0,"stats":{"Line":55}},{"line":164,"address":[],"length":0,"stats":{"Line":41}},{"line":165,"address":[],"length":0,"stats":{"Line":35}},{"line":166,"address":[],"length":0,"stats":{"Line":21}},{"line":170,"address":[],"length":0,"stats":{"Line":19}}],"covered":36,"coverable":37},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vault","extractor.rs"],"content":"//! Note content extraction: links, title, type, frontmatter.\n\nuse std::path::Path;\nuse std::sync::LazyLock;\n\nuse regex::Regex;\n\nuse crate::frontmatter::{self, Frontmatter};\nuse crate::index::types::{LinkType, NoteType};\n\n/// Extracted information from a note file.\n#[derive(Debug, Clone)]\npub struct ExtractedNote {\n    /// Note title (from frontmatter, first heading, or filename).\n    pub title: String,\n    /// Note type from frontmatter `type:` field.\n    pub note_type: NoteType,\n    /// Frontmatter as JSON string (if present).\n    pub frontmatter_json: Option\u003cString\u003e,\n    /// All links found in the document.\n    pub links: Vec\u003cExtractedLink\u003e,\n}\n\n/// A link extracted from a note.\n#[derive(Debug, Clone)]\npub struct ExtractedLink {\n    /// Target path/name (raw, as written in the link).\n    pub target: String,\n    /// Display text (alias for wikilinks, text for markdown links).\n    pub text: Option\u003cString\u003e,\n    /// Type of link.\n    pub link_type: LinkType,\n    /// Line number where link appears (1-based).\n    pub line_number: u32,\n    /// Context text (surrounding content).\n    pub context: Option\u003cString\u003e,\n}\n\n// Regex patterns for link extraction\nstatic WIKILINK_RE: LazyLock\u003cRegex\u003e = LazyLock::new(|| {\n    // Matches [[target]] or [[target|alias]]\n    // Also handles [[target#section]] and [[target#section|alias]]\n    Regex::new(r\"\\[\\[([^\\]|]+)(?:\\|([^\\]]+))?\\]\\]\").unwrap()\n});\n\nstatic MARKDOWN_LINK_RE: LazyLock\u003cRegex\u003e = LazyLock::new(|| {\n    // Matches [text](url) - captures .md files and relative paths\n    // Excludes http:// and https:// URLs\n    Regex::new(r\"\\[([^\\]]+)\\]\\(([^)]+)\\)\").unwrap()\n});\n\n/// Extract note information from file content.\npub fn extract_note(content: \u0026str, file_path: \u0026Path) -\u003e ExtractedNote {\n    // Parse frontmatter\n    let parsed = frontmatter::parse(content).unwrap_or_else(|_| {\n        crate::frontmatter::ParsedDocument {\n            frontmatter: None,\n            body: content.to_string(),\n        }\n    });\n\n    // Extract note type from frontmatter\n    let note_type = parsed\n        .frontmatter\n        .as_ref()\n        .and_then(|fm| fm.fields.get(\"type\"))\n        .and_then(|v| v.as_str())\n        .map(|s| s.parse().unwrap_or_default())\n        .unwrap_or_default();\n\n    // Extract title: frontmatter \u003e first heading \u003e filename\n    let title = extract_title(\u0026parsed.frontmatter, \u0026parsed.body, file_path);\n\n    // Serialize frontmatter to JSON\n    let frontmatter_json = parsed\n        .frontmatter\n        .as_ref()\n        .map(|fm| serde_json::to_string(\u0026fm.fields).unwrap_or_default());\n\n    // Extract links from body\n    let mut links = extract_links(\u0026parsed.body);\n\n    // Extract frontmatter references (project:, parent:, etc.)\n    let fm_links = extract_frontmatter_links(\u0026parsed.frontmatter);\n    links.extend(fm_links);\n\n    ExtractedNote { title, note_type, frontmatter_json, links }\n}\n\nfn extract_title(fm: \u0026Option\u003cFrontmatter\u003e, body: \u0026str, file_path: \u0026Path) -\u003e String {\n    // Try frontmatter title\n    if let Some(fm) = fm\n        \u0026\u0026 let Some(title) = fm.fields.get(\"title\").and_then(|v| v.as_str())\n    {\n        return title.to_string();\n    }\n\n    // Try first heading\n    for line in body.lines() {\n        let trimmed = line.trim();\n        if let Some(heading) = trimmed.strip_prefix('#') {\n            let heading = heading.trim_start_matches('#').trim();\n            if !heading.is_empty() {\n                return heading.to_string();\n            }\n        }\n    }\n\n    // Fall back to filename without extension\n    file_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"Untitled\").to_string()\n}\n\nfn extract_links(body: \u0026str) -\u003e Vec\u003cExtractedLink\u003e {\n    let mut links = Vec::new();\n\n    for (line_num, line) in body.lines().enumerate() {\n        let line_number = (line_num + 1) as u32;\n\n        // Extract wikilinks\n        for cap in WIKILINK_RE.captures_iter(line) {\n            let target = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n            let alias = cap.get(2).map(|m| m.as_str().to_string());\n\n            links.push(ExtractedLink {\n                target: target.to_string(),\n                text: alias,\n                link_type: LinkType::Wikilink,\n                line_number,\n                context: Some(truncate_context(line, 100)),\n            });\n        }\n\n        // Extract markdown links to local files\n        for cap in MARKDOWN_LINK_RE.captures_iter(line) {\n            let text = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n            let url = cap.get(2).map(|m| m.as_str()).unwrap_or(\"\");\n\n            // Skip external URLs\n            if url.starts_with(\"http://\") || url.starts_with(\"https://\") {\n                continue;\n            }\n\n            // Skip non-markdown links (images, etc.) unless they're relative paths\n            if !url.ends_with(\".md\") \u0026\u0026 !is_likely_note_reference(url) {\n                continue;\n            }\n\n            links.push(ExtractedLink {\n                target: url.to_string(),\n                text: Some(text.to_string()),\n                link_type: LinkType::Markdown,\n                line_number,\n                context: Some(truncate_context(line, 100)),\n            });\n        }\n    }\n\n    links\n}\n\nfn is_likely_note_reference(url: \u0026str) -\u003e bool {\n    // Consider it a note reference if it:\n    // - Doesn't have a file extension (might be a note name)\n    // - Or ends with .md\n    // - And doesn't look like an image or other asset\n    let lower = url.to_lowercase();\n\n    // Skip obvious non-notes\n    if lower.ends_with(\".png\")\n        || lower.ends_with(\".jpg\")\n        || lower.ends_with(\".jpeg\")\n        || lower.ends_with(\".gif\")\n        || lower.ends_with(\".svg\")\n        || lower.ends_with(\".pdf\")\n    {\n        return false;\n    }\n\n    // If no extension, it might be a note reference\n    !url.contains('.')\n}\n\nfn extract_frontmatter_links(fm: \u0026Option\u003cFrontmatter\u003e) -\u003e Vec\u003cExtractedLink\u003e {\n    let mut links = Vec::new();\n\n    let fm = match fm {\n        Some(fm) =\u003e fm,\n        None =\u003e return links,\n    };\n\n    // Known reference fields\n    let ref_fields = [\"project\", \"parent\", \"related\", \"blocks\", \"blocked_by\"];\n\n    for field in \u0026ref_fields {\n        if let Some(value) = fm.fields.get(*field) {\n            // Handle single string value\n            if let Some(s) = value.as_str() {\n                links.push(ExtractedLink {\n                    target: s.to_string(),\n                    text: Some(format!(\"{}: {}\", field, s)),\n                    link_type: LinkType::Frontmatter,\n                    line_number: 0, // Frontmatter doesn't have meaningful line numbers\n                    context: None,\n                });\n            }\n            // Handle array of strings\n            if let Some(arr) = value.as_sequence() {\n                for item in arr {\n                    if let Some(s) = item.as_str() {\n                        links.push(ExtractedLink {\n                            target: s.to_string(),\n                            text: Some(format!(\"{}: {}\", field, s)),\n                            link_type: LinkType::Frontmatter,\n                            line_number: 0,\n                            context: None,\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    links\n}\n\nfn truncate_context(line: \u0026str, max_len: usize) -\u003e String {\n    if line.len() \u003c= max_len {\n        line.to_string()\n    } else {\n        format!(\"{}...\", \u0026line[..max_len])\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_extract_wikilinks() {\n        let content = r#\"---\ntitle: Test Note\n---\n# Heading\n\nThis links to [[other-note]] and [[another|with alias]].\nAlso [[path/to/note]] works.\n\"#;\n        let note = extract_note(content, Path::new(\"test.md\"));\n\n        assert_eq!(note.links.len(), 3);\n        assert_eq!(note.links[0].target, \"other-note\");\n        assert_eq!(note.links[0].text, None);\n        assert_eq!(note.links[0].link_type, LinkType::Wikilink);\n\n        assert_eq!(note.links[1].target, \"another\");\n        assert_eq!(note.links[1].text, Some(\"with alias\".to_string()));\n\n        assert_eq!(note.links[2].target, \"path/to/note\");\n    }\n\n    #[test]\n    fn test_extract_markdown_links() {\n        let content = r#\"# Note\n\nSee [this note](./other.md) for details.\nAlso [external](https://example.com) should be skipped.\nAnd [image](./pic.png) should be skipped too.\n\"#;\n        let note = extract_note(content, Path::new(\"test.md\"));\n\n        assert_eq!(note.links.len(), 1);\n        assert_eq!(note.links[0].target, \"./other.md\");\n        assert_eq!(note.links[0].text, Some(\"this note\".to_string()));\n        assert_eq!(note.links[0].link_type, LinkType::Markdown);\n    }\n\n    #[test]\n    fn test_extract_frontmatter_links() {\n        let content = r#\"---\ntitle: Task\ntype: task\nproject: my-project\nrelated:\n  - note-a\n  - note-b\n---\n# Task content\n\"#;\n        let note = extract_note(content, Path::new(\"task.md\"));\n\n        let fm_links: Vec\u003c_\u003e =\n            note.links.iter().filter(|l| l.link_type == LinkType::Frontmatter).collect();\n\n        assert_eq!(fm_links.len(), 3);\n        assert!(fm_links.iter().any(|l| l.target == \"my-project\"));\n        assert!(fm_links.iter().any(|l| l.target == \"note-a\"));\n        assert!(fm_links.iter().any(|l| l.target == \"note-b\"));\n    }\n\n    #[test]\n    fn test_extract_title_from_frontmatter() {\n        let content = r#\"---\ntitle: My Title\n---\n# Heading\n\"#;\n        let note = extract_note(content, Path::new(\"file.md\"));\n        assert_eq!(note.title, \"My Title\");\n    }\n\n    #[test]\n    fn test_extract_title_from_heading() {\n        let content = \"# First Heading\\n\\nContent here.\";\n        let note = extract_note(content, Path::new(\"file.md\"));\n        assert_eq!(note.title, \"First Heading\");\n    }\n\n    #[test]\n    fn test_extract_title_from_filename() {\n        let content = \"No frontmatter, no heading.\";\n        let note = extract_note(content, Path::new(\"my-note.md\"));\n        assert_eq!(note.title, \"my-note\");\n    }\n\n    #[test]\n    fn test_extract_note_type() {\n        let content = r#\"---\ntype: task\n---\n# Task\n\"#;\n        let note = extract_note(content, Path::new(\"task.md\"));\n        assert_eq!(note.note_type, NoteType::Task);\n    }\n\n    #[test]\n    fn test_extract_note_type_default() {\n        let content = \"# Just a note\";\n        let note = extract_note(content, Path::new(\"note.md\"));\n        assert_eq!(note.note_type, NoteType::None);\n    }\n\n    #[test]\n    fn test_line_numbers() {\n        let content = r#\"Line 1\nLine 2 with [[link1]]\nLine 3\nLine 4 with [[link2]]\n\"#;\n        let note = extract_note(content, Path::new(\"test.md\"));\n\n        assert_eq!(note.links.len(), 2);\n        assert_eq!(note.links[0].line_number, 2);\n        assert_eq!(note.links[1].line_number, 4);\n    }\n\n    #[test]\n    fn test_wikilink_with_section() {\n        let content = \"Link to [[note#section]] here.\";\n        let note = extract_note(content, Path::new(\"test.md\"));\n\n        assert_eq!(note.links.len(), 1);\n        assert_eq!(note.links[0].target, \"note#section\");\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":53}},{"line":55,"address":[],"length":0,"stats":{"Line":212}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":106}},{"line":64,"address":[],"length":0,"stats":{"Line":53}},{"line":66,"address":[],"length":0,"stats":{"Line":143}},{"line":67,"address":[],"length":0,"stats":{"Line":109}},{"line":68,"address":[],"length":0,"stats":{"Line":137}},{"line":72,"address":[],"length":0,"stats":{"Line":265}},{"line":75,"address":[],"length":0,"stats":{"Line":106}},{"line":76,"address":[],"length":0,"stats":{"Line":53}},{"line":78,"address":[],"length":0,"stats":{"Line":143}},{"line":81,"address":[],"length":0,"stats":{"Line":159}},{"line":84,"address":[],"length":0,"stats":{"Line":159}},{"line":85,"address":[],"length":0,"stats":{"Line":159}},{"line":90,"address":[],"length":0,"stats":{"Line":53}},{"line":92,"address":[],"length":0,"stats":{"Line":83}},{"line":93,"address":[],"length":0,"stats":{"Line":207}},{"line":95,"address":[],"length":0,"stats":{"Line":58}},{"line":99,"address":[],"length":0,"stats":{"Line":75}},{"line":100,"address":[],"length":0,"stats":{"Line":81}},{"line":101,"address":[],"length":0,"stats":{"Line":48}},{"line":102,"address":[],"length":0,"stats":{"Line":63}},{"line":103,"address":[],"length":0,"stats":{"Line":21}},{"line":104,"address":[],"length":0,"stats":{"Line":42}},{"line":110,"address":[],"length":0,"stats":{"Line":24}},{"line":113,"address":[],"length":0,"stats":{"Line":53}},{"line":114,"address":[],"length":0,"stats":{"Line":106}},{"line":116,"address":[],"length":0,"stats":{"Line":461}},{"line":117,"address":[],"length":0,"stats":{"Line":302}},{"line":120,"address":[],"length":0,"stats":{"Line":499}},{"line":121,"address":[],"length":0,"stats":{"Line":368}},{"line":122,"address":[],"length":0,"stats":{"Line":186}},{"line":124,"address":[],"length":0,"stats":{"Line":138}},{"line":125,"address":[],"length":0,"stats":{"Line":138}},{"line":126,"address":[],"length":0,"stats":{"Line":92}},{"line":127,"address":[],"length":0,"stats":{"Line":92}},{"line":128,"address":[],"length":0,"stats":{"Line":92}},{"line":129,"address":[],"length":0,"stats":{"Line":46}},{"line":134,"address":[],"length":0,"stats":{"Line":469}},{"line":135,"address":[],"length":0,"stats":{"Line":128}},{"line":136,"address":[],"length":0,"stats":{"Line":128}},{"line":139,"address":[],"length":0,"stats":{"Line":64}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":16}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":42}},{"line":149,"address":[],"length":0,"stats":{"Line":42}},{"line":150,"address":[],"length":0,"stats":{"Line":28}},{"line":151,"address":[],"length":0,"stats":{"Line":28}},{"line":152,"address":[],"length":0,"stats":{"Line":28}},{"line":153,"address":[],"length":0,"stats":{"Line":14}},{"line":158,"address":[],"length":0,"stats":{"Line":53}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":53}},{"line":184,"address":[],"length":0,"stats":{"Line":106}},{"line":186,"address":[],"length":0,"stats":{"Line":83}},{"line":187,"address":[],"length":0,"stats":{"Line":60}},{"line":188,"address":[],"length":0,"stats":{"Line":23}},{"line":192,"address":[],"length":0,"stats":{"Line":120}},{"line":194,"address":[],"length":0,"stats":{"Line":330}},{"line":195,"address":[],"length":0,"stats":{"Line":315}},{"line":197,"address":[],"length":0,"stats":{"Line":43}},{"line":198,"address":[],"length":0,"stats":{"Line":42}},{"line":199,"address":[],"length":0,"stats":{"Line":42}},{"line":200,"address":[],"length":0,"stats":{"Line":28}},{"line":201,"address":[],"length":0,"stats":{"Line":14}},{"line":202,"address":[],"length":0,"stats":{"Line":14}},{"line":203,"address":[],"length":0,"stats":{"Line":14}},{"line":207,"address":[],"length":0,"stats":{"Line":16}},{"line":208,"address":[],"length":0,"stats":{"Line":5}},{"line":209,"address":[],"length":0,"stats":{"Line":6}},{"line":210,"address":[],"length":0,"stats":{"Line":6}},{"line":211,"address":[],"length":0,"stats":{"Line":6}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":30}},{"line":226,"address":[],"length":0,"stats":{"Line":60}},{"line":227,"address":[],"length":0,"stats":{"Line":120}},{"line":228,"address":[],"length":0,"stats":{"Line":120}},{"line":230,"address":[],"length":0,"stats":{"Line":0}}],"covered":88,"coverable":98},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vault","hasher.rs"],"content":"//! Content hashing for change detection.\n\nuse std::fs::File;\nuse std::hash::{DefaultHasher, Hash, Hasher};\nuse std::io::{BufRead, BufReader, Result};\nuse std::path::Path;\n\n/// Compute a hash of file content for change detection.\n/// Uses DefaultHasher for speed (non-cryptographic, fast).\n/// Returns hex-encoded hash string.\npub fn content_hash(path: \u0026Path) -\u003e Result\u003cString\u003e {\n    let file = File::open(path)?;\n    let reader = BufReader::new(file);\n\n    let mut hasher = DefaultHasher::new();\n\n    for line in reader.lines() {\n        let line = line?;\n        line.hash(\u0026mut hasher);\n    }\n\n    Ok(format!(\"{:016x}\", hasher.finish()))\n}\n\n/// Compute hash from content string (for testing).\npub fn content_hash_str(content: \u0026str) -\u003e String {\n    let mut hasher = DefaultHasher::new();\n\n    for line in content.lines() {\n        line.hash(\u0026mut hasher);\n    }\n\n    format!(\"{:016x}\", hasher.finish())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_content_hash_str_consistent() {\n        let content = \"# Hello\\n\\nThis is a test.\";\n        let hash1 = content_hash_str(content);\n        let hash2 = content_hash_str(content);\n        assert_eq!(hash1, hash2);\n    }\n\n    #[test]\n    fn test_content_hash_str_different_content() {\n        let hash1 = content_hash_str(\"# Hello\");\n        let hash2 = content_hash_str(\"# World\");\n        assert_ne!(hash1, hash2);\n    }\n\n    #[test]\n    fn test_content_hash_file() {\n        let dir = TempDir::new().unwrap();\n        let path = dir.path().join(\"test.md\");\n        fs::write(\u0026path, \"# Test\\n\\nContent here.\").unwrap();\n\n        let hash = content_hash(\u0026path).unwrap();\n        assert_eq!(hash.len(), 16); // 64-bit hash as 16 hex chars\n    }\n\n    #[test]\n    fn test_content_hash_file_matches_str() {\n        let content = \"# Test\\n\\nContent here.\";\n        let dir = TempDir::new().unwrap();\n        let path = dir.path().join(\"test.md\");\n        fs::write(\u0026path, content).unwrap();\n\n        let file_hash = content_hash(\u0026path).unwrap();\n        let str_hash = content_hash_str(content);\n        assert_eq!(file_hash, str_hash);\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":62}},{"line":12,"address":[],"length":0,"stats":{"Line":186}},{"line":13,"address":[],"length":0,"stats":{"Line":186}},{"line":15,"address":[],"length":0,"stats":{"Line":124}},{"line":17,"address":[],"length":0,"stats":{"Line":468}},{"line":18,"address":[],"length":0,"stats":{"Line":688}},{"line":19,"address":[],"length":0,"stats":{"Line":1032}},{"line":22,"address":[],"length":0,"stats":{"Line":186}},{"line":26,"address":[],"length":0,"stats":{"Line":5}},{"line":27,"address":[],"length":0,"stats":{"Line":10}},{"line":29,"address":[],"length":0,"stats":{"Line":32}},{"line":30,"address":[],"length":0,"stats":{"Line":22}},{"line":33,"address":[],"length":0,"stats":{"Line":20}}],"covered":13,"coverable":13},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vault","mod.rs"],"content":"//! Vault file discovery and content extraction.\n//!\n//! This module provides utilities for walking vault directories,\n//! extracting metadata from markdown files, and computing content hashes.\n\npub mod extractor;\npub mod hasher;\npub mod walker;\n\npub use extractor::{ExtractedLink, ExtractedNote, extract_note};\npub use hasher::{content_hash, content_hash_str};\npub use walker::{VaultWalker, VaultWalkerError, WalkedFile};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vault","walker.rs"],"content":"//! Recursive vault directory walker.\n\nuse std::path::{Path, PathBuf};\nuse std::time::SystemTime;\nuse thiserror::Error;\nuse walkdir::WalkDir;\n\n#[derive(Debug, Error)]\npub enum VaultWalkerError {\n    #[error(\"vault root does not exist: {0}\")]\n    MissingRoot(String),\n\n    #[error(\"failed to walk vault directory {0}: {1}\")]\n    WalkError(String, #[source] walkdir::Error),\n\n    #[error(\"failed to read file metadata {0}: {1}\")]\n    MetadataError(String, #[source] std::io::Error),\n}\n\n/// Information about a discovered markdown file.\n#[derive(Debug, Clone)]\npub struct WalkedFile {\n    /// Absolute path to the file.\n    pub absolute_path: PathBuf,\n    /// Path relative to vault root.\n    pub relative_path: PathBuf,\n    /// File modification time.\n    pub modified: SystemTime,\n    /// File size in bytes.\n    pub size: u64,\n}\n\n/// Walker for discovering markdown files in a vault.\n#[derive(Debug)]\npub struct VaultWalker {\n    root: PathBuf,\n}\n\nimpl VaultWalker {\n    /// Create a new walker for the given vault root.\n    pub fn new(root: \u0026Path) -\u003e Result\u003cSelf, VaultWalkerError\u003e {\n        let root = root\n            .canonicalize()\n            .map_err(|_| VaultWalkerError::MissingRoot(root.display().to_string()))?;\n\n        if !root.exists() {\n            return Err(VaultWalkerError::MissingRoot(root.display().to_string()));\n        }\n\n        Ok(Self { root })\n    }\n\n    /// Walk the vault and return all markdown files.\n    /// Excludes hidden directories and common non-vault directories.\n    pub fn walk(\u0026self) -\u003e Result\u003cVec\u003cWalkedFile\u003e, VaultWalkerError\u003e {\n        let mut files = Vec::new();\n\n        for entry in WalkDir::new(\u0026self.root)\n            .follow_links(false)\n            .into_iter()\n            .filter_entry(|e| !is_hidden_or_ignored(e))\n        {\n            let entry = entry.map_err(|e| {\n                VaultWalkerError::WalkError(self.root.display().to_string(), e)\n            })?;\n\n            let path = entry.path();\n            if !path.is_file() || !is_markdown_file(path) {\n                continue;\n            }\n\n            let metadata = path.metadata().map_err(|e| {\n                VaultWalkerError::MetadataError(path.display().to_string(), e)\n            })?;\n\n            let relative_path =\n                path.strip_prefix(\u0026self.root).unwrap_or(path).to_path_buf();\n\n            files.push(WalkedFile {\n                absolute_path: path.to_path_buf(),\n                relative_path,\n                modified: metadata.modified().unwrap_or(std::time::UNIX_EPOCH),\n                size: metadata.len(),\n            });\n        }\n\n        files.sort_by(|a, b| a.relative_path.cmp(\u0026b.relative_path));\n        Ok(files)\n    }\n\n    /// Get the vault root path.\n    pub fn root(\u0026self) -\u003e \u0026Path {\n        \u0026self.root\n    }\n}\n\nfn is_markdown_file(path: \u0026Path) -\u003e bool {\n    path.extension().and_then(|e| e.to_str()).is_some_and(|e| e == \"md\")\n}\n\nfn is_hidden_or_ignored(entry: \u0026walkdir::DirEntry) -\u003e bool {\n    // Never filter the root directory (depth 0)\n    if entry.depth() == 0 {\n        return false;\n    }\n\n    let name = entry.file_name().to_string_lossy();\n\n    // Skip hidden files and directories\n    if name.starts_with('.') {\n        return true;\n    }\n\n    // Skip common non-vault directories\n    matches!(name.as_ref(), \"node_modules\" | \"target\" | \"__pycache__\" | \"venv\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    fn create_test_vault() -\u003e TempDir {\n        let dir = TempDir::new().unwrap();\n        let root = dir.path();\n\n        // Create some markdown files\n        fs::write(root.join(\"note1.md\"), \"# Note 1\").unwrap();\n        fs::write(root.join(\"note2.md\"), \"# Note 2\").unwrap();\n\n        // Create subdirectory with notes\n        fs::create_dir(root.join(\"subdir\")).unwrap();\n        fs::write(root.join(\"subdir/note3.md\"), \"# Note 3\").unwrap();\n\n        // Create hidden directory (should be skipped)\n        fs::create_dir(root.join(\".hidden\")).unwrap();\n        fs::write(root.join(\".hidden/secret.md\"), \"# Secret\").unwrap();\n\n        // Create non-markdown file (should be skipped)\n        fs::write(root.join(\"readme.txt\"), \"Not markdown\").unwrap();\n\n        dir\n    }\n\n    #[test]\n    fn test_walk_finds_markdown_files() {\n        let vault = create_test_vault();\n        let walker = VaultWalker::new(vault.path()).unwrap();\n        let files = walker.walk().unwrap();\n\n        assert_eq!(files.len(), 3);\n\n        let paths: Vec\u003c_\u003e = files.iter().map(|f| f.relative_path.clone()).collect();\n        assert!(paths.contains(\u0026PathBuf::from(\"note1.md\")));\n        assert!(paths.contains(\u0026PathBuf::from(\"note2.md\")));\n        assert!(paths.contains(\u0026PathBuf::from(\"subdir/note3.md\")));\n    }\n\n    #[test]\n    fn test_walk_skips_hidden_directories() {\n        let vault = create_test_vault();\n        let walker = VaultWalker::new(vault.path()).unwrap();\n        let files = walker.walk().unwrap();\n\n        let paths: Vec\u003c_\u003e =\n            files.iter().map(|f| f.relative_path.to_string_lossy().to_string()).collect();\n\n        assert!(!paths.iter().any(|p| p.contains(\".hidden\")));\n    }\n\n    #[test]\n    fn test_walk_skips_non_markdown() {\n        let vault = create_test_vault();\n        let walker = VaultWalker::new(vault.path()).unwrap();\n        let files = walker.walk().unwrap();\n\n        let paths: Vec\u003c_\u003e =\n            files.iter().map(|f| f.relative_path.to_string_lossy().to_string()).collect();\n\n        assert!(!paths.iter().any(|p| p.contains(\"readme.txt\")));\n    }\n\n    #[test]\n    fn test_walk_results_sorted() {\n        let vault = create_test_vault();\n        let walker = VaultWalker::new(vault.path()).unwrap();\n        let files = walker.walk().unwrap();\n\n        let paths: Vec\u003c_\u003e = files.iter().map(|f| \u0026f.relative_path).collect();\n        let mut sorted = paths.clone();\n        sorted.sort();\n\n        assert_eq!(paths, sorted);\n    }\n\n    #[test]\n    fn test_missing_root() {\n        let result = VaultWalker::new(Path::new(\"/nonexistent/path\"));\n        assert!(result.is_err());\n        assert!(matches!(result.unwrap_err(), VaultWalkerError::MissingRoot(_)));\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":24}},{"line":42,"address":[],"length":0,"stats":{"Line":47}},{"line":44,"address":[],"length":0,"stats":{"Line":27}},{"line":46,"address":[],"length":0,"stats":{"Line":23}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":23}},{"line":55,"address":[],"length":0,"stats":{"Line":23}},{"line":56,"address":[],"length":0,"stats":{"Line":46}},{"line":58,"address":[],"length":0,"stats":{"Line":166}},{"line":59,"address":[],"length":0,"stats":{"Line":23}},{"line":60,"address":[],"length":0,"stats":{"Line":23}},{"line":61,"address":[],"length":0,"stats":{"Line":271}},{"line":63,"address":[],"length":0,"stats":{"Line":360}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":360}},{"line":68,"address":[],"length":0,"stats":{"Line":194}},{"line":69,"address":[],"length":0,"stats":{"Line":50}},{"line":72,"address":[],"length":0,"stats":{"Line":280}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":70}},{"line":77,"address":[],"length":0,"stats":{"Line":350}},{"line":79,"address":[],"length":0,"stats":{"Line":210}},{"line":80,"address":[],"length":0,"stats":{"Line":210}},{"line":81,"address":[],"length":0,"stats":{"Line":140}},{"line":82,"address":[],"length":0,"stats":{"Line":280}},{"line":83,"address":[],"length":0,"stats":{"Line":70}},{"line":87,"address":[],"length":0,"stats":{"Line":259}},{"line":88,"address":[],"length":0,"stats":{"Line":23}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":74}},{"line":98,"address":[],"length":0,"stats":{"Line":592}},{"line":101,"address":[],"length":0,"stats":{"Line":124}},{"line":103,"address":[],"length":0,"stats":{"Line":124}},{"line":104,"address":[],"length":0,"stats":{"Line":23}},{"line":107,"address":[],"length":0,"stats":{"Line":303}},{"line":110,"address":[],"length":0,"stats":{"Line":101}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":485}}],"covered":34,"coverable":39},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","config_loader_errors.rs"],"content":"use mdvault_core::config::loader::{ConfigError, ConfigLoader};\nuse std::fs;\nuse std::path::PathBuf;\nuse tempfile::tempdir;\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn missing_file_fails() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"nope/config.toml\");\n    let err = ConfigLoader::load(Some(\u0026cfg_path), None).unwrap_err();\n    match err {\n        ConfigError::NotFound(_) =\u003e {}\n        other =\u003e panic!(\"expected NotFound, got {other:?}\"),\n    }\n}\n\n#[test]\nfn bad_version_fails() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"config.toml\");\n    write_file(\u0026cfg_path, \"version = 2\\nprofiles = {}\\n\");\n\n    let err = ConfigLoader::load(Some(\u0026cfg_path), None).unwrap_err();\n    match err {\n        ConfigError::BadVersion(2) =\u003e {}\n        other =\u003e panic!(\"expected BadVersion(2), got {other:?}\"),\n    }\n}\n\n#[test]\nfn no_profiles_fails() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"config.toml\");\n    write_file(\u0026cfg_path, \"version = 1\\nprofiles = {}\\n\");\n\n    let err = ConfigLoader::load(Some(\u0026cfg_path), None).unwrap_err();\n    match err {\n        ConfigError::NoProfiles =\u003e {}\n        other =\u003e panic!(\"expected NoProfiles, got {other:?}\"),\n    }\n}\n\n#[test]\nfn profile_not_found_fails() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"config.toml\");\n    let toml = r#\"\nversion = 1\nprofile = \"default\"\n[profiles.default]\nvault_root = \"/tmp/vault\"\ntemplates_dir = \"{{vault_root}}/tpl\"\ncaptures_dir  = \"{{vault_root}}/cap\"\nmacros_dir    = \"{{vault_root}}/mac\"\n\"#;\n    write_file(\u0026cfg_path, toml);\n\n    let err = ConfigLoader::load(Some(\u0026cfg_path), Some(\"missing\")).unwrap_err();\n    match err {\n        ConfigError::ProfileNotFound(p) if p == \"missing\" =\u003e {}\n        other =\u003e panic!(\"expected ProfileNotFound(\\\"missing\\\"), got {other:?}\"),\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":3}},{"line":7,"address":[],"length":0,"stats":{"Line":9}},{"line":8,"address":[],"length":0,"stats":{"Line":6}},{"line":10,"address":[],"length":0,"stats":{"Line":12}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","config_loader_ok.rs"],"content":"use mdvault_core::config::loader::ConfigLoader;\nuse std::fs;\nuse std::path::PathBuf;\nuse tempfile::tempdir;\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn load_default_profile_ok() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"config.toml\");\n    let toml = r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"/tmp/vault\"\ntemplates_dir = \"{{vault_root}}/.markadd/templates\"\ncaptures_dir  = \"{{vault_root}}/.markadd/captures\"\nmacros_dir    = \"{{vault_root}}/.markadd/macros\"\n\n[security]\nallow_shell = false\nallow_http  = true\n\"#;\n\n    write_file(\u0026cfg_path, toml);\n\n    let rc = ConfigLoader::load(Some(\u0026cfg_path), None).expect(\"should load\");\n    assert_eq!(rc.active_profile, \"default\");\n    assert_eq!(rc.vault_root.display().to_string(), \"/tmp/vault\");\n    assert!(rc.templates_dir.ends_with(\".markadd/templates\"));\n    assert!(rc.captures_dir.ends_with(\".markadd/captures\"));\n    assert!(rc.macros_dir.ends_with(\".markadd/macros\"));\n    assert!(!rc.security.allow_shell);\n    assert!(rc.security.allow_http);\n}\n\n#[test]\nfn load_with_profile_override_ok() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"markadd/config.toml\");\n    let toml = r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"/tmp/def\"\ntemplates_dir = \"{{vault_root}}/tpl\"\ncaptures_dir  = \"{{vault_root}}/cap\"\nmacros_dir    = \"{{vault_root}}/mac\"\n\n[profiles.work]\nvault_root = \"/tmp/work\"\ntemplates_dir = \"{{vault_root}}/tpl\"\ncaptures_dir  = \"{{vault_root}}/cap\"\nmacros_dir    = \"{{vault_root}}/mac\"\n\"#;\n    write_file(\u0026cfg_path, toml);\n\n    let rc = ConfigLoader::load(Some(\u0026cfg_path), Some(\"work\")).expect(\"should load\");\n    assert_eq!(rc.active_profile, \"work\");\n    assert_eq!(rc.vault_root.display().to_string(), \"/tmp/work\");\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":2}},{"line":7,"address":[],"length":0,"stats":{"Line":6}},{"line":8,"address":[],"length":0,"stats":{"Line":4}},{"line":10,"address":[],"length":0,"stats":{"Line":8}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","doctor_snapshot.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","markdown_ast_golden.rs"],"content":"use insta::assert_snapshot;\nuse mdvault_core::markdown_ast::{InsertPosition, MarkdownEditor, SectionMatch};\n\n#[test]\nfn golden_changelog_insert_unreleased_begin() {\n    let input = include_str!(\"fixtures/changelog_simple.md\");\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Unreleased\"),\n        \"### Added\\n\\n- New feature from test\\n\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    assert_snapshot!(result.content);\n}\n\n#[test]\nfn golden_changelog_insert_added_end() {\n    let input = include_str!(\"fixtures/changelog_simple.md\");\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Added\"),\n        \"- Another new feature\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    assert_snapshot!(result.content);\n}\n\n#[test]\nfn golden_complex_document_preserves_formatting() {\n    let input = include_str!(\"fixtures/changelog_complex.md\");\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Added\"),\n        \"- Complex item with `code` and **bold**\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    assert_snapshot!(result.content);\n}\n\n#[test]\nfn golden_insert_into_changed_with_code_block() {\n    let input = include_str!(\"fixtures/changelog_complex.md\");\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Changed\"),\n        \"- New change entry\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    assert_snapshot!(result.content);\n}\n\n#[test]\nfn golden_find_headings_complex() {\n    let input = include_str!(\"fixtures/changelog_complex.md\");\n\n    let headings = MarkdownEditor::find_headings(input);\n    let headings_str: Vec\u003cString\u003e =\n        headings.iter().map(|h| format!(\"L{}: {}\", h.level, h.title)).collect();\n\n    assert_snapshot!(headings_str.join(\"\\n\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","markdown_ast_insert.rs"],"content":"use mdvault_core::markdown_ast::{\n    InsertPosition, MarkdownAstError, MarkdownEditor, SectionMatch,\n};\n\n// === Basic insertion tests ===\n\n#[test]\nfn insert_at_begin_of_section() {\n    let input = r#\"# Changelog\n\n## Unreleased\n\n### Added\n\n- Feature A\n\n## 1.0.0\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Added\"),\n        \"- Feature B\\n\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    // Feature B should appear before Feature A\n    let feature_b_pos = result.content.find(\"Feature B\").unwrap();\n    let feature_a_pos = result.content.find(\"Feature A\").unwrap();\n    assert!(feature_b_pos \u003c feature_a_pos);\n}\n\n#[test]\nfn insert_at_end_of_section() {\n    let input = r#\"# Inbox\n\n- Task 1\n- Task 2\n\n# Done\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Inbox\"),\n        \"- Task 3\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // Task 3 should appear after Task 2 but before Done\n    let task2_pos = result.content.find(\"Task 2\").unwrap();\n    let task3_pos = result.content.find(\"Task 3\").unwrap();\n    let done_pos = result.content.find(\"# Done\").unwrap();\n    assert!(task2_pos \u003c task3_pos);\n    assert!(task3_pos \u003c done_pos);\n}\n\n// === Section matching tests ===\n\n#[test]\nfn case_insensitive_match_default() {\n    let input = \"# INBOX\\n\\nContent\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"inbox\"),\n        \"New item\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(result.is_ok());\n}\n\n#[test]\nfn case_sensitive_match_fails_when_case_differs() {\n    let input = \"# INBOX\\n\\nContent\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"inbox\").case_sensitive(true),\n        \"New item\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(matches!(result, Err(MarkdownAstError::SectionNotFound(_))));\n}\n\n#[test]\nfn case_sensitive_match_succeeds_when_case_matches() {\n    let input = \"# INBOX\\n\\nContent\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"INBOX\").case_sensitive(true),\n        \"New item\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(result.is_ok());\n}\n\n#[test]\nfn trimmed_title_matching() {\n    let input = \"# Inbox   \\n\\nContent\\n\"; // Trailing spaces in heading\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Inbox\"),\n        \"New\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(result.is_ok());\n}\n\n// === Edge cases ===\n\n#[test]\nfn section_not_found_error() {\n    let input = \"# Existing\\n\\nContent\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"NonExistent\"),\n        \"Fragment\\n\",\n        InsertPosition::Begin,\n    );\n\n    match result {\n        Err(MarkdownAstError::SectionNotFound(s)) =\u003e assert_eq!(s, \"NonExistent\"),\n        _ =\u003e panic!(\"Expected SectionNotFound error\"),\n    }\n}\n\n#[test]\nfn empty_document_error() {\n    let result = MarkdownEditor::insert_into_section(\n        \"\",\n        \u0026SectionMatch::new(\"Any\"),\n        \"Fragment\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(matches!(result, Err(MarkdownAstError::EmptyDocument)));\n}\n\n#[test]\nfn whitespace_only_document_error() {\n    let result = MarkdownEditor::insert_into_section(\n        \"   \\n\\n   \",\n        \u0026SectionMatch::new(\"Any\"),\n        \"Fragment\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(matches!(result, Err(MarkdownAstError::EmptyDocument)));\n}\n\n#[test]\nfn empty_fragment_is_noop() {\n    let input = \"# Section\\n\\nOriginal\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Section\"),\n        \"\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    // Content should be unchanged\n    assert!(result.content.contains(\"Original\"));\n}\n\n#[test]\nfn code_block_with_hash_not_matched_as_heading() {\n    let input = r#\"# Real Heading\n\n```bash\n# This is a comment, not a heading\necho \"hello\"\n```\n\n# Another Heading\n\"#;\n\n    let headings = MarkdownEditor::find_headings(input);\n    assert_eq!(headings.len(), 2);\n    assert_eq!(headings[0].title, \"Real Heading\");\n    assert_eq!(headings[1].title, \"Another Heading\");\n}\n\n#[test]\nfn last_section_extends_to_eof() {\n    let input = \"# Only Section\\n\\nLine 1\\n\\nLine 2\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Only Section\"),\n        \"New line\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // New line should appear after Line 2\n    let line2_pos = result.content.find(\"Line 2\").unwrap();\n    let newline_pos = result.content.find(\"New line\").unwrap();\n    assert!(newline_pos \u003e line2_pos);\n}\n\n#[test]\nfn insert_into_empty_section() {\n    let input = \"# Empty Section\\n\\n# Next Section\\n\\nContent\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Empty Section\"),\n        \"New content\\n\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    // New content should appear after Empty Section but before Next Section\n    let empty_section_pos = result.content.find(\"# Empty Section\").unwrap();\n    let new_content_pos = result.content.find(\"New content\").unwrap();\n    let next_section_pos = result.content.find(\"# Next Section\").unwrap();\n    assert!(new_content_pos \u003e empty_section_pos);\n    assert!(new_content_pos \u003c next_section_pos);\n}\n\n#[test]\nfn nested_sections_respects_level() {\n    let input = r#\"# Level 1\n\n## Level 2 A\n\nContent A\n\n### Level 3\n\nDeep content\n\n## Level 2 B\n\nContent B\n\"#;\n\n    // Insert into Level 2 A - should only affect until Level 2 B\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Level 2 A\"),\n        \"New A content\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // Verify insertion is before \"## Level 2 B\"\n    let level2b_pos = result.content.find(\"## Level 2 B\").unwrap();\n    let new_content_pos = result.content.find(\"New A content\").unwrap();\n    assert!(new_content_pos \u003c level2b_pos);\n}\n\n#[test]\nfn multiple_same_name_sections_matches_first() {\n    let input = r#\"# Inbox\n\nFirst inbox content\n\n# Other\n\n# Inbox\n\nSecond inbox content\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Inbox\"),\n        \"New item\\n\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    // Should insert after FIRST \"# Inbox\"\n    let first_inbox = result.content.find(\"# Inbox\").unwrap();\n    let new_item = result.content.find(\"New item\").unwrap();\n\n    // Find second inbox after the first\n    let after_first = \u0026result.content[first_inbox + 7..];\n    let second_inbox = after_first.find(\"# Inbox\").unwrap() + first_inbox + 7;\n\n    assert!(new_item \u003e first_inbox \u0026\u0026 new_item \u003c second_inbox);\n}\n\n// === find_headings tests ===\n\n#[test]\nfn find_headings_returns_all_levels() {\n    let input = r#\"# H1\n\n## H2\n\n### H3\n\n#### H4\n\n##### H5\n\n###### H6\n\"#;\n\n    let headings = MarkdownEditor::find_headings(input);\n    assert_eq!(headings.len(), 6);\n    assert_eq!(headings[0].level, 1);\n    assert_eq!(headings[1].level, 2);\n    assert_eq!(headings[2].level, 3);\n    assert_eq!(headings[3].level, 4);\n    assert_eq!(headings[4].level, 5);\n    assert_eq!(headings[5].level, 6);\n}\n\n#[test]\nfn find_headings_preserves_order() {\n    let input = r#\"# First\n\n## Second\n\n# Third\n\"#;\n\n    let headings = MarkdownEditor::find_headings(input);\n    assert_eq!(headings.len(), 3);\n    assert_eq!(headings[0].title, \"First\");\n    assert_eq!(headings[1].title, \"Second\");\n    assert_eq!(headings[2].title, \"Third\");\n}\n\n// === section_exists tests ===\n\n#[test]\nfn section_exists_returns_true_for_existing() {\n    let input = \"# Existing\\n\\nContent\\n\";\n    assert!(MarkdownEditor::section_exists(input, \u0026SectionMatch::new(\"Existing\")));\n}\n\n#[test]\nfn section_exists_returns_false_for_missing() {\n    let input = \"# Existing\\n\\nContent\\n\";\n    assert!(!MarkdownEditor::section_exists(input, \u0026SectionMatch::new(\"Missing\")));\n}\n\n// === Setext headings ===\n\n#[test]\nfn setext_headings_level_1() {\n    let input = r#\"Main Title\n===========\n\nContent under main.\n\"#;\n\n    let headings = MarkdownEditor::find_headings(input);\n    assert_eq!(headings.len(), 1);\n    assert_eq!(headings[0].title, \"Main Title\");\n    assert_eq!(headings[0].level, 1);\n}\n\n#[test]\nfn setext_headings_level_2() {\n    let input = r#\"Subtitle\n--------\n\nSubtitle content.\n\"#;\n\n    let headings = MarkdownEditor::find_headings(input);\n    assert_eq!(headings.len(), 1);\n    assert_eq!(headings[0].title, \"Subtitle\");\n    assert_eq!(headings[0].level, 2);\n}\n\n#[test]\nfn insert_into_setext_heading() {\n    let input = r#\"My Section\n===========\n\nOriginal content.\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"My Section\"),\n        \"New content\\n\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    assert!(result.content.contains(\"New content\"));\n}\n\n// === Wikilinks and special character preservation ===\n\n#[test]\nfn preserves_wikilinks_in_existing_content() {\n    let input = r#\"# Notes\n\n- [[wikilink]]\n- [[page#section]]\n- Regular text\n\n# Other\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Notes\"),\n        \"- New item\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // Wikilinks should NOT be escaped\n    assert!(\n        result.content.contains(\"[[wikilink]]\"),\n        \"Wikilinks should be preserved, got: {}\",\n        result.content\n    );\n    assert!(\n        result.content.contains(\"[[page#section]]\"),\n        \"Wikilinks with sections should be preserved, got: {}\",\n        result.content\n    );\n}\n\n#[test]\nfn preserves_wikilinks_in_inserted_content() {\n    let input = r#\"# Notes\n\n- Existing item\n\n# Other\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Notes\"),\n        \"- [[new wikilink]]\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // Inserted wikilinks should NOT be escaped\n    assert!(\n        result.content.contains(\"[[new wikilink]]\"),\n        \"Inserted wikilinks should be preserved, got: {}\",\n        result.content\n    );\n}\n\n// === Blank line handling tests ===\n\n#[test]\nfn insert_at_end_preserves_section_separator() {\n    // This is the exact case from the user report:\n    // When inserting at end of section 1, the new text should appear\n    // after existing content, with the blank line separator maintained\n    // between sections.\n    let input = r#\"# section 1\n- content1\n- other content\n\n# another section\n- more text\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"section 1\"),\n        \"- new text\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // Expected output:\n    // # section 1\n    // - content1\n    // - other content\n    // - new text\n    //\n    // # another section\n    // - more text\n\n    let expected = r#\"# section 1\n- content1\n- other content\n- new text\n\n# another section\n- more text\n\"#;\n\n    assert_eq!(\n        result.content, expected,\n        \"\\nExpected:\\n{}\\n\\nGot:\\n{}\\n\",\n        expected, result.content\n    );\n}\n\n#[test]\nfn insert_at_end_with_multiple_blank_lines() {\n    // Multiple blank lines should be normalized to one\n    let input = \"# Section\\n- item1\\n\\n\\n\\n# Next\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Section\"),\n        \"- item2\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // New item should be right after item1, with one blank line before Next\n    assert!(result.content.contains(\"- item1\\n- item2\\n\"));\n    assert!(result.content.contains(\"\\n\\n# Next\"));\n}\n\n#[test]\nfn insert_at_end_of_last_section_no_trailing_blank() {\n    // Last section shouldn't add extra blank lines at EOF\n    let input = \"# Only Section\\n- item1\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Only Section\"),\n        \"- item2\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    assert_eq!(result.content, \"# Only Section\\n- item1\\n- item2\\n\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","template_engine.rs"],"content":"use mdvault_core::templates::engine::{RenderContext, render};\nuse mdvault_core::templates::repository::LoadedTemplate;\nuse std::path::PathBuf;\n\nfn loaded(contents: \u0026str) -\u003e LoadedTemplate {\n    LoadedTemplate {\n        logical_name: \"test\".into(),\n        path: PathBuf::from(\"test.md\"),\n        content: contents.to_string(),\n        frontmatter: None,\n        body: contents.to_string(),\n    }\n}\n\n#[test]\nfn render_replaces_known_variables() {\n    let tpl = loaded(\"Hello {{name}}!\");\n    let mut ctx = RenderContext::new();\n    ctx.insert(\"name\".into(), \"Agustin\".into());\n\n    let out = render(\u0026tpl, \u0026ctx).expect(\"render ok\");\n    assert_eq!(out, \"Hello Agustin!\");\n}\n\n#[test]\nfn render_leaves_unknown_variables_intact() {\n    let tpl = loaded(\"Hello {{name}} and {{unknown}}!\");\n    let mut ctx = RenderContext::new();\n    ctx.insert(\"name\".into(), \"Agustin\".into());\n\n    let out = render(\u0026tpl, \u0026ctx).expect(\"render ok\");\n    assert_eq!(out, \"Hello Agustin and {{unknown}}!\");\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":2}},{"line":7,"address":[],"length":0,"stats":{"Line":6}},{"line":8,"address":[],"length":0,"stats":{"Line":4}},{"line":9,"address":[],"length":0,"stats":{"Line":6}},{"line":11,"address":[],"length":0,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","templates_discovery.rs"],"content":"use mdvault_core::templates::discovery::discover_templates;\nuse std::fs;\nuse std::path::PathBuf;\nuse tempfile::tempdir;\n\nfn write(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn discovers_only_md_templates() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path().join(\"tpl\");\n\n    let a = root.join(\"daily.md\");\n    let b = root.join(\"blog\").join(\"post.md\");\n    let ignored1 = root.join(\"wiki\").join(\"topic.markdown\");\n    let ignored2 = root.join(\"weird.tpl.md\");\n    let ignored3 = root.join(\"note.txt\");\n\n    write(\u0026a, \"# daily\");\n    write(\u0026b, \"# blog\");\n    write(\u0026ignored1, \"# nope\");\n    write(\u0026ignored2, \"# nope\");\n    write(\u0026ignored3, \"# nope\");\n\n    let got = discover_templates(\u0026root).expect(\"discover ok\");\n    let names: Vec\u003cString\u003e = got.into_iter().map(|t| t.logical_name).collect();\n\n    assert_eq!(names, vec![\"blog/post\".to_string(), \"daily\".to_string(),]);\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":5}},{"line":7,"address":[],"length":0,"stats":{"Line":15}},{"line":8,"address":[],"length":0,"stats":{"Line":10}},{"line":10,"address":[],"length":0,"stats":{"Line":20}}],"covered":4,"coverable":4}]};
        var previousData = {"files":[{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","capture.rs"],"content":"use std::collections::{HashMap, HashSet};\nuse std::fs;\nuse std::path::Path;\nuse std::sync::Arc;\n\nuse crate::prompt::{collect_variables, PromptOptions};\nuse mdvault_core::captures::{CaptureRepoError, CaptureRepository, CaptureSpec};\nuse mdvault_core::config::loader::{default_config_path, ConfigLoader};\nuse mdvault_core::config::types::ResolvedConfig;\nuse mdvault_core::frontmatter::{apply_ops, parse, serialize};\nuse mdvault_core::macros::MacroRepository;\nuse mdvault_core::markdown_ast::{MarkdownAstError, MarkdownEditor, SectionMatch};\nuse mdvault_core::scripting::{run_on_update_hook, NoteContext, VaultContext};\nuse mdvault_core::templates::engine::render_string as engine_render_string;\nuse mdvault_core::templates::repository::TemplateRepository;\nuse mdvault_core::types::{TypeRegistry, TypedefRepository};\n\nuse chrono::Local;\nuse regex::Regex;\n\n/// Built-in variables that are automatically provided\nconst BUILTIN_VARS: \u0026[\u0026str] = \u0026[\n    \"date\",\n    \"time\",\n    \"datetime\",\n    \"vault_root\",\n    \"templates_dir\",\n    \"captures_dir\",\n    \"macros_dir\",\n];\n\npub fn run_list(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv capture --list\");\n            eprintln!(\"{e}\");\n            if config.is_none() {\n                eprintln!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    let repo = match CaptureRepository::new(\u0026cfg.captures_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv capture --list\");\n            eprintln!(\"{e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let captures = repo.list_all();\n    if captures.is_empty() {\n        println!(\"(no captures found)\");\n        return;\n    }\n\n    for info in captures {\n        // Try to load the capture to get its variables\n        match repo.get_by_name(\u0026info.logical_name) {\n            Ok(loaded) =\u003e {\n                let user_vars = extract_user_variables(\u0026loaded.spec);\n                if user_vars.is_empty() {\n                    println!(\"{}\", info.logical_name);\n                } else {\n                    let vars_str = user_vars.join(\", \");\n                    println!(\"{}  [{}]\", info.logical_name, vars_str);\n                }\n            }\n            Err(_) =\u003e {\n                // If we can't load it, just show the name\n                println!(\"{}  (error loading)\", info.logical_name);\n            }\n        }\n    }\n    println!(\"-- {} captures --\", captures.len());\n}\n\n/// Extract user-defined variables from a capture spec (excludes built-ins)\nfn extract_user_variables(spec: \u0026CaptureSpec) -\u003e Vec\u003cString\u003e {\n    let re = Regex::new(r\"\\{\\{([a-zA-Z0-9_]+)\\}\\}\").unwrap();\n    let builtin: HashSet\u003c\u0026str\u003e = BUILTIN_VARS.iter().copied().collect();\n\n    let mut vars = HashSet::new();\n\n    // Extract from content (if present)\n    if let Some(content) = \u0026spec.content {\n        for cap in re.captures_iter(content) {\n            let var = cap.get(1).unwrap().as_str();\n            if !builtin.contains(var) {\n                vars.insert(var.to_string());\n            }\n        }\n    }\n\n    // Extract from target file path\n    for cap in re.captures_iter(\u0026spec.target.file) {\n        let var = cap.get(1).unwrap().as_str();\n        if !builtin.contains(var) {\n            vars.insert(var.to_string());\n        }\n    }\n\n    // Extract from section (if present)\n    if let Some(section) = \u0026spec.target.section {\n        for cap in re.captures_iter(section) {\n            let var = cap.get(1).unwrap().as_str();\n            if !builtin.contains(var) {\n                vars.insert(var.to_string());\n            }\n        }\n    }\n\n    let mut sorted: Vec\u003c_\u003e = vars.into_iter().collect();\n    sorted.sort();\n    sorted\n}\n\npub fn run(\n    config: Option\u003c\u0026Path\u003e,\n    profile: Option\u003c\u0026str\u003e,\n    capture_name: \u0026str,\n    vars: \u0026[(String, String)],\n    batch: bool,\n) {\n    // 1. Load config\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv capture\");\n            eprintln!(\"{e}\");\n            if config.is_none() {\n                eprintln!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    // 2. Load capture repository\n    let repo = match CaptureRepository::new(\u0026cfg.captures_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv capture\");\n            eprintln!(\"{e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // 3. Get capture spec\n    let loaded = match repo.get_by_name(capture_name) {\n        Ok(c) =\u003e c,\n        Err(e) =\u003e match e {\n            CaptureRepoError::NotFound(name) =\u003e {\n                eprintln!(\"Capture not found: {name}\");\n                eprintln!(\"Available captures:\");\n                for c in repo.list_all() {\n                    eprintln!(\"  - {}\", c.logical_name);\n                }\n                std::process::exit(1);\n            }\n            other =\u003e {\n                eprintln!(\"Failed to load capture: {other}\");\n                std::process::exit(1);\n            }\n        },\n    };\n\n    // 4. Build render context\n    let base_ctx = build_capture_context(\u0026cfg);\n\n    // Convert provided vars to HashMap\n    let provided_vars: HashMap\u003cString, String\u003e = vars.iter().cloned().collect();\n\n    // Build content string for variable extraction (combine all templated fields)\n    let mut content_for_vars = String::new();\n    if let Some(content) = \u0026loaded.spec.content {\n        content_for_vars.push_str(content);\n    }\n    content_for_vars.push_str(\u0026loaded.spec.target.file);\n    if let Some(section) = \u0026loaded.spec.target.section {\n        content_for_vars.push_str(section);\n    }\n\n    // Collect variables (prompt for missing ones if interactive)\n    let vars_map = loaded.spec.vars.as_ref();\n    let prompt_options = PromptOptions { batch_mode: batch };\n\n    let collected = match collect_variables(\n        vars_map,\n        \u0026content_for_vars,\n        \u0026provided_vars,\n        \u0026base_ctx,\n        \u0026prompt_options,\n    ) {\n        Ok(c) =\u003e c,\n        Err(e) =\u003e {\n            eprintln!(\"Error: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Merge collected variables into context\n    let mut ctx = base_ctx;\n    for (k, v) in collected.values {\n        ctx.insert(k, v);\n    }\n\n    // 5. Render target file path\n    let target_file_raw = render_string(\u0026loaded.spec.target.file, \u0026ctx);\n    let target_file = resolve_target_path(\u0026cfg.vault_root, \u0026target_file_raw);\n\n    // 6. Read existing file or create if missing\n    let existing_content = match fs::read_to_string(\u0026target_file) {\n        Ok(content) =\u003e content,\n        Err(e)\n            if e.kind() == std::io::ErrorKind::NotFound\n                \u0026\u0026 loaded.spec.target.create_if_missing =\u003e\n        {\n            // Create the file with minimal structure\n            let content =\n                create_minimal_note(\u0026ctx, loaded.spec.target.section.as_deref());\n\n            // Ensure parent directory exists\n            if let Some(parent) = target_file.parent() {\n                if let Err(e) = fs::create_dir_all(parent) {\n                    eprintln!(\"Failed to create directory {}: {e}\", parent.display());\n                    std::process::exit(1);\n                }\n            }\n\n            // Write the new file\n            if let Err(e) = fs::write(\u0026target_file, \u0026content) {\n                eprintln!(\"Failed to create target file {}: {e}\", target_file.display());\n                std::process::exit(1);\n            }\n\n            println!(\"Created: {}\", target_file.display());\n            content\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Failed to read target file {}: {e}\", target_file.display());\n            eprintln!(\"Hint: The target file must exist before capturing to it.\");\n            eprintln!(\n                \"      Use 'create_if_missing: true' in the capture spec to auto-create.\"\n            );\n            std::process::exit(1);\n        }\n    };\n\n    // 7. Execute capture (frontmatter + content insertion)\n    let (result_content, section_info) =\n        match execute_capture_operations(\u0026existing_content, \u0026loaded.spec, \u0026ctx) {\n            Ok(r) =\u003e r,\n            Err(e) =\u003e {\n                eprintln!(\"{e}\");\n                std::process::exit(1);\n            }\n        };\n\n    // 8. Write back to file\n    if let Err(e) = fs::write(\u0026target_file, \u0026result_content) {\n        eprintln!(\"Failed to write to {}: {e}\", target_file.display());\n        std::process::exit(1);\n    }\n\n    // 9. Run on_update hook if defined for this note type\n    run_on_update_hook_if_needed(\u0026cfg, \u0026target_file, \u0026result_content);\n\n    println!(\"OK   mdv capture\");\n    println!(\"capture: {}\", capture_name);\n    println!(\"target:  {}\", target_file.display());\n    if let Some((title, level)) = section_info {\n        println!(\"section: {} (level {})\", title, level);\n    }\n    if loaded.spec.frontmatter.is_some() {\n        println!(\"frontmatter: modified\");\n    }\n}\n\n/// Run on_update hook for the target note if its type has one defined.\nfn run_on_update_hook_if_needed(cfg: \u0026ResolvedConfig, target_file: \u0026Path, content: \u0026str) {\n    // Parse frontmatter to get note type\n    let parsed = match parse(content) {\n        Ok(p) =\u003e p,\n        Err(_) =\u003e return, // Can't parse, skip hook\n    };\n\n    // Get note type from frontmatter\n    let note_type = parsed\n        .frontmatter\n        .as_ref()\n        .and_then(|fm| fm.fields.get(\"type\"))\n        .and_then(|v| match v {\n            serde_yaml::Value::String(s) =\u003e Some(s.as_str()),\n            _ =\u003e None,\n        })\n        .unwrap_or(\"none\");\n\n    // Skip if no type or \"none\" type\n    if note_type == \"none\" {\n        return;\n    }\n\n    // Load type definitions\n    let typedef_repo = match TypedefRepository::new(\u0026cfg.typedefs_dir) {\n        Ok(r) =\u003e r,\n        Err(_) =\u003e return, // Can't load types, skip hook\n    };\n\n    let registry = match TypeRegistry::from_repository(\u0026typedef_repo) {\n        Ok(r) =\u003e r,\n        Err(_) =\u003e return,\n    };\n\n    // Get type definition\n    let typedef = match registry.get(note_type) {\n        Some(td) =\u003e td,\n        None =\u003e return, // No definition for this type\n    };\n\n    // Skip if no on_update hook\n    if !typedef.has_on_update_hook {\n        return;\n    }\n\n    // Build note context\n    let frontmatter = parsed\n        .frontmatter\n        .as_ref()\n        .map(|fm| {\n            let mut map = serde_yaml::Mapping::new();\n            for (k, v) in \u0026fm.fields {\n                map.insert(serde_yaml::Value::String(k.clone()), v.clone());\n            }\n            serde_yaml::Value::Mapping(map)\n        })\n        .unwrap_or(serde_yaml::Value::Mapping(serde_yaml::Mapping::new()));\n\n    let note_ctx = NoteContext {\n        path: target_file.to_path_buf(),\n        note_type: note_type.to_string(),\n        frontmatter,\n        content: content.to_string(),\n    };\n\n    // Build vault context (with repositories for vault operations)\n    // Note: We don't need full repositories for the hook - we just need the registry\n    // Use ok() to convert Result to Option and skip if loading fails\n    let capture_repo = CaptureRepository::new(\u0026cfg.captures_dir).ok();\n    let template_repo = TemplateRepository::new(\u0026cfg.templates_dir).ok();\n    let macro_repo = MacroRepository::new(\u0026cfg.macros_dir).ok();\n\n    // If any required repository is missing, skip the hook\n    let (capture_repo, template_repo, macro_repo) =\n        match (capture_repo, template_repo, macro_repo) {\n            (Some(c), Some(t), Some(m)) =\u003e (c, t, m),\n            _ =\u003e return, // Can't create vault context without all repos\n        };\n\n    let vault_ctx = VaultContext::from_arcs(\n        Arc::new(cfg.clone()),\n        Arc::new(template_repo),\n        Arc::new(capture_repo),\n        Arc::new(macro_repo),\n        Arc::new(registry),\n    );\n\n    // Run the hook\n    match run_on_update_hook(\u0026typedef, \u0026note_ctx, vault_ctx) {\n        Ok(result) =\u003e {\n            if result.modified {\n                // Build updated document\n                let mut updated_parsed = parsed;\n\n                if let Some(serde_yaml::Value::Mapping(map)) = result.frontmatter {\n                    let mut fields = HashMap::new();\n                    for (k, v) in map {\n                        if let serde_yaml::Value::String(key) = k {\n                            fields.insert(key, v);\n                        }\n                    }\n                    updated_parsed.frontmatter =\n                        Some(mdvault_core::frontmatter::Frontmatter { fields });\n                }\n\n                if let Some(new_content) = result.content {\n                    updated_parsed.body = new_content;\n                }\n\n                // Write back\n                let final_content = serialize(\u0026updated_parsed);\n                if let Err(e) = fs::write(target_file, \u0026final_content) {\n                    eprintln!(\"Warning: Failed to apply on_update hook changes: {e}\");\n                }\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Warning: on_update hook failed: {e}\");\n        }\n    }\n}\n\n/// Execute capture operations: frontmatter modification and/or content insertion.\n/// Returns the modified content and optional section info (title, level).\nfn execute_capture_operations(\n    existing_content: \u0026str,\n    spec: \u0026CaptureSpec,\n    ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(String, Option\u003c(String, u8)\u003e), String\u003e {\n    // Parse frontmatter from existing content first\n    let mut parsed = parse(existing_content)\n        .map_err(|e| format!(\"Failed to parse frontmatter: {e}\"))?;\n    let mut section_info = None;\n\n    // Apply frontmatter operations if specified\n    if let Some(fm_ops) = \u0026spec.frontmatter {\n        parsed = apply_ops(parsed, fm_ops, ctx)\n            .map_err(|e| format!(\"Failed to apply frontmatter ops: {e}\"))?;\n    }\n\n    // Insert content if specified - operate on body only to preserve frontmatter\n    if let Some(content_template) = \u0026spec.content {\n        let section = spec.target.section.as_ref().ok_or_else(|| {\n            \"Capture has content but no target section specified\".to_string()\n        })?;\n\n        let rendered_content = render_string(content_template, ctx);\n        let section_match = SectionMatch::new(section);\n        let position = spec.target.position.clone().into();\n\n        let result = MarkdownEditor::insert_into_section(\n            \u0026parsed.body,\n            \u0026section_match,\n            \u0026rendered_content,\n            position,\n        )\n        .map_err(|e| match \u0026e {\n            MarkdownAstError::SectionNotFound(s) =\u003e {\n                let headings = MarkdownEditor::find_headings(\u0026parsed.body);\n                let mut msg = format!(\"Section not found: '{s}'\\nAvailable sections:\\n\");\n                for h in headings {\n                    msg.push_str(\u0026format!(\"  - {} (level {})\\n\", h.title, h.level));\n                }\n                msg\n            }\n            MarkdownAstError::EmptyDocument =\u003e \"Target file is empty\".to_string(),\n            MarkdownAstError::RenderError(msg) =\u003e format!(\"Markdown render error: {msg}\"),\n        })?;\n\n        section_info = Some((result.matched_heading.title, result.matched_heading.level));\n        parsed.body = result.content;\n    }\n\n    // Serialize the document (frontmatter + body)\n    let final_content = serialize(\u0026parsed);\n    Ok((final_content, section_info))\n}\n\nfn build_capture_context(cfg: \u0026ResolvedConfig) -\u003e HashMap\u003cString, String\u003e {\n    let mut ctx = HashMap::new();\n\n    // Date/time\n    let now = Local::now();\n    ctx.insert(\"date\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"time\".into(), now.format(\"%H:%M\").to_string());\n    ctx.insert(\"datetime\".into(), now.to_rfc3339());\n\n    // Config paths\n    ctx.insert(\"vault_root\".into(), cfg.vault_root.to_string_lossy().to_string());\n    ctx.insert(\"templates_dir\".into(), cfg.templates_dir.to_string_lossy().to_string());\n    ctx.insert(\"captures_dir\".into(), cfg.captures_dir.to_string_lossy().to_string());\n    ctx.insert(\"macros_dir\".into(), cfg.macros_dir.to_string_lossy().to_string());\n\n    ctx\n}\n\nfn render_string(template: \u0026str, ctx: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    // Use the engine's render_string which supports date math expressions\n    engine_render_string(template, ctx).unwrap_or_else(|_| template.to_string())\n}\n\nfn resolve_target_path(vault_root: \u0026Path, target: \u0026str) -\u003e std::path::PathBuf {\n    let path = std::path::Path::new(target);\n    if path.is_absolute() {\n        path.to_path_buf()\n    } else {\n        vault_root.join(path)\n    }\n}\n\n/// Create a minimal note structure for auto-created files.\nfn create_minimal_note(vars: \u0026HashMap\u003cString, String\u003e, section: Option\u003c\u0026str\u003e) -\u003e String {\n    let date = vars.get(\"date\").map(|s| s.as_str()).unwrap_or(\"unknown\");\n    let title = vars.get(\"title\").map(|s| s.as_str()).unwrap_or(date);\n\n    let mut content = format!(\"---\\ntype: daily\\ndate: {}\\n---\\n\\n# {}\\n\", date, title);\n\n    // Add the target section if specified\n    if let Some(section_name) = section {\n        content.push_str(\u0026format!(\"\\n## {}\\n\", section_name));\n    }\n\n    content\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":7}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":9}},{"line":65,"address":[],"length":0,"stats":{"Line":7}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":83,"address":[],"length":0,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":18}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":13}},{"line":91,"address":[],"length":0,"stats":{"Line":16}},{"line":92,"address":[],"length":0,"stats":{"Line":11}},{"line":93,"address":[],"length":0,"stats":{"Line":9}},{"line":99,"address":[],"length":0,"stats":{"Line":9}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":9}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":15}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":14}},{"line":129,"address":[],"length":0,"stats":{"Line":42}},{"line":130,"address":[],"length":0,"stats":{"Line":28}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":28}},{"line":143,"address":[],"length":0,"stats":{"Line":28}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":41}},{"line":153,"address":[],"length":0,"stats":{"Line":26}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":39}},{"line":174,"address":[],"length":0,"stats":{"Line":78}},{"line":177,"address":[],"length":0,"stats":{"Line":26}},{"line":178,"address":[],"length":0,"stats":{"Line":29}},{"line":179,"address":[],"length":0,"stats":{"Line":16}},{"line":181,"address":[],"length":0,"stats":{"Line":39}},{"line":182,"address":[],"length":0,"stats":{"Line":29}},{"line":183,"address":[],"length":0,"stats":{"Line":16}},{"line":187,"address":[],"length":0,"stats":{"Line":39}},{"line":188,"address":[],"length":0,"stats":{"Line":26}},{"line":190,"address":[],"length":0,"stats":{"Line":39}},{"line":191,"address":[],"length":0,"stats":{"Line":26}},{"line":192,"address":[],"length":0,"stats":{"Line":26}},{"line":193,"address":[],"length":0,"stats":{"Line":26}},{"line":194,"address":[],"length":0,"stats":{"Line":13}},{"line":195,"address":[],"length":0,"stats":{"Line":13}},{"line":197,"address":[],"length":0,"stats":{"Line":26}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":26}},{"line":206,"address":[],"length":0,"stats":{"Line":53}},{"line":207,"address":[],"length":0,"stats":{"Line":30}},{"line":211,"address":[],"length":0,"stats":{"Line":52}},{"line":212,"address":[],"length":0,"stats":{"Line":52}},{"line":215,"address":[],"length":0,"stats":{"Line":38}},{"line":216,"address":[],"length":0,"stats":{"Line":24}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":3}},{"line":244,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":22}},{"line":254,"address":[],"length":0,"stats":{"Line":36}},{"line":255,"address":[],"length":0,"stats":{"Line":22}},{"line":256,"address":[],"length":0,"stats":{"Line":1}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":22}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":44}},{"line":271,"address":[],"length":0,"stats":{"Line":22}},{"line":272,"address":[],"length":0,"stats":{"Line":22}},{"line":273,"address":[],"length":0,"stats":{"Line":33}},{"line":274,"address":[],"length":0,"stats":{"Line":29}},{"line":275,"address":[],"length":0,"stats":{"Line":6}},{"line":277,"address":[],"length":0,"stats":{"Line":28}},{"line":278,"address":[],"length":0,"stats":{"Line":6}},{"line":283,"address":[],"length":0,"stats":{"Line":11}},{"line":285,"address":[],"length":0,"stats":{"Line":22}},{"line":286,"address":[],"length":0,"stats":{"Line":22}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":22}},{"line":292,"address":[],"length":0,"stats":{"Line":11}},{"line":294,"address":[],"length":0,"stats":{"Line":29}},{"line":295,"address":[],"length":0,"stats":{"Line":11}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":11}},{"line":303,"address":[],"length":0,"stats":{"Line":11}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":12}},{"line":413,"address":[],"length":0,"stats":{"Line":36}},{"line":414,"address":[],"length":0,"stats":{"Line":12}},{"line":415,"address":[],"length":0,"stats":{"Line":24}},{"line":418,"address":[],"length":0,"stats":{"Line":18}},{"line":419,"address":[],"length":0,"stats":{"Line":30}},{"line":420,"address":[],"length":0,"stats":{"Line":6}},{"line":424,"address":[],"length":0,"stats":{"Line":19}},{"line":425,"address":[],"length":0,"stats":{"Line":28}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":28}},{"line":430,"address":[],"length":0,"stats":{"Line":21}},{"line":431,"address":[],"length":0,"stats":{"Line":28}},{"line":434,"address":[],"length":0,"stats":{"Line":7}},{"line":435,"address":[],"length":0,"stats":{"Line":7}},{"line":436,"address":[],"length":0,"stats":{"Line":7}},{"line":437,"address":[],"length":0,"stats":{"Line":7}},{"line":439,"address":[],"length":0,"stats":{"Line":8}},{"line":440,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":3}},{"line":442,"address":[],"length":0,"stats":{"Line":3}},{"line":443,"address":[],"length":0,"stats":{"Line":7}},{"line":444,"address":[],"length":0,"stats":{"Line":6}},{"line":446,"address":[],"length":0,"stats":{"Line":1}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":12}},{"line":453,"address":[],"length":0,"stats":{"Line":12}},{"line":457,"address":[],"length":0,"stats":{"Line":33}},{"line":458,"address":[],"length":0,"stats":{"Line":11}},{"line":461,"address":[],"length":0,"stats":{"Line":13}},{"line":462,"address":[],"length":0,"stats":{"Line":26}},{"line":465,"address":[],"length":0,"stats":{"Line":26}},{"line":466,"address":[],"length":0,"stats":{"Line":91}},{"line":467,"address":[],"length":0,"stats":{"Line":91}},{"line":468,"address":[],"length":0,"stats":{"Line":78}},{"line":471,"address":[],"length":0,"stats":{"Line":78}},{"line":472,"address":[],"length":0,"stats":{"Line":78}},{"line":473,"address":[],"length":0,"stats":{"Line":78}},{"line":474,"address":[],"length":0,"stats":{"Line":78}},{"line":476,"address":[],"length":0,"stats":{"Line":13}},{"line":479,"address":[],"length":0,"stats":{"Line":20}},{"line":481,"address":[],"length":0,"stats":{"Line":80}},{"line":484,"address":[],"length":0,"stats":{"Line":13}},{"line":485,"address":[],"length":0,"stats":{"Line":39}},{"line":486,"address":[],"length":0,"stats":{"Line":26}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":39}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}}],"covered":144,"coverable":261},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","doctor.rs"],"content":"use mdvault_core::config::loader::{default_config_path, ConfigLoader};\nuse std::path::Path;\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e) {\n    match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e {\n            println!(\"OK   mdv doctor\");\n            println!(\n                \"path: {}\",\n                config\n                    .map(|p| p.display().to_string())\n                    .unwrap_or_else(|| default_config_path().display().to_string())\n            );\n            println!(\"profile: {}\", rc.active_profile);\n            println!(\"vault_root: {}\", rc.vault_root.display());\n            println!(\"templates_dir: {}\", rc.templates_dir.display());\n            println!(\"captures_dir: {}\", rc.captures_dir.display());\n            println!(\"macros_dir: {}\", rc.macros_dir.display());\n            println!(\"security.allow_shell: {}\", rc.security.allow_shell);\n            println!(\"security.allow_http:  {}\", rc.security.allow_http);\n        }\n        Err(e) =\u003e {\n            println!(\"FAIL mdv doctor\");\n            println!(\"{e}\");\n            if config.is_none() {\n                println!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":4}},{"line":5,"address":[],"length":0,"stats":{"Line":8}},{"line":6,"address":[],"length":0,"stats":{"Line":3}},{"line":7,"address":[],"length":0,"stats":{"Line":6}},{"line":8,"address":[],"length":0,"stats":{"Line":3}},{"line":9,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":11,"address":[],"length":0,"stats":{"Line":7}},{"line":12,"address":[],"length":0,"stats":{"Line":5}},{"line":14,"address":[],"length":0,"stats":{"Line":6}},{"line":15,"address":[],"length":0,"stats":{"Line":9}},{"line":16,"address":[],"length":0,"stats":{"Line":9}},{"line":17,"address":[],"length":0,"stats":{"Line":9}},{"line":18,"address":[],"length":0,"stats":{"Line":9}},{"line":19,"address":[],"length":0,"stats":{"Line":6}},{"line":20,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":1}}],"covered":22,"coverable":22},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","links.rs"],"content":"//! Links command implementation.\n\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::IndexDb;\n\nuse super::output::{print_links_json, print_links_quiet, print_links_table, LinkOutput};\nuse crate::{LinksArgs, OutputFormat};\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: LinksArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Normalize the note path (strip leading ./)\n    let note_path = normalize_path(\u0026args.note);\n\n    // Look up the note\n    let note = match db.get_note_by_path(Path::new(\u0026note_path)) {\n        Ok(Some(n)) =\u003e n,\n        Ok(None) =\u003e {\n            eprintln!(\"Note not found in index: {}\", note_path);\n            eprintln!(\"Hint: Check the path or run 'mdv reindex'.\");\n            std::process::exit(1);\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Error looking up note: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    let note_id = note.id.expect(\"indexed note should have ID\");\n\n    // Determine what to show (both shown by default)\n    let show_backlinks = args.backlinks || !args.outlinks;\n    let show_outlinks = args.outlinks || !args.backlinks;\n\n    // Resolve output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Get and display backlinks\n    if show_backlinks {\n        match db.get_backlinks(note_id) {\n            Ok(links) =\u003e {\n                let outputs: Vec\u003cLinkOutput\u003e = links\n                    .iter()\n                    .map(|l| {\n                        // Look up source note path\n                        let source_path = db\n                            .get_note_by_id(l.source_id)\n                            .ok()\n                            .flatten()\n                            .map(|n| n.path.to_string_lossy().to_string());\n                        LinkOutput::from_link(l, source_path.as_deref())\n                    })\n                    .collect();\n\n                if show_outlinks \u0026\u0026 !matches!(format, OutputFormat::Json) {\n                    println!(\"=== Backlinks (notes linking to {}) ===\", note_path);\n                    println!();\n                }\n                match format {\n                    OutputFormat::Table =\u003e print_links_table(\u0026outputs, \"backlinks\"),\n                    OutputFormat::Json =\u003e print_links_json(\u0026outputs),\n                    OutputFormat::Quiet =\u003e print_links_quiet(\u0026outputs, true),\n                }\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Error getting backlinks: {}\", e);\n                std::process::exit(1);\n            }\n        }\n    }\n\n    // Get and display outgoing links\n    if show_outlinks {\n        match db.get_outgoing_links(note_id) {\n            Ok(links) =\u003e {\n                let outputs: Vec\u003cLinkOutput\u003e = links\n                    .iter()\n                    .map(|l| LinkOutput::from_link(l, Some(\u0026note_path)))\n                    .collect();\n\n                if show_backlinks \u0026\u0026 !matches!(format, OutputFormat::Json) {\n                    println!();\n                    println!(\"=== Outgoing links (notes {} links to) ===\", note_path);\n                    println!();\n                }\n                match format {\n                    OutputFormat::Table =\u003e print_links_table(\u0026outputs, \"outgoing links\"),\n                    OutputFormat::Json =\u003e print_links_json(\u0026outputs),\n                    OutputFormat::Quiet =\u003e print_links_quiet(\u0026outputs, false),\n                }\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Error getting outgoing links: {}\", e);\n                std::process::exit(1);\n            }\n        }\n    }\n}\n\n/// Normalize note path by removing leading ./.\nfn normalize_path(path: \u0026str) -\u003e String {\n    path.strip_prefix(\"./\").unwrap_or(path).to_string()\n}\n\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":71},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","list.rs"],"content":"//! List command implementation.\n\nuse std::path::Path;\n\nuse chrono::{DateTime, NaiveDate, NaiveTime, Utc};\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{IndexDb, NoteQuery};\nuse mdvault_core::vars::try_evaluate_date_expr;\n\nuse super::output::{print_notes_json, print_notes_quiet, print_notes_table};\nuse crate::{ListArgs, OutputFormat};\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: ListArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Build query\n    let query = NoteQuery {\n        note_type: args.r#type.map(|t| t.into()),\n        path_prefix: None,\n        modified_after: parse_date_arg(\u0026args.modified_after, \"modified-after\"),\n        modified_before: parse_date_arg(\u0026args.modified_before, \"modified-before\"),\n        limit: args.limit,\n        offset: None,\n    };\n\n    // Execute query\n    let notes = match db.query_notes(\u0026query) {\n        Ok(notes) =\u003e notes,\n        Err(e) =\u003e {\n            eprintln!(\"Error querying notes: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Determine output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Output results\n    match format {\n        OutputFormat::Table =\u003e print_notes_table(\u0026notes),\n        OutputFormat::Json =\u003e print_notes_json(\u0026notes),\n        OutputFormat::Quiet =\u003e print_notes_quiet(\u0026notes),\n    }\n}\n\n/// Parse a date argument, supporting both YYYY-MM-DD and date math expressions.\nfn parse_date_arg(arg: \u0026Option\u003cString\u003e, name: \u0026str) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n    let s = arg.as_ref()?;\n\n    // Try date math expression first (e.g., \"today - 7d\")\n    if let Some(result) = try_evaluate_date_expr(s) {\n        if let Ok(date) = NaiveDate::parse_from_str(\u0026result, \"%Y-%m-%d\") {\n            let datetime = date.and_time(NaiveTime::from_hms_opt(0, 0, 0).unwrap());\n            return Some(DateTime::from_naive_utc_and_offset(datetime, Utc));\n        }\n    }\n\n    // Try ISO date (YYYY-MM-DD)\n    if let Ok(date) = NaiveDate::parse_from_str(s, \"%Y-%m-%d\") {\n        let datetime = date.and_time(NaiveTime::from_hms_opt(0, 0, 0).unwrap());\n        return Some(DateTime::from_naive_utc_and_offset(datetime, Utc));\n    }\n\n    // Try ISO datetime (YYYY-MM-DDTHH:MM:SS)\n    if let Ok(dt) = DateTime::parse_from_rfc3339(s) {\n        return Some(dt.with_timezone(\u0026Utc));\n    }\n\n    eprintln!(\n        \"Warning: Could not parse --{} '{}'. Expected YYYY-MM-DD or date expression.\",\n        name, s\n    );\n    None\n}\n\n/// Resolve the output format from flags.\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","list_templates.rs"],"content":"use mdvault_core::config::loader::{default_config_path, ConfigLoader};\nuse mdvault_core::templates::discovery::discover_templates;\nuse std::path::Path;\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e) {\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            println!(\"FAIL mdv list-templates\");\n            println!(\"{e}\");\n            if config.is_none() {\n                println!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    match discover_templates(\u0026rc.templates_dir) {\n        Ok(list) =\u003e {\n            if list.is_empty() {\n                println!(\"(no templates found)\");\n                return;\n            }\n            for t in \u0026list {\n                println!(\"{}\", t.logical_name);\n            }\n            println!(\"-- {} templates --\", list.len());\n        }\n        Err(e) =\u003e {\n            println!(\"FAIL mdv list-templates\");\n            println!(\"{e}\");\n            std::process::exit(1);\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":1}},{"line":6,"address":[],"length":0,"stats":{"Line":3}},{"line":7,"address":[],"length":0,"stats":{"Line":2}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":7}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":9,"coverable":21},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","macro_cmd.rs"],"content":"//! Macro command implementation.\n\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse std::process::Command;\n\nuse crate::prompt::{collect_variables, PromptOptions};\nuse mdvault_core::captures::CaptureRepository;\nuse mdvault_core::config::loader::{default_config_path, ConfigLoader};\nuse mdvault_core::config::types::ResolvedConfig;\nuse mdvault_core::frontmatter::{apply_ops, parse, serialize};\nuse mdvault_core::macros::{\n    get_shell_commands, requires_trust, run_macro, CaptureStep, MacroRepoError,\n    MacroRepository, MacroRunError, MacroSpec, RunContext, RunOptions, ShellStep,\n    StepExecutor, StepResult, TemplateStep,\n};\nuse mdvault_core::markdown_ast::{MarkdownEditor, SectionMatch};\nuse mdvault_core::templates::discovery::TemplateInfo;\nuse mdvault_core::templates::engine::{\n    build_minimal_context, render_string, resolve_template_output_path,\n};\nuse mdvault_core::templates::repository::TemplateRepository;\n\nuse chrono::Local;\n\n/// List available macros.\npub fn run_list(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv macro --list\");\n            eprintln!(\"{e}\");\n            if config.is_none() {\n                eprintln!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    let repo = match MacroRepository::new(\u0026cfg.macros_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv macro --list\");\n            eprintln!(\"{e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let macros = repo.list_all();\n    if macros.is_empty() {\n        println!(\"(no macros found)\");\n        return;\n    }\n\n    for info in macros {\n        match repo.get_by_name(\u0026info.logical_name) {\n            Ok(loaded) =\u003e {\n                let trust_marker =\n                    if requires_trust(\u0026loaded.spec) { \" [requires --trust]\" } else { \"\" };\n                let desc = if loaded.spec.description.is_empty() {\n                    String::new()\n                } else {\n                    format!(\" - {}\", loaded.spec.description)\n                };\n                println!(\n                    \"{}  ({} steps){trust_marker}{desc}\",\n                    info.logical_name,\n                    loaded.spec.steps.len()\n                );\n            }\n            Err(_) =\u003e {\n                println!(\"{}  (error loading)\", info.logical_name);\n            }\n        }\n    }\n    println!(\"-- {} macros --\", macros.len());\n}\n\n/// Run a macro.\npub fn run(\n    config: Option\u003c\u0026Path\u003e,\n    profile: Option\u003c\u0026str\u003e,\n    macro_name: \u0026str,\n    vars: \u0026[(String, String)],\n    batch: bool,\n    trust: bool,\n) {\n    // 1. Load config\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv macro\");\n            eprintln!(\"{e}\");\n            if config.is_none() {\n                eprintln!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    // 2. Load macro repository\n    let repo = match MacroRepository::new(\u0026cfg.macros_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"FAIL mdv macro\");\n            eprintln!(\"{e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // 3. Get macro spec\n    let loaded = match repo.get_by_name(macro_name) {\n        Ok(m) =\u003e m,\n        Err(e) =\u003e match e {\n            MacroRepoError::NotFound(name) =\u003e {\n                eprintln!(\"Macro not found: {name}\");\n                eprintln!(\"Available macros:\");\n                for m in repo.list_all() {\n                    eprintln!(\"  - {}\", m.logical_name);\n                }\n                std::process::exit(1);\n            }\n            other =\u003e {\n                eprintln!(\"Failed to load macro: {other}\");\n                std::process::exit(1);\n            }\n        },\n    };\n\n    // 4. Check trust requirements\n    if requires_trust(\u0026loaded.spec) \u0026\u0026 !trust {\n        eprintln!(\n            \"Error: This macro contains shell commands that require the --trust flag.\"\n        );\n        eprintln!(\"Shell commands:\");\n        for cmd in get_shell_commands(\u0026loaded.spec) {\n            eprintln!(\"  $ {cmd}\");\n        }\n        eprintln!(\"\\nRun with --trust to allow shell execution.\");\n        std::process::exit(1);\n    }\n\n    // 5. Build base context\n    let base_ctx = build_macro_context(\u0026cfg);\n\n    // Convert provided vars to HashMap\n    let provided_vars: HashMap\u003cString, String\u003e = vars.iter().cloned().collect();\n\n    // Build content string for variable extraction from macro vars\n    let content_for_vars = build_vars_content(\u0026loaded.spec);\n\n    // Collect variables (prompt for missing ones if interactive)\n    let vars_map = loaded.spec.vars.as_ref();\n    let prompt_options = PromptOptions { batch_mode: batch };\n\n    let collected = match collect_variables(\n        vars_map,\n        \u0026content_for_vars,\n        \u0026provided_vars,\n        \u0026base_ctx,\n        \u0026prompt_options,\n    ) {\n        Ok(c) =\u003e c,\n        Err(e) =\u003e {\n            eprintln!(\"Error: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Merge collected variables into context\n    let mut ctx_vars = base_ctx;\n    for (k, v) in collected.values {\n        ctx_vars.insert(k, v);\n    }\n\n    // 6. Create executor with loaded repositories\n    let template_repo = match TemplateRepository::new(\u0026cfg.templates_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load templates: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let capture_repo = match CaptureRepository::new(\u0026cfg.captures_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load captures: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let executor = CliStepExecutor { config: cfg.clone(), template_repo, capture_repo };\n\n    // 7. Create run context and options\n    let run_options = RunOptions {\n        trust,\n        allow_shell: cfg.security.allow_shell || trust,\n        dry_run: false,\n    };\n\n    let run_ctx = RunContext::new(ctx_vars, run_options);\n\n    // 8. Run the macro\n    let result = run_macro(\u0026loaded, \u0026executor, run_ctx);\n\n    // 9. Print results\n    if result.success {\n        println!(\"OK   mdv macro\");\n        println!(\"macro: {}\", macro_name);\n        println!(\"steps: {} completed\", result.step_results.len());\n        for (i, step_result) in result.step_results.iter().enumerate() {\n            let status = if step_result.success { \"OK\" } else { \"FAIL\" };\n            println!(\"  [{status}] Step {}: {}\", i + 1, step_result.message);\n        }\n    } else {\n        eprintln!(\"FAIL mdv macro\");\n        eprintln!(\"macro: {}\", macro_name);\n        for (i, step_result) in result.step_results.iter().enumerate() {\n            let status = if step_result.success { \"OK\" } else { \"FAIL\" };\n            eprintln!(\"  [{status}] Step {}: {}\", i + 1, step_result.message);\n        }\n        std::process::exit(1);\n    }\n}\n\n/// Build content string for variable extraction from macro spec.\nfn build_vars_content(spec: \u0026MacroSpec) -\u003e String {\n    let mut content = String::new();\n\n    // Add macro-level vars\n    if let Some(vars) = \u0026spec.vars {\n        for (name, spec) in vars {\n            content.push_str(\u0026format!(\"{{{{{name}}}}}\"));\n            if let Some(default) = spec.default() {\n                content.push_str(default);\n            }\n        }\n    }\n\n    // Add vars from step overrides\n    for step in \u0026spec.steps {\n        match step {\n            mdvault_core::macros::MacroStep::Template(t) =\u003e {\n                for v in t.vars_with.values() {\n                    content.push_str(v);\n                }\n                if let Some(output) = \u0026t.output {\n                    content.push_str(output);\n                }\n            }\n            mdvault_core::macros::MacroStep::Capture(c) =\u003e {\n                for v in c.vars_with.values() {\n                    content.push_str(v);\n                }\n            }\n            mdvault_core::macros::MacroStep::Shell(s) =\u003e {\n                content.push_str(\u0026s.shell);\n            }\n        }\n    }\n\n    content\n}\n\nfn build_macro_context(cfg: \u0026ResolvedConfig) -\u003e HashMap\u003cString, String\u003e {\n    let mut ctx = HashMap::new();\n\n    // Date/time\n    let now = Local::now();\n    ctx.insert(\"date\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"time\".into(), now.format(\"%H:%M\").to_string());\n    ctx.insert(\"datetime\".into(), now.to_rfc3339());\n    ctx.insert(\"today\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"now\".into(), now.to_rfc3339());\n\n    // Config paths\n    ctx.insert(\"vault_root\".into(), cfg.vault_root.to_string_lossy().to_string());\n    ctx.insert(\"templates_dir\".into(), cfg.templates_dir.to_string_lossy().to_string());\n    ctx.insert(\"captures_dir\".into(), cfg.captures_dir.to_string_lossy().to_string());\n    ctx.insert(\"macros_dir\".into(), cfg.macros_dir.to_string_lossy().to_string());\n\n    ctx\n}\n\n/// CLI step executor that uses template and capture repositories.\nstruct CliStepExecutor {\n    config: ResolvedConfig,\n    template_repo: TemplateRepository,\n    capture_repo: CaptureRepository,\n}\n\nimpl StepExecutor for CliStepExecutor {\n    fn execute_template(\n        \u0026self,\n        step: \u0026TemplateStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        let step_vars = ctx.with_step_vars(\u0026step.vars_with);\n\n        // Load template\n        let loaded = self\n            .template_repo\n            .get_by_name(\u0026step.template)\n            .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n        // Build template info\n        let info = TemplateInfo {\n            logical_name: loaded.logical_name.clone(),\n            path: loaded.path.clone(),\n        };\n\n        // Resolve output path\n        let output_path = if let Some(ref output) = step.output {\n            let rendered = render_string(output, \u0026step_vars)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n            self.config.vault_root.join(\u0026rendered)\n        } else {\n            let minimal_ctx = build_minimal_context(\u0026self.config, \u0026info);\n            let mut merged_ctx = minimal_ctx;\n            for (k, v) in \u0026step_vars {\n                merged_ctx.insert(k.clone(), v.clone());\n            }\n            resolve_template_output_path(\u0026loaded, \u0026self.config, \u0026merged_ctx)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?\n                .ok_or_else(|| {\n                    MacroRunError::TemplateError(\n                        \"Template has no output path and none specified in macro\"\n                            .to_string(),\n                    )\n                })?\n        };\n\n        // Check if file exists\n        if output_path.exists() {\n            return Err(MacroRunError::TemplateError(format!(\n                \"File already exists: {}\",\n                output_path.display()\n            )));\n        }\n\n        // Render template\n        let rendered = render_string(\u0026loaded.body, \u0026step_vars)\n            .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n        // Create parent directories\n        if let Some(parent) = output_path.parent() {\n            fs::create_dir_all(parent)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n        }\n\n        // Write file\n        fs::write(\u0026output_path, \u0026rendered)\n            .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n        Ok(StepResult {\n            step_index: 0, // Will be set by runner\n            success: true,\n            message: format!(\"Created {}\", output_path.display()),\n            output_path: Some(output_path),\n        })\n    }\n\n    fn execute_capture(\n        \u0026self,\n        step: \u0026CaptureStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        let step_vars = ctx.with_step_vars(\u0026step.vars_with);\n\n        // Load capture\n        let loaded = self\n            .capture_repo\n            .get_by_name(\u0026step.capture)\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n        // Render target file path\n        let target_file_raw = render_string(\u0026loaded.spec.target.file, \u0026step_vars)\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n        let target_file = if Path::new(\u0026target_file_raw).is_absolute() {\n            PathBuf::from(\u0026target_file_raw)\n        } else {\n            self.config.vault_root.join(\u0026target_file_raw)\n        };\n\n        // Read existing file\n        let existing_content = fs::read_to_string(\u0026target_file).map_err(|e| {\n            MacroRunError::CaptureError(format!(\n                \"Failed to read {}: {e}\",\n                target_file.display()\n            ))\n        })?;\n\n        // Parse frontmatter\n        let mut parsed = parse(\u0026existing_content)\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n        // Apply frontmatter operations\n        if let Some(fm_ops) = \u0026loaded.spec.frontmatter {\n            parsed = apply_ops(parsed, fm_ops, \u0026step_vars)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n        }\n\n        // Insert content if specified\n        if let Some(content_template) = \u0026loaded.spec.content {\n            let section = loaded.spec.target.section.as_ref().ok_or_else(|| {\n                MacroRunError::CaptureError(\n                    \"Capture has content but no target section\".to_string(),\n                )\n            })?;\n\n            let rendered_content = render_string(content_template, \u0026step_vars)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n            let section_match = SectionMatch::new(section);\n            let position = loaded.spec.target.position.clone().into();\n\n            let result = MarkdownEditor::insert_into_section(\n                \u0026parsed.body,\n                \u0026section_match,\n                \u0026rendered_content,\n                position,\n            )\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n            parsed.body = result.content;\n        }\n\n        // Serialize and write\n        let final_content = serialize(\u0026parsed);\n        fs::write(\u0026target_file, \u0026final_content)\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n        Ok(StepResult {\n            step_index: 0,\n            success: true,\n            message: format!(\"Updated {}\", target_file.display()),\n            output_path: Some(target_file),\n        })\n    }\n\n    fn execute_shell(\n        \u0026self,\n        step: \u0026ShellStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        let rendered_cmd = render_string(\u0026step.shell, \u0026ctx.vars)\n            .map_err(|e| MacroRunError::ShellError(e.to_string()))?;\n\n        // Execute the command\n        let output = Command::new(\"sh\")\n            .arg(\"-c\")\n            .arg(\u0026rendered_cmd)\n            .current_dir(\u0026self.config.vault_root)\n            .output()\n            .map_err(|e| MacroRunError::ShellError(e.to_string()))?;\n\n        if output.status.success() {\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Executed: {rendered_cmd}\"),\n                output_path: None,\n            })\n        } else {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            Err(MacroRunError::ShellError(format!(\n                \"Command failed: {rendered_cmd}\\n{stderr}\"\n            )))\n        }\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":10}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":60,"address":[],"length":0,"stats":{"Line":12}},{"line":61,"address":[],"length":0,"stats":{"Line":12}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":8}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":8}},{"line":81,"address":[],"length":0,"stats":{"Line":7}},{"line":90,"address":[],"length":0,"stats":{"Line":21}},{"line":91,"address":[],"length":0,"stats":{"Line":14}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":14}},{"line":104,"address":[],"length":0,"stats":{"Line":14}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":20}},{"line":114,"address":[],"length":0,"stats":{"Line":12}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":13}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":15}},{"line":148,"address":[],"length":0,"stats":{"Line":30}},{"line":151,"address":[],"length":0,"stats":{"Line":15}},{"line":154,"address":[],"length":0,"stats":{"Line":15}},{"line":155,"address":[],"length":0,"stats":{"Line":10}},{"line":157,"address":[],"length":0,"stats":{"Line":15}},{"line":158,"address":[],"length":0,"stats":{"Line":10}},{"line":159,"address":[],"length":0,"stats":{"Line":10}},{"line":160,"address":[],"length":0,"stats":{"Line":10}},{"line":161,"address":[],"length":0,"stats":{"Line":5}},{"line":162,"address":[],"length":0,"stats":{"Line":5}},{"line":164,"address":[],"length":0,"stats":{"Line":10}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":10}},{"line":173,"address":[],"length":0,"stats":{"Line":29}},{"line":174,"address":[],"length":0,"stats":{"Line":18}},{"line":178,"address":[],"length":0,"stats":{"Line":10}},{"line":179,"address":[],"length":0,"stats":{"Line":10}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":10}},{"line":187,"address":[],"length":0,"stats":{"Line":10}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":20}},{"line":199,"address":[],"length":0,"stats":{"Line":10}},{"line":203,"address":[],"length":0,"stats":{"Line":20}},{"line":206,"address":[],"length":0,"stats":{"Line":25}},{"line":209,"address":[],"length":0,"stats":{"Line":5}},{"line":210,"address":[],"length":0,"stats":{"Line":10}},{"line":211,"address":[],"length":0,"stats":{"Line":10}},{"line":212,"address":[],"length":0,"stats":{"Line":20}},{"line":213,"address":[],"length":0,"stats":{"Line":22}},{"line":214,"address":[],"length":0,"stats":{"Line":18}},{"line":215,"address":[],"length":0,"stats":{"Line":18}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":5}},{"line":230,"address":[],"length":0,"stats":{"Line":10}},{"line":233,"address":[],"length":0,"stats":{"Line":10}},{"line":234,"address":[],"length":0,"stats":{"Line":23}},{"line":235,"address":[],"length":0,"stats":{"Line":18}},{"line":236,"address":[],"length":0,"stats":{"Line":8}},{"line":237,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":17}},{"line":244,"address":[],"length":0,"stats":{"Line":6}},{"line":245,"address":[],"length":0,"stats":{"Line":4}},{"line":246,"address":[],"length":0,"stats":{"Line":10}},{"line":247,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":5}},{"line":267,"address":[],"length":0,"stats":{"Line":5}},{"line":268,"address":[],"length":0,"stats":{"Line":10}},{"line":271,"address":[],"length":0,"stats":{"Line":10}},{"line":272,"address":[],"length":0,"stats":{"Line":35}},{"line":273,"address":[],"length":0,"stats":{"Line":35}},{"line":274,"address":[],"length":0,"stats":{"Line":30}},{"line":275,"address":[],"length":0,"stats":{"Line":35}},{"line":276,"address":[],"length":0,"stats":{"Line":30}},{"line":279,"address":[],"length":0,"stats":{"Line":30}},{"line":280,"address":[],"length":0,"stats":{"Line":30}},{"line":281,"address":[],"length":0,"stats":{"Line":30}},{"line":282,"address":[],"length":0,"stats":{"Line":30}},{"line":284,"address":[],"length":0,"stats":{"Line":5}},{"line":295,"address":[],"length":0,"stats":{"Line":4}},{"line":300,"address":[],"length":0,"stats":{"Line":16}},{"line":303,"address":[],"length":0,"stats":{"Line":8}},{"line":304,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":8}},{"line":306,"address":[],"length":0,"stats":{"Line":4}},{"line":310,"address":[],"length":0,"stats":{"Line":12}},{"line":311,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":8}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":16}},{"line":321,"address":[],"length":0,"stats":{"Line":8}},{"line":322,"address":[],"length":0,"stats":{"Line":172}},{"line":323,"address":[],"length":0,"stats":{"Line":210}},{"line":325,"address":[],"length":0,"stats":{"Line":16}},{"line":326,"address":[],"length":0,"stats":{"Line":4}},{"line":327,"address":[],"length":0,"stats":{"Line":4}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":4}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":16}},{"line":345,"address":[],"length":0,"stats":{"Line":4}},{"line":348,"address":[],"length":0,"stats":{"Line":8}},{"line":349,"address":[],"length":0,"stats":{"Line":8}},{"line":350,"address":[],"length":0,"stats":{"Line":4}},{"line":354,"address":[],"length":0,"stats":{"Line":12}},{"line":355,"address":[],"length":0,"stats":{"Line":4}},{"line":357,"address":[],"length":0,"stats":{"Line":4}},{"line":358,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":4}},{"line":360,"address":[],"length":0,"stats":{"Line":12}},{"line":361,"address":[],"length":0,"stats":{"Line":4}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":370,"address":[],"length":0,"stats":{"Line":8}},{"line":373,"address":[],"length":0,"stats":{"Line":4}},{"line":374,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":4}},{"line":376,"address":[],"length":0,"stats":{"Line":2}},{"line":379,"address":[],"length":0,"stats":{"Line":8}},{"line":380,"address":[],"length":0,"stats":{"Line":2}},{"line":381,"address":[],"length":0,"stats":{"Line":6}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":4}},{"line":388,"address":[],"length":0,"stats":{"Line":8}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":6}},{"line":397,"address":[],"length":0,"stats":{"Line":2}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":4}},{"line":407,"address":[],"length":0,"stats":{"Line":8}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":8}},{"line":414,"address":[],"length":0,"stats":{"Line":2}},{"line":415,"address":[],"length":0,"stats":{"Line":6}},{"line":416,"address":[],"length":0,"stats":{"Line":8}},{"line":419,"address":[],"length":0,"stats":{"Line":2}},{"line":420,"address":[],"length":0,"stats":{"Line":2}},{"line":421,"address":[],"length":0,"stats":{"Line":2}},{"line":422,"address":[],"length":0,"stats":{"Line":2}},{"line":424,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":4}},{"line":430,"address":[],"length":0,"stats":{"Line":6}},{"line":431,"address":[],"length":0,"stats":{"Line":6}},{"line":432,"address":[],"length":0,"stats":{"Line":2}},{"line":434,"address":[],"length":0,"stats":{"Line":2}},{"line":435,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":6}},{"line":438,"address":[],"length":0,"stats":{"Line":2}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}}],"covered":163,"coverable":242},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","mod.rs"],"content":"pub mod capture;\npub mod doctor;\npub mod links;\npub mod list;\npub mod list_templates;\npub mod macro_cmd;\npub mod new;\npub mod orphans;\npub mod output;\npub mod project;\npub mod reindex;\npub mod rename;\npub mod search;\npub mod stale;\npub mod task;\npub mod validate;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","new.rs"],"content":"use crate::prompt::{prompt_for_field, CollectedVars, PromptOptions};\nuse crate::NewArgs;\nuse dialoguer::{theme::ColorfulTheme, Editor, Input, Select};\nuse mdvault_core::captures::CaptureRepository;\nuse mdvault_core::config::loader::{default_config_path, ConfigLoader};\nuse mdvault_core::config::types::ResolvedConfig;\nuse mdvault_core::frontmatter::parse as parse_frontmatter;\nuse mdvault_core::ids::{generate_project_id, generate_task_id};\nuse mdvault_core::index::{IndexBuilder, IndexDb, NoteQuery, NoteType};\nuse mdvault_core::macros::MacroRepository;\nuse mdvault_core::scripting::{\n    run_on_create_hook, HookResult, NoteContext, VaultContext,\n};\nuse mdvault_core::templates::discovery::TemplateInfo;\nuse mdvault_core::templates::engine::{\n    build_minimal_context, render, render_string, resolve_template_output_path,\n};\nuse mdvault_core::templates::repository::{TemplateRepoError, TemplateRepository};\nuse mdvault_core::types::{\n    discovery::load_typedef_from_file, generate_scaffolding, get_missing_required_fields,\n    TypeDefinition, TypeRegistry, TypedefRepository,\n};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n/// Core metadata that must be preserved in notes regardless of template/hook modifications.\n/// These fields are managed by mdvault and should not be removed or overwritten by user code.\n#[derive(Debug, Clone, Default)]\nstruct CoreMetadata {\n    /// Note type (project, task, etc.)\n    note_type: Option\u003cString\u003e,\n    /// Title of the note\n    title: Option\u003cString\u003e,\n    /// Project ID (for projects)\n    project_id: Option\u003cString\u003e,\n    /// Task ID (for tasks)\n    task_id: Option\u003cString\u003e,\n    /// Task counter (for projects)\n    task_counter: Option\u003cu32\u003e,\n    /// Parent project (for tasks)\n    project: Option\u003cString\u003e,\n}\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: NewArgs) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            println!(\"FAIL mdv new\");\n            println!(\"{e}\");\n            if config.is_none() {\n                println!(\"looked for: {}\", default_config_path().display());\n            }\n            std::process::exit(1);\n        }\n    };\n\n    // Decide between template mode and type-based scaffolding\n    if let Some(ref template_name) = args.template {\n        // Template mode (existing behavior)\n        run_template_mode(\u0026cfg, template_name, \u0026args);\n    } else if let Some(ref type_name) = args.note_type {\n        // Type-based scaffolding mode\n        run_scaffolding_mode(\u0026cfg, type_name, \u0026args);\n    } else {\n        eprintln!(\"Error: either provide a type name or use --template\");\n        eprintln!(\"Usage: mdv new \u003ctype\u003e [title] [--var field=value]\");\n        eprintln!(\"       mdv new --template \u003cname\u003e [--var key=value]\");\n        std::process::exit(1);\n    }\n}\n\n/// Run template-based note creation (existing behavior).\nfn run_template_mode(cfg: \u0026ResolvedConfig, template_name: \u0026str, args: \u0026NewArgs) {\n    let repo = match TemplateRepository::new(\u0026cfg.templates_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            println!(\"FAIL mdv new\");\n            println!(\"{e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let loaded = match repo.get_by_name(template_name) {\n        Ok(t) =\u003e t,\n        Err(e) =\u003e match e {\n            TemplateRepoError::NotFound(name) =\u003e {\n                eprintln!(\"Template not found: {name}\");\n                std::process::exit(1);\n            }\n            other =\u003e {\n                eprintln!(\"Failed to load template: {other}\");\n                std::process::exit(1);\n            }\n        },\n    };\n\n    // Build TemplateInfo for context building\n    let info = TemplateInfo {\n        logical_name: loaded.logical_name.clone(),\n        path: loaded.path.clone(),\n    };\n\n    // Check if template links to a Lua script\n    let lua_typedef: Option\u003cTypeDefinition\u003e =\n        loaded.frontmatter.as_ref().and_then(|fm| fm.lua.as_ref()).and_then(|lua_path| {\n            // Resolve lua path relative to typedefs directory\n            let lua_file = cfg.typedefs_dir.join(lua_path);\n            match load_typedef_from_file(\u0026lua_file) {\n                Ok(td) =\u003e Some(td),\n                Err(e) =\u003e {\n                    eprintln!(\"Warning: failed to load Lua script '{}': {}\", lua_path, e);\n                    None\n                }\n            }\n        });\n\n    // Convert provided vars to HashMap\n    let mut provided_vars: HashMap\u003cString, String\u003e = args.vars.iter().cloned().collect();\n\n    // Handle title: In template mode, the first positional arg (note_type) is actually the title\n    // since --template replaces the type name. Also check args.title for completeness.\n    let title = args.title.clone().or_else(|| args.note_type.clone());\n    if let Some(ref t) = title {\n        provided_vars.entry(\"title\".to_string()).or_insert(t.clone());\n    }\n\n    // For task templates: show project picker if project not already provided\n    if template_name == \"task\" \u0026\u0026 !provided_vars.contains_key(\"project\") \u0026\u0026 !args.batch {\n        if let Some(project) = prompt_project_selection(cfg) {\n            provided_vars.insert(\"project\".to_string(), project);\n        }\n    }\n\n    // Build minimal context for variable resolution\n    let minimal_ctx = build_minimal_context(cfg, \u0026info);\n\n    // Collect variables using Lua schema prompts\n    let prompt_options = PromptOptions { batch_mode: args.batch };\n\n    let collected = if let Some(ref typedef) = lua_typedef {\n        // Use Lua schema for prompting - fields with `prompt` set will be prompted\n        match collect_schema_variables(typedef, \u0026provided_vars, \u0026prompt_options) {\n            Ok(c) =\u003e c,\n            Err(e) =\u003e {\n                eprintln!(\"Error: {e}\");\n                std::process::exit(1);\n            }\n        }\n    } else {\n        // No Lua script - just use provided vars directly\n        CollectedVars {\n            values: provided_vars.clone(),\n            prompted: Vec::new(),\n            defaulted: Vec::new(),\n        }\n    };\n\n    // Merge collected variables into context\n    let mut ctx = minimal_ctx;\n    for (k, v) in collected.values {\n        ctx.insert(k, v);\n    }\n\n    // Resolve output path: CLI arg \u003e template frontmatter \u003e Lua typedef output\n    let output_path = if let Some(ref out) = args.output {\n        out.clone()\n    } else {\n        // Try to get from template frontmatter first\n        match resolve_template_output_path(\u0026loaded, cfg, \u0026ctx) {\n            Ok(Some(path)) =\u003e path,\n            Ok(None) =\u003e {\n                // Fall back to Lua typedef output if available\n                if let Some(ref typedef) = lua_typedef {\n                    if let Some(ref output_template) = typedef.output {\n                        // Render the output template with current context\n                        match render_output_path(output_template, cfg, \u0026ctx) {\n                            Ok(path) =\u003e path,\n                            Err(e) =\u003e {\n                                eprintln!(\"Failed to resolve Lua output path: {e}\");\n                                std::process::exit(1);\n                            }\n                        }\n                    } else {\n                        eprintln!(\n                            \"Error: --output is required (neither template nor Lua script has output)\"\n                        );\n                        std::process::exit(1);\n                    }\n                } else {\n                    eprintln!(\n                        \"Error: --output is required (template has no output in frontmatter)\"\n                    );\n                    std::process::exit(1);\n                }\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Failed to resolve output path: {e}\");\n                std::process::exit(1);\n            }\n        }\n    };\n\n    // Update context with output info\n    let output_abs = if output_path.is_absolute() {\n        output_path.clone()\n    } else {\n        std::env::current_dir()\n            .unwrap_or_else(|_| std::path::PathBuf::from(\".\"))\n            .join(\u0026output_path)\n    };\n    ctx.insert(\"output_path\".to_string(), output_abs.to_string_lossy().to_string());\n    if let Some(name) = output_abs.file_name().and_then(|s| s.to_str()) {\n        ctx.insert(\"output_filename\".to_string(), name.to_string());\n    }\n    if let Some(parent) = output_abs.parent() {\n        ctx.insert(\"output_dir\".to_string(), parent.to_string_lossy().to_string());\n    }\n\n    if output_path.exists() {\n        eprintln!(\n            \"Refusing to overwrite existing file: {} (add --force later if needed)\",\n            output_path.display()\n        );\n        std::process::exit(1);\n    }\n\n    let rendered = match render(\u0026loaded, \u0026ctx) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to render template: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    if let Some(parent) = output_path.parent() {\n        if let Err(e) = fs::create_dir_all(parent) {\n            eprintln!(\"Failed to create parent directory {}: {e}\", parent.display());\n            std::process::exit(1);\n        }\n    }\n\n    if let Err(e) = fs::write(\u0026output_path, \u0026rendered) {\n        eprintln!(\"Failed to write output file {}: {e}\", output_path.display());\n        std::process::exit(1);\n    }\n\n    // Execute on_create hook if type definition exists\n    match run_on_create_hook_if_exists(cfg, \u0026output_path, \u0026rendered) {\n        Ok(hook_result) =\u003e {\n            if hook_result.modified {\n                if let Err(e) =\n                    apply_hook_modifications(\u0026output_path, \u0026rendered, \u0026hook_result)\n                {\n                    eprintln!(\n                        \"Warning: failed to apply on_create hook modifications: {e}\"\n                    );\n                }\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Warning: on_create hook failed: {e}\");\n        }\n    }\n\n    // Log to daily note for tasks and projects\n    // Note: In template mode, we don't auto-generate IDs (user should use scaffolding mode for that)\n    // But we still log to daily with whatever ID might be in the context\n    if template_name == \"task\" || template_name == \"project\" {\n        let title = ctx.get(\"title\").cloned().unwrap_or_else(|| \"Untitled\".to_string());\n        let note_id = ctx\n            .get(\"task-id\")\n            .or_else(|| ctx.get(\"project-id\"))\n            .cloned()\n            .unwrap_or_default();\n        log_to_daily(cfg, template_name, \u0026title, \u0026note_id, \u0026output_path);\n\n        // Force reindex so the new note appears in queries\n        reindex_vault(cfg);\n    }\n\n    println!(\"OK   mdv new\");\n    println!(\"template: {}\", template_name);\n    println!(\"output:   {}\", output_path.display());\n}\n\n/// Run type-based scaffolding mode.\nfn run_scaffolding_mode(cfg: \u0026ResolvedConfig, type_name: \u0026str, args: \u0026NewArgs) {\n    // Load type registry\n    let typedef_repo = match TypedefRepository::new(\u0026cfg.typedefs_dir) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load type definitions: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let type_registry = match TypeRegistry::from_repository(\u0026typedef_repo) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to build type registry: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Check if type is known\n    if !type_registry.is_known_type(type_name) {\n        eprintln!(\"Unknown type: {type_name}\");\n        eprintln!(\"Available types:\");\n        for t in type_registry.list_all_types() {\n            eprintln!(\"  {t}\");\n        }\n        std::process::exit(1);\n    }\n\n    // Get type definition (may be None for built-in types without Lua override)\n    let typedef = type_registry.get(type_name);\n\n    // Check if there's a matching template\n    let template_repo = TemplateRepository::new(\u0026cfg.templates_dir).ok();\n    let loaded_template =\n        template_repo.as_ref().and_then(|repo| repo.get_by_name(type_name).ok());\n\n    // For non-project/task types with templates, delegate to template mode\n    // For projects and tasks, we ALWAYS use scaffolding mode to ensure proper ID generation\n    if loaded_template.is_some() \u0026\u0026 type_name != \"project\" \u0026\u0026 type_name != \"task\" {\n        run_template_mode(cfg, type_name, args);\n        return;\n    }\n\n    // Get title (required for scaffolding)\n    let title = match \u0026args.title {\n        Some(t) =\u003e t.clone(),\n        None =\u003e {\n            if args.batch {\n                eprintln!(\"Error: title is required in batch mode\");\n                eprintln!(\"Usage: mdv new {type_name} \\\"Title\\\"\");\n                std::process::exit(1);\n            }\n            // Prompt for title\n            match prompt_for_field(\"title\", \"Note title\", None, true) {\n                Ok(t) =\u003e t,\n                Err(e) =\u003e {\n                    eprintln!(\"Error: {e}\");\n                    std::process::exit(1);\n                }\n            }\n        }\n    };\n\n    // Collect vars from command line\n    let mut vars: HashMap\u003cString, String\u003e = args.vars.iter().cloned().collect();\n\n    // Handle project creation with ID generation\n    let (output_path, note_id) = if type_name == \"project\" {\n        // Compute default project ID from title\n        let computed_id = generate_project_id(\u0026title);\n\n        // Prompt for project ID with computed value as default (unless batch mode)\n        let project_id = if args.batch {\n            computed_id\n        } else {\n            match prompt_for_field(\n                \"project-id\",\n                \"Project ID (3-letter code)\",\n                Some(\u0026computed_id),\n                true,\n            ) {\n                Ok(id) if !id.is_empty() =\u003e id.to_uppercase(),\n                Ok(_) =\u003e computed_id, // Empty input uses computed default\n                Err(e) =\u003e {\n                    eprintln!(\"Error: {e}\");\n                    std::process::exit(1);\n                }\n            }\n        };\n\n        vars.insert(\"project-id\".to_string(), project_id.clone());\n        vars.insert(\"task_counter\".to_string(), \"0\".to_string());\n        vars.insert(\"title\".to_string(), title.clone());\n\n        let path = if let Some(ref out) = args.output {\n            out.clone()\n        } else if let Some(ref td) = typedef {\n            // Use Lua typedef's output template if available\n            if let Some(ref output_template) = td.output {\n                match render_output_path(output_template, cfg, \u0026vars) {\n                    Ok(p) =\u003e p,\n                    Err(e) =\u003e {\n                        eprintln!(\"Warning: failed to render Lua output path: {e}\");\n                        // Fall back to default\n                        cfg.vault_root\n                            .join(format!(\"Projects/{}/{}.md\", project_id, project_id))\n                    }\n                }\n            } else {\n                // No output template in Lua, use default\n                cfg.vault_root.join(format!(\"Projects/{}/{}.md\", project_id, project_id))\n            }\n        } else {\n            // No typedef, use default\n            cfg.vault_root.join(format!(\"Projects/{}/{}.md\", project_id, project_id))\n        };\n        (path, project_id)\n    } else if type_name == \"task\" {\n        // For tasks: prompt for project selection if not already provided\n        let project_folder = if let Some(proj) = vars.get(\"project\").cloned() {\n            proj\n        } else if !args.batch {\n            match prompt_project_selection(cfg) {\n                Some(proj) =\u003e {\n                    vars.insert(\"project\".to_string(), proj.clone());\n                    proj\n                }\n                None =\u003e \"inbox\".to_string(),\n            }\n        } else {\n            \"inbox\".to_string()\n        };\n\n        // Add title to vars for output path rendering\n        vars.insert(\"title\".to_string(), title.clone());\n\n        // Get project info and generate task ID\n        let (task_id, output_path) = if project_folder == \"inbox\" {\n            // Inbox tasks get a simple incremental ID\n            let task_id = generate_inbox_task_id(cfg);\n            vars.insert(\"task-id\".to_string(), task_id.clone());\n            let path = if let Some(ref out) = args.output {\n                out.clone()\n            } else if let Some(ref td) = typedef {\n                // Use Lua typedef's output template if available\n                if let Some(ref output_template) = td.output {\n                    match render_output_path(output_template, cfg, \u0026vars) {\n                        Ok(p) =\u003e p,\n                        Err(e) =\u003e {\n                            eprintln!(\"Warning: failed to render Lua output path: {e}\");\n                            cfg.vault_root.join(format!(\"Inbox/{}.md\", task_id))\n                        }\n                    }\n                } else {\n                    cfg.vault_root.join(format!(\"Inbox/{}.md\", task_id))\n                }\n            } else {\n                cfg.vault_root.join(format!(\"Inbox/{}.md\", task_id))\n            };\n            (task_id, path)\n        } else {\n            // Get project's task counter and increment it\n            match get_and_increment_project_counter(cfg, \u0026project_folder) {\n                Ok((project_id, counter)) =\u003e {\n                    let task_id = generate_task_id(\u0026project_id, counter);\n                    vars.insert(\"task-id\".to_string(), task_id.clone());\n                    vars.insert(\"project-id\".to_string(), project_id.clone());\n                    let path = if let Some(ref out) = args.output {\n                        out.clone()\n                    } else if let Some(ref td) = typedef {\n                        // Use Lua typedef's output template if available\n                        if let Some(ref output_template) = td.output {\n                            match render_output_path(output_template, cfg, \u0026vars) {\n                                Ok(p) =\u003e p,\n                                Err(e) =\u003e {\n                                    eprintln!(\n                                        \"Warning: failed to render Lua output path: {e}\"\n                                    );\n                                    cfg.vault_root.join(format!(\n                                        \"Projects/{}/Tasks/{}.md\",\n                                        project_folder, task_id\n                                    ))\n                                }\n                            }\n                        } else {\n                            cfg.vault_root.join(format!(\n                                \"Projects/{}/Tasks/{}.md\",\n                                project_folder, task_id\n                            ))\n                        }\n                    } else {\n                        cfg.vault_root.join(format!(\n                            \"Projects/{}/Tasks/{}.md\",\n                            project_folder, task_id\n                        ))\n                    };\n                    (task_id, path)\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"Warning: could not get project info: {e}\");\n                    // Fall back to inbox-style ID\n                    let task_id = generate_inbox_task_id(cfg);\n                    vars.insert(\"task-id\".to_string(), task_id.clone());\n                    let path = if let Some(ref td) = typedef {\n                        if let Some(ref output_template) = td.output {\n                            match render_output_path(output_template, cfg, \u0026vars) {\n                                Ok(p) =\u003e p,\n                                Err(_) =\u003e cfg.vault_root.join(format!(\n                                    \"Projects/{}/Tasks/{}.md\",\n                                    project_folder, task_id\n                                )),\n                            }\n                        } else {\n                            cfg.vault_root.join(format!(\n                                \"Projects/{}/Tasks/{}.md\",\n                                project_folder, task_id\n                            ))\n                        }\n                    } else {\n                        cfg.vault_root.join(format!(\n                            \"Projects/{}/Tasks/{}.md\",\n                            project_folder, task_id\n                        ))\n                    };\n                    (task_id, path)\n                }\n            }\n        };\n        (output_path, task_id)\n    } else {\n        // Other types use default output path\n        let path = if let Some(ref out) = args.output {\n            out.clone()\n        } else {\n            cfg.vault_root.join(format!(\"{}s/{}.md\", type_name, slugify(\u0026title)))\n        };\n        (path, String::new())\n    };\n\n    // Build core metadata for projects and tasks\n    // This will be used to ensure these fields survive template/hook modifications\n    let core_metadata = if type_name == \"project\" {\n        CoreMetadata {\n            note_type: Some(\"project\".to_string()),\n            title: Some(title.clone()),\n            project_id: vars.get(\"project-id\").cloned(),\n            task_counter: Some(0),\n            ..Default::default()\n        }\n    } else if type_name == \"task\" {\n        CoreMetadata {\n            note_type: Some(\"task\".to_string()),\n            title: Some(title.clone()),\n            task_id: vars.get(\"task-id\").cloned(),\n            project: vars.get(\"project\").cloned(),\n            ..Default::default()\n        }\n    } else {\n        CoreMetadata::default()\n    };\n\n    // Prompt for missing required fields\n    if let Some(ref td) = typedef {\n        let missing = get_missing_required_fields(td, \u0026vars);\n\n        if !missing.is_empty() {\n            if args.batch {\n                eprintln!(\"Error: missing required fields:\");\n                for (field, schema) in \u0026missing {\n                    let type_hint = schema\n                        .field_type\n                        .map(|t| t.to_string())\n                        .unwrap_or_else(|| \"string\".to_string());\n                    eprintln!(\"  {} ({})\", field, type_hint);\n                }\n                std::process::exit(1);\n            }\n\n            // Prompt for each missing field\n            for (field, schema) in missing {\n                let type_hint = schema\n                    .field_type\n                    .map(|t| t.to_string())\n                    .unwrap_or_else(|| \"string\".to_string());\n\n                let prompt = if let Some(ref desc) = schema.description {\n                    format!(\"{} ({})\", desc, type_hint)\n                } else {\n                    format!(\"{} ({})\", field, type_hint)\n                };\n\n                // For enums, show available values\n                let enum_hint = schema.enum_values.as_ref().map(|v| v.join(\"/\"));\n\n                match prompt_for_field(field, \u0026prompt, enum_hint.as_deref(), true) {\n                    Ok(value) =\u003e {\n                        vars.insert(field.clone(), value);\n                    }\n                    Err(e) =\u003e {\n                        eprintln!(\"Error: {e}\");\n                        std::process::exit(1);\n                    }\n                }\n            }\n        }\n    }\n\n    if output_path.exists() {\n        eprintln!(\"Refusing to overwrite existing file: {}\", output_path.display());\n        std::process::exit(1);\n    }\n\n    // Generate content - use template if available, otherwise scaffolding\n    // For projects/tasks, we'll ensure core metadata is preserved either way\n    let content = if let Some(ref loaded) = loaded_template {\n        // Build context for template rendering\n        let info = TemplateInfo {\n            logical_name: loaded.logical_name.clone(),\n            path: loaded.path.clone(),\n        };\n        let mut ctx = build_minimal_context(cfg, \u0026info);\n\n        // Add all vars to context\n        ctx.insert(\"title\".to_string(), title.clone());\n        for (k, v) in \u0026vars {\n            ctx.insert(k.clone(), v.clone());\n        }\n\n        // Update context with output info\n        ctx.insert(\"output_path\".to_string(), output_path.to_string_lossy().to_string());\n        if let Some(name) = output_path.file_name().and_then(|s| s.to_str()) {\n            ctx.insert(\"output_filename\".to_string(), name.to_string());\n        }\n\n        // Render template\n        match render(loaded, \u0026ctx) {\n            Ok(rendered) =\u003e rendered,\n            Err(e) =\u003e {\n                eprintln!(\"Failed to render template: {e}\");\n                eprintln!(\"Falling back to scaffolding...\");\n                generate_scaffolding(type_name, typedef.as_deref(), \u0026title, \u0026vars)\n            }\n        }\n    } else {\n        generate_scaffolding(type_name, typedef.as_deref(), \u0026title, \u0026vars)\n    };\n\n    // Apply core metadata immediately after content generation (before writing)\n    // This ensures template output has the required fields\n    let content = if type_name == \"project\" || type_name == \"task\" {\n        match ensure_core_metadata(\u0026content, \u0026core_metadata) {\n            Ok(fixed) =\u003e fixed,\n            Err(e) =\u003e {\n                eprintln!(\"Warning: failed to apply core metadata: {e}\");\n                content\n            }\n        }\n    } else {\n        content\n    };\n\n    // Create parent directories\n    if let Some(parent) = output_path.parent() {\n        if let Err(e) = fs::create_dir_all(parent) {\n            eprintln!(\"Failed to create parent directory {}: {e}\", parent.display());\n            std::process::exit(1);\n        }\n    }\n\n    // Write file\n    if let Err(e) = fs::write(\u0026output_path, \u0026content) {\n        eprintln!(\"Failed to write output file {}: {e}\", output_path.display());\n        std::process::exit(1);\n    }\n\n    // Execute on_create hook if defined\n    match run_on_create_hook_if_exists(cfg, \u0026output_path, \u0026content) {\n        Ok(hook_result) =\u003e {\n            if hook_result.modified {\n                if let Err(e) =\n                    apply_hook_modifications(\u0026output_path, \u0026content, \u0026hook_result)\n                {\n                    eprintln!(\n                        \"Warning: failed to apply on_create hook modifications: {e}\"\n                    );\n                }\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Warning: on_create hook failed: {e}\");\n        }\n    }\n\n    // Ensure core metadata is preserved after template/hook modifications\n    // This guarantees that projects have project-id and tasks have task-id\n    if type_name == \"project\" || type_name == \"task\" {\n        match fs::read_to_string(\u0026output_path) {\n            Ok(current_content) =\u003e {\n                match ensure_core_metadata(\u0026current_content, \u0026core_metadata) {\n                    Ok(fixed_content) =\u003e {\n                        if let Err(e) = fs::write(\u0026output_path, fixed_content) {\n                            eprintln!(\"Warning: failed to write core metadata: {e}\");\n                        }\n                    }\n                    Err(e) =\u003e {\n                        eprintln!(\"Warning: failed to ensure core metadata: {e}\");\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Warning: failed to read file for metadata check: {e}\");\n            }\n        }\n    }\n\n    // Log to daily note for tasks and projects\n    if type_name == \"task\" || type_name == \"project\" {\n        log_to_daily(cfg, type_name, \u0026title, \u0026note_id, \u0026output_path);\n    }\n\n    // Force reindex so the new note appears in queries\n    reindex_vault(cfg);\n\n    println!(\"OK   mdv new\");\n    println!(\"type:   {}\", type_name);\n    if !note_id.is_empty() {\n        println!(\"id:     {}\", note_id);\n    }\n    println!(\"output: {}\", output_path.display());\n}\n\n/// Slugify a string for use in paths.\nfn slugify(s: \u0026str) -\u003e String {\n    let mut result = String::with_capacity(s.len());\n    for c in s.chars() {\n        if c.is_ascii_alphanumeric() {\n            result.push(c.to_ascii_lowercase());\n        } else if (c == ' ' || c == '_' || c == '-') \u0026\u0026 !result.ends_with('-') {\n            result.push('-');\n        }\n    }\n    result.trim_matches('-').to_string()\n}\n\n/// Ensure core metadata fields are present in the note content.\n///\n/// This function is called after template rendering and hook execution to guarantee\n/// that required fields managed by mdvault are not removed or corrupted by user code.\n/// Templates and hooks can ADD fields but cannot REMOVE core fields.\nfn ensure_core_metadata(content: \u0026str, core: \u0026CoreMetadata) -\u003e Result\u003cString, String\u003e {\n    let parsed = parse_frontmatter(content).map_err(|e| e.to_string())?;\n\n    // Start with existing frontmatter or create new\n    let mut fields: HashMap\u003cString, serde_yaml::Value\u003e =\n        if let Some(fm) = parsed.frontmatter { fm.fields } else { HashMap::new() };\n\n    // Inject/overwrite core fields - these are authoritative from Rust\n    if let Some(ref t) = core.note_type {\n        fields.insert(\"type\".to_string(), serde_yaml::Value::String(t.clone()));\n    }\n\n    if let Some(ref t) = core.title {\n        fields.insert(\"title\".to_string(), serde_yaml::Value::String(t.clone()));\n    }\n\n    if let Some(ref id) = core.project_id {\n        fields.insert(\"project-id\".to_string(), serde_yaml::Value::String(id.clone()));\n    }\n\n    if let Some(ref id) = core.task_id {\n        fields.insert(\"task-id\".to_string(), serde_yaml::Value::String(id.clone()));\n    }\n\n    if let Some(counter) = core.task_counter {\n        fields.insert(\n            \"task_counter\".to_string(),\n            serde_yaml::Value::Number(serde_yaml::Number::from(counter)),\n        );\n    }\n\n    if let Some(ref proj) = core.project {\n        fields.insert(\"project\".to_string(), serde_yaml::Value::String(proj.clone()));\n    }\n\n    // Rebuild the document\n    let mut mapping = serde_yaml::Mapping::new();\n    for (k, v) in fields {\n        mapping.insert(serde_yaml::Value::String(k), v);\n    }\n\n    let yaml_str = serde_yaml::to_string(\u0026serde_yaml::Value::Mapping(mapping))\n        .map_err(|e| e.to_string())?;\n\n    Ok(format!(\"---\\n{}---\\n{}\", yaml_str, parsed.body))\n}\n\n/// Generate a task ID for inbox tasks (no project).\nfn generate_inbox_task_id(cfg: \u0026ResolvedConfig) -\u003e String {\n    let inbox_path = cfg.vault_root.join(\"Inbox\");\n    let mut max_counter = 0u32;\n\n    if inbox_path.exists() {\n        if let Ok(entries) = fs::read_dir(\u0026inbox_path) {\n            for entry in entries.filter_map(|e| e.ok()) {\n                let name = entry.file_name();\n                let name_str = name.to_string_lossy();\n                // Parse INB-XXX pattern\n                if name_str.starts_with(\"INB-\") {\n                    if let Some(num_str) =\n                        name_str.strip_prefix(\"INB-\").and_then(|s| s.strip_suffix(\".md\"))\n                    {\n                        if let Ok(n) = num_str.parse::\u003cu32\u003e() {\n                            max_counter = max_counter.max(n);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    generate_task_id(\"INB\", max_counter + 1)\n}\n\n/// Get project's ID and increment its task counter.\n/// Returns (project_id, new_counter) on success.\nfn get_and_increment_project_counter(\n    cfg: \u0026ResolvedConfig,\n    project_folder: \u0026str,\n) -\u003e Result\u003c(String, u32), String\u003e {\n    // Find the project file - try both \u003cfolder\u003e/\u003cfolder\u003e.md and \u003cfolder\u003e.md patterns\n    let project_path = find_project_file(cfg, project_folder)?;\n\n    // Read and parse the project file\n    let content = fs::read_to_string(\u0026project_path)\n        .map_err(|e| format!(\"Failed to read project file: {e}\"))?;\n\n    let parsed = parse_frontmatter(\u0026content)\n        .map_err(|e| format!(\"Failed to parse project frontmatter: {e}\"))?;\n\n    let fm = parsed.frontmatter.ok_or(\"Project has no frontmatter\")?;\n\n    // Get project-id\n    let project_id = fm\n        .fields\n        .get(\"project-id\")\n        .and_then(|v| match v {\n            serde_yaml::Value::String(s) =\u003e Some(s.clone()),\n            _ =\u003e None,\n        })\n        .unwrap_or_else(|| generate_project_id(project_folder));\n\n    // Get current task counter\n    let current_counter = fm\n        .fields\n        .get(\"task_counter\")\n        .and_then(|v| match v {\n            serde_yaml::Value::Number(n) =\u003e n.as_u64().map(|n| n as u32),\n            serde_yaml::Value::String(s) =\u003e s.parse::\u003cu32\u003e().ok(),\n            _ =\u003e None,\n        })\n        .unwrap_or(0);\n\n    let new_counter = current_counter + 1;\n\n    // Update the project file with new counter\n    let mut new_fm = fm.fields.clone();\n    new_fm.insert(\n        \"task_counter\".to_string(),\n        serde_yaml::Value::Number(serde_yaml::Number::from(new_counter)),\n    );\n\n    // Rebuild the document\n    let mut mapping = serde_yaml::Mapping::new();\n    for (k, v) in new_fm {\n        mapping.insert(serde_yaml::Value::String(k), v);\n    }\n    let yaml_str = serde_yaml::to_string(\u0026serde_yaml::Value::Mapping(mapping))\n        .map_err(|e| format!(\"Failed to serialize frontmatter: {e}\"))?;\n\n    let new_content = format!(\"---\\n{}---\\n{}\", yaml_str, parsed.body);\n\n    fs::write(\u0026project_path, new_content)\n        .map_err(|e| format!(\"Failed to update project file: {e}\"))?;\n\n    Ok((project_id, new_counter))\n}\n\n/// Find the project file for a given project folder name.\nfn find_project_file(\n    cfg: \u0026ResolvedConfig,\n    project_folder: \u0026str,\n) -\u003e Result\u003cPathBuf, String\u003e {\n    // Try Projects/\u003cfolder\u003e/\u003cfolder\u003e.md\n    let path1 =\n        cfg.vault_root.join(format!(\"Projects/{}/{}.md\", project_folder, project_folder));\n    if path1.exists() {\n        return Ok(path1);\n    }\n\n    // Try Projects/\u003cfolder\u003e.md\n    let path2 = cfg.vault_root.join(format!(\"Projects/{}.md\", project_folder));\n    if path2.exists() {\n        return Ok(path2);\n    }\n\n    // Try scanning the Projects/\u003cfolder\u003e/ directory for any .md file\n    let folder_path = cfg.vault_root.join(format!(\"Projects/{}\", project_folder));\n    if folder_path.is_dir() {\n        if let Ok(entries) = fs::read_dir(\u0026folder_path) {\n            for entry in entries.filter_map(|e| e.ok()) {\n                let path = entry.path();\n                if path.extension().map(|e| e == \"md\").unwrap_or(false) {\n                    // Check if it's a project file (not in Tasks subdirectory)\n                    if !path.to_string_lossy().contains(\"/Tasks/\") {\n                        return Ok(path);\n                    }\n                }\n            }\n        }\n    }\n\n    Err(format!(\"Project file not found for: {}\", project_folder))\n}\n\n/// Force a vault reindex to include newly created notes.\nfn reindex_vault(cfg: \u0026ResolvedConfig) {\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n\n    // Ensure index directory exists\n    if let Some(parent) = index_path.parent() {\n        let _ = fs::create_dir_all(parent);\n    }\n\n    // Open the database and run incremental reindex\n    match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e {\n            let builder = IndexBuilder::new(\u0026db, \u0026cfg.vault_root);\n            if let Err(e) = builder.incremental_reindex(None) {\n                eprintln!(\"Warning: reindex failed: {e}\");\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Warning: could not open index for reindex: {e}\");\n        }\n    }\n}\n\n/// Extract note type from rendered content's frontmatter.\nfn extract_note_type(content: \u0026str) -\u003e Option\u003cString\u003e {\n    let parsed = parse_frontmatter(content).ok()?;\n    let fm = parsed.frontmatter?;\n\n    if let Some(serde_yaml::Value::String(t)) = fm.fields.get(\"type\") {\n        return Some(t.clone());\n    }\n    None\n}\n\n/// Run on_create hook if the note type has one defined.\n/// Returns the HookResult which may contain modifications to apply.\nfn run_on_create_hook_if_exists(\n    cfg: \u0026ResolvedConfig,\n    output_path: \u0026Path,\n    content: \u0026str,\n) -\u003e Result\u003cHookResult, String\u003e {\n    // Extract note type from frontmatter\n    let note_type = match extract_note_type(content) {\n        Some(t) =\u003e t,\n        None =\u003e {\n            return Ok(HookResult { modified: false, frontmatter: None, content: None })\n        }\n    };\n\n    // Load type registry\n    let typedef_repo =\n        TypedefRepository::new(\u0026cfg.typedefs_dir).map_err(|e| e.to_string())?;\n    let type_registry =\n        TypeRegistry::from_repository(\u0026typedef_repo).map_err(|e| e.to_string())?;\n\n    // Check if type has on_create hook\n    let typedef = match type_registry.get(\u0026note_type) {\n        Some(td) if td.has_on_create_hook =\u003e td,\n        _ =\u003e return Ok(HookResult { modified: false, frontmatter: None, content: None }),\n    };\n\n    // Load all repositories for VaultContext\n    let template_repo =\n        TemplateRepository::new(\u0026cfg.templates_dir).map_err(|e| e.to_string())?;\n    let capture_repo =\n        CaptureRepository::new(\u0026cfg.captures_dir).map_err(|e| e.to_string())?;\n    let macro_repo = MacroRepository::new(\u0026cfg.macros_dir).map_err(|e| e.to_string())?;\n\n    // Build VaultContext\n    let vault_ctx = VaultContext::new(\n        cfg.clone(),\n        template_repo,\n        capture_repo,\n        macro_repo,\n        type_registry,\n    );\n\n    // Parse frontmatter for NoteContext\n    let parsed = parse_frontmatter(content).map_err(|e| e.to_string())?;\n\n    // Convert Frontmatter to serde_yaml::Value\n    let frontmatter = match parsed.frontmatter {\n        Some(fm) =\u003e {\n            let mut mapping = serde_yaml::Mapping::new();\n            for (k, v) in fm.fields {\n                mapping.insert(serde_yaml::Value::String(k), v);\n            }\n            serde_yaml::Value::Mapping(mapping)\n        }\n        None =\u003e serde_yaml::Value::Null,\n    };\n\n    // Build NoteContext\n    let note_ctx = NoteContext::new(\n        output_path.to_path_buf(),\n        note_type,\n        frontmatter,\n        content.to_string(),\n    );\n\n    // Run the hook and return its result\n    run_on_create_hook(\u0026typedef, \u0026note_ctx, vault_ctx).map_err(|e| e.to_string())\n}\n\n/// Apply hook modifications to the output file.\nfn apply_hook_modifications(\n    output_path: \u0026Path,\n    original_content: \u0026str,\n    hook_result: \u0026HookResult,\n) -\u003e Result\u003c(), String\u003e {\n    if !hook_result.modified {\n        return Ok(());\n    }\n\n    // Parse original content to get structure\n    let original_parsed =\n        parse_frontmatter(original_content).map_err(|e| e.to_string())?;\n\n    // Determine final frontmatter\n    let final_frontmatter = if let Some(ref new_fm) = hook_result.frontmatter {\n        new_fm.clone()\n    } else if let Some(fm) = original_parsed.frontmatter {\n        let mut mapping = serde_yaml::Mapping::new();\n        for (k, v) in fm.fields {\n            mapping.insert(serde_yaml::Value::String(k), v);\n        }\n        serde_yaml::Value::Mapping(mapping)\n    } else {\n        serde_yaml::Value::Null\n    };\n\n    // Determine final content body\n    // If hook returned content, it might contain frontmatter, so parse it to get just the body\n    let final_body = if let Some(ref new_content) = hook_result.content {\n        // Parse the hook's content to extract just the body (in case it includes frontmatter)\n        let content_parsed = parse_frontmatter(new_content).map_err(|e| e.to_string())?;\n        content_parsed.body\n    } else {\n        original_parsed.body\n    };\n\n    // Rebuild the document\n    let final_content = if final_frontmatter.is_null() {\n        final_body\n    } else {\n        let yaml_str =\n            serde_yaml::to_string(\u0026final_frontmatter).map_err(|e| e.to_string())?;\n        format!(\"---\\n{}---\\n{}\", yaml_str, final_body)\n    };\n\n    // Write back to file\n    fs::write(output_path, final_content).map_err(|e| e.to_string())\n}\n\n/// Log a creation event to today's daily note.\n/// Creates the daily note if it doesn't exist.\nfn log_to_daily(\n    cfg: \u0026ResolvedConfig,\n    note_type: \u0026str,\n    title: \u0026str,\n    note_id: \u0026str,\n    output_path: \u0026Path,\n) {\n    let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n    let time = chrono::Local::now().format(\"%H:%M\").to_string();\n\n    // Build daily note path (default pattern: Journal/Daily/YYYY-MM-DD.md)\n    let daily_path = cfg.vault_root.join(format!(\"Journal/Daily/{}.md\", today));\n\n    // Ensure parent directory exists\n    if let Some(parent) = daily_path.parent() {\n        if let Err(e) = fs::create_dir_all(parent) {\n            eprintln!(\"Warning: could not create daily directory: {e}\");\n            return;\n        }\n    }\n\n    // Read or create daily note\n    let mut content = match fs::read_to_string(\u0026daily_path) {\n        Ok(c) =\u003e c,\n        Err(e) if e.kind() == std::io::ErrorKind::NotFound =\u003e {\n            // Create minimal daily note\n            let content = format!(\n                \"---\\ntype: daily\\ndate: {}\\n---\\n\\n# {}\\n\\n## Log\\n\",\n                today, today\n            );\n            if let Err(e) = fs::write(\u0026daily_path, \u0026content) {\n                eprintln!(\"Warning: could not create daily note: {e}\");\n                return;\n            }\n            println!(\"Created daily note: {}\", daily_path.display());\n            content\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Warning: could not read daily note: {e}\");\n            return;\n        }\n    };\n\n    // Build the log entry with link to the note\n    let rel_path = output_path.strip_prefix(\u0026cfg.vault_root).unwrap_or(output_path);\n    let link = rel_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"note\");\n\n    // Format: \"- **HH:MM** Created task [MCP-001]: [[MCP-001|Title]]\"\n    let id_display =\n        if note_id.is_empty() { String::new() } else { format!(\" [{}]\", note_id) };\n\n    let log_entry = format!(\n        \"- **{}** Created {}{}: [[{}|{}]]\\n\",\n        time, note_type, id_display, link, title\n    );\n\n    // Find the Log section and append, or append at end\n    if let Some(log_pos) = content.find(\"## Log\") {\n        // Find the end of the Log section (next ## or end of file)\n        let after_log = \u0026content[log_pos + 6..]; // Skip \"## Log\"\n        let insert_pos = if let Some(next_section) = after_log.find(\"\\n## \") {\n            log_pos + 6 + next_section\n        } else {\n            content.len()\n        };\n\n        // Insert the log entry\n        content.insert_str(insert_pos, \u0026format!(\"\\n{}\", log_entry));\n    } else {\n        // No Log section, add one\n        content.push_str(\u0026format!(\"\\n## Log\\n{}\", log_entry));\n    }\n\n    // Write back\n    if let Err(e) = fs::write(\u0026daily_path, \u0026content) {\n        eprintln!(\"Warning: could not update daily note: {e}\");\n    }\n}\n\n/// Query existing projects from the index and prompt user to select one.\n/// Returns None if user cancels, Some(\"inbox\") for inbox, or Some(project_name) for a project.\nfn prompt_project_selection(cfg: \u0026ResolvedConfig) -\u003e Option\u003cString\u003e {\n    // Open the index database\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(_) =\u003e {\n            // No index yet, default to inbox\n            println!(\"No index found. Task will go to inbox.\");\n            return Some(\"inbox\".to_string());\n        }\n    };\n\n    // Query all projects\n    let query = NoteQuery { note_type: Some(NoteType::Project), ..Default::default() };\n\n    let projects = match db.query_notes(\u0026query) {\n        Ok(p) =\u003e p,\n        Err(_) =\u003e return Some(\"inbox\".to_string()),\n    };\n\n    // Build selection items: inbox first, then projects\n    let mut items: Vec\u003cString\u003e = vec![\"Inbox (no project - for triage)\".to_string()];\n\n    for p in \u0026projects {\n        let title = if p.title.is_empty() { \"Untitled\" } else { \u0026p.title };\n        items.push(title.to_string());\n    }\n\n    // Show selector\n    let selection = Select::with_theme(\u0026ColorfulTheme::default())\n        .with_prompt(\"Select project for this task\")\n        .items(\u0026items)\n        .default(0)\n        .interact_opt()\n        .ok()?;\n\n    // Handle selection\n    selection.map(|idx| {\n        if idx == 0 {\n            // Inbox selected\n            \"inbox\".to_string()\n        } else {\n            // Project selected (idx - 1 because inbox is at 0)\n            let project = \u0026projects[idx - 1];\n            project\n                .path\n                .file_stem()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"project\")\n                .to_string()\n        }\n    })\n}\n\n/// Collect variables from Lua schema fields that have `prompt` set.\n/// Prompts for fields that:\n/// - Have `prompt` defined (the prompt text to show)\n/// - Are not already provided in `provided_vars`\n/// - Are not marked as `core` (managed by Rust)\nfn collect_schema_variables(\n    typedef: \u0026TypeDefinition,\n    provided_vars: \u0026HashMap\u003cString, String\u003e,\n    options: \u0026PromptOptions,\n) -\u003e Result\u003cCollectedVars, String\u003e {\n    let mut result = CollectedVars {\n        values: HashMap::new(),\n        prompted: Vec::new(),\n        defaulted: Vec::new(),\n    };\n\n    // Start with provided vars\n    for (k, v) in provided_vars {\n        result.values.insert(k.clone(), v.clone());\n    }\n\n    // Process schema fields in alphabetical order for consistency\n    let mut fields: Vec\u003c_\u003e = typedef.schema.iter().collect();\n    fields.sort_by(|a, b| a.0.cmp(b.0));\n\n    for (field_name, schema) in fields {\n        // Skip if already provided\n        if result.values.contains_key(field_name) {\n            continue;\n        }\n\n        // Skip core fields (managed by Rust)\n        if schema.core {\n            continue;\n        }\n\n        // If field has a prompt, ask the user\n        if let Some(ref prompt_text) = schema.prompt {\n            if options.batch_mode {\n                // In batch mode, use default or fail if required\n                if let Some(ref default) = schema.default {\n                    let value = yaml_value_to_string(default);\n                    result.values.insert(field_name.clone(), value);\n                    result.defaulted.push(field_name.clone());\n                } else if schema.required {\n                    return Err(format!(\n                        \"Missing required field '{}' in batch mode\",\n                        field_name\n                    ));\n                }\n            } else {\n                // Interactive: prompt for field\n                let enum_values = schema.enum_values.as_deref();\n                let default_str = schema.default.as_ref().map(yaml_value_to_string);\n\n                match prompt_for_schema_field(\n                    field_name,\n                    prompt_text,\n                    enum_values,\n                    default_str.as_deref(),\n                    schema.required,\n                    schema.multiline,\n                ) {\n                    Ok(value) if !value.is_empty() =\u003e {\n                        result.values.insert(field_name.clone(), value);\n                        result.prompted.push(field_name.clone());\n                    }\n                    Ok(_) =\u003e {\n                        // Empty value - use default if available\n                        if let Some(ref default) = schema.default {\n                            result.values.insert(\n                                field_name.clone(),\n                                yaml_value_to_string(default),\n                            );\n                            result.defaulted.push(field_name.clone());\n                        }\n                        result.prompted.push(field_name.clone());\n                    }\n                    Err(e) =\u003e return Err(e),\n                }\n            }\n        } else if let Some(ref default) = schema.default {\n            // No prompt but has default - use it\n            result.values.insert(field_name.clone(), yaml_value_to_string(default));\n            result.defaulted.push(field_name.clone());\n        }\n    }\n\n    Ok(result)\n}\n\n/// Prompt for a single schema field value.\n///\n/// Uses different widgets based on field type:\n/// - Enum fields: Select widget for choosing from options\n/// - Multiline fields: Editor widget for multi-line text\n/// - Other fields: Input widget for single-line text\nfn prompt_for_schema_field(\n    field_name: \u0026str,\n    prompt_text: \u0026str,\n    enum_values: Option\u003c\u0026[String]\u003e,\n    default: Option\u003c\u0026str\u003e,\n    required: bool,\n    multiline: bool,\n) -\u003e Result\u003cString, String\u003e {\n    let theme = ColorfulTheme::default();\n\n    // If enum values provided, use Select widget\n    if let Some(values) = enum_values {\n        let default_idx =\n            default.and_then(|d| values.iter().position(|v| v == d)).unwrap_or(0);\n\n        let selection = Select::with_theme(\u0026theme)\n            .with_prompt(prompt_text)\n            .items(values)\n            .default(default_idx)\n            .interact_opt()\n            .map_err(|e| {\n                format!(\"Failed to read selection for '{}': {}\", field_name, e)\n            })?;\n\n        return match selection {\n            Some(idx) =\u003e Ok(values[idx].clone()),\n            None =\u003e {\n                // User cancelled - use default if available, else empty\n                Ok(default.unwrap_or(\"\").to_string())\n            }\n        };\n    }\n\n    // If multiline, use Editor widget\n    if multiline {\n        let initial = default.unwrap_or(\"\");\n        let content = Editor::new()\n            .edit(initial)\n            .map_err(|e| format!(\"Editor error for '{}': {}\", field_name, e))?\n            .unwrap_or_else(|| initial.to_string());\n        return Ok(content);\n    }\n\n    // Default: use Input widget\n    let mut builder = Input::\u003cString\u003e::with_theme(\u0026theme).with_prompt(prompt_text);\n\n    if let Some(def) = default {\n        builder = builder.default(def.to_string());\n    }\n\n    builder = builder.allow_empty(!required);\n\n    builder\n        .interact_text()\n        .map_err(|e| format!(\"Failed to read input for '{}': {}\", field_name, e))\n}\n\n/// Convert a serde_yaml::Value to a string for template context.\nfn yaml_value_to_string(value: \u0026serde_yaml::Value) -\u003e String {\n    match value {\n        serde_yaml::Value::String(s) =\u003e s.clone(),\n        serde_yaml::Value::Number(n) =\u003e n.to_string(),\n        serde_yaml::Value::Bool(b) =\u003e b.to_string(),\n        serde_yaml::Value::Null =\u003e String::new(),\n        other =\u003e serde_yaml::to_string(other).unwrap_or_default().trim().to_string(),\n    }\n}\n\n/// Render an output path template with variable substitution.\n/// Uses the template engine to support filters like `{{title | slugify}}`.\nfn render_output_path(\n    template: \u0026str,\n    cfg: \u0026ResolvedConfig,\n    ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003cPathBuf, String\u003e {\n    // Use the template engine to render with filter support\n    let rendered = render_string(template, ctx).map_err(|e| e.to_string())?;\n\n    // Make path absolute relative to vault root\n    let path = PathBuf::from(\u0026rendered);\n    if path.is_absolute() {\n        Ok(path)\n    } else {\n        Ok(cfg.vault_root.join(path))\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":10}},{"line":46,"address":[],"length":0,"stats":{"Line":30}},{"line":47,"address":[],"length":0,"stats":{"Line":20}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":30}},{"line":61,"address":[],"length":0,"stats":{"Line":30}},{"line":62,"address":[],"length":0,"stats":{"Line":10}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":10}},{"line":75,"address":[],"length":0,"stats":{"Line":20}},{"line":76,"address":[],"length":0,"stats":{"Line":20}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":30}},{"line":85,"address":[],"length":0,"stats":{"Line":20}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":30}},{"line":101,"address":[],"length":0,"stats":{"Line":10}},{"line":105,"address":[],"length":0,"stats":{"Line":20}},{"line":106,"address":[],"length":0,"stats":{"Line":50}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":50}},{"line":123,"address":[],"length":0,"stats":{"Line":60}},{"line":124,"address":[],"length":0,"stats":{"Line":10}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":10}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":40}},{"line":139,"address":[],"length":0,"stats":{"Line":20}},{"line":141,"address":[],"length":0,"stats":{"Line":20}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":30}},{"line":154,"address":[],"length":0,"stats":{"Line":10}},{"line":155,"address":[],"length":0,"stats":{"Line":10}},{"line":160,"address":[],"length":0,"stats":{"Line":20}},{"line":161,"address":[],"length":0,"stats":{"Line":18}},{"line":162,"address":[],"length":0,"stats":{"Line":6}},{"line":166,"address":[],"length":0,"stats":{"Line":24}},{"line":167,"address":[],"length":0,"stats":{"Line":10}},{"line":170,"address":[],"length":0,"stats":{"Line":20}},{"line":171,"address":[],"length":0,"stats":{"Line":8}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":18}},{"line":206,"address":[],"length":0,"stats":{"Line":18}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":54}},{"line":213,"address":[],"length":0,"stats":{"Line":54}},{"line":214,"address":[],"length":0,"stats":{"Line":45}},{"line":216,"address":[],"length":0,"stats":{"Line":27}},{"line":217,"address":[],"length":0,"stats":{"Line":45}},{"line":220,"address":[],"length":0,"stats":{"Line":9}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":27}},{"line":229,"address":[],"length":0,"stats":{"Line":18}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":18}},{"line":237,"address":[],"length":0,"stats":{"Line":9}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":18}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":27}},{"line":250,"address":[],"length":0,"stats":{"Line":9}},{"line":251,"address":[],"length":0,"stats":{"Line":9}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":18}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":18}},{"line":283,"address":[],"length":0,"stats":{"Line":18}},{"line":284,"address":[],"length":0,"stats":{"Line":27}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":9}},{"line":937,"address":[],"length":0,"stats":{"Line":36}},{"line":938,"address":[],"length":0,"stats":{"Line":18}},{"line":940,"address":[],"length":0,"stats":{"Line":6}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":2}},{"line":948,"address":[],"length":0,"stats":{"Line":9}},{"line":954,"address":[],"length":0,"stats":{"Line":9}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":9}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":0}},{"line":1048,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":0}},{"line":1054,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1090,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[],"length":0,"stats":{"Line":0}},{"line":1094,"address":[],"length":0,"stats":{"Line":0}},{"line":1098,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":0}},{"line":1100,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":0}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1106,"address":[],"length":0,"stats":{"Line":0}},{"line":1107,"address":[],"length":0,"stats":{"Line":0}},{"line":1112,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1116,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[],"length":0,"stats":{"Line":0}},{"line":1119,"address":[],"length":0,"stats":{"Line":0}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":0}},{"line":1128,"address":[],"length":0,"stats":{"Line":0}},{"line":1129,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":0}},{"line":1135,"address":[],"length":0,"stats":{"Line":0}},{"line":1138,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":0}},{"line":1149,"address":[],"length":0,"stats":{"Line":0}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1152,"address":[],"length":0,"stats":{"Line":0}},{"line":1153,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1162,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1173,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":0}},{"line":1178,"address":[],"length":0,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1187,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1192,"address":[],"length":0,"stats":{"Line":0}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[],"length":0,"stats":{"Line":0}},{"line":1195,"address":[],"length":0,"stats":{"Line":0}},{"line":1196,"address":[],"length":0,"stats":{"Line":0}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1198,"address":[],"length":0,"stats":{"Line":0}},{"line":1208,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1220,"address":[],"length":0,"stats":{"Line":0}},{"line":1221,"address":[],"length":0,"stats":{"Line":0}},{"line":1225,"address":[],"length":0,"stats":{"Line":0}},{"line":1226,"address":[],"length":0,"stats":{"Line":0}},{"line":1228,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[],"length":0,"stats":{"Line":0}},{"line":1231,"address":[],"length":0,"stats":{"Line":0}},{"line":1235,"address":[],"length":0,"stats":{"Line":0}},{"line":1236,"address":[],"length":0,"stats":{"Line":0}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[],"length":0,"stats":{"Line":0}},{"line":1243,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[],"length":0,"stats":{"Line":0}},{"line":1246,"address":[],"length":0,"stats":{"Line":0}},{"line":1247,"address":[],"length":0,"stats":{"Line":0}},{"line":1248,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1250,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1259,"address":[],"length":0,"stats":{"Line":0}},{"line":1260,"address":[],"length":0,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1263,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[],"length":0,"stats":{"Line":0}},{"line":1266,"address":[],"length":0,"stats":{"Line":0}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[],"length":0,"stats":{"Line":0}},{"line":1272,"address":[],"length":0,"stats":{"Line":0}},{"line":1273,"address":[],"length":0,"stats":{"Line":0}},{"line":1274,"address":[],"length":0,"stats":{"Line":0}},{"line":1275,"address":[],"length":0,"stats":{"Line":0}},{"line":1277,"address":[],"length":0,"stats":{"Line":0}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1281,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1286,"address":[],"length":0,"stats":{"Line":0}},{"line":1287,"address":[],"length":0,"stats":{"Line":0}},{"line":1291,"address":[],"length":0,"stats":{"Line":0}},{"line":1300,"address":[],"length":0,"stats":{"Line":0}},{"line":1308,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1312,"address":[],"length":0,"stats":{"Line":0}},{"line":1313,"address":[],"length":0,"stats":{"Line":0}},{"line":1315,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":0}},{"line":1317,"address":[],"length":0,"stats":{"Line":0}},{"line":1318,"address":[],"length":0,"stats":{"Line":0}},{"line":1320,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1324,"address":[],"length":0,"stats":{"Line":0}},{"line":1325,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1334,"address":[],"length":0,"stats":{"Line":0}},{"line":1335,"address":[],"length":0,"stats":{"Line":0}},{"line":1336,"address":[],"length":0,"stats":{"Line":0}},{"line":1337,"address":[],"length":0,"stats":{"Line":0}},{"line":1338,"address":[],"length":0,"stats":{"Line":0}},{"line":1339,"address":[],"length":0,"stats":{"Line":0}},{"line":1340,"address":[],"length":0,"stats":{"Line":0}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1350,"address":[],"length":0,"stats":{"Line":0}},{"line":1352,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1361,"address":[],"length":0,"stats":{"Line":0}},{"line":1362,"address":[],"length":0,"stats":{"Line":0}},{"line":1363,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":0}},{"line":1370,"address":[],"length":0,"stats":{"Line":0}},{"line":1376,"address":[],"length":0,"stats":{"Line":0}},{"line":1379,"address":[],"length":0,"stats":{"Line":0}},{"line":1380,"address":[],"length":0,"stats":{"Line":0}},{"line":1381,"address":[],"length":0,"stats":{"Line":0}},{"line":1383,"address":[],"length":0,"stats":{"Line":0}}],"covered":64,"coverable":683},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","orphans.rs"],"content":"//! Orphans command implementation.\n\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::IndexDb;\n\nuse super::output::{print_notes_json, print_notes_quiet, print_notes_table};\nuse crate::{OrphansArgs, OutputFormat};\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: OrphansArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Find orphans\n    let orphans = match db.find_orphans() {\n        Ok(notes) =\u003e notes,\n        Err(e) =\u003e {\n            eprintln!(\"Error finding orphans: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Resolve output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Output results\n    match format {\n        OutputFormat::Table =\u003e print_notes_table(\u0026orphans),\n        OutputFormat::Json =\u003e print_notes_json(\u0026orphans),\n        OutputFormat::Quiet =\u003e print_notes_quiet(\u0026orphans),\n    }\n}\n\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","output.rs"],"content":"//! Shared output formatting for query commands.\n\nuse mdvault_core::index::{IndexedLink, IndexedNote};\nuse serde::Serialize;\n\n/// Formatted note for JSON output.\n#[derive(Debug, Serialize)]\npub struct NoteOutput {\n    pub path: String,\n    #[serde(rename = \"type\")]\n    pub note_type: String,\n    pub title: String,\n    pub modified: String,\n}\n\nimpl From\u003c\u0026IndexedNote\u003e for NoteOutput {\n    fn from(note: \u0026IndexedNote) -\u003e Self {\n        Self {\n            path: note.path.to_string_lossy().to_string(),\n            note_type: note.note_type.as_str().to_string(),\n            title: note.title.clone(),\n            modified: note.modified.format(\"%Y-%m-%d %H:%M\").to_string(),\n        }\n    }\n}\n\n/// Formatted link for JSON output.\n#[derive(Debug, Serialize)]\npub struct LinkOutput {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub source_path: Option\u003cString\u003e,\n    pub target_path: String,\n    pub link_type: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub link_text: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub line_number: Option\u003cu32\u003e,\n}\n\nimpl LinkOutput {\n    pub fn from_link(link: \u0026IndexedLink, source_path: Option\u003c\u0026str\u003e) -\u003e Self {\n        Self {\n            source_path: source_path.map(|s| s.to_string()),\n            target_path: link.target_path.clone(),\n            link_type: link.link_type.as_str().to_string(),\n            link_text: link.link_text.clone(),\n            line_number: link.line_number,\n        }\n    }\n}\n\n/// Print notes as a table.\npub fn print_notes_table(notes: \u0026[IndexedNote]) {\n    if notes.is_empty() {\n        println!(\"(no notes found)\");\n        return;\n    }\n\n    // Calculate column widths\n    let path_width = notes\n        .iter()\n        .map(|n| n.path.to_string_lossy().len())\n        .max()\n        .unwrap_or(4)\n        .clamp(4, 50);\n    let type_width = 8; // \"project\" is longest\n    let title_width = notes.iter().map(|n| n.title.len()).max().unwrap_or(5).clamp(5, 40);\n\n    // Header\n    println!(\n        \"{:\u003cpath_width$}  {:\u003ctype_width$}  {:\u003ctitle_width$}  MODIFIED\",\n        \"PATH\",\n        \"TYPE\",\n        \"TITLE\",\n        path_width = path_width,\n        type_width = type_width,\n        title_width = title_width,\n    );\n    println!(\n        \"{:-\u003cpath_width$}  {:-\u003ctype_width$}  {:-\u003ctitle_width$}  {:-\u003c16}\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        path_width = path_width,\n        type_width = type_width,\n        title_width = title_width,\n    );\n\n    // Rows\n    for note in notes {\n        let path = truncate(\u0026note.path.to_string_lossy(), path_width);\n        let title = truncate(\u0026note.title, title_width);\n        let modified = note.modified.format(\"%Y-%m-%d %H:%M\").to_string();\n\n        println!(\n            \"{:\u003cpath_width$}  {:\u003ctype_width$}  {:\u003ctitle_width$}  {}\",\n            path,\n            note.note_type.as_str(),\n            title,\n            modified,\n            path_width = path_width,\n            type_width = type_width,\n            title_width = title_width,\n        );\n    }\n\n    println!();\n    println!(\"-- {} notes --\", notes.len());\n}\n\n/// Print notes as JSON.\npub fn print_notes_json(notes: \u0026[IndexedNote]) {\n    let output: Vec\u003cNoteOutput\u003e = notes.iter().map(NoteOutput::from).collect();\n    println!(\"{}\", serde_json::to_string_pretty(\u0026output).unwrap_or_default());\n}\n\n/// Print notes as paths only (quiet mode).\npub fn print_notes_quiet(notes: \u0026[IndexedNote]) {\n    for note in notes {\n        println!(\"{}\", note.path.display());\n    }\n}\n\n/// Print links as a table.\npub fn print_links_table(links: \u0026[LinkOutput], direction: \u0026str) {\n    if links.is_empty() {\n        println!(\"(no {} found)\", direction);\n        return;\n    }\n\n    let path_width = links\n        .iter()\n        .map(|l| {\n            l.target_path.len().max(l.source_path.as_ref().map(|s| s.len()).unwrap_or(0))\n        })\n        .max()\n        .unwrap_or(4)\n        .clamp(4, 50);\n    let type_width = 10;\n\n    println!(\n        \"{:\u003cpath_width$}  {:\u003ctype_width$}  LINE\",\n        \"PATH\",\n        \"LINK_TYPE\",\n        path_width = path_width,\n        type_width = type_width\n    );\n    println!(\n        \"{:-\u003cpath_width$}  {:-\u003ctype_width$}  {:-\u003c6}\",\n        \"\",\n        \"\",\n        \"\",\n        path_width = path_width,\n        type_width = type_width\n    );\n\n    for link in links {\n        let path = if direction == \"backlinks\" {\n            link.source_path.as_deref().unwrap_or(\u0026link.target_path)\n        } else {\n            \u0026link.target_path\n        };\n        let path = truncate(path, path_width);\n        let line =\n            link.line_number.map(|n| n.to_string()).unwrap_or_else(|| \"-\".to_string());\n\n        println!(\n            \"{:\u003cpath_width$}  {:\u003ctype_width$}  {}\",\n            path,\n            link.link_type,\n            line,\n            path_width = path_width,\n            type_width = type_width,\n        );\n    }\n\n    println!();\n    println!(\"-- {} {} --\", links.len(), direction);\n}\n\n/// Print links as JSON.\npub fn print_links_json(links: \u0026[LinkOutput]) {\n    println!(\"{}\", serde_json::to_string_pretty(\u0026links).unwrap_or_default());\n}\n\n/// Print links as paths only (quiet mode).\npub fn print_links_quiet(links: \u0026[LinkOutput], use_source: bool) {\n    for link in links {\n        if use_source {\n            if let Some(ref source) = link.source_path {\n                println!(\"{}\", source);\n            }\n        } else {\n            println!(\"{}\", link.target_path);\n        }\n    }\n}\n\n/// Truncate string with ellipsis if needed.\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else if max_len \u003e 3 {\n        format!(\"{}...\", \u0026s[..max_len - 3])\n    } else {\n        s[..max_len].to_string()\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":81},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","project.rs"],"content":"//! Project management commands.\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{IndexDb, IndexedNote, NoteQuery, NoteType};\nuse std::path::Path;\nuse tabled::{settings::Style, Table, Tabled};\n\n/// Row for project list table.\n#[derive(Tabled)]\nstruct ProjectRow {\n    #[tabled(rename = \"ID\")]\n    id: String,\n    #[tabled(rename = \"Title\")]\n    title: String,\n    #[tabled(rename = \"Status\")]\n    status: String,\n    #[tabled(rename = \"Open\")]\n    open: usize,\n    #[tabled(rename = \"Done\")]\n    done: usize,\n    #[tabled(rename = \"Total\")]\n    total: usize,\n}\n\n/// Row for task list in status view.\n#[derive(Tabled)]\nstruct TaskRow {\n    #[tabled(rename = \"ID\")]\n    id: String,\n    #[tabled(rename = \"Title\")]\n    title: String,\n    #[tabled(rename = \"Status\")]\n    status: String,\n}\n\n/// List all projects with task counts.\npub fn list(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, status_filter: Option\u003c\u0026str\u003e) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load config: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to open index: {e}\");\n            eprintln!(\"Run 'mdv reindex' first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Query all projects\n    let project_query =\n        NoteQuery { note_type: Some(NoteType::Project), ..Default::default() };\n\n    let projects = match db.query_notes(\u0026project_query) {\n        Ok(p) =\u003e p,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to query projects: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    if projects.is_empty() {\n        println!(\"No projects found.\");\n        println!(\"Create one with: mdv new project\");\n        return;\n    }\n\n    // Query all tasks to count per project\n    let task_query = NoteQuery { note_type: Some(NoteType::Task), ..Default::default() };\n    let tasks = db.query_notes(\u0026task_query).unwrap_or_default();\n\n    // Build table rows\n    let mut rows: Vec\u003cProjectRow\u003e = Vec::new();\n\n    for project in \u0026projects {\n        // Get project ID and status from frontmatter\n        let (project_id, project_status) = extract_project_info(project);\n\n        // Filter by status if specified\n        if let Some(filter) = status_filter {\n            if project_status != filter {\n                continue;\n            }\n        }\n\n        let title = if project.title.is_empty() {\n            project\n                .path\n                .file_stem()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"Untitled\")\n                .to_string()\n        } else {\n            project.title.clone()\n        };\n\n        // Count tasks for this project\n        let project_folder =\n            project.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n\n        let project_tasks: Vec\u003c_\u003e = tasks\n            .iter()\n            .filter(|t| {\n                let path_str = t.path.to_string_lossy();\n                path_str.contains(\u0026format!(\"Projects/{}/\", project_folder))\n            })\n            .collect();\n\n        let total = project_tasks.len();\n        let done = project_tasks\n            .iter()\n            .filter(|t| {\n                get_task_status(t)\n                    .map(|s| s == \"done\" || s == \"completed\")\n                    .unwrap_or(false)\n            })\n            .count();\n        let open = total - done;\n\n        rows.push(ProjectRow {\n            id: project_id,\n            title,\n            status: project_status,\n            open,\n            done,\n            total,\n        });\n    }\n\n    if rows.is_empty() {\n        println!(\"No projects match the filter.\");\n        return;\n    }\n\n    let table = Table::new(\u0026rows).with(Style::rounded()).to_string();\n\n    println!(\"{}\", table);\n    println!(\"\\nTotal: {} projects\", rows.len());\n}\n\n/// Show project status with tasks in kanban-style columns.\npub fn status(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, project_name: \u0026str) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load config: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to open index: {e}\");\n            eprintln!(\"Run 'mdv reindex' first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Find the project\n    let project_query =\n        NoteQuery { note_type: Some(NoteType::Project), ..Default::default() };\n    let projects = db.query_notes(\u0026project_query).unwrap_or_default();\n\n    let project = projects.iter().find(|p| {\n        let folder = p.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n        let (id, _) = extract_project_info(p);\n        folder.eq_ignore_ascii_case(project_name) || id.eq_ignore_ascii_case(project_name)\n    });\n\n    let project = match project {\n        Some(p) =\u003e p,\n        None =\u003e {\n            eprintln!(\"Project not found: {}\", project_name);\n            eprintln!(\"Run 'mdv project list' to see available projects.\");\n            std::process::exit(1);\n        }\n    };\n\n    let project_folder = project.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let (project_id, project_status) = extract_project_info(project);\n    let project_title = if project.title.is_empty() {\n        project_folder.to_string()\n    } else {\n        project.title.clone()\n    };\n\n    // Print project header\n    println!(\"Project: {} [{}]\", project_title, project_id);\n    println!(\"Status:  {}\", project_status);\n    println!();\n\n    // Query all tasks\n    let task_query = NoteQuery { note_type: Some(NoteType::Task), ..Default::default() };\n    let all_tasks = db.query_notes(\u0026task_query).unwrap_or_default();\n\n    // Filter tasks for this project\n    let project_tasks: Vec\u003c_\u003e = all_tasks\n        .into_iter()\n        .filter(|t| {\n            let path_str = t.path.to_string_lossy();\n            path_str.contains(\u0026format!(\"Projects/{}/\", project_folder))\n                || path_str.contains(\u0026format!(\"projects/{}/\", project_folder))\n        })\n        .collect();\n\n    if project_tasks.is_empty() {\n        println!(\"No tasks found for this project.\");\n        println!(\"Create one with: mdv new task\");\n        return;\n    }\n\n    // Group tasks by status\n    let mut todo: Vec\u003c\u0026IndexedNote\u003e = vec![];\n    let mut in_progress: Vec\u003c\u0026IndexedNote\u003e = vec![];\n    let mut blocked: Vec\u003c\u0026IndexedNote\u003e = vec![];\n    let mut done: Vec\u003c\u0026IndexedNote\u003e = vec![];\n\n    for task in \u0026project_tasks {\n        let status = get_task_status(task).unwrap_or_else(|| \"todo\".to_string());\n\n        match status.as_str() {\n            \"todo\" | \"open\" =\u003e todo.push(task),\n            \"in-progress\" | \"in_progress\" | \"doing\" =\u003e in_progress.push(task),\n            \"blocked\" | \"waiting\" =\u003e blocked.push(task),\n            \"done\" | \"completed\" =\u003e done.push(task),\n            _ =\u003e todo.push(task),\n        }\n    }\n\n    // Print summary\n    println!(\"Task Summary:\");\n    println!(\"  TODO:        {}\", todo.len());\n    println!(\"  In Progress: {}\", in_progress.len());\n    println!(\"  Blocked:     {}\", blocked.len());\n    println!(\"  Done:        {}\", done.len());\n    println!(\"  Total:       {}\", project_tasks.len());\n    println!();\n\n    // Print task tables by status\n    if !todo.is_empty() {\n        println!(\"TODO:\");\n        print_task_table(\u0026todo);\n        println!();\n    }\n\n    if !in_progress.is_empty() {\n        println!(\"IN PROGRESS:\");\n        print_task_table(\u0026in_progress);\n        println!();\n    }\n\n    if !blocked.is_empty() {\n        println!(\"BLOCKED:\");\n        print_task_table(\u0026blocked);\n        println!();\n    }\n\n    if !done.is_empty() {\n        println!(\"DONE:\");\n        print_task_table(\u0026done);\n        println!();\n    }\n}\n\n/// Print a table of tasks.\nfn print_task_table(tasks: \u0026[\u0026IndexedNote]) {\n    let rows: Vec\u003cTaskRow\u003e = tasks\n        .iter()\n        .map(|task| {\n            let task_id = get_task_id(task).unwrap_or_else(|| \"-\".to_string());\n            let title = if task.title.is_empty() {\n                task.path\n                    .file_stem()\n                    .and_then(|s| s.to_str())\n                    .unwrap_or(\"Untitled\")\n                    .to_string()\n            } else {\n                task.title.clone()\n            };\n            let status = get_task_status(task).unwrap_or_else(|| \"unknown\".to_string());\n\n            TaskRow { id: task_id, title, status }\n        })\n        .collect();\n\n    let table = Table::new(\u0026rows).with(Style::rounded()).to_string();\n\n    println!(\"{}\", table);\n}\n\n/// Extract project ID and status from frontmatter.\nfn extract_project_info(project: \u0026IndexedNote) -\u003e (String, String) {\n    let fm = project\n        .frontmatter_json\n        .as_ref()\n        .and_then(|fm| serde_json::from_str::\u003cserde_json::Value\u003e(fm).ok());\n\n    let id = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"project-id\").and_then(|v| v.as_str()))\n        .map(String::from)\n        .unwrap_or_else(|| {\n            project.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"???\").to_string()\n        });\n\n    let status = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"status\").and_then(|v| v.as_str()))\n        .map(String::from)\n        .unwrap_or_else(|| \"unknown\".to_string());\n\n    (id, status)\n}\n\n/// Get task status from frontmatter.\nfn get_task_status(task: \u0026IndexedNote) -\u003e Option\u003cString\u003e {\n    task.frontmatter_json\n        .as_ref()\n        .and_then(|fm| serde_json::from_str::\u003cserde_json::Value\u003e(fm).ok())\n        .and_then(|fm| fm.get(\"status\").and_then(|v| v.as_str()).map(String::from))\n}\n\n/// Get task ID from frontmatter.\nfn get_task_id(task: \u0026IndexedNote) -\u003e Option\u003cString\u003e {\n    task.frontmatter_json\n        .as_ref()\n        .and_then(|fm| serde_json::from_str::\u003cserde_json::Value\u003e(fm).ok())\n        .and_then(|fm| fm.get(\"task-id\").and_then(|v| v.as_str()).map(String::from))\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":179},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","reindex.rs"],"content":"//! Reindex command implementation.\n\nuse std::io::Write;\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{DerivedIndexBuilder, IndexBuilder, IndexDb};\n\n/// Run the reindex command.\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, verbose: bool, force: bool) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Determine index path\n    let index_dir = rc.vault_root.join(\".mdvault\");\n    let index_path = index_dir.join(\"index.db\");\n\n    // Ensure .mdvault directory exists\n    if let Err(e) = std::fs::create_dir_all(\u0026index_dir) {\n        eprintln!(\"Error creating index directory: {}\", e);\n        std::process::exit(1);\n    }\n\n    // Open database\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index database: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    let mode = if force { \"full\" } else { \"incremental\" };\n    println!(\"Indexing vault ({} mode): {}\", mode, rc.vault_root.display());\n\n    // Create progress callback\n    let progress: Option\u003cmdvault_core::index::ProgressCallback\u003e = if verbose {\n        Some(Box::new(|current, total, path| {\n            println!(\"[{}/{}] {}\", current, total, path);\n        }))\n    } else {\n        Some(Box::new(|current, total, _path| {\n            // Simple progress indicator\n            if current % 50 == 0 || current == total {\n                print!(\"\\rScanning... {}/{}\", current, total);\n                std::io::stdout().flush().ok();\n            }\n        }))\n    };\n\n    // Build index\n    let builder = IndexBuilder::new(\u0026db, \u0026rc.vault_root);\n    let result = if force {\n        builder.full_reindex(progress)\n    } else {\n        builder.incremental_reindex(progress)\n    };\n\n    match result {\n        Ok(stats) =\u003e {\n            if !verbose {\n                println!(); // Newline after progress\n            }\n            println!();\n            println!(\"Indexing complete:\");\n            println!(\"  Files found:    {}\", stats.files_found);\n\n            if force {\n                // Full reindex stats\n                println!(\"  Notes indexed:  {}\", stats.notes_indexed);\n            } else {\n                // Incremental stats\n                println!(\"  Unchanged:      {}\", stats.files_unchanged);\n                println!(\"  Added:          {}\", stats.files_added);\n                println!(\"  Updated:        {}\", stats.files_updated);\n                println!(\"  Deleted:        {}\", stats.files_deleted);\n            }\n\n            if stats.notes_skipped \u003e 0 {\n                println!(\"  Skipped:        {}\", stats.notes_skipped);\n            }\n            println!(\"  Links indexed:  {}\", stats.links_indexed);\n            println!(\"  Broken links:   {}\", stats.broken_links);\n            println!(\"  Duration:       {}ms\", stats.duration_ms);\n\n            // Compute derived indices\n            if verbose {\n                println!();\n                println!(\"Computing derived indices...\");\n            }\n            let derived_builder = DerivedIndexBuilder::new(\u0026db);\n            match derived_builder.compute_all() {\n                Ok(derived_stats) =\u003e {\n                    println!();\n                    println!(\"Derived indices:\");\n                    println!(\n                        \"  Dailies processed:    {}\",\n                        derived_stats.dailies_processed\n                    );\n                    println!(\n                        \"  Activity records:     {}\",\n                        derived_stats.activity_records\n                    );\n                    println!(\n                        \"  Activity summaries:   {}\",\n                        derived_stats.summaries_computed\n                    );\n                    println!(\n                        \"  Cooccurrence pairs:   {}\",\n                        derived_stats.cooccurrence_pairs\n                    );\n                    println!(\"  Duration:             {}ms\", derived_stats.duration_ms);\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"Warning: Failed to compute derived indices: {}\", e);\n                }\n            }\n\n            println!();\n            println!(\"Index stored at: {}\", index_path.display());\n        }\n        Err(e) =\u003e {\n            eprintln!(\"\\nError during indexing: {}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":75},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","rename.rs"],"content":"//! Rename command implementation.\n\nuse std::io::{self, Write};\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::IndexDb;\nuse mdvault_core::rename::{\n    execute_rename, generate_preview, FileChange, RenameError, RenamePreview,\n};\n\nuse crate::RenameArgs;\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: RenameArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Generate preview\n    let preview = match generate_preview(\u0026db, \u0026rc.vault_root, \u0026args.source, \u0026args.dest) {\n        Ok(p) =\u003e p,\n        Err(e) =\u003e {\n            print_error(\u0026e);\n            std::process::exit(1);\n        }\n    };\n\n    // Display preview\n    print_preview(\u0026preview, \u0026rc.vault_root);\n\n    // If dry-run, stop here\n    if args.dry_run {\n        println!();\n        println!(\"(dry-run mode - no changes made)\");\n        return;\n    }\n\n    // Confirm unless --yes\n    if !args.yes \u0026\u0026 !confirm_rename() {\n        println!(\"Cancelled.\");\n        return;\n    }\n\n    // Execute rename\n    match execute_rename(\u0026db, \u0026rc.vault_root, \u0026args.source, \u0026args.dest) {\n        Ok(result) =\u003e {\n            println!();\n            println!(\n                \"Renamed: {} -\u003e {}\",\n                result\n                    .old_path\n                    .strip_prefix(\u0026rc.vault_root)\n                    .unwrap_or(\u0026result.old_path)\n                    .display(),\n                result\n                    .new_path\n                    .strip_prefix(\u0026rc.vault_root)\n                    .unwrap_or(\u0026result.new_path)\n                    .display()\n            );\n            println!(\"Files modified: {}\", result.files_modified.len());\n            println!(\"References updated: {}\", result.references_updated);\n\n            // Print any warnings\n            for warning in \u0026result.warnings {\n                eprintln!(\"{}\", warning);\n            }\n        }\n        Err(e) =\u003e {\n            print_error(\u0026e);\n            std::process::exit(1);\n        }\n    }\n}\n\nfn print_error(e: \u0026RenameError) {\n    match e {\n        RenameError::SourceNotFound(path) =\u003e {\n            eprintln!(\"Error: Source file not found: {}\", path.display());\n        }\n        RenameError::TargetExists(path) =\u003e {\n            eprintln!(\"Error: Target file already exists: {}\", path.display());\n        }\n        RenameError::NoteNotInIndex(path) =\u003e {\n            eprintln!(\"Error: Note not found in index: {}\", path.display());\n            eprintln!(\"Hint: Run 'mdv reindex' to update the index.\");\n        }\n        _ =\u003e {\n            eprintln!(\"Error: {}\", e);\n        }\n    }\n}\n\nfn print_preview(preview: \u0026RenamePreview, vault_root: \u0026Path) {\n    let old_rel = preview.old_path.strip_prefix(vault_root).unwrap_or(\u0026preview.old_path);\n    let new_rel = preview.new_path.strip_prefix(vault_root).unwrap_or(\u0026preview.new_path);\n\n    println!(\"Renaming: {} -\u003e {}\", old_rel.display(), new_rel.display());\n    println!();\n\n    if preview.references.is_empty() {\n        println!(\"No references found to update.\");\n    } else {\n        println!(\n            \"Found {} reference(s) in {} file(s):\",\n            preview.total_references(),\n            preview.files_affected()\n        );\n        println!();\n\n        for change in \u0026preview.changes {\n            print_file_change(change, vault_root);\n        }\n    }\n\n    // Print warnings\n    for warning in \u0026preview.warnings {\n        println!();\n        eprintln!(\"{}\", warning);\n    }\n}\n\nfn print_file_change(change: \u0026FileChange, vault_root: \u0026Path) {\n    let rel_path = change.path.strip_prefix(vault_root).unwrap_or(\u0026change.path);\n    println!(\"{}:\", rel_path.display());\n\n    for reference in \u0026change.references {\n        let location = if reference.line_number \u003e 0 {\n            format!(\"  Line {}:\", reference.line_number)\n        } else {\n            \"  Frontmatter:\".to_string()\n        };\n\n        // Show the original reference\n        println!(\"{} {}\", location, reference.original);\n    }\n\n    println!();\n}\n\nfn confirm_rename() -\u003e bool {\n    print!(\"Proceed? [y/N] \");\n    io::stdout().flush().unwrap();\n\n    let mut input = String::new();\n    if io::stdin().read_line(\u0026mut input).is_err() {\n        return false;\n    }\n\n    let input = input.trim().to_lowercase();\n    input == \"y\" || input == \"yes\"\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":93},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","search.rs"],"content":"//! Search command implementation.\n\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{\n    IndexDb, MatchSource, SearchEngine, SearchMode, SearchQuery, SearchResult,\n};\nuse serde::Serialize;\n\nuse crate::{OutputFormat, SearchArgs, SearchModeArg};\n\n/// Search result for JSON output.\n#[derive(Debug, Serialize)]\nstruct SearchResultOutput {\n    path: String,\n    #[serde(rename = \"type\")]\n    note_type: String,\n    title: String,\n    score: f64,\n    match_source: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    staleness: Option\u003cf64\u003e,\n}\n\nimpl From\u003c\u0026SearchResult\u003e for SearchResultOutput {\n    fn from(result: \u0026SearchResult) -\u003e Self {\n        Self {\n            path: result.note.path.to_string_lossy().to_string(),\n            note_type: result.note.note_type.as_str().to_string(),\n            title: result.note.title.clone(),\n            score: result.score,\n            match_source: format_match_source(\u0026result.match_source),\n            staleness: result.staleness,\n        }\n    }\n}\n\nfn format_match_source(source: \u0026MatchSource) -\u003e String {\n    match source {\n        MatchSource::Direct =\u003e \"direct\".to_string(),\n        MatchSource::Linked { hops } =\u003e format!(\"linked({})\", hops),\n        MatchSource::Temporal { daily_path } =\u003e format!(\"temporal({})\", daily_path),\n        MatchSource::Cooccurrence { shared_dailies } =\u003e {\n            format!(\"cooccur({})\", shared_dailies)\n        }\n    }\n}\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: SearchArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Convert search mode\n    let mode = match args.mode {\n        SearchModeArg::Direct =\u003e SearchMode::Direct,\n        SearchModeArg::Neighbourhood =\u003e SearchMode::Neighbourhood { hops: 2 },\n        SearchModeArg::Temporal =\u003e SearchMode::Temporal { days: 30 },\n        SearchModeArg::Cooccurrence =\u003e SearchMode::Cooccurrence { min_shared: 2 },\n        SearchModeArg::Full =\u003e SearchMode::Full,\n    };\n\n    // Build search query\n    let query = SearchQuery {\n        text: args.query,\n        note_type: args.r#type.map(|t| t.into()),\n        path_prefix: None,\n        mode,\n        limit: args.limit,\n        temporal_boost: args.boost,\n    };\n\n    // Execute search\n    let engine = SearchEngine::new(\u0026db);\n    let results = match engine.search(\u0026query) {\n        Ok(results) =\u003e results,\n        Err(e) =\u003e {\n            eprintln!(\"Error searching: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Determine output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Output results\n    match format {\n        OutputFormat::Table =\u003e print_results_table(\u0026results),\n        OutputFormat::Json =\u003e print_results_json(\u0026results),\n        OutputFormat::Quiet =\u003e print_results_quiet(\u0026results),\n    }\n}\n\n/// Print search results as a table.\nfn print_results_table(results: \u0026[SearchResult]) {\n    if results.is_empty() {\n        println!(\"(no results found)\");\n        return;\n    }\n\n    // Calculate column widths\n    let path_width = results\n        .iter()\n        .map(|r| r.note.path.to_string_lossy().len())\n        .max()\n        .unwrap_or(4)\n        .clamp(4, 40);\n    let title_width =\n        results.iter().map(|r| r.note.title.len()).max().unwrap_or(5).clamp(5, 30);\n    let source_width = 15;\n\n    // Header\n    println!(\n        \"{:\u003cpath_width$}  {:\u003ctitle_width$}  SCORE  {:\u003csource_width$}\",\n        \"PATH\",\n        \"TITLE\",\n        \"SOURCE\",\n        path_width = path_width,\n        title_width = title_width,\n        source_width = source_width,\n    );\n    println!(\n        \"{:-\u003cpath_width$}  {:-\u003ctitle_width$}  {:-\u003c5}  {:-\u003csource_width$}\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        path_width = path_width,\n        title_width = title_width,\n        source_width = source_width,\n    );\n\n    // Rows\n    for result in results {\n        let path = truncate(\u0026result.note.path.to_string_lossy(), path_width);\n        let title = truncate(\u0026result.note.title, title_width);\n        let source = format_match_source(\u0026result.match_source);\n        let source = truncate(\u0026source, source_width);\n\n        println!(\n            \"{:\u003cpath_width$}  {:\u003ctitle_width$}  {:5.2}  {:\u003csource_width$}\",\n            path,\n            title,\n            result.score,\n            source,\n            path_width = path_width,\n            title_width = title_width,\n            source_width = source_width,\n        );\n    }\n\n    println!();\n    println!(\"-- {} results --\", results.len());\n}\n\n/// Print search results as JSON.\nfn print_results_json(results: \u0026[SearchResult]) {\n    let output: Vec\u003cSearchResultOutput\u003e =\n        results.iter().map(SearchResultOutput::from).collect();\n    println!(\"{}\", serde_json::to_string_pretty(\u0026output).unwrap_or_default());\n}\n\n/// Print search results as paths only.\nfn print_results_quiet(results: \u0026[SearchResult]) {\n    for result in results {\n        println!(\"{}\", result.note.path.display());\n    }\n}\n\n/// Truncate string with ellipsis if needed.\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else if max_len \u003e 3 {\n        format!(\"{}...\", \u0026s[..max_len - 3])\n    } else {\n        s[..max_len].to_string()\n    }\n}\n\n/// Resolve the output format from flags.\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":93},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","stale.rs"],"content":"//! Stale notes command implementation.\n\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{IndexDb, IndexedNote};\nuse serde::Serialize;\n\nuse crate::{OutputFormat, StaleArgs};\n\n/// Stale note output for JSON.\n#[derive(Debug, Serialize)]\nstruct StaleNoteOutput {\n    path: String,\n    #[serde(rename = \"type\")]\n    note_type: String,\n    title: String,\n    staleness: f64,\n    last_seen: Option\u003cString\u003e,\n}\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: StaleArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Open database\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Error opening index: {}\", e);\n            eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Get note type filter\n    let note_type_str = args.r#type.map(|t| {\n        use mdvault_core::index::NoteType;\n        let nt: NoteType = t.into();\n        nt.as_str().to_string()\n    });\n\n    // Query stale notes\n    let results: Vec\u003cStaleNote\u003e = if let Some(days) = args.days {\n        // Query by days not seen\n        match db.get_notes_not_seen_in_days(days, note_type_str.as_deref(), args.limit) {\n            Ok(notes) =\u003e notes\n                .into_iter()\n                .map(|(note, last_seen)| StaleNote {\n                    note,\n                    staleness: 1.0, // Max staleness for day-based query\n                    last_seen,\n                })\n                .collect(),\n            Err(e) =\u003e {\n                eprintln!(\"Error querying stale notes: {}\", e);\n                std::process::exit(1);\n            }\n        }\n    } else {\n        // Query by staleness threshold\n        match db.get_stale_notes(args.threshold, note_type_str.as_deref(), args.limit) {\n            Ok(notes) =\u003e notes\n                .into_iter()\n                .map(|(note, staleness)| StaleNote {\n                    note,\n                    staleness,\n                    last_seen: None, // Not available in staleness query\n                })\n                .collect(),\n            Err(e) =\u003e {\n                eprintln!(\"Error querying stale notes: {}\", e);\n                std::process::exit(1);\n            }\n        }\n    };\n\n    // Determine output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Output results\n    match format {\n        OutputFormat::Table =\u003e print_stale_table(\u0026results),\n        OutputFormat::Json =\u003e print_stale_json(\u0026results),\n        OutputFormat::Quiet =\u003e print_stale_quiet(\u0026results),\n    }\n}\n\n/// Internal stale note representation.\nstruct StaleNote {\n    note: IndexedNote,\n    staleness: f64,\n    last_seen: Option\u003cString\u003e,\n}\n\n/// Print stale notes as a table.\nfn print_stale_table(notes: \u0026[StaleNote]) {\n    if notes.is_empty() {\n        println!(\"(no stale notes found)\");\n        return;\n    }\n\n    // Calculate column widths\n    let path_width = notes\n        .iter()\n        .map(|n| n.note.path.to_string_lossy().len())\n        .max()\n        .unwrap_or(4)\n        .clamp(4, 45);\n    let title_width =\n        notes.iter().map(|n| n.note.title.len()).max().unwrap_or(5).clamp(5, 30);\n\n    // Header\n    println!(\n        \"{:\u003cpath_width$}  {:\u003ctitle_width$}  STALENESS  LAST_SEEN\",\n        \"PATH\",\n        \"TITLE\",\n        path_width = path_width,\n        title_width = title_width,\n    );\n    println!(\n        \"{:-\u003cpath_width$}  {:-\u003ctitle_width$}  {:-\u003c9}  {:-\u003c10}\",\n        \"\",\n        \"\",\n        \"\",\n        \"\",\n        path_width = path_width,\n        title_width = title_width,\n    );\n\n    // Rows\n    for stale in notes {\n        let path = truncate(\u0026stale.note.path.to_string_lossy(), path_width);\n        let title = truncate(\u0026stale.note.title, title_width);\n        let last_seen = stale.last_seen.as_deref().unwrap_or(\"-\");\n\n        println!(\n            \"{:\u003cpath_width$}  {:\u003ctitle_width$}  {:9.2}  {}\",\n            path,\n            title,\n            stale.staleness,\n            last_seen,\n            path_width = path_width,\n            title_width = title_width,\n        );\n    }\n\n    println!();\n    println!(\"-- {} stale notes --\", notes.len());\n}\n\n/// Print stale notes as JSON.\nfn print_stale_json(notes: \u0026[StaleNote]) {\n    let output: Vec\u003cStaleNoteOutput\u003e = notes\n        .iter()\n        .map(|stale| StaleNoteOutput {\n            path: stale.note.path.to_string_lossy().to_string(),\n            note_type: stale.note.note_type.as_str().to_string(),\n            title: stale.note.title.clone(),\n            staleness: stale.staleness,\n            last_seen: stale.last_seen.clone(),\n        })\n        .collect();\n    println!(\"{}\", serde_json::to_string_pretty(\u0026output).unwrap_or_default());\n}\n\n/// Print stale notes as paths only.\nfn print_stale_quiet(notes: \u0026[StaleNote]) {\n    for stale in notes {\n        println!(\"{}\", stale.note.path.display());\n    }\n}\n\n/// Truncate string with ellipsis if needed.\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else if max_len \u003e 3 {\n        format!(\"{}...\", \u0026s[..max_len - 3])\n    } else {\n        s[..max_len].to_string()\n    }\n}\n\n/// Resolve the output format from flags.\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":89},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","task.rs"],"content":"//! Task management commands.\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::index::{IndexDb, IndexedNote, NoteQuery, NoteType};\nuse std::path::Path;\nuse tabled::{settings::Style, Table, Tabled};\n\n/// Row for task list table.\n#[derive(Tabled)]\nstruct TaskListRow {\n    #[tabled(rename = \"ID\")]\n    id: String,\n    #[tabled(rename = \"Title\")]\n    title: String,\n    #[tabled(rename = \"Status\")]\n    status: String,\n    #[tabled(rename = \"Project\")]\n    project: String,\n}\n\n/// List tasks with optional filters.\npub fn list(\n    config: Option\u003c\u0026Path\u003e,\n    profile: Option\u003c\u0026str\u003e,\n    project_filter: Option\u003c\u0026str\u003e,\n    status_filter: Option\u003c\u0026str\u003e,\n) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load config: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to open index: {e}\");\n            eprintln!(\"Run 'mdv reindex' first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Query all tasks\n    let query = NoteQuery { note_type: Some(NoteType::Task), ..Default::default() };\n\n    let tasks = match db.query_notes(\u0026query) {\n        Ok(t) =\u003e t,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to query tasks: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    if tasks.is_empty() {\n        println!(\"No tasks found.\");\n        return;\n    }\n\n    // Build table rows\n    let mut rows: Vec\u003cTaskListRow\u003e = Vec::new();\n\n    for task in \u0026tasks {\n        let path_str = task.path.to_string_lossy();\n\n        // Filter by project if specified\n        if let Some(proj) = project_filter {\n            if !path_str.contains(proj) {\n                continue;\n            }\n        }\n\n        // Get task info from frontmatter\n        let (task_id, task_status, project) = extract_task_info(task);\n\n        // Filter by status if specified\n        if let Some(status) = status_filter {\n            if task_status != status {\n                continue;\n            }\n        }\n\n        let title = if task.title.is_empty() {\n            task.path\n                .file_stem()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"Untitled\")\n                .to_string()\n        } else {\n            task.title.clone()\n        };\n\n        rows.push(TaskListRow { id: task_id, title, status: task_status, project });\n    }\n\n    if rows.is_empty() {\n        println!(\"No tasks match the filter.\");\n        return;\n    }\n\n    // Sort by project then ID\n    rows.sort_by(|a, b| a.project.cmp(\u0026b.project).then_with(|| a.id.cmp(\u0026b.id)));\n\n    let table = Table::new(\u0026rows).with(Style::rounded()).to_string();\n\n    println!(\"{}\", table);\n    println!(\"\\nTotal: {} tasks\", rows.len());\n}\n\n/// Show detailed status for a specific task.\npub fn status(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, task_id: \u0026str) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load config: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n    let db = match IndexDb::open(\u0026index_path) {\n        Ok(db) =\u003e db,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to open index: {e}\");\n            eprintln!(\"Run 'mdv reindex' first.\");\n            std::process::exit(1);\n        }\n    };\n\n    // Query all tasks and find the one with matching ID\n    let query = NoteQuery { note_type: Some(NoteType::Task), ..Default::default() };\n    let tasks = db.query_notes(\u0026query).unwrap_or_default();\n\n    let task = tasks.iter().find(|t| {\n        let (id, _, _) = extract_task_info(t);\n        id.eq_ignore_ascii_case(task_id)\n    });\n\n    let task = match task {\n        Some(t) =\u003e t,\n        None =\u003e {\n            // Also try matching by filename\n            let task_by_path = tasks.iter().find(|t| {\n                let stem = t.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n                stem.eq_ignore_ascii_case(task_id)\n            });\n            match task_by_path {\n                Some(t) =\u003e t,\n                None =\u003e {\n                    eprintln!(\"Task not found: {}\", task_id);\n                    eprintln!(\"Run 'mdv task list' to see available tasks.\");\n                    std::process::exit(1);\n                }\n            }\n        }\n    };\n\n    // Extract all task info\n    let (id, status, project) = extract_task_info(task);\n    let title = if task.title.is_empty() {\n        task.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"Untitled\").to_string()\n    } else {\n        task.title.clone()\n    };\n\n    // Get additional info from frontmatter\n    let fm = task\n        .frontmatter_json\n        .as_ref()\n        .and_then(|fm| serde_json::from_str::\u003cserde_json::Value\u003e(fm).ok());\n\n    let created = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"created\").and_then(|v| v.as_str()))\n        .unwrap_or(\"-\");\n\n    let completed_at = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"completed_at\").and_then(|v| v.as_str()))\n        .unwrap_or(\"-\");\n\n    // Print task details\n    println!(\"Task: {} [{}]\", title, id);\n    println!();\n    println!(\"  Status:       {}\", status);\n    println!(\"  Project:      {}\", project);\n    println!(\"  Created:      {}\", created);\n    if status == \"done\" || status == \"completed\" {\n        println!(\"  Completed:    {}\", completed_at);\n    }\n    println!(\"  Path:         {}\", task.path.display());\n}\n\n/// Mark a task as done.\npub fn done(\n    config: Option\u003c\u0026Path\u003e,\n    profile: Option\u003c\u0026str\u003e,\n    task_path: \u0026Path,\n    summary: Option\u003c\u0026str\u003e,\n) {\n    let cfg = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to load config: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Resolve task path relative to vault root\n    let full_path = if task_path.is_absolute() {\n        task_path.to_path_buf()\n    } else {\n        cfg.vault_root.join(task_path)\n    };\n\n    if !full_path.exists() {\n        eprintln!(\"Task not found: {}\", full_path.display());\n        std::process::exit(1);\n    }\n\n    // Read the task file\n    let content = match std::fs::read_to_string(\u0026full_path) {\n        Ok(c) =\u003e c,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to read task: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Parse and update frontmatter\n    let parsed = match mdvault_core::frontmatter::parse(\u0026content) {\n        Ok(p) =\u003e p,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to parse task frontmatter: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let mut fm = match parsed.frontmatter {\n        Some(fm) =\u003e fm,\n        None =\u003e {\n            eprintln!(\"Task has no frontmatter\");\n            std::process::exit(1);\n        }\n    };\n\n    // Update status to done\n    fm.fields.insert(\"status\".to_string(), serde_yaml::Value::String(\"done\".to_string()));\n\n    // Update completed_at\n    let now = chrono::Utc::now().format(\"%Y-%m-%dT%H:%M:%S\").to_string();\n    fm.fields.insert(\"completed_at\".to_string(), serde_yaml::Value::String(now.clone()));\n\n    // Get task ID for output\n    let task_id = fm\n        .fields\n        .get(\"task-id\")\n        .and_then(|v| match v {\n            serde_yaml::Value::String(s) =\u003e Some(s.clone()),\n            _ =\u003e None,\n        })\n        .unwrap_or_else(|| {\n            full_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"task\").to_string()\n        });\n\n    // Rebuild the document\n    let mut mapping = serde_yaml::Mapping::new();\n    for (k, v) in fm.fields {\n        mapping.insert(serde_yaml::Value::String(k), v);\n    }\n    let yaml_str = match serde_yaml::to_string(\u0026serde_yaml::Value::Mapping(mapping)) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            eprintln!(\"Failed to serialize frontmatter: {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    // Append summary to body if provided\n    let body = if let Some(sum) = summary {\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n        let time = chrono::Local::now().format(\"%H:%M\").to_string();\n        format!(\n            \"{}\\n- **[[{}]] {}** : Completed - {}\\n\",\n            parsed.body.trim_end(),\n            today,\n            time,\n            sum\n        )\n    } else {\n        parsed.body\n    };\n\n    let final_content = format!(\"---\\n{}---\\n{}\", yaml_str, body);\n\n    // Write back\n    if let Err(e) = std::fs::write(\u0026full_path, final_content) {\n        eprintln!(\"Failed to write task: {e}\");\n        std::process::exit(1);\n    }\n\n    println!(\"OK   mdv task done\");\n    println!(\"task:   {}\", task_id);\n    println!(\"status: done\");\n    if summary.is_some() {\n        println!(\"summary: logged to task\");\n    }\n}\n\n/// Extract task ID, status, and project from frontmatter.\nfn extract_task_info(task: \u0026IndexedNote) -\u003e (String, String, String) {\n    let fm = task\n        .frontmatter_json\n        .as_ref()\n        .and_then(|fm| serde_json::from_str::\u003cserde_json::Value\u003e(fm).ok());\n\n    let id = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"task-id\").and_then(|v| v.as_str()))\n        .map(String::from)\n        .unwrap_or_else(|| \"-\".to_string());\n\n    let status = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"status\").and_then(|v| v.as_str()))\n        .map(String::from)\n        .unwrap_or_else(|| \"unknown\".to_string());\n\n    let project = fm\n        .as_ref()\n        .and_then(|fm| fm.get(\"project\").and_then(|v| v.as_str()))\n        .map(String::from)\n        .unwrap_or_else(|| {\n            // Try to extract from path\n            extract_project_from_path(\u0026task.path.to_string_lossy())\n        });\n\n    (id, status, project)\n}\n\n/// Extract project name from a task path.\nfn extract_project_from_path(path: \u0026str) -\u003e String {\n    // Expected format: Projects/\u003cproject\u003e/Tasks/\u003ctask\u003e.md\n    let parts: Vec\u003c\u0026str\u003e = path.split('/').collect();\n    if parts.len() \u003e= 3 \u0026\u0026 parts[0] == \"Projects\" {\n        return parts[1].to_string();\n    }\n    \"inbox\".to_string()\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":173},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","cmd","validate.rs"],"content":"//! Validate command implementation.\n\nuse std::path::Path;\n\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::frontmatter::parse as parse_frontmatter;\nuse mdvault_core::index::IndexDb;\nuse mdvault_core::types::{\n    add_link_integrity_warnings, apply_fixes, try_fix_note, validate_note, TypeRegistry,\n    TypedefRepository, ValidationResult,\n};\n\nuse crate::{OutputFormat, ValidateArgs};\n\npub fn run(config: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e, args: ValidateArgs) {\n    // Load configuration\n    let rc = match ConfigLoader::load(config, profile) {\n        Ok(rc) =\u003e rc,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading config: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // Load type definitions\n    let typedef_repo = match TypedefRepository::new(\u0026rc.typedefs_dir) {\n        Ok(repo) =\u003e repo,\n        Err(e) =\u003e {\n            eprintln!(\"Error loading type definitions: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    let registry = match TypeRegistry::from_repository(\u0026typedef_repo) {\n        Ok(reg) =\u003e reg,\n        Err(e) =\u003e {\n            eprintln!(\"Error building type registry: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    // If --list-types, just show available types\n    if args.list_types {\n        print_types(\u0026registry);\n        return;\n    }\n\n    // Open index database if needed (for querying notes or link checking)\n    let index_path = rc.vault_root.join(\".mdvault/index.db\");\n    let index_db: Option\u003cIndexDb\u003e = if args.path.is_none() || args.check_links {\n        match IndexDb::open(\u0026index_path) {\n            Ok(db) =\u003e Some(db),\n            Err(e) =\u003e {\n                if args.path.is_none() {\n                    // Index is required for index-based mode\n                    eprintln!(\"Error opening index: {}\", e);\n                    eprintln!(\"Hint: Run 'mdv reindex' to build the index first.\");\n                    std::process::exit(1);\n                } else if args.check_links {\n                    // Index is optional for single-file mode with link checking\n                    eprintln!(\n                        \"Warning: Cannot check links - index not available. Run 'mdv reindex' first.\"\n                    );\n                    None\n                } else {\n                    None\n                }\n            }\n        }\n    } else {\n        None\n    };\n\n    // Check if we're validating a specific file or using the index\n    let notes_to_validate = if let Some(ref path) = args.path {\n        // Single file mode\n        let full_path = if Path::new(path).is_absolute() {\n            std::path::PathBuf::from(path)\n        } else {\n            rc.vault_root.join(path)\n        };\n\n        if !full_path.exists() {\n            eprintln!(\"Error: File not found: {}\", full_path.display());\n            std::process::exit(1);\n        }\n\n        let content = match std::fs::read_to_string(\u0026full_path) {\n            Ok(c) =\u003e c,\n            Err(e) =\u003e {\n                eprintln!(\"Error reading file: {}\", e);\n                std::process::exit(1);\n            }\n        };\n\n        // Extract note type from frontmatter\n        let note_type = extract_note_type(\u0026content);\n\n        // Compute relative path for link checking\n        let relative_path = full_path\n            .strip_prefix(\u0026rc.vault_root)\n            .map(|p| p.to_path_buf())\n            .unwrap_or_else(|_| full_path.clone());\n\n        vec![NoteInfo { path: full_path, relative_path, note_type, content }]\n    } else {\n        // Index-based mode - index_db is guaranteed to be Some here\n        let db = index_db.as_ref().unwrap();\n\n        // Query notes to validate\n        let query = mdvault_core::index::NoteQuery {\n            note_type: args.r#type.as_ref().map(|s| s.parse().unwrap_or_default()),\n            path_prefix: None,\n            modified_after: None,\n            modified_before: None,\n            limit: args.limit,\n            offset: None,\n        };\n\n        let notes = match db.query_notes(\u0026query) {\n            Ok(notes) =\u003e notes,\n            Err(e) =\u003e {\n                eprintln!(\"Error querying notes: {}\", e);\n                std::process::exit(1);\n            }\n        };\n\n        // Convert to NoteInfo\n        let note_infos: Vec\u003cNoteInfo\u003e = notes\n            .into_iter()\n            .map(|n| {\n                let full_path = rc.vault_root.join(\u0026n.path);\n                let content = std::fs::read_to_string(\u0026full_path).unwrap_or_default();\n                NoteInfo {\n                    path: full_path,\n                    relative_path: n.path,\n                    note_type: n.note_type.as_str().to_string(),\n                    content,\n                }\n            })\n            .collect();\n\n        note_infos\n    };\n\n    // Validate each note\n    let mut total = 0;\n    let mut valid_count = 0;\n    let mut error_count = 0;\n    let mut fixed_count = 0;\n    let mut results: Vec\u003c(\n        std::path::PathBuf,\n        String,\n        ValidationResult,\n        Option\u003cVec\u003cString\u003e\u003e,\n    )\u003e = Vec::new();\n\n    for note in \u0026notes_to_validate {\n        total += 1;\n        let note_type = \u0026note.note_type;\n\n        // Parse frontmatter\n        let frontmatter: serde_yaml::Value = parse_frontmatter(\u0026note.content)\n            .ok()\n            .and_then(|p| p.frontmatter)\n            .map(|fm| {\n                let mut map = serde_yaml::Mapping::new();\n                for (k, v) in fm.fields {\n                    map.insert(serde_yaml::Value::String(k), v);\n                }\n                serde_yaml::Value::Mapping(map)\n            })\n            .unwrap_or(serde_yaml::Value::Mapping(serde_yaml::Mapping::new()));\n\n        // Run type-based validation (skip for untyped notes without custom definitions)\n        let mut result = if !registry.has_definition(note_type) \u0026\u0026 note_type == \"none\" {\n            ValidationResult::default()\n        } else {\n            validate_note(\n                \u0026registry,\n                note_type,\n                \u0026note.path.to_string_lossy(),\n                \u0026frontmatter,\n                \u0026note.content,\n            )\n        };\n\n        // Check link integrity if requested and index is available\n        if args.check_links {\n            if let Some(ref db) = index_db {\n                add_link_integrity_warnings(\u0026mut result, db, \u0026note.relative_path);\n            }\n        }\n\n        // Determine if note is valid (errors only, warnings don't count)\n        let has_errors = !result.errors.is_empty();\n        let has_warnings = !result.warnings.is_empty();\n\n        if !has_errors \u0026\u0026 !has_warnings {\n            valid_count += 1;\n        } else if !has_errors {\n            // Only warnings, still valid but add to results for display\n            valid_count += 1;\n            results.push((note.path.clone(), note_type.clone(), result, None));\n        } else {\n            // Has errors - try to fix if --fix is set\n            let fixes = if args.fix {\n                let fix_result =\n                    try_fix_note(\u0026registry, note_type, \u0026note.content, \u0026result.errors);\n                if fix_result.fixed {\n                    if let Some(new_content) = fix_result.content {\n                        if let Err(e) = apply_fixes(\u0026note.path, \u0026new_content) {\n                            eprintln!(\n                                \"Warning: Failed to apply fixes to {}: {}\",\n                                note.path.display(),\n                                e\n                            );\n                            None\n                        } else {\n                            fixed_count += 1;\n                            Some(fix_result.fixes)\n                        }\n                    } else {\n                        None\n                    }\n                } else {\n                    None\n                }\n            } else {\n                None\n            };\n\n            // Only count as error if not fully fixed\n            if fixes.is_none()\n                || result.errors.len() \u003e fixes.as_ref().map_or(0, |f| f.len())\n            {\n                error_count += 1;\n            }\n            results.push((note.path.clone(), note_type.clone(), result, fixes));\n        }\n    }\n\n    // Determine output format\n    let format = resolve_format(args.output, args.json, args.quiet);\n\n    // Output results\n    match format {\n        OutputFormat::Table =\u003e print_results_table(\n            \u0026results,\n            total,\n            valid_count,\n            error_count,\n            fixed_count,\n            args.fix,\n        ),\n        OutputFormat::Json =\u003e {\n            print_results_json(\u0026results, total, valid_count, error_count, fixed_count)\n        }\n        OutputFormat::Quiet =\u003e print_results_quiet(\u0026results),\n    }\n\n    // Exit with error code if any validation failures remain unfixed\n    if error_count \u003e 0 {\n        std::process::exit(1);\n    }\n}\n\n/// Information about a note to validate.\nstruct NoteInfo {\n    path: std::path::PathBuf,\n    relative_path: std::path::PathBuf,\n    note_type: String,\n    content: String,\n}\n\n/// Extract note type from content's frontmatter.\nfn extract_note_type(content: \u0026str) -\u003e String {\n    parse_frontmatter(content)\n        .ok()\n        .and_then(|p| p.frontmatter)\n        .and_then(|fm| fm.fields.get(\"type\").cloned())\n        .and_then(|v| match v {\n            serde_yaml::Value::String(s) =\u003e Some(s),\n            _ =\u003e None,\n        })\n        .unwrap_or_else(|| \"none\".to_string())\n}\n\nfn print_types(registry: \u0026TypeRegistry) {\n    println!(\"Available note types:\");\n    println!();\n\n    // Built-in types\n    println!(\"Built-in types:\");\n    for name in [\"daily\", \"weekly\", \"task\", \"project\", \"zettel\"] {\n        let has_override = registry.has_definition(name);\n        if has_override {\n            println!(\"  {} (with Lua override)\", name);\n        } else {\n            println!(\"  {}\", name);\n        }\n    }\n\n    // Custom types\n    let custom = registry.list_custom_types();\n    if !custom.is_empty() {\n        println!();\n        println!(\"Custom types:\");\n        for name in custom {\n            if let Some(td) = registry.get(name) {\n                if let Some(desc) = \u0026td.description {\n                    println!(\"  {} - {}\", name, desc);\n                } else {\n                    println!(\"  {}\", name);\n                }\n            }\n        }\n    }\n}\n\nfn print_results_table(\n    results: \u0026[(std::path::PathBuf, String, ValidationResult, Option\u003cVec\u003cString\u003e\u003e)],\n    total: usize,\n    valid: usize,\n    errors: usize,\n    fixed: usize,\n    fix_mode: bool,\n) {\n    if results.is_empty() {\n        println!(\"All {} notes validated successfully.\", total);\n        return;\n    }\n\n    if fix_mode \u0026\u0026 fixed \u003e 0 {\n        println!(\n            \"Validation Results: {} valid, {} fixed, {} with errors (of {} total)\",\n            valid, fixed, errors, total\n        );\n    } else {\n        println!(\n            \"Validation Results: {} valid, {} with errors (of {} total)\",\n            valid, errors, total\n        );\n    }\n    println!();\n\n    for (path, note_type, result, fixes) in results {\n        println!(\"{}  [type: {}]\", path.display(), note_type);\n\n        // Show fixes if any\n        if let Some(applied_fixes) = fixes {\n            for fix in applied_fixes {\n                println!(\"  + {}\", fix);\n            }\n        }\n\n        // Show remaining errors\n        for error in \u0026result.errors {\n            // Skip errors that were fixed\n            if let Some(ref applied) = fixes {\n                let error_str = error.to_string();\n                if applied\n                    .iter()\n                    .any(|f| error_str.contains(f.split('\\'').nth(1).unwrap_or(\"\")))\n                {\n                    continue;\n                }\n            }\n            println!(\"  - {}\", error);\n        }\n\n        for warning in \u0026result.warnings {\n            println!(\"  ~ {}\", warning);\n        }\n        println!();\n    }\n}\n\nfn print_results_json(\n    results: \u0026[(std::path::PathBuf, String, ValidationResult, Option\u003cVec\u003cString\u003e\u003e)],\n    total: usize,\n    valid: usize,\n    errors: usize,\n    fixed: usize,\n) {\n    #[derive(serde::Serialize)]\n    struct Output {\n        total: usize,\n        valid: usize,\n        errors: usize,\n        fixed: usize,\n        results: Vec\u003cNoteResult\u003e,\n    }\n\n    #[derive(serde::Serialize)]\n    struct NoteResult {\n        path: String,\n        note_type: String,\n        valid: bool,\n        errors: Vec\u003cString\u003e,\n        warnings: Vec\u003cString\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        fixes_applied: Option\u003cVec\u003cString\u003e\u003e,\n    }\n\n    let output = Output {\n        total,\n        valid,\n        errors,\n        fixed,\n        results: results\n            .iter()\n            .map(|(path, note_type, result, fixes)| NoteResult {\n                path: path.to_string_lossy().to_string(),\n                note_type: note_type.clone(),\n                valid: result.valid,\n                errors: result.errors.iter().map(|e| e.to_string()).collect(),\n                warnings: result.warnings.clone(),\n                fixes_applied: fixes.clone(),\n            })\n            .collect(),\n    };\n\n    println!(\"{}\", serde_json::to_string_pretty(\u0026output).unwrap());\n}\n\nfn print_results_quiet(\n    results: \u0026[(std::path::PathBuf, String, ValidationResult, Option\u003cVec\u003cString\u003e\u003e)],\n) {\n    for (path, _, _, _) in results {\n        println!(\"{}\", path.display());\n    }\n}\n\nfn resolve_format(output: OutputFormat, json: bool, quiet: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else if quiet {\n        OutputFormat::Quiet\n    } else {\n        output\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":204},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","completions.rs"],"content":"//! Shell completion support with dynamic value completers.\n//!\n//! This module provides intelligent tab completions that understand the user's vault\n//! configuration, offering context-aware suggestions for types, templates, captures, etc.\n\nuse clap_complete::engine::CompletionCandidate;\nuse mdvault_core::captures::CaptureRepository;\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::macros::MacroRepository;\nuse mdvault_core::templates::repository::TemplateRepository;\nuse mdvault_core::types::{TypeRegistry, TypedefRepository};\nuse std::ffi::OsStr;\n\n/// Load the resolved config, returning None if it fails.\nfn load_config() -\u003e Option\u003cmdvault_core::config::types::ResolvedConfig\u003e {\n    ConfigLoader::load(None, None).ok()\n}\n\n/// Complete note types (built-in + custom from TypeRegistry).\npub fn complete_types(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    // Built-in types are always available\n    let builtin_types = [\n        (\"daily\", \"Daily journal notes\"),\n        (\"weekly\", \"Weekly overview notes\"),\n        (\"task\", \"Individual actionable tasks\"),\n        (\"project\", \"Collections of related tasks\"),\n        (\"zettel\", \"Knowledge notes (Zettelkasten-style)\"),\n    ];\n\n    for (name, help) in builtin_types {\n        if name.starts_with(current_str) {\n            completions.push(CompletionCandidate::new(name).help(Some(help.into())));\n        }\n    }\n\n    // Try to load custom types from config\n    if let Some(cfg) = load_config() {\n        if let Ok(typedef_repo) = TypedefRepository::new(\u0026cfg.typedefs_dir) {\n            if let Ok(registry) = TypeRegistry::from_repository(\u0026typedef_repo) {\n                for type_name in registry.list_custom_types() {\n                    if type_name.starts_with(current_str) {\n                        completions.push(\n                            CompletionCandidate::new(type_name)\n                                .help(Some(\"Custom type\".into())),\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n/// Complete template names from TemplateRepository.\npub fn complete_templates(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    if let Some(cfg) = load_config() {\n        if let Ok(repo) = TemplateRepository::new(\u0026cfg.templates_dir) {\n            for info in repo.list_all() {\n                if info.logical_name.starts_with(current_str) {\n                    completions.push(CompletionCandidate::new(\u0026info.logical_name));\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n/// Complete capture names from CaptureRepository.\npub fn complete_captures(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    if let Some(cfg) = load_config() {\n        if let Ok(repo) = CaptureRepository::new(\u0026cfg.captures_dir) {\n            for info in repo.list_all() {\n                if info.logical_name.starts_with(current_str) {\n                    completions.push(CompletionCandidate::new(\u0026info.logical_name));\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n/// Complete macro names from MacroRepository.\npub fn complete_macros(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    if let Some(cfg) = load_config() {\n        if let Ok(repo) = MacroRepository::new(\u0026cfg.macros_dir) {\n            for info in repo.list_all() {\n                if info.logical_name.starts_with(current_str) {\n                    completions.push(CompletionCandidate::new(\u0026info.logical_name));\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n/// Complete project names from the index.\npub fn complete_projects(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    use mdvault_core::index::{IndexDb, NoteQuery, NoteType};\n\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    if let Some(cfg) = load_config() {\n        let index_path = cfg.vault_root.join(\".mdvault/index.db\");\n        if let Ok(db) = IndexDb::open(\u0026index_path) {\n            let query =\n                NoteQuery { note_type: Some(NoteType::Project), ..Default::default() };\n            if let Ok(projects) = db.query_notes(\u0026query) {\n                for project in projects {\n                    // Use folder name as the project identifier\n                    let name =\n                        project.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n                    if name.starts_with(current_str) {\n                        let title = if project.title.is_empty() {\n                            name.to_string()\n                        } else {\n                            project.title.clone()\n                        };\n                        completions.push(\n                            CompletionCandidate::new(name).help(Some(title.into())),\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n/// Complete note paths from the vault.\n/// This walks the vault directory and returns markdown files.\npub fn complete_notes(current: \u0026OsStr) -\u003e Vec\u003cCompletionCandidate\u003e {\n    let mut completions = vec![];\n    let current_str = current.to_str().unwrap_or(\"\");\n\n    if let Some(cfg) = load_config() {\n        // Walk and collect note paths relative to vault root\n        for entry in walkdir::WalkDir::new(\u0026cfg.vault_root)\n            .min_depth(1)\n            .max_depth(5) // Limit depth for performance\n            .into_iter()\n            .filter_map(|e| e.ok())\n            .filter(|e| e.path().extension().map(|ext| ext == \"md\").unwrap_or(false))\n            .take(100)\n        // Limit results for performance\n        {\n            if let Ok(rel_path) = entry.path().strip_prefix(\u0026cfg.vault_root) {\n                let path_str = rel_path.to_string_lossy();\n                if path_str.starts_with(current_str) {\n                    completions.push(CompletionCandidate::new(path_str.to_string()));\n                }\n            }\n        }\n    }\n\n    completions\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_complete_types_builtin() {\n        let completions = complete_types(OsStr::new(\"\"));\n        let names: Vec\u003c_\u003e =\n            completions.iter().map(|c| c.get_value().to_str().unwrap()).collect();\n\n        assert!(names.contains(\u0026\"daily\"));\n        assert!(names.contains(\u0026\"task\"));\n        assert!(names.contains(\u0026\"project\"));\n    }\n\n    #[test]\n    fn test_complete_types_prefix_filter() {\n        let completions = complete_types(OsStr::new(\"da\"));\n        let names: Vec\u003c_\u003e =\n            completions.iter().map(|c| c.get_value().to_str().unwrap()).collect();\n\n        assert!(names.contains(\u0026\"daily\"));\n        assert!(!names.contains(\u0026\"task\"));\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":8}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":22,"address":[],"length":0,"stats":{"Line":10}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":32}},{"line":34,"address":[],"length":0,"stats":{"Line":36}},{"line":35,"address":[],"length":0,"stats":{"Line":36}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}}],"covered":19,"coverable":85},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","main.rs"],"content":"mod cmd;\nmod completions;\nmod prompt;\nmod tui;\n\nuse clap::{Args, CommandFactory, Parser, Subcommand, ValueEnum};\nuse clap_complete::engine::ArgValueCompleter;\nuse clap_complete::env::CompleteEnv;\nuse clap_complete::Shell;\nuse std::path::PathBuf;\n\n/// Output format for query commands.\n#[derive(Debug, Clone, Copy, Default, ValueEnum)]\npub enum OutputFormat {\n    /// Human-readable table format\n    #[default]\n    Table,\n    /// JSON output\n    Json,\n    /// Quiet mode - paths only\n    Quiet,\n}\n\n/// Note type filter for list command.\n#[derive(Debug, Clone, Copy, ValueEnum)]\npub enum NoteTypeArg {\n    /// Daily journal notes\n    Daily,\n    /// Weekly overview notes\n    Weekly,\n    /// Individual actionable tasks\n    Task,\n    /// Collections of related tasks\n    Project,\n    /// Knowledge notes (Zettelkasten-style)\n    Zettel,\n}\n\nimpl From\u003cNoteTypeArg\u003e for mdvault_core::index::NoteType {\n    fn from(arg: NoteTypeArg) -\u003e Self {\n        match arg {\n            NoteTypeArg::Daily =\u003e mdvault_core::index::NoteType::Daily,\n            NoteTypeArg::Weekly =\u003e mdvault_core::index::NoteType::Weekly,\n            NoteTypeArg::Task =\u003e mdvault_core::index::NoteType::Task,\n            NoteTypeArg::Project =\u003e mdvault_core::index::NoteType::Project,\n            NoteTypeArg::Zettel =\u003e mdvault_core::index::NoteType::Zettel,\n        }\n    }\n}\n\n#[derive(Debug, Parser)]\n#[command(name = \"mdv\", version, about = \"Your markdown vault on the command line\")]\nstruct Cli {\n    #[arg(long, global = true)]\n    config: Option\u003cPathBuf\u003e,\n\n    #[arg(long, global = true)]\n    profile: Option\u003cString\u003e,\n\n    #[command(subcommand)]\n    command: Option\u003cCommands\u003e,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    /// Validate configuration and print resolved paths\n    Doctor,\n\n    /// List logical template names discovered under templates_dir\n    ListTemplates,\n\n    /// Render a template into a new file\n    New(NewArgs),\n\n    /// Capture content into an existing file's section\n    Capture(CaptureArgs),\n\n    /// Execute a multi-step macro workflow\n    Macro(MacroArgs),\n\n    /// Build or rebuild the vault index\n    Reindex(ReindexArgs),\n\n    /// List notes in the vault with optional filters\n    List(ListArgs),\n\n    /// Show links for a note (backlinks and/or outgoing)\n    Links(LinksArgs),\n\n    /// Find orphan notes (no incoming links)\n    Orphans(OrphansArgs),\n\n    /// Validate notes against type definitions\n    Validate(ValidateArgs),\n\n    /// Lint notes (alias for validate)\n    #[command(hide = true)]\n    Lint(ValidateArgs),\n\n    /// Search notes with contextual expansion\n    Search(SearchArgs),\n\n    /// Find stale notes (not referenced in recent dailies)\n    Stale(StaleArgs),\n\n    /// Rename a note and update all references to it\n    Rename(RenameArgs),\n\n    /// Generate shell completion scripts\n    Completions(CompletionsArgs),\n\n    /// Task management commands\n    #[command(subcommand)]\n    Task(TaskCommands),\n\n    /// Project management commands\n    #[command(subcommand)]\n    Project(ProjectCommands),\n}\n\n/// Task management subcommands.\n#[derive(Debug, Subcommand)]\nenum TaskCommands {\n    /// List tasks with optional filters\n    List(TaskListArgs),\n\n    /// Mark a task as done\n    Done(TaskDoneArgs),\n\n    /// Show detailed status for a task\n    Status(TaskStatusArgs),\n}\n\n/// Project management subcommands.\n#[derive(Debug, Subcommand)]\nenum ProjectCommands {\n    /// List all projects with task counts\n    List(ProjectListArgs),\n\n    /// Show project status with tasks in kanban-style view\n    Status(ProjectStatusArgs),\n}\n\n#[derive(Debug, Args)]\npub struct TaskListArgs {\n    /// Filter by project name\n    #[arg(long, short)]\n    pub project: Option\u003cString\u003e,\n\n    /// Filter by status (todo, in-progress, done, blocked)\n    #[arg(long, short)]\n    pub status: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct TaskDoneArgs {\n    /// Path to the task note (relative to vault root)\n    #[arg(add = ArgValueCompleter::new(completions::complete_notes))]\n    pub task: PathBuf,\n\n    /// Summary of what was done (logged to task)\n    #[arg(long, short)]\n    pub summary: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct ProjectListArgs {\n    /// Filter by status (active, completed, on-hold, archived)\n    #[arg(long, short)]\n    pub status: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct ProjectStatusArgs {\n    /// Project ID or folder name (e.g., \"MCP\" or \"my-cool-project\")\n    #[arg(add = ArgValueCompleter::new(completions::complete_projects))]\n    pub project: String,\n}\n\n#[derive(Debug, Args)]\npub struct TaskStatusArgs {\n    /// Task ID (e.g., \"MCP-001\")\n    #[arg(add = ArgValueCompleter::new(completions::complete_notes))]\n    pub task_id: String,\n}\n\n#[derive(Debug, Args)]\npub struct ReindexArgs {\n    /// Show verbose output (list each file as it's indexed)\n    #[arg(long, short)]\n    pub verbose: bool,\n\n    /// Force full rebuild of the index (default: incremental)\n    #[arg(long)]\n    pub force: bool,\n\n    /// Explicitly request incremental update (default behavior)\n    #[arg(long, conflicts_with = \"force\")]\n    pub incremental: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv macro --list\n  mdv macro weekly-review\n  mdv macro deploy-notes --trust\n  mdv macro setup --var project=\\\"my-app\\\"\n\")]\npub struct MacroArgs {\n    /// Logical macro name (e.g. \\\"weekly-review\\\" or \\\"deploy\\\")\n    #[arg(required_unless_present = \"list\", add = ArgValueCompleter::new(completions::complete_macros))]\n    pub name: Option\u003cString\u003e,\n\n    /// List available macros\n    #[arg(long, short)]\n    pub list: bool,\n\n    /// Variables to pass to the macro (e.g. --var topic=\\\"Planning\\\")\n    #[arg(long = \"var\", value_parser = parse_key_val)]\n    pub vars: Vec\u003c(String, String)\u003e,\n\n    /// Non-interactive mode: fail if variables are missing instead of prompting\n    #[arg(long)]\n    pub batch: bool,\n\n    /// Trust shell commands in the macro\n    #[arg(long)]\n    pub trust: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv new task \\\"My Task\\\" --var project=myproject\n  mdv new --template daily\n  mdv new project \\\"New Project\\\" --var status=active -o projects/new.md\n\")]\npub struct NewArgs {\n    /// Note type for scaffolding (e.g., \\\"task\\\", \\\"project\\\", \\\"zettel\\\")\n    /// Creates a note with frontmatter based on the type's schema\n    #[arg(add = ArgValueCompleter::new(completions::complete_types))]\n    pub note_type: Option\u003cString\u003e,\n\n    /// Note title (used in frontmatter and as heading)\n    pub title: Option\u003cString\u003e,\n\n    /// Use a template file instead of type-based scaffolding\n    #[arg(long, add = ArgValueCompleter::new(completions::complete_templates))]\n    pub template: Option\u003cString\u003e,\n\n    /// Output file path (auto-generated from type/title if not provided)\n    #[arg(long, short)]\n    pub output: Option\u003cPathBuf\u003e,\n\n    /// Variables/fields to set (e.g. --var project=myproject)\n    #[arg(long = \"var\", value_parser = parse_key_val)]\n    pub vars: Vec\u003c(String, String)\u003e,\n\n    /// Non-interactive mode: fail if variables are missing instead of prompting\n    #[arg(long)]\n    pub batch: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv capture --list\n  mdv capture inbox --var text=\\\"Buy milk\\\"\n  mdv capture todo --var task=\\\"Review PR\\\" --var priority=high\n\")]\npub struct CaptureArgs {\n    /// Logical capture name (e.g. \"inbox\" or \"todo\")\n    #[arg(required_unless_present = \"list\", add = ArgValueCompleter::new(completions::complete_captures))]\n    pub name: Option\u003cString\u003e,\n\n    /// List available captures and their expected variables\n    #[arg(long, short)]\n    pub list: bool,\n\n    /// Variables to pass to the capture (e.g. --var text=\"My note\")\n    #[arg(long = \"var\", value_parser = parse_key_val)]\n    pub vars: Vec\u003c(String, String)\u003e,\n\n    /// Non-interactive mode: fail if variables are missing instead of prompting\n    #[arg(long)]\n    pub batch: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv list                              # List all notes\n  mdv list --type task                  # Filter by type\n  mdv list --modified-after 2024-01-01  # Filter by date\n  mdv list --modified-after \\\"today - 7d\\\" # Notes from last week\n  mdv list --json                       # JSON output\n  mdv list -q                           # Paths only\n\")]\npub struct ListArgs {\n    /// Filter by note type\n    #[arg(long)]\n    pub r#type: Option\u003cNoteTypeArg\u003e,\n\n    /// Show only notes modified after this date (YYYY-MM-DD or date expression)\n    #[arg(long)]\n    pub modified_after: Option\u003cString\u003e,\n\n    /// Show only notes modified before this date (YYYY-MM-DD or date expression)\n    #[arg(long)]\n    pub modified_before: Option\u003cString\u003e,\n\n    /// Maximum number of notes to return\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cu32\u003e,\n\n    /// Output format\n    #[arg(long, short, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv links note.md                     # Show backlinks and outlinks\n  mdv links note.md --backlinks         # Only backlinks\n  mdv links note.md --outlinks          # Only outlinks\n  mdv links tasks/todo.md --json        # JSON output\n\")]\npub struct LinksArgs {\n    /// Path to the note (relative to vault root)\n    #[arg(add = ArgValueCompleter::new(completions::complete_notes))]\n    pub note: String,\n\n    /// Show only backlinks (notes linking to this note)\n    #[arg(long, short = 'b')]\n    pub backlinks: bool,\n\n    /// Show only outgoing links (notes this note links to)\n    #[arg(long, short = 'o')]\n    pub outlinks: bool,\n\n    /// Output format\n    #[arg(long, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv orphans                           # Find orphan notes\n  mdv orphans --json                    # JSON output\n  mdv orphans -q                        # Paths only\n\")]\npub struct OrphansArgs {\n    /// Output format\n    #[arg(long, short, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv validate                          # Validate all notes\n  mdv validate path/to/note.md          # Validate specific file\n  mdv validate --type task              # Validate only task notes\n  mdv validate --fix                    # Auto-fix safe issues\n  mdv validate --list-types             # Show available type definitions\n  mdv validate --json                   # JSON output\n\")]\npub struct ValidateArgs {\n    /// Specific note path to validate (relative to vault root)\n    pub path: Option\u003cString\u003e,\n\n    /// Only validate notes of this type\n    #[arg(long)]\n    pub r#type: Option\u003cString\u003e,\n\n    /// Maximum number of notes to validate\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cu32\u003e,\n\n    /// Auto-fix safe issues (missing defaults, enum case normalization)\n    #[arg(long)]\n    pub fix: bool,\n\n    /// List available type definitions\n    #[arg(long)]\n    pub list_types: bool,\n\n    /// Output format\n    #[arg(long, short, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n\n    /// Check link integrity (report broken links as warnings)\n    #[arg(long)]\n    pub check_links: bool,\n}\n\n/// Search mode for result expansion.\n#[derive(Debug, Clone, Copy, Default, ValueEnum)]\npub enum SearchModeArg {\n    /// Only return notes directly matching the query\n    #[default]\n    Direct,\n    /// Include linked notes within 2 hops\n    Neighbourhood,\n    /// Include recent dailies referencing matches\n    Temporal,\n    /// Include notes that cooccur with matches\n    Cooccurrence,\n    /// Full contextual search (all modes)\n    Full,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv search \\\"parser\\\"                     # Direct search for 'parser'\n  mdv search \\\"parser\\\" --mode full         # Search with full context\n  mdv search \\\"fix bug\\\" --type task        # Search only task notes\n  mdv search --type task --mode full       # All tasks with context\n  mdv search \\\"ML\\\" --boost                 # Boost recently active notes\n\")]\npub struct SearchArgs {\n    /// Search query (matches title and path)\n    pub query: Option\u003cString\u003e,\n\n    /// Filter by note type\n    #[arg(long)]\n    pub r#type: Option\u003cNoteTypeArg\u003e,\n\n    /// Search mode for context expansion\n    #[arg(long, value_enum, default_value = \"direct\")]\n    pub mode: SearchModeArg,\n\n    /// Boost recently active notes\n    #[arg(long)]\n    pub boost: bool,\n\n    /// Maximum number of results\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cu32\u003e,\n\n    /// Output format\n    #[arg(long, short, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv stale                              # List all stale notes\n  mdv stale --type task                  # Only stale tasks\n  mdv stale --threshold 0.7              # Higher staleness threshold\n  mdv stale --days 90                    # Notes not seen in 90 days\n\")]\npub struct StaleArgs {\n    /// Filter by note type\n    #[arg(long)]\n    pub r#type: Option\u003cNoteTypeArg\u003e,\n\n    /// Minimum staleness score (0.0-1.0, default 0.5)\n    #[arg(long, default_value = \"0.5\")]\n    pub threshold: f64,\n\n    /// Show notes not seen for this many days (alternative to threshold)\n    #[arg(long)]\n    pub days: Option\u003cu32\u003e,\n\n    /// Maximum number of results\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cu32\u003e,\n\n    /// Output format\n    #[arg(long, short, value_enum, default_value = \"table\")]\n    pub output: OutputFormat,\n\n    /// Output as JSON (shorthand for --output json)\n    #[arg(long)]\n    pub json: bool,\n\n    /// Quiet mode - output paths only (shorthand for --output quiet)\n    #[arg(long, short)]\n    pub quiet: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv rename old.md new.md              # Rename note and update references\n  mdv rename old.md new.md --dry-run    # Preview changes without modifying files\n  mdv rename old.md new.md --yes        # Skip confirmation prompt\n\")]\npub struct RenameArgs {\n    /// Source file path (relative to vault root)\n    #[arg(add = ArgValueCompleter::new(completions::complete_notes))]\n    pub source: std::path::PathBuf,\n\n    /// Destination file path (relative to vault root)\n    pub dest: std::path::PathBuf,\n\n    /// Preview changes without modifying files\n    #[arg(long)]\n    pub dry_run: bool,\n\n    /// Skip confirmation prompt\n    #[arg(long, short)]\n    pub yes: bool,\n}\n\n#[derive(Debug, Args)]\n#[command(after_help = \"\\\nExamples:\n  mdv completions bash \u003e ~/.local/share/bash-completion/completions/mdv\n  mdv completions zsh \u003e ~/.zfunc/_mdv\n  mdv completions fish \u003e ~/.config/fish/completions/mdv.fish\n\")]\npub struct CompletionsArgs {\n    /// Shell to generate completions for\n    #[arg(value_enum)]\n    pub shell: Shell,\n}\n\nfn parse_key_val(s: \u0026str) -\u003e Result\u003c(String, String), String\u003e {\n    let pos =\n        s.find('=').ok_or_else(|| format!(\"invalid KEY=value: no `=` found in `{s}`\"))?;\n    Ok((s[..pos].to_string(), s[pos + 1..].to_string()))\n}\n\nfn main() {\n    // Enable dynamic shell completions\n    // This intercepts completion requests before normal CLI parsing\n    CompleteEnv::with_factory(Cli::command).complete();\n\n    let cli = Cli::parse();\n\n    match cli.command {\n        // No command provided - launch TUI\n        None =\u003e {\n            if let Err(e) = tui::run(cli.config.as_deref(), cli.profile.as_deref()) {\n                eprintln!(\"Error: {e}\");\n                std::process::exit(1);\n            }\n        }\n        Some(Commands::Doctor) =\u003e {\n            cmd::doctor::run(cli.config.as_deref(), cli.profile.as_deref())\n        }\n        Some(Commands::ListTemplates) =\u003e {\n            cmd::list_templates::run(cli.config.as_deref(), cli.profile.as_deref())\n        }\n        Some(Commands::New(args)) =\u003e {\n            cmd::new::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Capture(args)) =\u003e {\n            if args.list {\n                cmd::capture::run_list(cli.config.as_deref(), cli.profile.as_deref());\n            } else {\n                cmd::capture::run(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    args.name.as_ref().unwrap(),\n                    \u0026args.vars,\n                    args.batch,\n                );\n            }\n        }\n        Some(Commands::Macro(args)) =\u003e {\n            if args.list {\n                cmd::macro_cmd::run_list(cli.config.as_deref(), cli.profile.as_deref());\n            } else {\n                cmd::macro_cmd::run(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    args.name.as_ref().unwrap(),\n                    \u0026args.vars,\n                    args.batch,\n                    args.trust,\n                );\n            }\n        }\n        Some(Commands::Reindex(args)) =\u003e {\n            cmd::reindex::run(\n                cli.config.as_deref(),\n                cli.profile.as_deref(),\n                args.verbose,\n                args.force,\n            );\n        }\n        Some(Commands::List(args)) =\u003e {\n            cmd::list::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Links(args)) =\u003e {\n            cmd::links::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Orphans(args)) =\u003e {\n            cmd::orphans::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Validate(args)) | Some(Commands::Lint(args)) =\u003e {\n            cmd::validate::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Search(args)) =\u003e {\n            cmd::search::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Stale(args)) =\u003e {\n            cmd::stale::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Rename(args)) =\u003e {\n            cmd::rename::run(cli.config.as_deref(), cli.profile.as_deref(), args);\n        }\n        Some(Commands::Completions(args)) =\u003e {\n            clap_complete::generate(\n                args.shell,\n                \u0026mut Cli::command(),\n                \"mdv\",\n                \u0026mut std::io::stdout(),\n            );\n        }\n        Some(Commands::Task(subcmd)) =\u003e match subcmd {\n            TaskCommands::List(args) =\u003e {\n                cmd::task::list(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    args.project.as_deref(),\n                    args.status.as_deref(),\n                );\n            }\n            TaskCommands::Done(args) =\u003e {\n                cmd::task::done(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    \u0026args.task,\n                    args.summary.as_deref(),\n                );\n            }\n            TaskCommands::Status(args) =\u003e {\n                cmd::task::status(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    \u0026args.task_id,\n                );\n            }\n        },\n        Some(Commands::Project(subcmd)) =\u003e match subcmd {\n            ProjectCommands::List(args) =\u003e {\n                cmd::project::list(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    args.status.as_deref(),\n                );\n            }\n            ProjectCommands::Status(args) =\u003e {\n                cmd::project::status(\n                    cli.config.as_deref(),\n                    cli.profile.as_deref(),\n                    \u0026args.project,\n                );\n            }\n        },\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":16}},{"line":566,"address":[],"length":0,"stats":{"Line":16}},{"line":567,"address":[],"length":0,"stats":{"Line":48}},{"line":568,"address":[],"length":0,"stats":{"Line":48}},{"line":571,"address":[],"length":0,"stats":{"Line":39}},{"line":574,"address":[],"length":0,"stats":{"Line":78}},{"line":576,"address":[],"length":0,"stats":{"Line":78}},{"line":578,"address":[],"length":0,"stats":{"Line":39}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":20}},{"line":590,"address":[],"length":0,"stats":{"Line":5}},{"line":592,"address":[],"length":0,"stats":{"Line":20}},{"line":593,"address":[],"length":0,"stats":{"Line":50}},{"line":595,"address":[],"length":0,"stats":{"Line":15}},{"line":596,"address":[],"length":0,"stats":{"Line":16}},{"line":597,"address":[],"length":0,"stats":{"Line":4}},{"line":600,"address":[],"length":0,"stats":{"Line":42}},{"line":601,"address":[],"length":0,"stats":{"Line":42}},{"line":602,"address":[],"length":0,"stats":{"Line":42}},{"line":603,"address":[],"length":0,"stats":{"Line":14}},{"line":604,"address":[],"length":0,"stats":{"Line":14}},{"line":608,"address":[],"length":0,"stats":{"Line":9}},{"line":609,"address":[],"length":0,"stats":{"Line":11}},{"line":610,"address":[],"length":0,"stats":{"Line":8}},{"line":613,"address":[],"length":0,"stats":{"Line":21}},{"line":614,"address":[],"length":0,"stats":{"Line":21}},{"line":615,"address":[],"length":0,"stats":{"Line":21}},{"line":616,"address":[],"length":0,"stats":{"Line":14}},{"line":617,"address":[],"length":0,"stats":{"Line":7}},{"line":618,"address":[],"length":0,"stats":{"Line":7}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}}],"covered":29,"coverable":86},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","prompt.rs"],"content":"//! Interactive prompts for collecting variable values.\n//!\n//! This module provides functionality to:\n//! - Prompt users for missing variable values\n//! - Show prompts and descriptions from VarSpec\n//! - Handle defaults and required/optional status\n//! - Support batch mode (non-interactive) for CI/scripting\n\nuse dialoguer::{theme::ColorfulTheme, Input};\nuse mdvault_core::templates::engine::RenderContext;\nuse mdvault_core::vars::{\n    collect_all_variables, try_evaluate_date_expr, VarSpec, VarsMap,\n};\nuse std::collections::HashMap;\nuse std::io::{self, IsTerminal};\n\n/// Options for prompting behavior.\n#[derive(Debug, Clone, Default)]\npub struct PromptOptions {\n    /// If true, fail on missing variables instead of prompting.\n    pub batch_mode: bool,\n}\n\n/// Result of variable collection.\n#[derive(Debug)]\npub struct CollectedVars {\n    /// All collected variable values.\n    pub values: HashMap\u003cString, String\u003e,\n    /// Variables that were prompted for.\n    #[allow(dead_code)]\n    pub prompted: Vec\u003cString\u003e,\n    /// Variables that used defaults.\n    #[allow(dead_code)]\n    pub defaulted: Vec\u003cString\u003e,\n}\n\n/// Error type for variable collection.\n#[derive(Debug)]\npub enum PromptError {\n    /// Missing required variable in batch mode.\n    MissingRequired(String),\n    /// IO error during prompting.\n    Io(io::Error),\n    /// User cancelled input.\n    Cancelled,\n}\n\nimpl std::fmt::Display for PromptError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            PromptError::MissingRequired(name) =\u003e {\n                write!(f, \"missing required variable: {name}\\n  Hint: use --var {name}=\\\"...\\\" or remove --batch\")\n            }\n            PromptError::Io(e) =\u003e write!(f, \"IO error: {e}\"),\n            PromptError::Cancelled =\u003e write!(f, \"input cancelled by user\"),\n        }\n    }\n}\n\nimpl std::error::Error for PromptError {}\n\nimpl From\u003cio::Error\u003e for PromptError {\n    fn from(e: io::Error) -\u003e Self {\n        PromptError::Io(e)\n    }\n}\n\n/// Collect all required variables by prompting the user for missing values.\n///\n/// # Arguments\n/// * `vars_map` - Variable specifications from template/capture frontmatter\n/// * `content` - Template/capture content to extract additional variables from\n/// * `provided` - Variables already provided via --var flags\n/// * `context` - Render context with built-in variables\n/// * `options` - Prompting options (batch mode, etc.)\n///\n/// # Returns\n/// Collected variables including provided, prompted, and defaulted values.\npub fn collect_variables(\n    vars_map: Option\u003c\u0026VarsMap\u003e,\n    content: \u0026str,\n    provided: \u0026HashMap\u003cString, String\u003e,\n    context: \u0026RenderContext,\n    options: \u0026PromptOptions,\n) -\u003e Result\u003cCollectedVars, PromptError\u003e {\n    let mut values = provided.clone();\n    let mut prompted = Vec::new();\n    let mut defaulted = Vec::new();\n\n    // Check if stdin is a terminal (interactive)\n    let is_interactive = io::stdin().is_terminal() \u0026\u0026 !options.batch_mode;\n\n    // Get all variables needed\n    let all_vars = collect_all_variables(vars_map, content);\n\n    for (name, spec) in all_vars {\n        // Skip if already provided\n        if values.contains_key(\u0026name) {\n            continue;\n        }\n\n        // Skip if it's in the context (built-in variable)\n        if context.contains_key(\u0026name) {\n            continue;\n        }\n\n        // Try to get default value\n        let default_value = spec\n            .as_ref()\n            .and_then(|s| s.default())\n            .and_then(|d| resolve_default(d, \u0026values, context));\n\n        let is_required = spec.as_ref().is_none_or(|s| s.is_required());\n\n        if let Some(default) = default_value {\n            if is_interactive {\n                // Prompt with default pre-filled\n                let value = prompt_with_default(\u0026name, spec.as_ref(), \u0026default)?;\n                if value != default {\n                    prompted.push(name.clone());\n                } else {\n                    defaulted.push(name.clone());\n                }\n                values.insert(name, value);\n            } else {\n                // Use default in batch mode\n                defaulted.push(name.clone());\n                values.insert(name, default);\n            }\n        } else if is_required {\n            if is_interactive {\n                // Prompt for required variable\n                let value = prompt_required(\u0026name, spec.as_ref())?;\n                prompted.push(name.clone());\n                values.insert(name, value);\n            } else {\n                // Fail in batch mode\n                return Err(PromptError::MissingRequired(name));\n            }\n        }\n        // Optional variables without defaults are skipped\n    }\n\n    Ok(CollectedVars { values, prompted, defaulted })\n}\n\n/// Resolve a default value, which may contain date math expressions.\nfn resolve_default(\n    default: \u0026str,\n    values: \u0026HashMap\u003cString, String\u003e,\n    context: \u0026RenderContext,\n) -\u003e Option\u003cString\u003e {\n    // Check if it's a date math expression like \"{{today + 1d}}\"\n    let trimmed = default.trim();\n    if trimmed.starts_with(\"{{\") \u0026\u0026 trimmed.ends_with(\"}}\") {\n        let inner = \u0026trimmed[2..trimmed.len() - 2].trim();\n        if let Some(evaluated) = try_evaluate_date_expr(inner) {\n            return Some(evaluated);\n        }\n        // Try variable lookup\n        if let Some(val) = values.get(*inner).or_else(|| context.get(*inner)) {\n            return Some(val.clone());\n        }\n    }\n\n    // Return as-is if it's a static default\n    Some(default.to_string())\n}\n\n/// Prompt for a required variable (no default).\nfn prompt_required(name: \u0026str, spec: Option\u003c\u0026VarSpec\u003e) -\u003e Result\u003cString, PromptError\u003e {\n    let theme = ColorfulTheme::default();\n    let prompt_text = spec.map(|s| s.prompt()).filter(|p| !p.is_empty()).unwrap_or(name);\n\n    // Show description if available\n    if let Some(desc) = spec.and_then(|s| s.description()) {\n        eprintln!(\"  {desc}\");\n    }\n\n    Input::\u003cString\u003e::with_theme(\u0026theme)\n        .with_prompt(prompt_text)\n        .interact_text()\n        .map_err(dialoguer_error_to_prompt_error)\n}\n\n/// Prompt for a variable with a default value.\nfn prompt_with_default(\n    name: \u0026str,\n    spec: Option\u003c\u0026VarSpec\u003e,\n    default: \u0026str,\n) -\u003e Result\u003cString, PromptError\u003e {\n    let theme = ColorfulTheme::default();\n    let prompt_text = spec.map(|s| s.prompt()).filter(|p| !p.is_empty()).unwrap_or(name);\n\n    // Show description if available\n    if let Some(desc) = spec.and_then(|s| s.description()) {\n        eprintln!(\"  {desc}\");\n    }\n\n    Input::\u003cString\u003e::with_theme(\u0026theme)\n        .with_prompt(prompt_text)\n        .default(default.to_string())\n        .allow_empty(true)\n        .interact_text()\n        .map_err(dialoguer_error_to_prompt_error)\n}\n\n/// Convert dialoguer error to our PromptError.\nfn dialoguer_error_to_prompt_error(e: dialoguer::Error) -\u003e PromptError {\n    match e {\n        dialoguer::Error::IO(io_err) =\u003e {\n            if io_err.kind() == io::ErrorKind::UnexpectedEof {\n                PromptError::Cancelled\n            } else {\n                PromptError::Io(io_err)\n            }\n        }\n    }\n}\n\n/// Prompt for a single field value.\n///\n/// This is a simpler interface for prompting for individual fields,\n/// used by type-based scaffolding to collect missing required fields.\n///\n/// # Arguments\n/// * `field` - The field name (used in error messages)\n/// * `prompt` - The prompt text to display\n/// * `enum_hint` - Optional hint for enum values (e.g., \"low/medium/high\")\n/// * `required` - Whether the field is required\n///\n/// # Returns\n/// The user's input, or an error if cancelled or required field empty.\npub fn prompt_for_field(\n    field: \u0026str,\n    prompt: \u0026str,\n    enum_hint: Option\u003c\u0026str\u003e,\n    required: bool,\n) -\u003e Result\u003cString, PromptError\u003e {\n    let is_interactive = io::stdin().is_terminal();\n\n    if !is_interactive {\n        return Err(PromptError::MissingRequired(field.to_string()));\n    }\n\n    let theme = ColorfulTheme::default();\n\n    // Build prompt with enum hint if provided\n    let prompt_text = if let Some(hint) = enum_hint {\n        format!(\"{} [{}]\", prompt, hint)\n    } else {\n        prompt.to_string()\n    };\n\n    let input: String = Input::with_theme(\u0026theme)\n        .with_prompt(\u0026prompt_text)\n        .allow_empty(!required)\n        .interact_text()\n        .map_err(dialoguer_error_to_prompt_error)?;\n\n    if required \u0026\u0026 input.is_empty() {\n        return Err(PromptError::MissingRequired(field.to_string()));\n    }\n\n    Ok(input)\n}\n\n/// Parse --var arguments into a HashMap.\n///\n/// Expected format: `key=value`\n#[allow(dead_code)]\npub fn parse_var_args(args: \u0026[String]) -\u003e HashMap\u003cString, String\u003e {\n    let mut map = HashMap::new();\n    for arg in args {\n        if let Some((key, value)) = arg.split_once('=') {\n            map.insert(key.to_string(), value.to_string());\n        }\n    }\n    map\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_var_args() {\n        let args = vec![\n            \"title=Hello\".to_string(),\n            \"author=World\".to_string(),\n            \"empty=\".to_string(),\n        ];\n        let map = parse_var_args(\u0026args);\n        assert_eq!(map.get(\"title\"), Some(\u0026\"Hello\".to_string()));\n        assert_eq!(map.get(\"author\"), Some(\u0026\"World\".to_string()));\n        assert_eq!(map.get(\"empty\"), Some(\u0026String::new()));\n    }\n\n    #[test]\n    fn test_resolve_default_static() {\n        let values = HashMap::new();\n        let context = RenderContext::new();\n        let result = resolve_default(\"hello\", \u0026values, \u0026context);\n        assert_eq!(result, Some(\"hello\".to_string()));\n    }\n\n    #[test]\n    fn test_resolve_default_date_expr() {\n        let values = HashMap::new();\n        let context = RenderContext::new();\n        let result = resolve_default(\"{{today}}\", \u0026values, \u0026context);\n        // Should be a date string\n        assert!(result.is_some());\n        assert!(result.unwrap().contains(\"-\")); // YYYY-MM-DD format\n    }\n\n    #[test]\n    fn test_resolve_default_variable_lookup() {\n        let mut context = RenderContext::new();\n        context.insert(\"vault_root\".to_string(), \"/home/user/vault\".to_string());\n        let values = HashMap::new();\n        let result = resolve_default(\"{{vault_root}}\", \u0026values, \u0026context);\n        assert_eq!(result, Some(\"/home/user/vault\".to_string()));\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":18}},{"line":86,"address":[],"length":0,"stats":{"Line":54}},{"line":87,"address":[],"length":0,"stats":{"Line":36}},{"line":88,"address":[],"length":0,"stats":{"Line":36}},{"line":91,"address":[],"length":0,"stats":{"Line":54}},{"line":94,"address":[],"length":0,"stats":{"Line":72}},{"line":96,"address":[],"length":0,"stats":{"Line":63}},{"line":98,"address":[],"length":0,"stats":{"Line":45}},{"line":99,"address":[],"length":0,"stats":{"Line":13}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":10}},{"line":113,"address":[],"length":0,"stats":{"Line":12}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":10}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":36}},{"line":148,"address":[],"length":0,"stats":{"Line":5}},{"line":154,"address":[],"length":0,"stats":{"Line":15}},{"line":155,"address":[],"length":0,"stats":{"Line":14}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":7}},{"line":275,"address":[],"length":0,"stats":{"Line":12}},{"line":276,"address":[],"length":0,"stats":{"Line":15}},{"line":279,"address":[],"length":0,"stats":{"Line":1}}],"covered":34,"coverable":92},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","actions.rs"],"content":"//! Execution logic for templates, captures, and macros.\n\nuse std::collections::{HashMap, HashSet};\nuse std::fs;\nuse std::path::Path;\n\nuse chrono::Local;\nuse regex::Regex;\n\nuse mdvault_core::captures::{CaptureRepository, CaptureSpec};\nuse mdvault_core::config::types::ResolvedConfig;\nuse mdvault_core::frontmatter::{apply_ops, parse, serialize};\nuse mdvault_core::macros::{\n    run_macro, MacroRepository, RunContext, RunOptions, StepExecutor,\n};\nuse mdvault_core::markdown_ast::{MarkdownAstError, MarkdownEditor, SectionMatch};\nuse mdvault_core::templates::discovery::TemplateInfo;\nuse mdvault_core::templates::engine::{build_render_context, render};\nuse mdvault_core::templates::repository::TemplateRepository;\n\n/// Built-in variables that are automatically provided.\nconst BUILTIN_VARS: \u0026[\u0026str] = \u0026[\n    \"date\",\n    \"time\",\n    \"datetime\",\n    \"vault_root\",\n    \"templates_dir\",\n    \"captures_dir\",\n    \"macros_dir\",\n];\n\n/// Extract user-defined variables from a capture spec (excludes built-ins).\npub fn extract_user_variables(spec: \u0026CaptureSpec) -\u003e Vec\u003cString\u003e {\n    let re = Regex::new(r\"\\{\\{([a-zA-Z0-9_]+)\\}\\}\").unwrap();\n    let builtin: HashSet\u003c\u0026str\u003e = BUILTIN_VARS.iter().copied().collect();\n\n    let mut vars = HashSet::new();\n\n    // Extract from content (if present)\n    if let Some(content) = \u0026spec.content {\n        for cap in re.captures_iter(content) {\n            let var = cap.get(1).unwrap().as_str();\n            if !builtin.contains(var) {\n                vars.insert(var.to_string());\n            }\n        }\n    }\n\n    // Extract from target file path\n    for cap in re.captures_iter(\u0026spec.target.file) {\n        let var = cap.get(1).unwrap().as_str();\n        if !builtin.contains(var) {\n            vars.insert(var.to_string());\n        }\n    }\n\n    // Extract from section (if present)\n    if let Some(section) = \u0026spec.target.section {\n        for cap in re.captures_iter(section) {\n            let var = cap.get(1).unwrap().as_str();\n            if !builtin.contains(var) {\n                vars.insert(var.to_string());\n            }\n        }\n    }\n\n    let mut sorted: Vec\u003c_\u003e = vars.into_iter().collect();\n    sorted.sort();\n    sorted\n}\n\n/// Execute template creation.\npub fn execute_template(\n    config: \u0026ResolvedConfig,\n    template_name: \u0026str,\n    output_path: \u0026Path,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003cString, String\u003e {\n    // Check output doesn't exist\n    if output_path.exists() {\n        return Err(format!(\"File already exists: {}\", output_path.display()));\n    }\n\n    // Load template\n    let repo = TemplateRepository::new(\u0026config.templates_dir)\n        .map_err(|e| format!(\"Failed to load templates: {e}\"))?;\n\n    let loaded =\n        repo.get_by_name(template_name).map_err(|e| format!(\"Template error: {e}\"))?;\n\n    // Build context with user variables\n    let info = TemplateInfo {\n        logical_name: loaded.logical_name.clone(),\n        path: loaded.path.clone(),\n    };\n\n    let mut ctx = build_render_context(config, \u0026info, output_path);\n    // Add user-provided variables to context\n    for (k, v) in vars {\n        ctx.insert(k.clone(), v.clone());\n    }\n\n    let rendered = render(\u0026loaded, \u0026ctx).map_err(|e| format!(\"Render error: {e}\"))?;\n\n    // Create parent dirs and write\n    if let Some(parent) = output_path.parent() {\n        fs::create_dir_all(parent)\n            .map_err(|e| format!(\"Failed to create directories: {e}\"))?;\n    }\n\n    fs::write(output_path, rendered).map_err(|e| format!(\"Write failed: {e}\"))?;\n\n    Ok(format!(\"Created: {}\", output_path.display()))\n}\n\n/// Execute capture insertion.\npub fn execute_capture(\n    config: \u0026ResolvedConfig,\n    capture_name: \u0026str,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003cString, String\u003e {\n    // Load capture\n    let repo = CaptureRepository::new(\u0026config.captures_dir)\n        .map_err(|e| format!(\"Failed to load captures: {e}\"))?;\n\n    let loaded =\n        repo.get_by_name(capture_name).map_err(|e| format!(\"Capture error: {e}\"))?;\n\n    // Build full context (builtins + user vars)\n    let mut ctx = build_capture_context(config);\n    for (k, v) in vars {\n        ctx.insert(k.clone(), v.clone());\n    }\n\n    // Resolve target file\n    let target_path = render_string(\u0026loaded.spec.target.file, \u0026ctx);\n    let target_path = resolve_target_path(\u0026config.vault_root, \u0026target_path);\n\n    // Read existing file\n    let existing = fs::read_to_string(\u0026target_path)\n        .map_err(|e| format!(\"Failed to read {}: {e}\", target_path.display()))?;\n\n    // Execute capture operations\n    let (result_content, section_info) =\n        execute_capture_operations(\u0026existing, \u0026loaded.spec, \u0026ctx)?;\n\n    // Write back\n    fs::write(\u0026target_path, \u0026result_content).map_err(|e| format!(\"Write failed: {e}\"))?;\n\n    let mut msg = format!(\"Captured to: {}\", target_path.display());\n    if let Some((title, _level)) = section_info {\n        msg.push_str(\u0026format!(\" (section: {})\", title));\n    }\n    if loaded.spec.frontmatter.is_some() {\n        msg.push_str(\" [frontmatter updated]\");\n    }\n\n    Ok(msg)\n}\n\n/// Execute capture operations: frontmatter modification and/or content insertion.\nfn execute_capture_operations(\n    existing_content: \u0026str,\n    spec: \u0026CaptureSpec,\n    ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(String, Option\u003c(String, u8)\u003e), String\u003e {\n    // Parse frontmatter from existing content first\n    let mut parsed = parse(existing_content)\n        .map_err(|e| format!(\"Failed to parse frontmatter: {e}\"))?;\n    let mut section_info = None;\n\n    // Apply frontmatter operations if specified\n    if let Some(fm_ops) = \u0026spec.frontmatter {\n        parsed = apply_ops(parsed, fm_ops, ctx)\n            .map_err(|e| format!(\"Frontmatter error: {e}\"))?;\n    }\n\n    // Insert content if specified - operate on body only to preserve frontmatter\n    if let Some(content_template) = \u0026spec.content {\n        let section = spec.target.section.as_ref().ok_or_else(|| {\n            \"Capture has content but no target section specified\".to_string()\n        })?;\n\n        let rendered_content = render_string(content_template, ctx);\n        let section_match = SectionMatch::new(section);\n        let position = spec.target.position.clone().into();\n\n        let result = MarkdownEditor::insert_into_section(\n            \u0026parsed.body,\n            \u0026section_match,\n            \u0026rendered_content,\n            position,\n        )\n        .map_err(|e| match \u0026e {\n            MarkdownAstError::SectionNotFound(s) =\u003e format!(\"Section not found: '{s}'\"),\n            MarkdownAstError::EmptyDocument =\u003e \"Target file is empty\".to_string(),\n            MarkdownAstError::RenderError(msg) =\u003e format!(\"Render error: {msg}\"),\n        })?;\n\n        section_info = Some((result.matched_heading.title, result.matched_heading.level));\n        parsed.body = result.content;\n    }\n\n    // Serialize the document (frontmatter + body)\n    let final_content = serialize(\u0026parsed);\n    Ok((final_content, section_info))\n}\n\nfn build_capture_context(cfg: \u0026ResolvedConfig) -\u003e HashMap\u003cString, String\u003e {\n    let mut ctx = HashMap::new();\n\n    // Date/time\n    let now = Local::now();\n    ctx.insert(\"date\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"time\".into(), now.format(\"%H:%M\").to_string());\n    ctx.insert(\"datetime\".into(), now.to_rfc3339());\n\n    // Config paths\n    ctx.insert(\"vault_root\".into(), cfg.vault_root.to_string_lossy().to_string());\n    ctx.insert(\"templates_dir\".into(), cfg.templates_dir.to_string_lossy().to_string());\n    ctx.insert(\"captures_dir\".into(), cfg.captures_dir.to_string_lossy().to_string());\n    ctx.insert(\"macros_dir\".into(), cfg.macros_dir.to_string_lossy().to_string());\n\n    ctx\n}\n\nfn render_string(template: \u0026str, ctx: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    let re = Regex::new(r\"\\{\\{([a-zA-Z0-9_]+)\\}\\}\").unwrap();\n    re.replace_all(template, |caps: \u0026regex::Captures\u003c'_\u003e| {\n        let key = \u0026caps[1];\n        ctx.get(key).cloned().unwrap_or_else(|| caps[0].to_string())\n    })\n    .into_owned()\n}\n\nfn resolve_target_path(vault_root: \u0026Path, target: \u0026str) -\u003e std::path::PathBuf {\n    let path = std::path::Path::new(target);\n    if path.is_absolute() {\n        path.to_path_buf()\n    } else {\n        vault_root.join(path)\n    }\n}\n\n/// Execute a macro workflow.\npub fn execute_macro(\n    config: \u0026ResolvedConfig,\n    macro_name: \u0026str,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003cString, String\u003e {\n    use mdvault_core::macros::{\n        CaptureStep, MacroRunError, ShellStep, StepResult, TemplateStep,\n    };\n\n    // Load macro\n    let repo = MacroRepository::new(\u0026config.macros_dir)\n        .map_err(|e| format!(\"Failed to load macros: {e}\"))?;\n\n    let loaded = repo.get_by_name(macro_name).map_err(|e| format!(\"Macro error: {e}\"))?;\n\n    // Build context with provided vars\n    let mut ctx_vars = build_capture_context(config);\n    for (k, v) in vars {\n        ctx_vars.insert(k.clone(), v.clone());\n    }\n\n    // TUI executor (no shell support)\n    struct TuiStepExecutor\u003c'a\u003e {\n        config: \u0026'a ResolvedConfig,\n    }\n\n    impl\u003c'a\u003e StepExecutor for TuiStepExecutor\u003c'a\u003e {\n        fn execute_template(\n            \u0026self,\n            step: \u0026TemplateStep,\n            ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            use mdvault_core::templates::engine::{\n                build_minimal_context, render, render_string,\n                resolve_template_output_path,\n            };\n\n            let step_vars = ctx.with_step_vars(\u0026step.vars_with);\n\n            // Load template\n            let repo = TemplateRepository::new(\u0026self.config.templates_dir)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n            let loaded = repo\n                .get_by_name(\u0026step.template)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n            // Build template info\n            let info = TemplateInfo {\n                logical_name: loaded.logical_name.clone(),\n                path: loaded.path.clone(),\n            };\n\n            // Resolve output path\n            let output_path = if let Some(ref output) = step.output {\n                let rendered = render_string(output, \u0026step_vars)\n                    .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n                self.config.vault_root.join(\u0026rendered)\n            } else {\n                let minimal_ctx = build_minimal_context(self.config, \u0026info);\n                let mut merged_ctx = minimal_ctx;\n                for (k, v) in \u0026step_vars {\n                    merged_ctx.insert(k.clone(), v.clone());\n                }\n                resolve_template_output_path(\u0026loaded, self.config, \u0026merged_ctx)\n                    .map_err(|e| MacroRunError::TemplateError(e.to_string()))?\n                    .ok_or_else(|| {\n                        MacroRunError::TemplateError(\n                            \"Template has no output path\".to_string(),\n                        )\n                    })?\n            };\n\n            // Check if file exists\n            if output_path.exists() {\n                return Err(MacroRunError::TemplateError(format!(\n                    \"File already exists: {}\",\n                    output_path.display()\n                )));\n            }\n\n            // Render template (includes frontmatter extra fields)\n            let rendered = render(\u0026loaded, \u0026step_vars)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n            // Create parent directories\n            if let Some(parent) = output_path.parent() {\n                fs::create_dir_all(parent)\n                    .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n            }\n\n            // Write file\n            fs::write(\u0026output_path, \u0026rendered)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Created {}\", output_path.display()),\n                output_path: Some(output_path),\n            })\n        }\n\n        fn execute_capture(\n            \u0026self,\n            step: \u0026CaptureStep,\n            ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            use mdvault_core::templates::engine::render_string;\n\n            let step_vars = ctx.with_step_vars(\u0026step.vars_with);\n\n            // Load capture\n            let repo = CaptureRepository::new(\u0026self.config.captures_dir)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n            let loaded = repo\n                .get_by_name(\u0026step.capture)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n            // Render target file path\n            let target_file_raw = render_string(\u0026loaded.spec.target.file, \u0026step_vars)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n            let target_file =\n                resolve_target_path(\u0026self.config.vault_root, \u0026target_file_raw);\n\n            // Read existing file\n            let existing_content = fs::read_to_string(\u0026target_file).map_err(|e| {\n                MacroRunError::CaptureError(format!(\n                    \"Failed to read {}: {e}\",\n                    target_file.display()\n                ))\n            })?;\n\n            // Parse frontmatter\n            let mut parsed = parse(\u0026existing_content)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n            // Apply frontmatter operations\n            if let Some(fm_ops) = \u0026loaded.spec.frontmatter {\n                parsed = apply_ops(parsed, fm_ops, \u0026step_vars)\n                    .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n            }\n\n            // Insert content if specified\n            if let Some(content_template) = \u0026loaded.spec.content {\n                let section = loaded.spec.target.section.as_ref().ok_or_else(|| {\n                    MacroRunError::CaptureError(\n                        \"Capture has content but no target section\".to_string(),\n                    )\n                })?;\n\n                let rendered_content = render_string(content_template, \u0026step_vars)\n                    .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n                let section_match = SectionMatch::new(section);\n                let position = loaded.spec.target.position.clone().into();\n\n                let result = MarkdownEditor::insert_into_section(\n                    \u0026parsed.body,\n                    \u0026section_match,\n                    \u0026rendered_content,\n                    position,\n                )\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n                parsed.body = result.content;\n            }\n\n            // Serialize and write\n            let final_content = serialize(\u0026parsed);\n            fs::write(\u0026target_file, \u0026final_content)\n                .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Updated {}\", target_file.display()),\n                output_path: Some(target_file),\n            })\n        }\n\n        fn execute_shell(\n            \u0026self,\n            _step: \u0026ShellStep,\n            _ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            // Shell not supported in TUI\n            Err(MacroRunError::TrustRequired)\n        }\n    }\n\n    let executor = TuiStepExecutor { config };\n\n    // Run with no trust (shell commands will fail)\n    let run_options = RunOptions { trust: false, allow_shell: false, dry_run: false };\n\n    let run_ctx = RunContext::new(ctx_vars, run_options);\n    let result = run_macro(\u0026loaded, \u0026executor, run_ctx);\n\n    if result.success {\n        let mut msg = format!(\"Completed {} steps\", result.step_results.len());\n        if let Some(last) = result.step_results.last() {\n            if let Some(path) = \u0026last.output_path {\n                msg.push_str(\u0026format!(\"  {}\", path.display()));\n            }\n        }\n        Ok(msg)\n    } else {\n        let failed = result\n            .step_results\n            .iter()\n            .find(|r| !r.success)\n            .map(|r| r.message.clone())\n            .unwrap_or_else(|| \"Unknown error\".to_string());\n        Err(format!(\"Macro failed: {}\", failed))\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":211},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","app.rs"],"content":"//! Application state and update logic following The Elm Architecture.\n\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\nuse mdvault_core::captures::CaptureInfo;\nuse mdvault_core::config::types::ResolvedConfig;\nuse mdvault_core::macros::{requires_trust, MacroInfo};\nuse mdvault_core::templates::discovery::TemplateInfo;\nuse mdvault_core::templates::engine::build_minimal_context;\nuse mdvault_core::templates::repository::TemplateRepository;\nuse mdvault_core::vars::collect_all_variables;\n\n/// Unified item that can be either a template, capture, or macro.\n#[derive(Debug, Clone)]\npub enum PaletteItem {\n    Template(TemplateInfo),\n    Capture(CaptureInfo),\n    Macro(MacroInfo),\n}\n\nimpl PaletteItem {\n    pub fn name(\u0026self) -\u003e \u0026str {\n        match self {\n            PaletteItem::Template(t) =\u003e \u0026t.logical_name,\n            PaletteItem::Capture(c) =\u003e \u0026c.logical_name,\n            PaletteItem::Macro(m) =\u003e \u0026m.logical_name,\n        }\n    }\n}\n\n/// Variable info with display metadata.\n#[derive(Debug, Clone)]\npub struct VarInfo {\n    /// Variable name.\n    pub name: String,\n    /// Prompt text to show user.\n    pub prompt: Option\u003cString\u003e,\n    /// Description of what this variable is for.\n    pub description: Option\u003cString\u003e,\n    /// Default value (pre-fills input).\n    pub default: Option\u003cString\u003e,\n}\n\n/// Current operating mode.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Mode {\n    /// Browsing palette, selecting item.\n    Browse,\n    /// Entering output path for template.\n    OutputPath,\n    /// Entering variables for selected item.\n    Input { var_index: usize },\n    /// Showing result (success/error).\n    Result,\n}\n\n/// Preview content for the selected item.\n#[derive(Debug, Clone)]\npub enum Preview {\n    None,\n    Template { content: String },\n    Capture { content: String },\n    Macro { content: String, requires_trust: bool },\n    Error(String),\n}\n\n/// Feedback message to display in status bar.\n#[derive(Debug, Clone)]\npub struct StatusMessage {\n    pub text: String,\n    pub is_error: bool,\n}\n\n/// Messages that drive state updates.\n#[derive(Debug, Clone)]\npub enum Message {\n    // Navigation\n    SelectNext,\n    SelectPrev,\n\n    // Mode transitions\n    Execute,\n    Cancel,\n\n    // Input handling\n    InputChar(char),\n    InputBackspace,\n    InputSubmit,\n\n    // System\n    Quit,\n    ClearStatus,\n}\n\n/// Main application state.\npub struct App {\n    /// Operating mode.\n    pub mode: Mode,\n\n    /// Resolved configuration.\n    pub config: ResolvedConfig,\n\n    /// All palette items (templates + captures + macros).\n    pub items: Vec\u003cPaletteItem\u003e,\n\n    /// Index where captures start in items list.\n    pub captures_start_index: usize,\n\n    /// Index where macros start in items list.\n    pub macros_start_index: usize,\n\n    /// Currently selected index in palette.\n    pub selected: usize,\n\n    /// Preview of currently selected item.\n    pub preview: Preview,\n\n    /// Variables required by current item (with metadata for prompts).\n    pub required_var_infos: Vec\u003cVarInfo\u003e,\n\n    /// Variable values entered by user.\n    pub var_values: HashMap\u003cString, String\u003e,\n\n    /// Current input buffer (for variable/path entry).\n    pub input_buffer: String,\n\n    /// Status bar message.\n    pub status: Option\u003cStatusMessage\u003e,\n\n    /// Should quit.\n    pub should_quit: bool,\n\n    /// Resolved output path for template (from frontmatter or user input).\n    pub resolved_output_path: Option\u003cPathBuf\u003e,\n}\n\nimpl App {\n    /// Create a new App with loaded config and discovered items.\n    pub fn new(\n        config: ResolvedConfig,\n        templates: Vec\u003cTemplateInfo\u003e,\n        captures: Vec\u003cCaptureInfo\u003e,\n        macros: Vec\u003cMacroInfo\u003e,\n    ) -\u003e Self {\n        let captures_start_index = templates.len();\n        let macros_start_index = templates.len() + captures.len();\n\n        let mut items: Vec\u003cPaletteItem\u003e =\n            templates.into_iter().map(PaletteItem::Template).collect();\n        items.extend(captures.into_iter().map(PaletteItem::Capture));\n        items.extend(macros.into_iter().map(PaletteItem::Macro));\n\n        let mut app = App {\n            mode: Mode::Browse,\n            config,\n            items,\n            captures_start_index,\n            macros_start_index,\n            selected: 0,\n            preview: Preview::None,\n            required_var_infos: Vec::new(),\n            var_values: HashMap::new(),\n            input_buffer: String::new(),\n            status: None,\n            should_quit: false,\n            resolved_output_path: None,\n        };\n\n        // Load preview for first item if any\n        app.load_preview();\n        app\n    }\n\n    /// Process a message and update state.\n    pub fn update(\u0026mut self, msg: Message) {\n        match msg {\n            Message::SelectNext =\u003e {\n                if self.selected \u003c self.items.len().saturating_sub(1) {\n                    self.selected += 1;\n                    self.load_preview();\n                }\n            }\n            Message::SelectPrev =\u003e {\n                if self.selected \u003e 0 {\n                    self.selected -= 1;\n                    self.load_preview();\n                }\n            }\n            Message::Execute =\u003e {\n                self.start_execution();\n            }\n            Message::Cancel =\u003e {\n                self.mode = Mode::Browse;\n                self.input_buffer.clear();\n                self.required_var_infos.clear();\n                self.var_values.clear();\n                self.resolved_output_path = None;\n            }\n            Message::InputChar(c) =\u003e {\n                self.input_buffer.push(c);\n            }\n            Message::InputBackspace =\u003e {\n                self.input_buffer.pop();\n            }\n            Message::InputSubmit =\u003e {\n                self.submit_input();\n            }\n            Message::ClearStatus =\u003e {\n                self.status = None;\n                self.mode = Mode::Browse;\n                self.input_buffer.clear();\n                self.required_var_infos.clear();\n                self.var_values.clear();\n                self.resolved_output_path = None;\n            }\n            Message::Quit =\u003e {\n                self.should_quit = true;\n            }\n        }\n    }\n\n    /// Load preview for currently selected item.\n    pub fn load_preview(\u0026mut self) {\n        use mdvault_core::macros::MacroRepository;\n\n        if self.items.is_empty() {\n            self.preview = Preview::None;\n            return;\n        }\n\n        let item = \u0026self.items[self.selected];\n        match item {\n            PaletteItem::Template(info) =\u003e match std::fs::read_to_string(\u0026info.path) {\n                Ok(content) =\u003e self.preview = Preview::Template { content },\n                Err(e) =\u003e self.preview = Preview::Error(format!(\"Failed to read: {e}\")),\n            },\n            PaletteItem::Capture(info) =\u003e match std::fs::read_to_string(\u0026info.path) {\n                Ok(content) =\u003e self.preview = Preview::Capture { content },\n                Err(e) =\u003e self.preview = Preview::Error(format!(\"Failed to read: {e}\")),\n            },\n            PaletteItem::Macro(info) =\u003e {\n                // Load macro to check if it requires trust\n                let needs_trust = match MacroRepository::new(\u0026self.config.macros_dir) {\n                    Ok(repo) =\u003e match repo.get_by_name(\u0026info.logical_name) {\n                        Ok(loaded) =\u003e requires_trust(\u0026loaded.spec),\n                        Err(_) =\u003e false,\n                    },\n                    Err(_) =\u003e false,\n                };\n                match std::fs::read_to_string(\u0026info.path) {\n                    Ok(content) =\u003e {\n                        self.preview =\n                            Preview::Macro { content, requires_trust: needs_trust }\n                    }\n                    Err(e) =\u003e {\n                        self.preview = Preview::Error(format!(\"Failed to read: {e}\"))\n                    }\n                }\n            }\n        }\n    }\n\n    /// Start execution workflow for selected item.\n    fn start_execution(\u0026mut self) {\n        if self.items.is_empty() {\n            return;\n        }\n\n        let item = \u0026self.items[self.selected];\n        match item {\n            PaletteItem::Template(info) =\u003e {\n                // Load template variables first\n                match self.load_template_var_infos(\u0026info.logical_name) {\n                    Ok(var_infos) =\u003e {\n                        self.required_var_infos = var_infos;\n                        self.var_values.clear();\n                        if self.required_var_infos.is_empty() {\n                            // No vars needed, proceed to output path resolution\n                            self.proceed_to_template_output();\n                        } else {\n                            // Pre-fill with default if available\n                            if let Some(default) = \u0026self.required_var_infos[0].default {\n                                self.input_buffer = default.clone();\n                            } else {\n                                self.input_buffer.clear();\n                            }\n                            self.mode = Mode::Input { var_index: 0 };\n                        }\n                    }\n                    Err(e) =\u003e {\n                        self.status = Some(StatusMessage { text: e, is_error: true });\n                        self.mode = Mode::Result;\n                    }\n                }\n            }\n            PaletteItem::Capture(info) =\u003e {\n                // Load capture to extract required variables with metadata\n                match self.load_capture_var_infos(\u0026info.logical_name) {\n                    Ok(var_infos) =\u003e {\n                        self.required_var_infos = var_infos;\n                        self.var_values.clear();\n                        if self.required_var_infos.is_empty() {\n                            // No vars needed, execute immediately\n                            self.execute_capture();\n                        } else {\n                            // Pre-fill with default if available\n                            if let Some(default) = \u0026self.required_var_infos[0].default {\n                                self.input_buffer = default.clone();\n                            } else {\n                                self.input_buffer.clear();\n                            }\n                            self.mode = Mode::Input { var_index: 0 };\n                        }\n                    }\n                    Err(e) =\u003e {\n                        self.status = Some(StatusMessage { text: e, is_error: true });\n                        self.mode = Mode::Result;\n                    }\n                }\n            }\n            PaletteItem::Macro(info) =\u003e {\n                // Load macro to extract required variables with metadata\n                match self.load_macro_var_infos(\u0026info.logical_name) {\n                    Ok((var_infos, needs_trust)) =\u003e {\n                        if needs_trust {\n                            // Macros with shell commands aren't supported in TUI yet\n                            self.status = Some(StatusMessage {\n                                text: \"Macro requires --trust flag. Use CLI: mdv macro --trust\".to_string(),\n                                is_error: true,\n                            });\n                            self.mode = Mode::Result;\n                            return;\n                        }\n                        self.required_var_infos = var_infos;\n                        self.var_values.clear();\n                        if self.required_var_infos.is_empty() {\n                            // No vars needed, execute immediately\n                            self.execute_macro();\n                        } else {\n                            // Pre-fill with default if available\n                            if let Some(default) = \u0026self.required_var_infos[0].default {\n                                self.input_buffer = default.clone();\n                            } else {\n                                self.input_buffer.clear();\n                            }\n                            self.mode = Mode::Input { var_index: 0 };\n                        }\n                    }\n                    Err(e) =\u003e {\n                        self.status = Some(StatusMessage { text: e, is_error: true });\n                        self.mode = Mode::Result;\n                    }\n                }\n            }\n        }\n    }\n\n    /// Try to resolve template output path from frontmatter.\n    fn resolve_template_output(\u0026self, name: \u0026str) -\u003e Result\u003cOption\u003cPathBuf\u003e, String\u003e {\n        use mdvault_core::templates::engine::render_string;\n\n        let repo = TemplateRepository::new(\u0026self.config.templates_dir)\n            .map_err(|e| format!(\"Failed to load templates: {e}\"))?;\n\n        let loaded = repo\n            .get_by_name(name)\n            .map_err(|e| format!(\"Failed to load template: {e}\"))?;\n\n        let info = TemplateInfo {\n            logical_name: loaded.logical_name.clone(),\n            path: loaded.path.clone(),\n        };\n\n        // Build context with user variables for output path resolution\n        let mut ctx = build_minimal_context(\u0026self.config, \u0026info);\n        for (k, v) in \u0026self.var_values {\n            ctx.insert(k.clone(), v.clone());\n        }\n\n        // Check if template has output path in frontmatter\n        if let Some(ref fm) = loaded.frontmatter {\n            if let Some(ref output) = fm.output {\n                let rendered = render_string(output, \u0026ctx)\n                    .map_err(|e| format!(\"Failed to render output path: {e}\"))?;\n                let path = self.config.vault_root.join(\u0026rendered);\n                return Ok(Some(path));\n            }\n        }\n\n        Ok(None)\n    }\n\n    /// Proceed to output path resolution after collecting variables.\n    fn proceed_to_template_output(\u0026mut self) {\n        let Some(PaletteItem::Template(info)) = self.items.get(self.selected) else {\n            return;\n        };\n\n        match self.resolve_template_output(\u0026info.logical_name) {\n            Ok(Some(path)) =\u003e {\n                // Template has frontmatter output, execute directly\n                self.resolved_output_path = Some(path);\n                self.execute_template();\n            }\n            Ok(None) =\u003e {\n                // No frontmatter output, prompt user\n                self.resolved_output_path = None;\n                self.input_buffer.clear();\n                self.mode = Mode::OutputPath;\n            }\n            Err(e) =\u003e {\n                self.status = Some(StatusMessage { text: e, is_error: true });\n                self.mode = Mode::Result;\n            }\n        }\n    }\n\n    /// Submit current input and advance to next step.\n    fn submit_input(\u0026mut self) {\n        match \u0026self.mode {\n            Mode::OutputPath =\u003e {\n                if self.input_buffer.is_empty() {\n                    return;\n                }\n                // Convert input to absolute path and execute\n                let output_path = PathBuf::from(\u0026self.input_buffer);\n                let output_path = if output_path.is_absolute() {\n                    output_path\n                } else {\n                    self.config.vault_root.join(\u0026output_path)\n                };\n                self.resolved_output_path = Some(output_path);\n                self.execute_template();\n            }\n            Mode::Input { var_index } =\u003e {\n                let var_index = *var_index;\n                if var_index \u003c self.required_var_infos.len() {\n                    let var_name = self.required_var_infos[var_index].name.clone();\n                    self.var_values.insert(var_name, self.input_buffer.clone());\n\n                    if var_index + 1 \u003c self.required_var_infos.len() {\n                        // Pre-fill next input with default if available\n                        if let Some(default) =\n                            \u0026self.required_var_infos[var_index + 1].default\n                        {\n                            self.input_buffer = default.clone();\n                        } else {\n                            self.input_buffer.clear();\n                        }\n                        // More vars to collect\n                        self.mode = Mode::Input { var_index: var_index + 1 };\n                    } else {\n                        // All vars collected, execute based on item type\n                        self.input_buffer.clear();\n                        match \u0026self.items[self.selected] {\n                            // Templates need output path resolution after vars\n                            PaletteItem::Template(_) =\u003e self.proceed_to_template_output(),\n                            PaletteItem::Capture(_) =\u003e self.execute_capture(),\n                            PaletteItem::Macro(_) =\u003e self.execute_macro(),\n                        }\n                    }\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    /// Load capture and extract user-defined variables with metadata.\n    fn load_capture_var_infos(\u0026self, name: \u0026str) -\u003e Result\u003cVec\u003cVarInfo\u003e, String\u003e {\n        use mdvault_core::captures::CaptureRepository;\n\n        let repo = CaptureRepository::new(\u0026self.config.captures_dir)\n            .map_err(|e| format!(\"Failed to load captures: {e}\"))?;\n\n        let loaded =\n            repo.get_by_name(name).map_err(|e| format!(\"Failed to load capture: {e}\"))?;\n\n        // Get variable names from content/target/section\n        let var_names = super::actions::extract_user_variables(\u0026loaded.spec);\n\n        // Enrich with metadata from vars spec\n        let var_infos: Vec\u003cVarInfo\u003e = var_names\n            .into_iter()\n            .map(|name| {\n                let (prompt, description, default) =\n                    if let Some(vars_map) = \u0026loaded.spec.vars {\n                        if let Some(var_spec) = vars_map.get(\u0026name) {\n                            let prompt_text = var_spec.prompt();\n                            // Only use prompt if non-empty (simple form has prompt, full form might have empty)\n                            let prompt_opt = if prompt_text.is_empty() {\n                                None\n                            } else {\n                                Some(prompt_text.to_string())\n                            };\n                            (\n                                prompt_opt,\n                                var_spec.description().map(|s| s.to_string()),\n                                var_spec.default().map(|s| s.to_string()),\n                            )\n                        } else {\n                            (None, None, None)\n                        }\n                    } else {\n                        (None, None, None)\n                    };\n                VarInfo { name, prompt, description, default }\n            })\n            .collect();\n\n        Ok(var_infos)\n    }\n\n    /// Load macro and extract user-defined variables with metadata.\n    /// Returns (var_infos, needs_trust).\n    fn load_macro_var_infos(\u0026self, name: \u0026str) -\u003e Result\u003c(Vec\u003cVarInfo\u003e, bool), String\u003e {\n        use mdvault_core::macros::MacroRepository;\n\n        let repo = MacroRepository::new(\u0026self.config.macros_dir)\n            .map_err(|e| format!(\"Failed to load macros: {e}\"))?;\n\n        let loaded =\n            repo.get_by_name(name).map_err(|e| format!(\"Failed to load macro: {e}\"))?;\n\n        let needs_trust = requires_trust(\u0026loaded.spec);\n\n        // Get variables from macro spec\n        let var_infos: Vec\u003cVarInfo\u003e = if let Some(vars_map) = \u0026loaded.spec.vars {\n            vars_map\n                .iter()\n                .map(|(name, spec)| {\n                    let prompt_text = spec.prompt();\n                    let prompt_opt = if prompt_text.is_empty() {\n                        None\n                    } else {\n                        Some(prompt_text.to_string())\n                    };\n                    VarInfo {\n                        name: name.clone(),\n                        prompt: prompt_opt,\n                        description: spec.description().map(|s| s.to_string()),\n                        default: spec.default().map(|s| s.to_string()),\n                    }\n                })\n                .collect()\n        } else {\n            Vec::new()\n        };\n\n        Ok((var_infos, needs_trust))\n    }\n\n    /// Load template and extract user-defined variables with metadata.\n    fn load_template_var_infos(\u0026self, name: \u0026str) -\u003e Result\u003cVec\u003cVarInfo\u003e, String\u003e {\n        let repo = TemplateRepository::new(\u0026self.config.templates_dir)\n            .map_err(|e| format!(\"Failed to load templates: {e}\"))?;\n\n        let loaded = repo\n            .get_by_name(name)\n            .map_err(|e| format!(\"Failed to load template: {e}\"))?;\n\n        // Collect variables from frontmatter vars and body content\n        let all_vars = collect_all_variables(\n            loaded.frontmatter.as_ref().and_then(|fm| fm.vars.as_ref()),\n            \u0026loaded.body,\n        );\n\n        // Convert to VarInfo with metadata\n        let var_infos: Vec\u003cVarInfo\u003e = all_vars\n            .into_iter()\n            .map(|(name, spec_opt)| {\n                if let Some(spec) = spec_opt {\n                    let prompt_text = spec.prompt();\n                    let prompt_opt = if prompt_text.is_empty() {\n                        None\n                    } else {\n                        Some(prompt_text.to_string())\n                    };\n                    VarInfo {\n                        name,\n                        prompt: prompt_opt,\n                        description: spec.description().map(|s| s.to_string()),\n                        default: spec.default().map(|s| s.to_string()),\n                    }\n                } else {\n                    // Variable found in content but not declared in frontmatter\n                    VarInfo { name, prompt: None, description: None, default: None }\n                }\n            })\n            .collect();\n\n        Ok(var_infos)\n    }\n\n    /// Execute template creation.\n    fn execute_template(\u0026mut self) {\n        let Some(PaletteItem::Template(info)) = self.items.get(self.selected) else {\n            return;\n        };\n\n        let Some(output_path) = self.resolved_output_path.take() else {\n            self.status = Some(StatusMessage {\n                text: \"No output path resolved\".to_string(),\n                is_error: true,\n            });\n            self.mode = Mode::Result;\n            return;\n        };\n\n        match super::actions::execute_template(\n            \u0026self.config,\n            \u0026info.logical_name,\n            \u0026output_path,\n            \u0026self.var_values,\n        ) {\n            Ok(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: false });\n            }\n            Err(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: true });\n            }\n        }\n        self.mode = Mode::Result;\n        self.input_buffer.clear();\n    }\n\n    /// Execute capture insertion.\n    fn execute_capture(\u0026mut self) {\n        let Some(PaletteItem::Capture(info)) = self.items.get(self.selected) else {\n            return;\n        };\n\n        match super::actions::execute_capture(\n            \u0026self.config,\n            \u0026info.logical_name,\n            \u0026self.var_values,\n        ) {\n            Ok(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: false });\n            }\n            Err(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: true });\n            }\n        }\n        self.mode = Mode::Result;\n    }\n\n    /// Execute macro workflow.\n    fn execute_macro(\u0026mut self) {\n        let Some(PaletteItem::Macro(info)) = self.items.get(self.selected) else {\n            return;\n        };\n\n        match super::actions::execute_macro(\n            \u0026self.config,\n            \u0026info.logical_name,\n            \u0026self.var_values,\n        ) {\n            Ok(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: false });\n            }\n            Err(msg) =\u003e {\n                self.status = Some(StatusMessage { text: msg, is_error: true });\n            }\n        }\n        self.mode = Mode::Result;\n    }\n\n    /// Get current input prompt label.\n    pub fn current_input_label(\u0026self) -\u003e Option\u003cString\u003e {\n        match \u0026self.mode {\n            Mode::OutputPath =\u003e Some(\"Output path\".to_string()),\n            Mode::Input { var_index } =\u003e {\n                self.required_var_infos.get(*var_index).map(|info| {\n                    // Use prompt if available, otherwise variable name\n                    info.prompt.clone().unwrap_or_else(|| info.name.clone())\n                })\n            }\n            _ =\u003e None,\n        }\n    }\n\n    /// Get current input description (if available).\n    pub fn current_input_description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match \u0026self.mode {\n            Mode::Input { var_index } =\u003e self\n                .required_var_infos\n                .get(*var_index)\n                .and_then(|info| info.description.as_deref()),\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":304},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","event.rs"],"content":"//! Event handling: maps keyboard events to application messages.\n\nuse crossterm::event::{KeyCode, KeyEvent, KeyModifiers};\n\nuse super::app::{App, Message, Mode};\n\n/// Map a key event to an optional message based on current app mode.\npub fn map_key_event(app: \u0026App, key: KeyEvent) -\u003e Option\u003cMessage\u003e {\n    // Global bindings (work in any mode)\n    if key.code == KeyCode::Char('c') \u0026\u0026 key.modifiers.contains(KeyModifiers::CONTROL) {\n        return Some(Message::Quit);\n    }\n\n    // Mode-specific bindings\n    match \u0026app.mode {\n        Mode::Browse =\u003e map_browse_keys(key),\n        Mode::OutputPath | Mode::Input { .. } =\u003e map_input_keys(key),\n        Mode::Result =\u003e map_result_keys(key),\n    }\n}\n\nfn map_browse_keys(key: KeyEvent) -\u003e Option\u003cMessage\u003e {\n    match key.code {\n        // Vim-style navigation\n        KeyCode::Char('j') | KeyCode::Down =\u003e Some(Message::SelectNext),\n        KeyCode::Char('k') | KeyCode::Up =\u003e Some(Message::SelectPrev),\n\n        // Actions\n        KeyCode::Enter =\u003e Some(Message::Execute),\n        KeyCode::Char('q') | KeyCode::Esc =\u003e Some(Message::Quit),\n\n        _ =\u003e None,\n    }\n}\n\nfn map_input_keys(key: KeyEvent) -\u003e Option\u003cMessage\u003e {\n    match key.code {\n        KeyCode::Char(c) =\u003e Some(Message::InputChar(c)),\n        KeyCode::Backspace =\u003e Some(Message::InputBackspace),\n        KeyCode::Enter =\u003e Some(Message::InputSubmit),\n        KeyCode::Esc =\u003e Some(Message::Cancel),\n        _ =\u003e None,\n    }\n}\n\nfn map_result_keys(key: KeyEvent) -\u003e Option\u003cMessage\u003e {\n    match key.code {\n        KeyCode::Enter | KeyCode::Esc | KeyCode::Char(' ') | KeyCode::Char('q') =\u003e {\n            Some(Message::ClearStatus)\n        }\n        _ =\u003e None,\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","mod.rs"],"content":"//! TUI module for interactive mode.\n\nmod actions;\nmod app;\nmod event;\nmod ui;\n\nuse std::io;\nuse std::path::Path;\nuse std::time::Duration;\n\nuse color_eyre::eyre::Result;\nuse crossterm::{\n    event::{poll, read, Event},\n    execute,\n    terminal::{\n        disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen,\n    },\n};\nuse ratatui::prelude::*;\n\nuse mdvault_core::captures::CaptureRepository;\nuse mdvault_core::config::loader::ConfigLoader;\nuse mdvault_core::macros::MacroRepository;\nuse mdvault_core::templates::repository::TemplateRepository;\n\nuse app::App;\nuse event::map_key_event;\n\n/// Run the TUI application.\npub fn run(config_path: Option\u003c\u0026Path\u003e, profile: Option\u003c\u0026str\u003e) -\u003e Result\u003c()\u003e {\n    // Load config (fail fast if config broken)\n    let config = ConfigLoader::load(config_path, profile).map_err(|e| {\n        color_eyre::eyre::eyre!(\"Configuration error: {e}\\nRun 'mdv doctor' to diagnose.\")\n    })?;\n\n    // Discover templates\n    let templates = match TemplateRepository::new(\u0026config.templates_dir) {\n        Ok(repo) =\u003e repo.list_all().to_vec(),\n        Err(e) =\u003e {\n            eprintln!(\"Warning: Failed to load templates: {e}\");\n            Vec::new()\n        }\n    };\n\n    // Discover captures\n    let captures = match CaptureRepository::new(\u0026config.captures_dir) {\n        Ok(repo) =\u003e repo.list_all().to_vec(),\n        Err(e) =\u003e {\n            eprintln!(\"Warning: Failed to load captures: {e}\");\n            Vec::new()\n        }\n    };\n\n    // Discover macros\n    let macros = match MacroRepository::new(\u0026config.macros_dir) {\n        Ok(repo) =\u003e repo.list_all().to_vec(),\n        Err(e) =\u003e {\n            eprintln!(\"Warning: Failed to load macros: {e}\");\n            Vec::new()\n        }\n    };\n\n    // Initialize app\n    let app = App::new(config, templates, captures, macros);\n\n    // Setup terminal\n    let mut terminal = setup_terminal()?;\n\n    // Run with cleanup on panic\n    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n        run_app(\u0026mut terminal, app)\n    }));\n\n    // Always restore terminal\n    restore_terminal(\u0026mut terminal)?;\n\n    match result {\n        Ok(Ok(())) =\u003e Ok(()),\n        Ok(Err(e)) =\u003e Err(e),\n        Err(_) =\u003e Err(color_eyre::eyre::eyre!(\"Application panicked\")),\n    }\n}\n\nfn setup_terminal() -\u003e Result\u003cTerminal\u003cCrosstermBackend\u003cio::Stdout\u003e\u003e\u003e {\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backend = CrosstermBackend::new(stdout);\n    let terminal = Terminal::new(backend)?;\n    Ok(terminal)\n}\n\nfn restore_terminal(terminal: \u0026mut Terminal\u003cCrosstermBackend\u003cio::Stdout\u003e\u003e) -\u003e Result\u003c()\u003e {\n    disable_raw_mode()?;\n    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;\n    terminal.show_cursor()?;\n    Ok(())\n}\n\nfn run_app(\n    terminal: \u0026mut Terminal\u003cCrosstermBackend\u003cio::Stdout\u003e\u003e,\n    mut app: App,\n) -\u003e Result\u003c()\u003e {\n    loop {\n        // 1. Render current state\n        terminal.draw(|frame| ui::draw(frame, \u0026app))?;\n\n        // 2. Poll for events (with timeout for responsiveness)\n        if poll(Duration::from_millis(100))? {\n            if let Event::Key(key) = read()? {\n                // 3. Map key event to message\n                if let Some(msg) = map_key_event(\u0026app, key) {\n                    // 4. Process message\n                    app.update(msg);\n                }\n            }\n        }\n\n        // 5. Check quit condition\n        if app.should_quit {\n            return Ok(());\n        }\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","ui","layout.rs"],"content":"//! Main layout and frame composition.\n\nuse ratatui::{prelude::*, widgets::Paragraph};\n\nuse super::{palette, preview, status};\nuse crate::tui::app::App;\n\n/// Draw the entire application UI.\npub fn draw(frame: \u0026mut Frame, app: \u0026App) {\n    // Main layout: header, body, footer\n    let main_chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Length(1), // Header\n            Constraint::Min(5),    // Body\n            Constraint::Length(2), // Status bar\n        ])\n        .split(frame.area());\n\n    // Header\n    draw_header(frame, main_chunks[0], app);\n\n    // Body: palette | preview\n    let body_chunks = Layout::default()\n        .direction(Direction::Horizontal)\n        .constraints([\n            Constraint::Percentage(30), // Palette\n            Constraint::Percentage(70), // Preview\n        ])\n        .split(main_chunks[1]);\n\n    palette::draw(frame, body_chunks[0], app);\n    preview::draw(frame, body_chunks[1], app);\n\n    // Status bar\n    status::draw(frame, main_chunks[2], app);\n}\n\nfn draw_header(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let profile_text = format!(\"[{}]\", app.config.active_profile);\n    let title = \"mdvault\";\n\n    // Calculate padding for right-alignment\n    let padding =\n        area.width.saturating_sub(title.len() as u16 + profile_text.len() as u16 + 2)\n            as usize;\n\n    let line = Line::from(vec![\n        Span::styled(format!(\" {}\", title), Style::default().fg(Color::Cyan).bold()),\n        Span::raw(\" \".repeat(padding)),\n        Span::styled(profile_text, Style::default().fg(Color::DarkGray)),\n        Span::raw(\" \"),\n    ]);\n\n    let paragraph = Paragraph::new(line);\n    frame.render_widget(paragraph, area);\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":31},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","ui","mod.rs"],"content":"//! UI rendering modules.\n\nmod layout;\nmod palette;\nmod preview;\nmod status;\n\npub use layout::draw;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","ui","palette.rs"],"content":"//! Palette list rendering (templates, captures, and macros).\n\nuse ratatui::{\n    prelude::*,\n    widgets::{Block, Borders, List, ListItem},\n};\n\nuse crate::tui::app::App;\n\npub fn draw(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let mut items: Vec\u003cListItem\u003e = Vec::new();\n\n    // Templates section\n    if app.captures_start_index \u003e 0 {\n        items.push(ListItem::new(Line::from(vec![Span::styled(\n            \" TEMPLATES\",\n            Style::default().fg(Color::Cyan).bold(),\n        )])));\n\n        for (i, item) in app.items.iter().enumerate().take(app.captures_start_index) {\n            let style = if i == app.selected {\n                Style::default().bg(Color::DarkGray).fg(Color::White)\n            } else {\n                Style::default()\n            };\n\n            let prefix = if i == app.selected { \" \u003e \" } else { \"   \" };\n            items.push(ListItem::new(format!(\"{}{}\", prefix, item.name())).style(style));\n        }\n    }\n\n    // Captures section\n    let has_captures = app.macros_start_index \u003e app.captures_start_index;\n    if has_captures {\n        // Add spacing if we had templates\n        if app.captures_start_index \u003e 0 {\n            items.push(ListItem::new(\"\"));\n        }\n\n        items.push(ListItem::new(Line::from(vec![Span::styled(\n            \" CAPTURES\",\n            Style::default().fg(Color::Magenta).bold(),\n        )])));\n\n        for i in app.captures_start_index..app.macros_start_index {\n            let item = \u0026app.items[i];\n            let style = if i == app.selected {\n                Style::default().bg(Color::DarkGray).fg(Color::White)\n            } else {\n                Style::default()\n            };\n\n            let prefix = if i == app.selected { \" \u003e \" } else { \"   \" };\n            items.push(ListItem::new(format!(\"{}{}\", prefix, item.name())).style(style));\n        }\n    }\n\n    // Macros section\n    let has_macros = app.macros_start_index \u003c app.items.len();\n    if has_macros {\n        // Add spacing if we had captures or templates\n        if app.macros_start_index \u003e 0 {\n            items.push(ListItem::new(\"\"));\n        }\n\n        items.push(ListItem::new(Line::from(vec![Span::styled(\n            \" MACROS\",\n            Style::default().fg(Color::Yellow).bold(),\n        )])));\n\n        for i in app.macros_start_index..app.items.len() {\n            let item = \u0026app.items[i];\n            let style = if i == app.selected {\n                Style::default().bg(Color::DarkGray).fg(Color::White)\n            } else {\n                Style::default()\n            };\n\n            let prefix = if i == app.selected { \" \u003e \" } else { \"   \" };\n            items.push(ListItem::new(format!(\"{}{}\", prefix, item.name())).style(style));\n        }\n    }\n\n    // Empty state\n    if app.items.is_empty() {\n        items.push(ListItem::new(Span::styled(\n            \" (no items found)\",\n            Style::default().fg(Color::DarkGray).italic(),\n        )));\n    }\n\n    let list = List::new(items).block(\n        Block::default()\n            .borders(Borders::ALL)\n            .border_style(Style::default().fg(Color::DarkGray)),\n    );\n\n    // We don't use ListState for selection since we manually handle the styling\n    frame.render_widget(list, area);\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","ui","preview.rs"],"content":"//! Preview pane rendering.\n\nuse ratatui::{\n    prelude::*,\n    widgets::{Block, Borders, Paragraph, Wrap},\n};\n\nuse crate::tui::app::{App, Mode, Preview};\n\npub fn draw(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    // In input modes, show the input form instead of preview\n    if matches!(app.mode, Mode::OutputPath | Mode::Input { .. }) {\n        draw_input_form(frame, area, app);\n        return;\n    }\n\n    let (title, content, style) = match \u0026app.preview {\n        Preview::None =\u003e (\n            \"Preview\".to_string(),\n            String::from(\"Select an item to preview\"),\n            Style::default().fg(Color::DarkGray),\n        ),\n        Preview::Template { content } =\u003e {\n            (\"Template Preview\".to_string(), content.clone(), Style::default())\n        }\n        Preview::Capture { content } =\u003e {\n            (\"Capture Preview\".to_string(), content.clone(), Style::default())\n        }\n        Preview::Macro { content, requires_trust } =\u003e {\n            let title = if *requires_trust {\n                \"Macro Preview [requires --trust]\".to_string()\n            } else {\n                \"Macro Preview\".to_string()\n            };\n            (title, content.clone(), Style::default())\n        }\n        Preview::Error(e) =\u003e {\n            (\"Error\".to_string(), e.clone(), Style::default().fg(Color::Red))\n        }\n    };\n\n    let paragraph = Paragraph::new(content)\n        .style(style)\n        .block(\n            Block::default()\n                .title(title)\n                .borders(Borders::ALL)\n                .border_style(Style::default().fg(Color::DarkGray)),\n        )\n        .wrap(Wrap { trim: false });\n\n    frame.render_widget(paragraph, area);\n}\n\nfn draw_input_form(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let label = app.current_input_label().unwrap_or_else(|| \"Input\".to_string());\n\n    let title = match \u0026app.mode {\n        Mode::OutputPath =\u003e \"Enter Output Path\".to_string(),\n        Mode::Input { var_index } =\u003e {\n            if app.required_var_infos.len() \u003e 1 {\n                // Show progress\n                format!(\"Variable {} of {}\", var_index + 1, app.required_var_infos.len())\n            } else {\n                \"Enter Variable\".to_string()\n            }\n        }\n        _ =\u003e \"Input\".to_string(),\n    };\n\n    let mut content = vec![\n        Line::from(\"\"),\n        Line::from(vec![Span::styled(\n            format!(\"  {}: \", label),\n            Style::default().fg(Color::Cyan).bold(),\n        )]),\n        Line::from(vec![\n            Span::raw(\"  \"),\n            Span::styled(\u0026app.input_buffer, Style::default().fg(Color::White)),\n            Span::styled(\"_\", Style::default().fg(Color::Gray).rapid_blink()),\n        ]),\n    ];\n\n    // Show description if available\n    if let Some(description) = app.current_input_description() {\n        content.push(Line::from(\"\"));\n        content.push(Line::from(vec![Span::styled(\n            format!(\"  {}\", description),\n            Style::default().fg(Color::DarkGray).italic(),\n        )]));\n    }\n\n    content.push(Line::from(\"\"));\n    content.push(Line::from(vec![Span::styled(\n        \"  [Enter] submit  [Esc] cancel\",\n        Style::default().fg(Color::DarkGray),\n    )]));\n\n    let paragraph = Paragraph::new(content).block(\n        Block::default()\n            .title(title)\n            .borders(Borders::ALL)\n            .border_style(Style::default().fg(Color::Cyan)),\n    );\n\n    frame.render_widget(paragraph, area);\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":60},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","src","tui","ui","status.rs"],"content":"//! Status bar rendering.\n\nuse ratatui::{\n    prelude::*,\n    widgets::{Block, Borders, Paragraph},\n};\n\nuse crate::tui::app::{App, Mode};\n\npub fn draw(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let (left_text, right_text) = match \u0026app.mode {\n        Mode::Browse =\u003e (\" [j/k] navigate  [Enter] execute  [q] quit\", \"Ready\"),\n        Mode::OutputPath | Mode::Input { .. } =\u003e {\n            (\" [Enter] submit  [Esc] cancel\", \"Input Mode\")\n        }\n        Mode::Result =\u003e (\" [Enter] continue\", \"Done\"),\n    };\n\n    // If there's a status message, show it on the right\n    let right_content = if let Some(status) = \u0026app.status {\n        let style = if status.is_error {\n            Style::default().fg(Color::Red)\n        } else {\n            Style::default().fg(Color::Green)\n        };\n        Span::styled(\u0026status.text, style)\n    } else {\n        Span::styled(right_text, Style::default().fg(Color::DarkGray))\n    };\n\n    let left = Span::styled(left_text, Style::default().fg(Color::DarkGray));\n\n    // Calculate padding for right-alignment\n    let left_len = left_text.len();\n    let right_len = if app.status.is_some() {\n        app.status.as_ref().unwrap().text.len()\n    } else {\n        right_text.len()\n    };\n    let padding =\n        area.width.saturating_sub(left_len as u16 + right_len as u16 + 2) as usize;\n\n    let line = Line::from(vec![left, Span::raw(\" \".repeat(padding)), right_content]);\n\n    let paragraph = Paragraph::new(line).block(\n        Block::default()\n            .borders(Borders::TOP)\n            .border_style(Style::default().fg(Color::DarkGray)),\n    );\n\n    frame.render_widget(paragraph, area);\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","capture_frontmatter.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(dir: \u0026std::path::Path, rel: \u0026str, content: impl AsRef\u003cstr\u003e) {\n    let path = dir.join(rel);\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content.as_ref()).unwrap();\n}\n\nfn make_config(vault_root: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{{{{vault_root}}}}/templates\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\"#\n    )\n}\n\n#[test]\nfn capture_sets_frontmatter_field() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that sets a frontmatter field\n    write(\n        root,\n        \"vault/captures/mark-done.yaml\",\n        r#\"\nname: mark-done\ndescription: Mark daily note as completed\n\ntarget:\n  file: \"daily/today.md\"\n\nfrontmatter:\n  completed: true\n  reviewed_at: \"{{datetime}}\"\n\"#,\n    );\n\n    // Target file with existing frontmatter\n    write(\n        root,\n        \"vault/daily/today.md\",\n        r#\"---\ntitle: Today's Note\ncompleted: false\n---\n\n# Today\n\nSome content here.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"capture\").arg(\"mark-done\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv capture\"))\n        .stdout(predicate::str::contains(\"frontmatter: modified\"));\n\n    let content = fs::read_to_string(root.join(\"vault/daily/today.md\")).unwrap();\n    assert!(content.contains(\"completed: true\"), \"completed should be true\");\n    assert!(content.contains(\"reviewed_at:\"), \"reviewed_at should be set\");\n    assert!(content.contains(\"title: Today's Note\"), \"title should be preserved\");\n}\n\n#[test]\nfn capture_toggles_frontmatter_boolean() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that toggles a boolean field\n    write(\n        root,\n        \"vault/captures/toggle-flag.yaml\",\n        r#\"\nname: toggle-flag\ndescription: Toggle a flag\n\ntarget:\n  file: \"notes.md\"\n\nfrontmatter:\n  - field: active\n    op: toggle\n\"#,\n    );\n\n    // Target file with a false flag\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"---\ntitle: Notes\nactive: false\n---\n\n# Notes\n\nContent here.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"capture\").arg(\"toggle-flag\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(root.join(\"vault/notes.md\")).unwrap();\n    assert!(content.contains(\"active: true\"), \"active should be toggled to true\");\n}\n\n#[test]\nfn capture_increments_frontmatter_counter() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that increments a counter\n    write(\n        root,\n        \"vault/captures/increment-views.yaml\",\n        r#\"\nname: increment-views\ndescription: Increment view count\n\ntarget:\n  file: \"article.md\"\n\nfrontmatter:\n  - field: views\n    op: increment\n\"#,\n    );\n\n    // Target file with a counter\n    write(\n        root,\n        \"vault/article.md\",\n        r#\"---\ntitle: Article\nviews: 5\n---\n\n# Article\n\nContent here.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"increment-views\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(root.join(\"vault/article.md\")).unwrap();\n    assert!(content.contains(\"views: 6\"), \"views should be incremented to 6\");\n}\n\n#[test]\nfn capture_appends_to_frontmatter_list() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that appends to a list\n    write(\n        root,\n        \"vault/captures/add-tag.yaml\",\n        r#\"\nname: add-tag\ndescription: Add a tag\n\ntarget:\n  file: \"note.md\"\n\nfrontmatter:\n  - field: tags\n    op: append\n    value: \"{{tag}}\"\n\"#,\n    );\n\n    // Target file with existing tags\n    write(\n        root,\n        \"vault/note.md\",\n        r#\"---\ntitle: Note\ntags:\n  - existing\n---\n\n# Note\n\nContent here.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"add-tag\")\n        .arg(\"--var\")\n        .arg(\"tag=new-tag\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(root.join(\"vault/note.md\")).unwrap();\n    assert!(content.contains(\"- existing\"), \"existing tag should be preserved\");\n    assert!(content.contains(\"- new-tag\"), \"new tag should be appended\");\n}\n\n#[test]\nfn capture_combines_content_and_frontmatter() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that does both content insertion and frontmatter modification\n    write(\n        root,\n        \"vault/captures/add-task.yaml\",\n        r#\"\nname: add-task\ndescription: Add a task and update frontmatter\n\ntarget:\n  file: \"tasks.md\"\n  section: \"TODO\"\n  position: end\n\ncontent: \"- [ ] {{task}}\"\n\nfrontmatter:\n  has_tasks: true\n  last_updated: \"{{date}}\"\n\"#,\n    );\n\n    // Target file\n    write(\n        root,\n        \"vault/tasks.md\",\n        r#\"---\ntitle: Tasks\nhas_tasks: false\n---\n\n# Tasks\n\n## TODO\n\n- [ ] Existing task\n\n## Done\n\n- [x] Completed\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"add-task\")\n        .arg(\"--var\")\n        .arg(\"task=New important task\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"section: TODO\"))\n        .stdout(predicate::str::contains(\"frontmatter: modified\"));\n\n    let content = fs::read_to_string(root.join(\"vault/tasks.md\")).unwrap();\n    // Check frontmatter was modified\n    assert!(content.contains(\"has_tasks: true\"), \"has_tasks should be true\");\n    assert!(content.contains(\"last_updated:\"), \"last_updated should be set\");\n    // Check content was inserted\n    assert!(content.contains(\"- [ ] New important task\"), \"task should be added\");\n    assert!(content.contains(\"- [ ] Existing task\"), \"existing task should be preserved\");\n}\n\n#[test]\nfn capture_creates_frontmatter_if_missing() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Capture that sets frontmatter\n    write(\n        root,\n        \"vault/captures/add-metadata.yaml\",\n        r#\"\nname: add-metadata\ndescription: Add metadata to file\n\ntarget:\n  file: \"plain.md\"\n\nfrontmatter:\n  created: \"{{date}}\"\n  status: draft\n\"#,\n    );\n\n    // Target file without frontmatter\n    write(\n        root,\n        \"vault/plain.md\",\n        r#\"# Plain Document\n\nThis file has no frontmatter.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"capture\").arg(\"add-metadata\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(root.join(\"vault/plain.md\")).unwrap();\n    assert!(content.contains(\"---\"), \"frontmatter should be created\");\n    assert!(content.contains(\"created:\"), \"created field should exist\");\n    assert!(content.contains(\"status: draft\"), \"status should be draft\");\n    assert!(content.contains(\"# Plain Document\"), \"content should be preserved\");\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":18}},{"line":8,"address":[],"length":0,"stats":{"Line":72}},{"line":9,"address":[],"length":0,"stats":{"Line":54}},{"line":10,"address":[],"length":0,"stats":{"Line":36}},{"line":12,"address":[],"length":0,"stats":{"Line":90}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":6}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","capture_simple.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(dir: \u0026std::path::Path, rel: \u0026str, content: impl AsRef\u003cstr\u003e) {\n    let path = dir.join(rel);\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content.as_ref()).unwrap();\n}\n\nfn make_config(vault_root: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{{{{vault_root}}}}/templates\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\"#\n    )\n}\n\n#[test]\nfn capture_inserts_at_section_begin() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ndescription: Add to inbox\n\ntarget:\n  file: \"notes.md\"\n  section: \"Inbox\"\n  position: begin\n\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"# My Notes\n\n## Inbox\n\n- Existing item\n\n## Done\n\n- Completed task\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"inbox\")\n        .arg(\"--var\")\n        .arg(\"text=New captured item\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv capture\"))\n        .stdout(predicate::str::contains(\"capture: inbox\"))\n        .stdout(predicate::str::contains(\"section: Inbox\"));\n\n    let content = fs::read_to_string(root.join(\"vault/notes.md\")).unwrap();\n    assert!(content.contains(\"- New captured item\"));\n    assert!(content.contains(\"- Existing item\"));\n\n    let new_pos = content.find(\"New captured item\").unwrap();\n    let existing_pos = content.find(\"Existing item\").unwrap();\n    assert!(new_pos \u003c existing_pos, \"New item should appear before existing item\");\n}\n\n#[test]\nfn capture_inserts_at_section_end() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/todo.yaml\",\n        r#\"\nname: todo\ndescription: Add to TODO\n\ntarget:\n  file: \"tasks.md\"\n  section: \"TODO\"\n  position: end\n\ncontent: \"- [ ] {{task}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/tasks.md\",\n        r#\"# Tasks\n\n## TODO\n\n- [ ] First task\n\n## Done\n\n- [x] Completed\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"todo\")\n        .arg(\"--var\")\n        .arg(\"task=New task\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(root.join(\"vault/tasks.md\")).unwrap();\n    assert!(content.contains(\"- [ ] New task\"));\n\n    let first_pos = content.find(\"First task\").unwrap();\n    let new_pos = content.find(\"New task\").unwrap();\n    assert!(new_pos \u003e first_pos, \"New task should appear after first task\");\n\n    let done_pos = content.find(\"## Done\").unwrap();\n    assert!(new_pos \u003c done_pos, \"New task should appear before Done section\");\n}\n\n#[test]\nfn capture_fails_on_missing_section() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ntarget:\n  file: \"notes.md\"\n  section: \"NonExistent\"\n  position: begin\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"# Notes\n\n## Existing Section\n\nContent here\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"inbox\")\n        .arg(\"--var\")\n        .arg(\"text=Test\");\n\n    cmd.assert()\n        .failure()\n        .stderr(predicate::str::contains(\"Section not found\"))\n        .stderr(predicate::str::contains(\"Existing Section\"));\n}\n\n#[test]\nfn capture_fails_on_missing_file() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ntarget:\n  file: \"missing.md\"\n  section: \"Inbox\"\n  position: begin\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"inbox\")\n        .arg(\"--var\")\n        .arg(\"text=Test\");\n\n    cmd.assert().failure().stderr(predicate::str::contains(\"Failed to read target file\"));\n}\n\n#[test]\nfn capture_not_found_shows_available() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ntarget:\n  file: \"notes.md\"\n  section: \"Inbox\"\n  position: begin\ncontent: \"test\"\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"capture\").arg(\"nonexistent\");\n\n    cmd.assert()\n        .failure()\n        .stderr(predicate::str::contains(\"Capture not found: nonexistent\"))\n        .stderr(predicate::str::contains(\"inbox\"));\n}\n\n#[test]\nfn capture_list_shows_variables() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ntarget:\n  file: \"notes.md\"\n  section: \"Inbox\"\n  position: begin\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/todo.yaml\",\n        r#\"\nname: todo\ntarget:\n  file: \"tasks.md\"\n  section: \"TODO\"\n  position: end\ncontent: \"- [ ] {{task}} ({{priority}})\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/simple.yaml\",\n        r#\"\nname: simple\ntarget:\n  file: \"log.md\"\n  section: \"Log\"\n  position: end\ncontent: \"Entry at {{date}}\"\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"capture\").arg(\"--list\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"inbox  [text]\"))\n        .stdout(predicate::str::contains(\"todo  [priority, task]\"))\n        .stdout(predicate::str::contains(\"simple\\n\")) // no variables\n        .stdout(predicate::str::contains(\"-- 3 captures --\"));\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":17}},{"line":8,"address":[],"length":0,"stats":{"Line":68}},{"line":9,"address":[],"length":0,"stats":{"Line":51}},{"line":10,"address":[],"length":0,"stats":{"Line":34}},{"line":12,"address":[],"length":0,"stats":{"Line":85}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":6}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","date_math.rs"],"content":"//! Integration tests for date math expressions in templates.\n\nuse assert_cmd::prelude::*;\nuse std::fs;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(dir: \u0026std::path::Path, rel: \u0026str, content: impl AsRef\u003cstr\u003e) {\n    let path = dir.join(rel);\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content.as_ref()).unwrap();\n}\n\nfn make_config(vault_root: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{{{{vault_root}}}}/templates\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\"#\n    )\n}\n\n#[test]\nfn template_with_date_math_today() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/dated.md\",\n        r#\"# Note for {{today}}\n\nTomorrow: {{today + 1d}}\nYesterday: {{today - 1d}}\nNext week: {{today + 1w}}\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let output = vault.join(\"output.md\");\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"dated\")\n        .arg(\"--output\")\n        .arg(\u0026output);\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(\u0026output).unwrap();\n\n    // Check that date math expressions are replaced with actual dates\n    // (we can't check exact values since they depend on current date)\n    assert!(!content.contains(\"{{today}}\"), \"today should be replaced\");\n    assert!(!content.contains(\"{{today + 1d}}\"), \"today + 1d should be replaced\");\n    assert!(!content.contains(\"{{today - 1d}}\"), \"today - 1d should be replaced\");\n    assert!(!content.contains(\"{{today + 1w}}\"), \"today + 1w should be replaced\");\n\n    // Check format is YYYY-MM-DD\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    assert!(lines[0].starts_with(\"# Note for 20\"), \"Date should be in YYYY format\");\n}\n\n#[test]\nfn template_with_date_format() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/formatted.md\",\n        r#\"Day name: {{today | %A}}\nMonth: {{today | %B}}\nYear: {{today | %Y}}\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let output = vault.join(\"output.md\");\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"formatted\")\n        .arg(\"--output\")\n        .arg(\u0026output);\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(\u0026output).unwrap();\n\n    // Format expressions should be replaced\n    assert!(!content.contains(\"{{today | %A}}\"), \"format should be replaced\");\n    assert!(!content.contains(\"{{today | %B}}\"), \"format should be replaced\");\n\n    // Should contain day/month names (not numeric)\n    assert!(content.contains(\"Day name: \"));\n    assert!(content.contains(\"Month: \"));\n    assert!(content.contains(\"Year: 20\"));\n}\n\n#[test]\nfn capture_with_date_math() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"# Notes\n\n## Log\n\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/log.yaml\",\n        r#\"\nname: log\ntarget:\n  file: \"notes.md\"\n  section: Log\n  position: begin\ncontent: \"- [{{today}}] {{text}} (due: {{today + 7d}})\"\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"log\")\n        .arg(\"--var\")\n        .arg(\"text=Test entry\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(vault.join(\"notes.md\")).unwrap();\n\n    // Date expressions should be replaced\n    assert!(!content.contains(\"{{today}}\"), \"today should be replaced\");\n    assert!(!content.contains(\"{{today + 7d}}\"), \"date math should be replaced\");\n    assert!(content.contains(\"Test entry\"));\n    assert!(content.contains(\"due:\"));\n}\n\n#[test]\nfn template_with_weekday_math() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/weekly.md\",\n        r#\"# Weekly Planning\n\nNext Monday: {{today + monday}}\nLast Friday: {{today - friday}}\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let output = vault.join(\"output.md\");\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"weekly\")\n        .arg(\"--output\")\n        .arg(\u0026output);\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(\u0026output).unwrap();\n\n    // Weekday expressions should be replaced\n    assert!(!content.contains(\"{{today + monday}}\"), \"weekday should be replaced\");\n    assert!(!content.contains(\"{{today - friday}}\"), \"weekday should be replaced\");\n}\n\n#[test]\nfn template_output_path_with_date_math() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Template with date math in output path\n    write(\n        root,\n        \"vault/templates/daily.md\",\n        r#\"---\noutput: \"daily/{{today}}.md\"\n---\n# Daily Note\n\nDate: {{today}}\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"daily\");\n\n    cmd.assert().success();\n\n    // Find the created file in daily/ directory\n    let daily_dir = vault.join(\"daily\");\n    assert!(daily_dir.exists(), \"daily directory should be created\");\n\n    let entries: Vec\u003c_\u003e = fs::read_dir(\u0026daily_dir).unwrap().collect();\n    assert_eq!(entries.len(), 1, \"Should have one daily note\");\n\n    let file_path = entries[0].as_ref().unwrap().path();\n    let filename = file_path.file_name().unwrap().to_string_lossy();\n    assert!(filename.ends_with(\".md\"));\n    assert!(filename.starts_with(\"20\"), \"Filename should start with year\");\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":11}},{"line":9,"address":[],"length":0,"stats":{"Line":44}},{"line":10,"address":[],"length":0,"stats":{"Line":33}},{"line":11,"address":[],"length":0,"stats":{"Line":22}},{"line":13,"address":[],"length":0,"stats":{"Line":55}},{"line":16,"address":[],"length":0,"stats":{"Line":5}},{"line":17,"address":[],"length":0,"stats":{"Line":5}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","doctor_fail.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n#[test]\nfn doctor_fails_when_config_missing() {\n    let tmp = tempdir().unwrap();\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.env(\"XDG_CONFIG_HOME\", tmp.path()); // empty dir  no config\n    cmd.arg(\"doctor\");\n    cmd.assert()\n        .failure()\n        .stdout(predicate::str::contains(\"FAIL mdv doctor\"))\n        .stdout(predicate::str::contains(\"looked for:\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","doctor_ok.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn doctor_reads_provided_config_path() {\n    let tmp = tempdir().unwrap();\n    let cfg = tmp.path().join(\"config.toml\");\n    let toml = r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"/tmp/v\"\ntemplates_dir = \"{{vault_root}}/.mdvault/templates\"\ncaptures_dir  = \"{{vault_root}}/.mdvault/captures\"\nmacros_dir    = \"{{vault_root}}/.mdvault/macros\"\n\n[security]\nallow_shell = false\nallow_http  = false\n\"#;\n    write_file(\u0026cfg, toml);\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.args([\"doctor\", \"--config\", cfg.to_str().unwrap()]);\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv doctor\"))\n        .stdout(predicate::str::contains(\"profile: default\"))\n        .stdout(predicate::str::contains(\"vault_root: /tmp/v\"));\n}\n\n#[test]\nfn doctor_uses_xdg_default_when_present() {\n    let tmp = tempdir().unwrap();\n    let cfg_dir = tmp.path().join(\"mdvault\");\n    let cfg_path = cfg_dir.join(\"config.toml\");\n    fs::create_dir_all(\u0026cfg_dir).unwrap();\n    write_file(\n        \u0026cfg_path,\n        r#\"\nversion = 1\nprofile = \"default\"\n[profiles.default]\nvault_root = \"/tmp/v\"\ntemplates_dir = \"{{vault_root}}/t\"\ncaptures_dir  = \"{{vault_root}}/c\"\nmacros_dir    = \"{{vault_root}}/m\"\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.env(\"XDG_CONFIG_HOME\", tmp.path());\n    cmd.arg(\"doctor\");\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv doctor\"))\n        .stdout(predicate::str::contains(\"vault_root: /tmp/v\"));\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":2}},{"line":9,"address":[],"length":0,"stats":{"Line":6}},{"line":10,"address":[],"length":0,"stats":{"Line":4}},{"line":12,"address":[],"length":0,"stats":{"Line":8}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","doctor_snapshot.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse regex::Regex;\nuse std::fs;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\nfn normalize_paths(s: \u0026str) -\u003e String {\n    let re = Regex::new(r#\"(?m)^path: .*$\"#).unwrap();\n    re.replace(s, \"path: \u003cCFG\u003e\").to_string()\n}\n\n#[test]\nfn doctor_snapshot_default_profile() {\n    let tmp = tempdir().unwrap();\n    let cfg = tmp.path().join(\"config.toml\");\n\n    let toml = r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"/tmp/v\"\ntemplates_dir = \"{{vault_root}}/.mdvault/templates\"\ncaptures_dir  = \"{{vault_root}}/.mdvault/captures\"\nmacros_dir    = \"{{vault_root}}/.mdvault/macros\"\n\n[security]\nallow_shell = false\nallow_http  = false\n\"#;\n    write_file(\u0026cfg, toml);\n\n    let assert = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"))\n        .args([\"doctor\", \"--config\", cfg.to_str().unwrap()])\n        .assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv doctor\"));\n\n    let out = String::from_utf8(assert.get_output().stdout.clone()).unwrap();\n    let norm = normalize_paths(\u0026out);\n\n    insta::assert_snapshot!(\"doctor_default_profile\", norm);\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":1}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":11,"address":[],"length":0,"stats":{"Line":2}},{"line":13,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":4}},{"line":18,"address":[],"length":0,"stats":{"Line":3}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","list_templates_ok.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*; // needed for `.not()`\nuse std::fs;\nuse std::path::PathBuf;\nuse tempfile::tempdir;\n\nfn write(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn list_templates_reports_markdown_files_only() {\n    let tmp = tempdir().unwrap();\n\n    // XDG-style config location\n    let xdg = tmp.path().join(\"xdg\");\n    let cfg_dir = xdg.join(\"mdvault\");\n    let cfg_path = cfg_dir.join(\"config.toml\");\n    fs::create_dir_all(\u0026cfg_dir).unwrap();\n\n    // Templates tree\n    let tpl_root = tmp.path().join(\"vault\").join(\".mdvault\").join(\"templates\");\n    let a = tpl_root.join(\"daily.md\");\n    let b = tpl_root.join(\"blog\").join(\"post.md\");\n    let ignored = tpl_root.join(\"ignore.tpl.md\"); // should be ignored under MD-only rule\n\n    write(\u0026a, \"# daily\");\n    write(\u0026b, \"# blog\");\n    write(\u0026ignored, \"nope\");\n\n    // Config pointing to our temporary vault/templates\n    let toml = format!(\n        r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"{vault}\"\ntemplates_dir = \"{tpl}\"\ncaptures_dir  = \"{{{{vault_root}}}}/.mdvault/captures\"\nmacros_dir    = \"{{{{vault_root}}}}/.mdvault/macros\"\n\"#,\n        vault = tmp.path().join(\"vault\").display(),\n        tpl = tpl_root.display(),\n    );\n    fs::write(\u0026cfg_path, toml).unwrap();\n\n    // With clap: global flags can be before the subcommand\n    let mut cmd = std::process::Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.env(\"XDG_CONFIG_HOME\", \u0026xdg);\n    cmd.env(\"NO_COLOR\", \"1\"); // keep output deterministic\n    cmd.args([\n        \"--config\",\n        cfg_path.to_str().unwrap(),\n        \"--profile\",\n        \"default\",\n        \"list-templates\",\n    ]);\n\n    cmd.assert()\n        .success()\n        .stdout(predicates::str::contains(\"daily\"))\n        .stdout(predicates::str::contains(\"blog/post\"))\n        .stdout(predicates::str::contains(\"-- 2 templates --\"))\n        // `not_contains` doesn't exist; use `contains(...).not()` from PredicateBooleanExt\n        .stdout(predicates::str::contains(\"ignore\").not());\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":3}},{"line":8,"address":[],"length":0,"stats":{"Line":9}},{"line":9,"address":[],"length":0,"stats":{"Line":6}},{"line":11,"address":[],"length":0,"stats":{"Line":12}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","macro_simple.rs"],"content":"//! Integration tests for macro command.\n\nuse assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(dir: \u0026std::path::Path, rel: \u0026str, content: impl AsRef\u003cstr\u003e) {\n    let path = dir.join(rel);\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content.as_ref()).unwrap();\n}\n\nfn make_config(vault_root: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{{{{vault_root}}}}/templates\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\n[security]\nallow_shell = false\n\"#\n    )\n}\n\n#[test]\nfn macro_list_shows_available_macros() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/macros/weekly-review.yaml\",\n        r#\"\nname: weekly-review\ndescription: Set up weekly review documents\nsteps:\n  - template: summary\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/daily-setup.yaml\",\n        r#\"\nname: daily-setup\ndescription: Create daily note\nsteps:\n  - template: daily\n  - capture: inbox-clear\n\"#,\n    );\n\n    // Create templates/captures directories\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"macro\").arg(\"--list\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"weekly-review\"))\n        .stdout(predicate::str::contains(\"Set up weekly review\"))\n        .stdout(predicate::str::contains(\"daily-setup\"))\n        .stdout(predicate::str::contains(\"2 steps\"))\n        .stdout(predicate::str::contains(\"-- 2 macros --\"));\n}\n\n#[test]\nfn macro_not_found_shows_available() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/macros/existing.yaml\",\n        r#\"\nname: existing\nsteps:\n  - template: test\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"macro\").arg(\"nonexistent\");\n\n    cmd.assert()\n        .failure()\n        .stderr(predicate::str::contains(\"Macro not found: nonexistent\"))\n        .stderr(predicate::str::contains(\"existing\"));\n}\n\n#[test]\nfn macro_with_shell_requires_trust() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/macros/deploy.yaml\",\n        r#\"\nname: deploy\ndescription: Deploy with git\nsteps:\n  - shell: \"git add .\"\n    description: Stage changes\n  - shell: \"git commit -m 'deploy'\"\n    description: Commit\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    // Without --trust, should fail\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"macro\").arg(\"deploy\");\n\n    cmd.assert()\n        .failure()\n        .stderr(predicate::str::contains(\"--trust\"))\n        .stderr(predicate::str::contains(\"git add\"));\n}\n\n#[test]\nfn macro_list_shows_trust_required() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/macros/safe.yaml\",\n        r#\"\nname: safe\nsteps:\n  - template: note\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/dangerous.yaml\",\n        r#\"\nname: dangerous\nsteps:\n  - template: note\n  - shell: \"echo hello\"\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(root.join(\"config.toml\")).arg(\"macro\").arg(\"--list\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"safe  (1 steps)\"))\n        .stdout(predicate::str::contains(\"dangerous  (2 steps) [requires --trust]\"));\n}\n\n#[test]\nfn macro_runs_template_step() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/note.md\",\n        r#\"---\noutput: \"notes/{{title}}.md\"\n---\n# {{title}}\n\nCreated on {{date}}\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/create-note.yaml\",\n        r#\"\nname: create-note\ndescription: Create a note\nvars:\n  title: \"Note title\"\nsteps:\n  - template: note\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"macro\")\n        .arg(\"create-note\")\n        .arg(\"--var\")\n        .arg(\"title=My Test Note\")\n        .arg(\"--batch\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv macro\"))\n        .stdout(predicate::str::contains(\"1 completed\"));\n\n    // Verify file was created\n    let output_file = vault.join(\"notes/My Test Note.md\");\n    assert!(output_file.exists(), \"Output file should be created\");\n\n    let content = fs::read_to_string(\u0026output_file).unwrap();\n    assert!(content.contains(\"# My Test Note\"));\n}\n\n#[test]\nfn macro_runs_capture_step() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/inbox.md\",\n        r#\"# Inbox\n\n## Items\n\n- Existing item\n\n## Archive\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/add-item.yaml\",\n        r#\"\nname: add-item\ntarget:\n  file: \"inbox.md\"\n  section: Items\n  position: end\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/quick-add.yaml\",\n        r#\"\nname: quick-add\ndescription: Add item to inbox\nvars:\n  text: \"Item text\"\nsteps:\n  - capture: add-item\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"macro\")\n        .arg(\"quick-add\")\n        .arg(\"--var\")\n        .arg(\"text=New macro item\")\n        .arg(\"--batch\");\n\n    cmd.assert().success().stdout(predicate::str::contains(\"OK   mdv macro\"));\n\n    let content = fs::read_to_string(vault.join(\"inbox.md\")).unwrap();\n    assert!(content.contains(\"- New macro item\"));\n    assert!(content.contains(\"- Existing item\"));\n}\n\n#[test]\nfn macro_runs_multiple_steps() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/meeting.md\",\n        r#\"---\noutput: \"meetings/{{topic}}.md\"\n---\n# Meeting: {{topic}}\n\n## Attendees\n\n## Notes\n\n## Actions\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/log.md\",\n        r#\"# Meeting Log\n\n## Recent\n\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/log-meeting.yaml\",\n        r#\"\nname: log-meeting\ntarget:\n  file: \"log.md\"\n  section: Recent\n  position: begin\ncontent: \"- [[meetings/{{topic}}]] - {{date}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/new-meeting.yaml\",\n        r#\"\nname: new-meeting\ndescription: Create meeting note and log it\nvars:\n  topic: \"Meeting topic\"\nsteps:\n  - template: meeting\n  - capture: log-meeting\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"macro\")\n        .arg(\"new-meeting\")\n        .arg(\"--var\")\n        .arg(\"topic=Weekly Sync\")\n        .arg(\"--batch\");\n\n    cmd.assert().success().stdout(predicate::str::contains(\"2 completed\"));\n\n    // Check meeting file was created\n    let meeting_file = vault.join(\"meetings/Weekly Sync.md\");\n    assert!(meeting_file.exists());\n    let meeting_content = fs::read_to_string(\u0026meeting_file).unwrap();\n    assert!(meeting_content.contains(\"# Meeting: Weekly Sync\"));\n\n    // Check log was updated\n    let log_content = fs::read_to_string(vault.join(\"log.md\")).unwrap();\n    assert!(log_content.contains(\"[[meetings/Weekly Sync]]\"));\n}\n\n#[test]\nfn macro_with_step_vars_override() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/note.md\",\n        r#\"---\noutput: \"notes/{{filename}}.md\"\n---\n# {{title}}\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/fixed-output.yaml\",\n        r#\"\nname: fixed-output\ndescription: Create note with fixed filename\nvars:\n  title: \"Note title\"\nsteps:\n  - template: note\n    with:\n      filename: \"fixed-name\"\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"macro\")\n        .arg(\"fixed-output\")\n        .arg(\"--var\")\n        .arg(\"title=Dynamic Title\")\n        .arg(\"--batch\");\n\n    cmd.assert().success();\n\n    // Should use fixed filename from step vars\n    let output_file = vault.join(\"notes/fixed-name.md\");\n    assert!(output_file.exists());\n\n    let content = fs::read_to_string(\u0026output_file).unwrap();\n    assert!(content.contains(\"# Dynamic Title\"));\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":25}},{"line":10,"address":[],"length":0,"stats":{"Line":100}},{"line":11,"address":[],"length":0,"stats":{"Line":75}},{"line":12,"address":[],"length":0,"stats":{"Line":50}},{"line":14,"address":[],"length":0,"stats":{"Line":125}},{"line":17,"address":[],"length":0,"stats":{"Line":8}},{"line":18,"address":[],"length":0,"stats":{"Line":8}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","new_simple.rs"],"content":"use assert_cmd::prelude::*;\nuse std::fs;\nuse std::path::PathBuf;\nuse tempfile::tempdir;\n\nfn write(path: \u0026PathBuf, contents: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, contents).unwrap();\n}\n\n#[test]\nfn new_renders_template_to_output_file() {\n    let tmp = tempdir().unwrap();\n\n    // XDG config\n    let xdg = tmp.path().join(\"xdg\");\n    let cfg_dir = xdg.join(\"mdvault\");\n    let cfg_path = cfg_dir.join(\"config.toml\");\n    fs::create_dir_all(\u0026cfg_dir).unwrap();\n\n    // Vault and templates\n    let vault = tmp.path().join(\"vault\");\n    let tpl_root = vault.join(\".mdvault\").join(\"templates\");\n    let tpl_daily = tpl_root.join(\"daily.md\");\n\n    write(\n        \u0026tpl_daily,\n        \"Title: {{template_name}}\\nVault: {{vault_root}}\\nFile: {{output_filename}}\\n\",\n    );\n\n    let toml = format!(\n        r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"{vault}\"\ntemplates_dir = \"{tpl}\"\ncaptures_dir  = \"{{{{vault_root}}}}/.mdvault/captures\"\nmacros_dir    = \"{{{{vault_root}}}}/.mdvault/macros\"\n\"#,\n        vault = vault.display(),\n        tpl = tpl_root.display(),\n    );\n    fs::write(\u0026cfg_path, toml).unwrap();\n\n    let output = vault.join(\"rendered.md\");\n\n    let mut cmd = std::process::Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.env(\"XDG_CONFIG_HOME\", \u0026xdg);\n    cmd.env(\"NO_COLOR\", \"1\");\n    cmd.args([\n        \"--config\",\n        cfg_path.to_str().unwrap(),\n        \"--profile\",\n        \"default\",\n        \"new\",\n        \"--template\",\n        \"daily\",\n        \"--output\",\n        output.to_str().unwrap(),\n    ]);\n\n    cmd.assert()\n        .success()\n        .stdout(predicates::str::contains(\"OK   mdv new\"))\n        .stdout(predicates::str::contains(\"template: daily\"));\n\n    let rendered = fs::read_to_string(\u0026output).unwrap();\n\n    assert!(rendered.contains(\"Title: daily\"));\n    assert!(rendered.contains(\"Vault:\"));\n    assert!(rendered.contains(\"File: rendered.md\"));\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":1}},{"line":7,"address":[],"length":0,"stats":{"Line":3}},{"line":8,"address":[],"length":0,"stats":{"Line":2}},{"line":10,"address":[],"length":0,"stats":{"Line":4}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","template_frontmatter.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(path: \u0026PathBuf, contents: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, contents).unwrap();\n}\n\nfn make_config(vault_root: \u0026str, templates_dir: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{templates_dir}\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\"#\n    )\n}\n\n#[test]\nfn template_with_frontmatter_output_creates_file_without_output_flag() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n\n    let vault = root.join(\"vault\");\n    let templates = vault.join(\"templates\");\n    let config_path = root.join(\"config.toml\");\n\n    write(\n        \u0026config_path,\n        \u0026make_config(\u0026vault.to_string_lossy(), \u0026templates.to_string_lossy()),\n    );\n\n    // Template with frontmatter output path\n    write(\n        \u0026templates.join(\"daily.md\"),\n        r#\"---\noutput: daily/{{date}}.md\n---\n# Daily Note for {{date}}\n\n## Inbox\n\n## Tasks\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(\u0026config_path).arg(\"new\").arg(\"--template\").arg(\"daily\");\n    // Note: no --output flag\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"OK   mdv new\"))\n        .stdout(predicate::str::contains(\"template: daily\"))\n        .stdout(predicate::str::contains(\"daily/\"));\n\n    // Verify the file was created in the expected location\n    let daily_dir = vault.join(\"daily\");\n    assert!(daily_dir.exists(), \"daily directory should be created\");\n\n    let files: Vec\u003c_\u003e = fs::read_dir(\u0026daily_dir).unwrap().collect();\n    assert_eq!(files.len(), 1, \"should have one file\");\n\n    let file_path = files[0].as_ref().unwrap().path();\n    let content = fs::read_to_string(\u0026file_path).unwrap();\n    assert!(content.contains(\"# Daily Note for\"));\n    assert!(content.contains(\"## Inbox\"));\n    assert!(content.contains(\"## Tasks\"));\n    // Frontmatter should be stripped\n    assert!(!content.contains(\"output:\"));\n}\n\n#[test]\nfn template_without_frontmatter_requires_output_flag() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n\n    let vault = root.join(\"vault\");\n    let templates = vault.join(\"templates\");\n    let config_path = root.join(\"config.toml\");\n\n    write(\n        \u0026config_path,\n        \u0026make_config(\u0026vault.to_string_lossy(), \u0026templates.to_string_lossy()),\n    );\n\n    // Template without frontmatter output path\n    write(\n        \u0026templates.join(\"simple.md\"),\n        r#\"# Simple Note\n\nContent here.\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(\u0026config_path).arg(\"new\").arg(\"--template\").arg(\"simple\");\n    // Note: no --output flag\n\n    cmd.assert().failure().stderr(predicate::str::contains(\"--output is required\"));\n}\n\n#[test]\nfn template_extra_frontmatter_is_rendered_in_output() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n\n    let vault = root.join(\"vault\");\n    let templates = vault.join(\"templates\");\n    let config_path = root.join(\"config.toml\");\n\n    write(\n        \u0026config_path,\n        \u0026make_config(\u0026vault.to_string_lossy(), \u0026templates.to_string_lossy()),\n    );\n\n    // Template with output path AND extra frontmatter fields\n    write(\n        \u0026templates.join(\"daily.md\"),\n        r#\"---\noutput: daily/{{date}}.md\ncreated: \"{{date}}\"\ntags:\n  - daily\n  - journal\n---\n# Daily Note for {{date}}\n\n## Inbox\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\").arg(\u0026config_path).arg(\"new\").arg(\"--template\").arg(\"daily\");\n\n    cmd.assert().success();\n\n    // Read the created file\n    let daily_dir = vault.join(\"daily\");\n    let files: Vec\u003c_\u003e = fs::read_dir(\u0026daily_dir).unwrap().collect();\n    let file_path = files[0].as_ref().unwrap().path();\n    let content = fs::read_to_string(\u0026file_path).unwrap();\n\n    // Extra frontmatter fields should be in output\n    assert!(content.contains(\"---\"), \"should have frontmatter delimiters\");\n    assert!(content.contains(\"created:\"), \"should have created field\");\n    assert!(content.contains(\"tags:\"), \"should have tags field\");\n    assert!(content.contains(\"- daily\"), \"should have daily tag\");\n    assert!(content.contains(\"- journal\"), \"should have journal tag\");\n\n    // The created field should have the date substituted (not {{date}})\n    assert!(!content.contains(\"{{date}}\"), \"date placeholder should be substituted\");\n\n    // The output field should NOT be in the rendered output\n    assert!(\n        !content.contains(\"output:\"),\n        \"output field should not be in rendered output\"\n    );\n}\n\n#[test]\nfn template_with_user_vars_in_frontmatter() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n\n    let vault = root.join(\"vault\");\n    let templates = vault.join(\"templates\");\n    let config_path = root.join(\"config.toml\");\n\n    write(\n        \u0026config_path,\n        \u0026make_config(\u0026vault.to_string_lossy(), \u0026templates.to_string_lossy()),\n    );\n\n    // Template with user-defined variable in frontmatter\n    write(\n        \u0026templates.join(\"meeting.md\"),\n        r#\"---\noutput: meetings/{{date}}.md\ntitle: \"{{meeting_title}}\"\nattendees: \"{{attendees}}\"\nvars:\n  meeting_title: \"Meeting title\"\n  attendees: \"Attendees\"\n---\n# {{meeting_title}}\n\nAttendees: {{attendees}}\n\"#,\n    );\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(\u0026config_path)\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"meeting\")\n        .arg(\"--var\")\n        .arg(\"meeting_title=Quarterly Review\")\n        .arg(\"--var\")\n        .arg(\"attendees=Alice, Bob\");\n\n    cmd.assert().success();\n\n    // Read the created file\n    let meetings_dir = vault.join(\"meetings\");\n    let files: Vec\u003c_\u003e = fs::read_dir(\u0026meetings_dir).unwrap().collect();\n    let file_path = files[0].as_ref().unwrap().path();\n    let content = fs::read_to_string(\u0026file_path).unwrap();\n\n    // User variables should be substituted in frontmatter\n    assert!(\n        content.contains(\"title: Quarterly Review\"),\n        \"title should have user value, got: {}\",\n        content\n    );\n    assert!(\n        content.contains(\"attendees: Alice, Bob\"),\n        \"attendees should have user value\"\n    );\n\n    // User variables should also be substituted in body\n    assert!(\n        content.contains(\"# Quarterly Review\"),\n        \"title in body should be substituted\"\n    );\n    assert!(\n        content.contains(\"Attendees: Alice, Bob\"),\n        \"attendees in body should be substituted\"\n    );\n\n    // The vars field should NOT be in the output (it's metadata)\n    assert!(!content.contains(\"vars:\"), \"vars metadata should not be in output\");\n}\n\n#[test]\nfn output_flag_overrides_frontmatter_output() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n\n    let vault = root.join(\"vault\");\n    let templates = vault.join(\"templates\");\n    let config_path = root.join(\"config.toml\");\n\n    write(\n        \u0026config_path,\n        \u0026make_config(\u0026vault.to_string_lossy(), \u0026templates.to_string_lossy()),\n    );\n\n    // Template with frontmatter output path\n    write(\n        \u0026templates.join(\"daily.md\"),\n        r#\"---\noutput: daily/{{date}}.md\n---\n# Daily Note\n\nContent\n\"#,\n    );\n\n    let custom_output = vault.join(\"custom\").join(\"my-note.md\");\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(\u0026config_path)\n        .arg(\"new\")\n        .arg(\"--template\")\n        .arg(\"daily\")\n        .arg(\"--output\")\n        .arg(\u0026custom_output);\n\n    cmd.assert().success().stdout(predicate::str::contains(\"my-note.md\"));\n\n    assert!(custom_output.exists(), \"custom output should be created\");\n\n    // The frontmatter output path should not be used\n    assert!(\n        !vault.join(\"daily\").exists(),\n        \"frontmatter output dir should not be created\"\n    );\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":10}},{"line":9,"address":[],"length":0,"stats":{"Line":30}},{"line":10,"address":[],"length":0,"stats":{"Line":20}},{"line":12,"address":[],"length":0,"stats":{"Line":40}},{"line":15,"address":[],"length":0,"stats":{"Line":5}},{"line":16,"address":[],"length":0,"stats":{"Line":5}}],"covered":6,"coverable":6},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","cli","tests","variable_metadata.rs"],"content":"//! Integration tests for variable metadata (prompts, defaults, descriptions).\n//!\n//! Note: Template `vars:` DSL was removed in v0.2.0 in favor of Lua-based schemas.\n//! Templates now use `lua:` frontmatter to reference Lua scripts that define schemas.\n//! These tests cover captures and macros which still support `vars:`.\n\nuse assert_cmd::prelude::*;\nuse std::fs;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write(dir: \u0026std::path::Path, rel: \u0026str, content: impl AsRef\u003cstr\u003e) {\n    let path = dir.join(rel);\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content.as_ref()).unwrap();\n}\n\nfn make_config(vault_root: \u0026str) -\u003e String {\n    format!(\n        r#\"\nversion = 1\nprofile = \"test\"\n\n[profiles.test]\nvault_root = \"{vault_root}\"\ntemplates_dir = \"{{{{vault_root}}}}/templates\"\ncaptures_dir = \"{{{{vault_root}}}}/captures\"\nmacros_dir = \"{{{{vault_root}}}}/macros\"\n\"#\n    )\n}\n\n#[test]\nfn capture_with_vars_metadata_uses_default() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"# Notes\n\n## Inbox\n\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/captures/inbox.yaml\",\n        r#\"\nname: inbox\ndescription: Add to inbox with priority\n\nvars:\n  text:\n    prompt: \"What to add?\"\n    required: true\n  priority:\n    prompt: \"Priority level\"\n    default: \"normal\"\n    description: \"Can be low, normal, or high\"\n\ntarget:\n  file: \"notes.md\"\n  section: Inbox\n  position: end\n\ncontent: \"- [{{priority}}] {{text}}\"\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"inbox\")\n        .arg(\"--var\")\n        .arg(\"text=Review PR\")\n        .arg(\"--batch\"); // Uses default priority\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(vault.join(\"notes.md\")).unwrap();\n    assert!(content.contains(\"- [normal] Review PR\"));\n}\n\n#[test]\nfn macro_with_vars_metadata() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    write(\n        root,\n        \"vault/templates/project.md\",\n        r#\"---\noutput: \"projects/{{name}}.md\"\n---\n# Project: {{name}}\n\nStatus: {{status}}\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/macros/new-project.yaml\",\n        r#\"\nname: new-project\ndescription: Create a new project\nvars:\n  name:\n    prompt: \"Project name\"\n    required: true\n  status:\n    prompt: \"Initial status\"\n    default: \"planning\"\n    description: \"planning, active, or completed\"\nsteps:\n  - template: project\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"captures\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"macro\")\n        .arg(\"new-project\")\n        .arg(\"--var\")\n        .arg(\"name=Website Redesign\")\n        .arg(\"--batch\"); // Uses default status\n\n    cmd.assert().success();\n\n    let output_file = vault.join(\"projects/Website Redesign.md\");\n    assert!(output_file.exists());\n\n    let content = fs::read_to_string(\u0026output_file).unwrap();\n    assert!(content.contains(\"# Project: Website Redesign\"));\n    assert!(content.contains(\"Status: planning\"));\n}\n\n#[test]\nfn simple_var_spec_as_prompt() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path();\n    let vault = root.join(\"vault\");\n\n    write(root, \"config.toml\", make_config(\u0026vault.to_string_lossy()));\n\n    // Simple form: just the prompt string\n    write(\n        root,\n        \"vault/captures/quick.yaml\",\n        r#\"\nname: quick\nvars:\n  text: \"Quick note text\"\ntarget:\n  file: \"notes.md\"\n  section: Quick\n  position: end\ncontent: \"- {{text}}\"\n\"#,\n    );\n\n    write(\n        root,\n        \"vault/notes.md\",\n        r#\"# Notes\n\n## Quick\n\n\"#,\n    );\n\n    fs::create_dir_all(vault.join(\"templates\")).unwrap();\n    fs::create_dir_all(vault.join(\"macros\")).unwrap();\n\n    let mut cmd = Command::new(assert_cmd::cargo::cargo_bin!(\"mdv\"));\n    cmd.arg(\"--config\")\n        .arg(root.join(\"config.toml\"))\n        .arg(\"capture\")\n        .arg(\"quick\")\n        .arg(\"--var\")\n        .arg(\"text=Simple note\");\n\n    cmd.assert().success();\n\n    let content = fs::read_to_string(vault.join(\"notes.md\")).unwrap();\n    assert!(content.contains(\"- Simple note\"));\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":9}},{"line":13,"address":[],"length":0,"stats":{"Line":36}},{"line":14,"address":[],"length":0,"stats":{"Line":27}},{"line":15,"address":[],"length":0,"stats":{"Line":18}},{"line":17,"address":[],"length":0,"stats":{"Line":45}},{"line":20,"address":[],"length":0,"stats":{"Line":3}},{"line":21,"address":[],"length":0,"stats":{"Line":3}}],"covered":7,"coverable":7},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","captures","discovery.rs"],"content":"use std::path::Path;\nuse walkdir::WalkDir;\n\nuse super::types::{CaptureDiscoveryError, CaptureInfo};\n\n/// Discover all capture YAML files in the given directory\npub fn discover_captures(root: \u0026Path) -\u003e Result\u003cVec\u003cCaptureInfo\u003e, CaptureDiscoveryError\u003e {\n    let root = root\n        .canonicalize()\n        .map_err(|_| CaptureDiscoveryError::MissingDir(root.display().to_string()))?;\n\n    if !root.exists() {\n        return Err(CaptureDiscoveryError::MissingDir(root.display().to_string()));\n    }\n\n    let mut out = Vec::new();\n\n    for entry in WalkDir::new(\u0026root) {\n        let entry = entry.map_err(|e| {\n            CaptureDiscoveryError::WalkError(root.display().to_string(), e)\n        })?;\n\n        let path = entry.path();\n        if !path.is_file() {\n            continue;\n        }\n        if !is_yaml_file(path) {\n            continue;\n        }\n\n        let rel = path.strip_prefix(\u0026root).unwrap_or(path);\n        let logical = logical_name_from_relative(rel);\n\n        out.push(CaptureInfo { logical_name: logical, path: path.to_path_buf() });\n    }\n\n    out.sort_by(|a, b| a.logical_name.cmp(\u0026b.logical_name));\n    Ok(out)\n}\n\nfn is_yaml_file(path: \u0026Path) -\u003e bool {\n    let name = path.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    name.ends_with(\".yaml\") || name.ends_with(\".yml\")\n}\n\nfn logical_name_from_relative(rel: \u0026Path) -\u003e String {\n    let s = rel.to_string_lossy();\n    // Remove .yaml or .yml extension\n    if let Some(stripped) = s.strip_suffix(\".yaml\") {\n        return stripped.to_string();\n    }\n    if let Some(stripped) = s.strip_suffix(\".yml\") {\n        return stripped.to_string();\n    }\n    s.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs::File;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_discover_captures_simple() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        // Create some files\n        File::create(root.join(\"todo.yaml\")).unwrap();\n        File::create(root.join(\"ideas.yml\")).unwrap();\n        File::create(root.join(\"ignored.txt\")).unwrap();\n        File::create(root.join(\"README.md\")).unwrap();\n\n        let captures = discover_captures(root).unwrap();\n\n        assert_eq!(captures.len(), 2);\n        assert_eq!(captures[0].logical_name, \"ideas\");\n        assert_eq!(captures[1].logical_name, \"todo\");\n    }\n\n    #[test]\n    fn test_discover_captures_nested() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        std::fs::create_dir(root.join(\"subdir\")).unwrap();\n        File::create(root.join(\"subdir/nested.yaml\")).unwrap();\n\n        let captures = discover_captures(root).unwrap();\n\n        assert_eq!(captures.len(), 1);\n        assert_eq!(captures[0].logical_name, \"subdir/nested\");\n    }\n\n    #[test]\n    fn test_discover_captures_missing_dir() {\n        let dir = tempdir().unwrap();\n        let missing = dir.path().join(\"missing\");\n        \n        let result = discover_captures(\u0026missing);\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":23}},{"line":8,"address":[],"length":0,"stats":{"Line":45}},{"line":10,"address":[],"length":0,"stats":{"Line":26}},{"line":12,"address":[],"length":0,"stats":{"Line":22}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":44}},{"line":18,"address":[],"length":0,"stats":{"Line":91}},{"line":19,"address":[],"length":0,"stats":{"Line":141}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":141}},{"line":24,"address":[],"length":0,"stats":{"Line":47}},{"line":25,"address":[],"length":0,"stats":{"Line":23}},{"line":27,"address":[],"length":0,"stats":{"Line":24}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":132}},{"line":32,"address":[],"length":0,"stats":{"Line":66}},{"line":34,"address":[],"length":0,"stats":{"Line":88}},{"line":37,"address":[],"length":0,"stats":{"Line":56}},{"line":38,"address":[],"length":0,"stats":{"Line":22}},{"line":41,"address":[],"length":0,"stats":{"Line":24}},{"line":42,"address":[],"length":0,"stats":{"Line":192}},{"line":43,"address":[],"length":0,"stats":{"Line":54}},{"line":46,"address":[],"length":0,"stats":{"Line":22}},{"line":47,"address":[],"length":0,"stats":{"Line":66}},{"line":49,"address":[],"length":0,"stats":{"Line":43}},{"line":50,"address":[],"length":0,"stats":{"Line":42}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":26,"coverable":29},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","captures","mod.rs"],"content":"pub mod discovery;\npub mod repository;\npub mod types;\n\n// Re-export primary API\npub use repository::CaptureRepository;\npub use types::{\n    CaptureDiscoveryError, CaptureInfo, CapturePosition, CaptureRepoError, CaptureSpec,\n    CaptureTarget, LoadedCapture,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","captures","repository.rs"],"content":"use std::fs;\nuse std::path::{Path, PathBuf};\n\nuse super::discovery::discover_captures;\nuse super::types::{\n    CaptureDiscoveryError, CaptureInfo, CaptureRepoError, CaptureSpec, LoadedCapture,\n};\n\n/// Repository for discovering and loading capture specifications\npub struct CaptureRepository {\n    pub root: PathBuf,\n    pub captures: Vec\u003cCaptureInfo\u003e,\n}\n\nimpl CaptureRepository {\n    /// Create a new repository by scanning the captures directory\n    pub fn new(root: \u0026Path) -\u003e Result\u003cSelf, CaptureDiscoveryError\u003e {\n        let captures = discover_captures(root)?;\n        Ok(Self { root: root.to_path_buf(), captures })\n    }\n\n    /// List all discovered captures\n    pub fn list_all(\u0026self) -\u003e \u0026[CaptureInfo] {\n        \u0026self.captures\n    }\n\n    /// Load a capture by its logical name\n    pub fn get_by_name(\u0026self, name: \u0026str) -\u003e Result\u003cLoadedCapture, CaptureRepoError\u003e {\n        let info = self\n            .captures\n            .iter()\n            .find(|c| c.logical_name == name)\n            .ok_or_else(|| CaptureRepoError::NotFound(name.to_string()))?;\n\n        let content = fs::read_to_string(\u0026info.path)\n            .map_err(|e| CaptureRepoError::Io { path: info.path.clone(), source: e })?;\n\n        let spec: CaptureSpec = serde_yaml::from_str(\u0026content).map_err(|e| {\n            CaptureRepoError::Parse { path: info.path.clone(), source: e }\n        })?;\n\n        Ok(LoadedCapture {\n            logical_name: info.logical_name.clone(),\n            path: info.path.clone(),\n            spec,\n        })\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":20}},{"line":18,"address":[],"length":0,"stats":{"Line":60}},{"line":19,"address":[],"length":0,"stats":{"Line":40}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":19}},{"line":29,"address":[],"length":0,"stats":{"Line":37}},{"line":30,"address":[],"length":0,"stats":{"Line":19}},{"line":32,"address":[],"length":0,"stats":{"Line":63}},{"line":33,"address":[],"length":0,"stats":{"Line":22}},{"line":35,"address":[],"length":0,"stats":{"Line":54}},{"line":36,"address":[],"length":0,"stats":{"Line":18}},{"line":38,"address":[],"length":0,"stats":{"Line":90}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":18}},{"line":43,"address":[],"length":0,"stats":{"Line":54}},{"line":44,"address":[],"length":0,"stats":{"Line":36}},{"line":45,"address":[],"length":0,"stats":{"Line":18}}],"covered":17,"coverable":18},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","captures","types.rs"],"content":"use serde::Deserialize;\nuse std::path::PathBuf;\nuse thiserror::Error;\n\nuse crate::frontmatter::FrontmatterOps;\nuse crate::markdown_ast::InsertPosition;\nuse crate::vars::VarsMap;\n\n/// A capture specification loaded from a YAML file\n#[derive(Debug, Clone, Deserialize)]\npub struct CaptureSpec {\n    /// Logical name of the capture\n    pub name: String,\n\n    /// Human-readable description\n    #[serde(default)]\n    pub description: String,\n\n    /// Variable specifications with prompts and defaults.\n    #[serde(default)]\n    pub vars: Option\u003cVarsMap\u003e,\n\n    /// Target file and section configuration\n    pub target: CaptureTarget,\n\n    /// Content template to insert (supports {{var}} placeholders)\n    /// Optional: capture may only modify frontmatter without adding content\n    #[serde(default)]\n    pub content: Option\u003cString\u003e,\n\n    /// Frontmatter operations to apply to the target file\n    #[serde(default)]\n    pub frontmatter: Option\u003cFrontmatterOps\u003e,\n}\n\n/// Target configuration for where to insert captured content\n#[derive(Debug, Clone, Deserialize)]\npub struct CaptureTarget {\n    /// Path to the target file (supports {{var}} placeholders)\n    pub file: String,\n\n    /// Section heading to insert into (optional: not needed for frontmatter-only captures)\n    #[serde(default)]\n    pub section: Option\u003cString\u003e,\n\n    /// Where in the section to insert (begin or end)\n    #[serde(default)]\n    pub position: CapturePosition,\n\n    /// If true, create the target file if it doesn't exist.\n    /// The file will be created with minimal frontmatter (type: daily, date) and the target section.\n    #[serde(default)]\n    pub create_if_missing: bool,\n}\n\n/// Position within a section (maps to InsertPosition)\n#[derive(Debug, Clone, Default, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum CapturePosition {\n    #[default]\n    Begin,\n    End,\n}\n\nimpl From\u003cCapturePosition\u003e for InsertPosition {\n    fn from(pos: CapturePosition) -\u003e Self {\n        match pos {\n            CapturePosition::Begin =\u003e InsertPosition::Begin,\n            CapturePosition::End =\u003e InsertPosition::End,\n        }\n    }\n}\n\n/// Information about a discovered capture file\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct CaptureInfo {\n    /// Logical name (filename without .yaml extension)\n    pub logical_name: String,\n    /// Full path to the YAML file\n    pub path: PathBuf,\n}\n\n/// A fully loaded capture ready for execution\n#[derive(Debug, Clone)]\npub struct LoadedCapture {\n    pub logical_name: String,\n    pub path: PathBuf,\n    pub spec: CaptureSpec,\n}\n\n#[derive(Debug, Error)]\npub enum CaptureDiscoveryError {\n    #[error(\"captures directory does not exist: {0}\")]\n    MissingDir(String),\n\n    #[error(\"failed to read captures directory {0}: {1}\")]\n    WalkError(String, #[source] walkdir::Error),\n}\n\n#[derive(Debug, Error)]\npub enum CaptureRepoError {\n    #[error(transparent)]\n    Discovery(#[from] CaptureDiscoveryError),\n\n    #[error(\"capture not found: {0}\")]\n    NotFound(String),\n\n    #[error(\"failed to read capture file {path}: {source}\")]\n    Io {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    #[error(\"failed to parse capture YAML {path}: {source}\")]\n    Parse {\n        path: PathBuf,\n        #[source]\n        source: serde_yaml::Error,\n    },\n}\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":9}},{"line":67,"address":[],"length":0,"stats":{"Line":9}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":5}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","config","loader.rs"],"content":"use crate::config::types::{ConfigFile, Profile, ResolvedConfig, SecurityPolicy};\nuse shellexpand::full;\nuse std::path::{Path, PathBuf};\nuse std::{env, fs};\n\nuse dirs::home_dir;\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum ConfigError {\n    #[error(\"config file not found at {0}\")]\n    NotFound(String),\n\n    #[error(\"failed to read config file {0}: {1}\")]\n    ReadError(String, #[source] std::io::Error),\n\n    #[error(\"failed to parse TOML in {0}: {1}\")]\n    ParseError(String, #[source] toml::de::Error),\n\n    #[error(\"profile '{0}' not found\")]\n    ProfileNotFound(String),\n\n    #[error(\"no profiles defined in config\")]\n    NoProfiles,\n\n    #[error(\"version {0} is unsupported (expected 1)\")]\n    BadVersion(u32),\n\n    #[error(\"home directory not available to expand '~'\")]\n    NoHome,\n}\n\npub struct ConfigLoader;\n\nimpl ConfigLoader {\n    pub fn load(\n        config_path: Option\u003c\u0026Path\u003e,\n        profile_override: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cResolvedConfig, ConfigError\u003e {\n        let path = match config_path {\n            Some(p) =\u003e p.to_path_buf(),\n            None =\u003e default_config_path(),\n        };\n\n        if !path.exists() {\n            return Err(ConfigError::NotFound(path.display().to_string()));\n        }\n\n        let s = fs::read_to_string(\u0026path)\n            .map_err(|e| ConfigError::ReadError(path.display().to_string(), e))?;\n\n        let cf: ConfigFile = toml::from_str(\u0026s)\n            .map_err(|e| ConfigError::ParseError(path.display().to_string(), e))?;\n\n        if cf.version != 1 {\n            return Err(ConfigError::BadVersion(cf.version));\n        }\n        if cf.profiles.is_empty() {\n            return Err(ConfigError::NoProfiles);\n        }\n\n        let active = profile_override\n            .map(ToOwned::to_owned)\n            .or(cf.profile.clone())\n            .unwrap_or_else(|| \"default\".to_string());\n\n        let prof = cf\n            .profiles\n            .get(\u0026active)\n            .ok_or_else(|| ConfigError::ProfileNotFound(active.clone()))?;\n\n        let resolved = Self::resolve_profile(\u0026active, prof, \u0026cf.security)?;\n        Ok(resolved)\n    }\n\n    fn resolve_profile(\n        active: \u0026str,\n        prof: \u0026Profile,\n        sec: \u0026SecurityPolicy,\n    ) -\u003e Result\u003cResolvedConfig, ConfigError\u003e {\n        let vault_root = expand_path(\u0026prof.vault_root)?;\n        let sub = |s: \u0026str| s.replace(\"{{vault_root}}\", \u0026vault_root.to_string_lossy());\n\n        let templates_dir = expand_path(\u0026sub(\u0026prof.templates_dir))?;\n        let captures_dir = expand_path(\u0026sub(\u0026prof.captures_dir))?;\n        let macros_dir = expand_path(\u0026sub(\u0026prof.macros_dir))?;\n        let typedefs_dir = match \u0026prof.typedefs_dir {\n            Some(dir) =\u003e expand_path(\u0026sub(dir))?,\n            None =\u003e default_typedefs_dir(),\n        };\n\n        Ok(ResolvedConfig {\n            active_profile: active.to_string(),\n            vault_root,\n            templates_dir,\n            captures_dir,\n            macros_dir,\n            typedefs_dir,\n            security: sec.clone(),\n        })\n    }\n}\n\npub fn default_config_path() -\u003e PathBuf {\n    if let Ok(xdg) = env::var(\"XDG_CONFIG_HOME\") {\n        return Path::new(\u0026xdg).join(\"mdvault\").join(\"config.toml\");\n    }\n    let home = home_dir().unwrap_or_else(|| PathBuf::from(\"~\"));\n    home.join(\".config\").join(\"mdvault\").join(\"config.toml\")\n}\n\n/// Default directory for Lua type definitions.\n/// Global location: ~/.config/mdvault/types/\npub fn default_typedefs_dir() -\u003e PathBuf {\n    if let Ok(xdg) = env::var(\"XDG_CONFIG_HOME\") {\n        return Path::new(\u0026xdg).join(\"mdvault\").join(\"types\");\n    }\n    let home = home_dir().unwrap_or_else(|| PathBuf::from(\"~\"));\n    home.join(\".config\").join(\"mdvault\").join(\"types\")\n}\n\nfn expand_path(input: \u0026str) -\u003e Result\u003cPathBuf, ConfigError\u003e {\n    let expanded = full(input).map_err(|_| ConfigError::NoHome)?;\n    Ok(PathBuf::from(expanded.to_string()))\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":55}},{"line":40,"address":[],"length":0,"stats":{"Line":110}},{"line":41,"address":[],"length":0,"stats":{"Line":147}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":55}},{"line":46,"address":[],"length":0,"stats":{"Line":3}},{"line":49,"address":[],"length":0,"stats":{"Line":156}},{"line":50,"address":[],"length":0,"stats":{"Line":52}},{"line":52,"address":[],"length":0,"stats":{"Line":208}},{"line":53,"address":[],"length":0,"stats":{"Line":52}},{"line":55,"address":[],"length":0,"stats":{"Line":52}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":100}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":96}},{"line":63,"address":[],"length":0,"stats":{"Line":48}},{"line":64,"address":[],"length":0,"stats":{"Line":144}},{"line":65,"address":[],"length":0,"stats":{"Line":48}},{"line":67,"address":[],"length":0,"stats":{"Line":94}},{"line":68,"address":[],"length":0,"stats":{"Line":48}},{"line":69,"address":[],"length":0,"stats":{"Line":96}},{"line":70,"address":[],"length":0,"stats":{"Line":54}},{"line":72,"address":[],"length":0,"stats":{"Line":230}},{"line":73,"address":[],"length":0,"stats":{"Line":46}},{"line":76,"address":[],"length":0,"stats":{"Line":46}},{"line":81,"address":[],"length":0,"stats":{"Line":138}},{"line":82,"address":[],"length":0,"stats":{"Line":460}},{"line":84,"address":[],"length":0,"stats":{"Line":138}},{"line":85,"address":[],"length":0,"stats":{"Line":138}},{"line":86,"address":[],"length":0,"stats":{"Line":138}},{"line":87,"address":[],"length":0,"stats":{"Line":92}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":46}},{"line":92,"address":[],"length":0,"stats":{"Line":46}},{"line":93,"address":[],"length":0,"stats":{"Line":138}},{"line":94,"address":[],"length":0,"stats":{"Line":92}},{"line":95,"address":[],"length":0,"stats":{"Line":92}},{"line":96,"address":[],"length":0,"stats":{"Line":92}},{"line":97,"address":[],"length":0,"stats":{"Line":92}},{"line":98,"address":[],"length":0,"stats":{"Line":92}},{"line":99,"address":[],"length":0,"stats":{"Line":46}},{"line":104,"address":[],"length":0,"stats":{"Line":8}},{"line":105,"address":[],"length":0,"stats":{"Line":12}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":12}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":46}},{"line":115,"address":[],"length":0,"stats":{"Line":49}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":129}},{"line":119,"address":[],"length":0,"stats":{"Line":43}},{"line":122,"address":[],"length":0,"stats":{"Line":184}},{"line":123,"address":[],"length":0,"stats":{"Line":736}},{"line":124,"address":[],"length":0,"stats":{"Line":368}}],"covered":53,"coverable":54},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","config","mod.rs"],"content":"pub mod loader;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","config","types.rs"],"content":"use std::collections::HashMap;\nuse std::path::PathBuf;\n\nuse serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\npub struct ConfigFile {\n    pub version: u32,\n    pub profile: Option\u003cString\u003e,\n    pub profiles: HashMap\u003cString, Profile\u003e,\n    #[serde(default)]\n    pub security: SecurityPolicy,\n}\n\n#[derive(Debug, Deserialize)]\npub struct Profile {\n    pub vault_root: String,\n    pub templates_dir: String,\n    pub captures_dir: String,\n    pub macros_dir: String,\n    /// Optional override for typedefs directory (defaults to global ~/.config/mdvault/types/)\n    pub typedefs_dir: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize, Default, Clone)]\npub struct SecurityPolicy {\n    #[serde(default)]\n    pub allow_shell: bool,\n    #[serde(default)]\n    pub allow_http: bool,\n}\n\n#[derive(Debug, Clone)]\npub struct ResolvedConfig {\n    pub active_profile: String,\n    pub vault_root: PathBuf,\n    pub templates_dir: PathBuf,\n    pub captures_dir: PathBuf,\n    pub macros_dir: PathBuf,\n    /// Directory for Lua type definitions (global, not per-profile).\n    pub typedefs_dir: PathBuf,\n    pub security: SecurityPolicy,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","frontmatter","mod.rs"],"content":"//! Frontmatter parsing, modification, and serialization.\n//!\n//! This module provides functionality to:\n//! - Parse YAML frontmatter from markdown documents\n//! - Modify frontmatter fields (set, toggle, increment, append)\n//! - Serialize documents back to markdown with frontmatter\n\npub mod modifier;\npub mod parser;\npub mod serializer;\npub mod types;\n\npub use modifier::{FrontmatterModifyError, apply_ops};\npub use parser::{FrontmatterParseError, parse, parse_template_frontmatter};\npub use serializer::serialize;\npub use types::{\n    Frontmatter, FrontmatterOp, FrontmatterOpType, FrontmatterOps, ParsedDocument,\n    TemplateFrontmatter,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","frontmatter","modifier.rs"],"content":"//! Frontmatter modification operations.\n\nuse super::types::{\n    Frontmatter, FrontmatterOp, FrontmatterOpType, FrontmatterOps, ParsedDocument,\n};\nuse regex::Regex;\nuse serde_yaml::Value;\nuse std::collections::HashMap;\nuse thiserror::Error;\n\n/// Errors that can occur during frontmatter modification.\n#[derive(Debug, Error)]\npub enum FrontmatterModifyError {\n    #[error(\"field '{0}' is not a boolean, cannot toggle\")]\n    NotBoolean(String),\n    #[error(\"field '{0}' is not a number, cannot increment\")]\n    NotNumber(String),\n    #[error(\"field '{0}' is not a list, cannot append\")]\n    NotList(String),\n}\n\n/// Apply frontmatter operations to a document.\npub fn apply_ops(\n    mut doc: ParsedDocument,\n    ops: \u0026FrontmatterOps,\n    render_ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003cParsedDocument, FrontmatterModifyError\u003e {\n    // Ensure frontmatter exists\n    if doc.frontmatter.is_none() {\n        doc.frontmatter = Some(Frontmatter::default());\n    }\n    let fm = doc.frontmatter.as_mut().unwrap();\n\n    match ops {\n        FrontmatterOps::Simple(map) =\u003e {\n            for (field, value) in map {\n                let rendered_value = render_value(value, render_ctx);\n                fm.fields.insert(field.clone(), rendered_value);\n            }\n        }\n        FrontmatterOps::Operations(op_list) =\u003e {\n            for op in op_list {\n                apply_single_op(fm, op, render_ctx)?;\n            }\n        }\n    }\n\n    Ok(doc)\n}\n\n/// Apply a single frontmatter operation.\nfn apply_single_op(\n    fm: \u0026mut Frontmatter,\n    op: \u0026FrontmatterOp,\n    render_ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(), FrontmatterModifyError\u003e {\n    match \u0026op.op {\n        FrontmatterOpType::Set =\u003e {\n            if let Some(value) = \u0026op.value {\n                let rendered = render_value(value, render_ctx);\n                fm.fields.insert(op.field.clone(), rendered);\n            }\n        }\n        FrontmatterOpType::Toggle =\u003e {\n            let current = fm.fields.get(\u0026op.field);\n            match current {\n                Some(Value::Bool(b)) =\u003e {\n                    fm.fields.insert(op.field.clone(), Value::Bool(!b));\n                }\n                None =\u003e {\n                    // Default: toggle from false to true\n                    fm.fields.insert(op.field.clone(), Value::Bool(true));\n                }\n                _ =\u003e return Err(FrontmatterModifyError::NotBoolean(op.field.clone())),\n            }\n        }\n        FrontmatterOpType::Increment =\u003e {\n            let current = fm.fields.get(\u0026op.field).cloned();\n            let increment = op.value.as_ref().and_then(|v| v.as_i64()).unwrap_or(1);\n\n            match current {\n                Some(Value::Number(n)) =\u003e {\n                    let new_val = n.as_i64().unwrap_or(0) + increment;\n                    fm.fields.insert(op.field.clone(), Value::Number(new_val.into()));\n                }\n                None =\u003e {\n                    fm.fields.insert(op.field.clone(), Value::Number(increment.into()));\n                }\n                _ =\u003e return Err(FrontmatterModifyError::NotNumber(op.field.clone())),\n            }\n        }\n        FrontmatterOpType::Append =\u003e {\n            let current = fm.fields.get(\u0026op.field).cloned();\n            let append_val = op\n                .value\n                .as_ref()\n                .map(|v| render_value(v, render_ctx))\n                .unwrap_or(Value::Null);\n\n            match current {\n                Some(Value::Sequence(mut seq)) =\u003e {\n                    seq.push(append_val);\n                    fm.fields.insert(op.field.clone(), Value::Sequence(seq));\n                }\n                None =\u003e {\n                    fm.fields.insert(op.field.clone(), Value::Sequence(vec![append_val]));\n                }\n                _ =\u003e return Err(FrontmatterModifyError::NotList(op.field.clone())),\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Render {{var}} placeholders in YAML values.\nfn render_value(value: \u0026Value, ctx: \u0026HashMap\u003cString, String\u003e) -\u003e Value {\n    match value {\n        Value::String(s) =\u003e {\n            let rendered = render_string(s, ctx);\n            Value::String(rendered)\n        }\n        // Recursively handle nested structures\n        Value::Mapping(map) =\u003e {\n            let rendered_map: serde_yaml::Mapping =\n                map.iter().map(|(k, v)| (k.clone(), render_value(v, ctx))).collect();\n            Value::Mapping(rendered_map)\n        }\n        Value::Sequence(seq) =\u003e {\n            Value::Sequence(seq.iter().map(|v| render_value(v, ctx)).collect())\n        }\n        _ =\u003e value.clone(),\n    }\n}\n\n/// Render {{var}} placeholders in a string.\nfn render_string(template: \u0026str, ctx: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    let re = Regex::new(r\"\\{\\{([a-zA-Z0-9_]+)\\}\\}\").unwrap();\n    re.replace_all(template, |caps: \u0026regex::Captures\u003c'_\u003e| {\n        let key = \u0026caps[1];\n        ctx.get(key).cloned().unwrap_or_else(|| caps[0].to_string())\n    })\n    .into_owned()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::frontmatter::parser::parse;\n\n    fn make_ctx() -\u003e HashMap\u003cString, String\u003e {\n        let mut ctx = HashMap::new();\n        ctx.insert(\"date\".to_string(), \"2024-01-15\".to_string());\n        ctx.insert(\"time\".to_string(), \"14:30\".to_string());\n        ctx\n    }\n\n    #[test]\n    fn test_simple_set() {\n        let content = \"---\\ntitle: Old\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let mut ops_map = HashMap::new();\n        ops_map.insert(\"title\".to_string(), Value::String(\"New\".to_string()));\n        ops_map.insert(\"added\".to_string(), Value::Bool(true));\n\n        let ops = FrontmatterOps::Simple(ops_map);\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"title\").and_then(|v| v.as_str()), Some(\"New\"));\n        assert_eq!(fm.fields.get(\"added\").and_then(|v| v.as_bool()), Some(true));\n    }\n\n    #[test]\n    fn test_toggle_existing_true() {\n        let content = \"---\\nflag: true\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"flag\".to_string(),\n            op: FrontmatterOpType::Toggle,\n            value: None,\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"flag\").and_then(|v| v.as_bool()), Some(false));\n    }\n\n    #[test]\n    fn test_toggle_missing_field() {\n        let content = \"---\\nother: value\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"flag\".to_string(),\n            op: FrontmatterOpType::Toggle,\n            value: None,\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"flag\").and_then(|v| v.as_bool()), Some(true));\n    }\n\n    #[test]\n    fn test_increment() {\n        let content = \"---\\ncount: 5\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"count\".to_string(),\n            op: FrontmatterOpType::Increment,\n            value: None, // Default increment of 1\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"count\").and_then(|v| v.as_i64()), Some(6));\n    }\n\n    #[test]\n    fn test_increment_with_value() {\n        let content = \"---\\ncount: 10\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"count\".to_string(),\n            op: FrontmatterOpType::Increment,\n            value: Some(Value::Number(5.into())),\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"count\").and_then(|v| v.as_i64()), Some(15));\n    }\n\n    #[test]\n    fn test_append_to_existing_list() {\n        let content = \"---\\nitems:\\n  - one\\n  - two\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"items\".to_string(),\n            op: FrontmatterOpType::Append,\n            value: Some(Value::String(\"three\".to_string())),\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        let items = fm.fields.get(\"items\").unwrap().as_sequence().unwrap();\n        assert_eq!(items.len(), 3);\n        assert_eq!(items[2].as_str(), Some(\"three\"));\n    }\n\n    #[test]\n    fn test_append_to_new_list() {\n        let content = \"---\\nother: value\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let ops = FrontmatterOps::Operations(vec![FrontmatterOp {\n            field: \"items\".to_string(),\n            op: FrontmatterOpType::Append,\n            value: Some(Value::String(\"first\".to_string())),\n        }]);\n\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n        let fm = result.frontmatter.unwrap();\n        let items = fm.fields.get(\"items\").unwrap().as_sequence().unwrap();\n        assert_eq!(items.len(), 1);\n        assert_eq!(items[0].as_str(), Some(\"first\"));\n    }\n\n    #[test]\n    fn test_variable_substitution() {\n        let content = \"---\\n---\\n# Content\";\n        let doc = parse(content).unwrap();\n\n        let mut ops_map = HashMap::new();\n        ops_map.insert(\n            \"modified\".to_string(),\n            Value::String(\"{{date}} at {{time}}\".to_string()),\n        );\n\n        let ops = FrontmatterOps::Simple(ops_map);\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(\n            fm.fields.get(\"modified\").and_then(|v| v.as_str()),\n            Some(\"2024-01-15 at 14:30\")\n        );\n    }\n\n    #[test]\n    fn test_creates_frontmatter_if_missing() {\n        let doc =\n            ParsedDocument { frontmatter: None, body: \"# No frontmatter\".to_string() };\n\n        let mut ops_map = HashMap::new();\n        ops_map.insert(\"new_field\".to_string(), Value::Bool(true));\n\n        let ops = FrontmatterOps::Simple(ops_map);\n        let result = apply_ops(doc, \u0026ops, \u0026make_ctx()).unwrap();\n\n        assert!(result.frontmatter.is_some());\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"new_field\").and_then(|v| v.as_bool()), Some(true));\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":15}},{"line":29,"address":[],"length":0,"stats":{"Line":32}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":60}},{"line":34,"address":[],"length":0,"stats":{"Line":15}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":46}},{"line":37,"address":[],"length":0,"stats":{"Line":50}},{"line":38,"address":[],"length":0,"stats":{"Line":40}},{"line":41,"address":[],"length":0,"stats":{"Line":9}},{"line":42,"address":[],"length":0,"stats":{"Line":27}},{"line":43,"address":[],"length":0,"stats":{"Line":36}},{"line":48,"address":[],"length":0,"stats":{"Line":15}},{"line":52,"address":[],"length":0,"stats":{"Line":9}},{"line":57,"address":[],"length":0,"stats":{"Line":9}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":12}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":15}},{"line":79,"address":[],"length":0,"stats":{"Line":17}},{"line":81,"address":[],"length":0,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":83,"address":[],"length":0,"stats":{"Line":15}},{"line":84,"address":[],"length":0,"stats":{"Line":15}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":15}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":12}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":8}},{"line":103,"address":[],"length":0,"stats":{"Line":8}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":5}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":9}},{"line":116,"address":[],"length":0,"stats":{"Line":13}},{"line":117,"address":[],"length":0,"stats":{"Line":13}},{"line":118,"address":[],"length":0,"stats":{"Line":9}},{"line":119,"address":[],"length":0,"stats":{"Line":36}},{"line":120,"address":[],"length":0,"stats":{"Line":9}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":8}},{"line":136,"address":[],"length":0,"stats":{"Line":9}},{"line":137,"address":[],"length":0,"stats":{"Line":36}},{"line":138,"address":[],"length":0,"stats":{"Line":33}},{"line":139,"address":[],"length":0,"stats":{"Line":12}},{"line":140,"address":[],"length":0,"stats":{"Line":30}}],"covered":50,"coverable":64},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","frontmatter","parser.rs"],"content":"//! Frontmatter parsing from markdown documents.\n\nuse super::types::{Frontmatter, ParsedDocument, TemplateFrontmatter};\nuse thiserror::Error;\n\n/// Errors that can occur during frontmatter parsing.\n#[derive(Debug, Error)]\npub enum FrontmatterParseError {\n    #[error(\"invalid YAML frontmatter: {0}\")]\n    InvalidYaml(#[from] serde_yaml::Error),\n}\n\n/// Parse frontmatter from markdown content.\n///\n/// Frontmatter is delimited by `---` at the start of the document:\n/// ```markdown\n/// ---\n/// key: value\n/// ---\n/// # Document content\n/// ```\npub fn parse(content: \u0026str) -\u003e Result\u003cParsedDocument, FrontmatterParseError\u003e {\n    let trimmed = content.trim_start();\n\n    // Check if document starts with frontmatter delimiter\n    if !trimmed.starts_with(\"---\") {\n        return Ok(ParsedDocument { frontmatter: None, body: content.to_string() });\n    }\n\n    // Find the closing ---\n    let after_first = \u0026trimmed[3..];\n\n    // Skip the newline after opening ---\n    let after_newline = after_first\n        .strip_prefix('\\n')\n        .or_else(|| after_first.strip_prefix(\"\\r\\n\"))\n        .unwrap_or(after_first);\n\n    // Find closing delimiter\n    if let Some(end_pos) = find_closing_delimiter(after_newline) {\n        let yaml_content = \u0026after_newline[..end_pos];\n\n        // Calculate body start (skip closing --- and following newline)\n        let after_closing = \u0026after_newline[end_pos + 3..];\n        let body = after_closing\n            .strip_prefix('\\n')\n            .or_else(|| after_closing.strip_prefix(\"\\r\\n\"))\n            .unwrap_or(after_closing)\n            .to_string();\n\n        // Parse YAML\n        let frontmatter: Frontmatter = if yaml_content.trim().is_empty() {\n            Frontmatter::default()\n        } else {\n            serde_yaml::from_str(yaml_content.trim())?\n        };\n\n        Ok(ParsedDocument { frontmatter: Some(frontmatter), body })\n    } else {\n        // No closing ---, treat as no frontmatter\n        Ok(ParsedDocument { frontmatter: None, body: content.to_string() })\n    }\n}\n\n/// Find the position of closing `---` delimiter.\nfn find_closing_delimiter(content: \u0026str) -\u003e Option\u003cusize\u003e {\n    // Look for --- at the start of a line\n    for (i, line) in content.lines().enumerate() {\n        if line.trim() == \"---\" {\n            // Calculate byte position\n            let pos: usize = content\n                .lines()\n                .take(i)\n                .map(|l| l.len() + 1) // +1 for newline\n                .sum();\n            return Some(pos);\n        }\n    }\n    None\n}\n\n/// Parse template-specific frontmatter.\n///\n/// Returns the parsed template frontmatter (if present) and the body content.\npub fn parse_template_frontmatter(\n    content: \u0026str,\n) -\u003e Result\u003c(Option\u003cTemplateFrontmatter\u003e, String), FrontmatterParseError\u003e {\n    let parsed = parse(content)?;\n\n    if let Some(fm) = parsed.frontmatter {\n        // Convert Frontmatter to TemplateFrontmatter\n        let yaml_value = serde_yaml::to_value(\u0026fm.fields)?;\n        let template_fm: TemplateFrontmatter = serde_yaml::from_value(yaml_value)?;\n        Ok((Some(template_fm), parsed.body))\n    } else {\n        Ok((None, parsed.body))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_no_frontmatter() {\n        let content = \"# Hello\\n\\nSome content\";\n        let result = parse(content).unwrap();\n        assert!(result.frontmatter.is_none());\n        assert_eq!(result.body, content);\n    }\n\n    #[test]\n    fn parse_simple_frontmatter() {\n        let content = \"---\\ntitle: Hello\\n---\\n# Content\";\n        let result = parse(content).unwrap();\n        assert!(result.frontmatter.is_some());\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"title\").and_then(|v| v.as_str()), Some(\"Hello\"));\n        assert_eq!(result.body, \"# Content\");\n    }\n\n    #[test]\n    fn parse_frontmatter_with_multiple_fields() {\n        let content =\n            \"---\\ntitle: Test\\ndate: 2024-01-15\\ntags:\\n  - rust\\n  - cli\\n---\\n\\nBody\";\n        let result = parse(content).unwrap();\n        assert!(result.frontmatter.is_some());\n        let fm = result.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"title\").and_then(|v| v.as_str()), Some(\"Test\"));\n        assert!(fm.fields.contains_key(\"tags\"));\n        assert_eq!(result.body, \"\\nBody\");\n    }\n\n    #[test]\n    fn parse_empty_frontmatter() {\n        let content = \"---\\n---\\n# Content\";\n        let result = parse(content).unwrap();\n        assert!(result.frontmatter.is_some());\n        assert!(result.frontmatter.unwrap().fields.is_empty());\n        assert_eq!(result.body, \"# Content\");\n    }\n\n    #[test]\n    fn parse_template_frontmatter_with_output() {\n        let content = \"---\\noutput: daily/{{date}}.md\\ntags: [daily]\\n---\\n# Daily\";\n        let (fm, body) = parse_template_frontmatter(content).unwrap();\n        assert!(fm.is_some());\n        let fm = fm.unwrap();\n        assert_eq!(fm.output, Some(\"daily/{{date}}.md\".to_string()));\n        assert!(fm.extra.contains_key(\"tags\"));\n        assert_eq!(body, \"# Daily\");\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":131}},{"line":23,"address":[],"length":0,"stats":{"Line":393}},{"line":26,"address":[],"length":0,"stats":{"Line":131}},{"line":27,"address":[],"length":0,"stats":{"Line":120}},{"line":31,"address":[],"length":0,"stats":{"Line":142}},{"line":34,"address":[],"length":0,"stats":{"Line":142}},{"line":36,"address":[],"length":0,"stats":{"Line":71}},{"line":37,"address":[],"length":0,"stats":{"Line":142}},{"line":40,"address":[],"length":0,"stats":{"Line":142}},{"line":41,"address":[],"length":0,"stats":{"Line":142}},{"line":44,"address":[],"length":0,"stats":{"Line":142}},{"line":45,"address":[],"length":0,"stats":{"Line":142}},{"line":47,"address":[],"length":0,"stats":{"Line":71}},{"line":48,"address":[],"length":0,"stats":{"Line":142}},{"line":52,"address":[],"length":0,"stats":{"Line":284}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":138}},{"line":58,"address":[],"length":0,"stats":{"Line":71}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":71}},{"line":68,"address":[],"length":0,"stats":{"Line":671}},{"line":69,"address":[],"length":0,"stats":{"Line":229}},{"line":71,"address":[],"length":0,"stats":{"Line":213}},{"line":73,"address":[],"length":0,"stats":{"Line":142}},{"line":74,"address":[],"length":0,"stats":{"Line":387}},{"line":76,"address":[],"length":0,"stats":{"Line":71}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":15}},{"line":88,"address":[],"length":0,"stats":{"Line":45}},{"line":90,"address":[],"length":0,"stats":{"Line":25}},{"line":92,"address":[],"length":0,"stats":{"Line":30}},{"line":93,"address":[],"length":0,"stats":{"Line":40}},{"line":94,"address":[],"length":0,"stats":{"Line":10}},{"line":96,"address":[],"length":0,"stats":{"Line":5}}],"covered":32,"coverable":34},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","frontmatter","serializer.rs"],"content":"//! Frontmatter serialization back to markdown.\n\nuse super::types::{Frontmatter, ParsedDocument};\nuse serde_yaml::Value;\nuse std::collections::HashMap;\n\n/// Serialize a parsed document back to markdown string.\npub fn serialize(doc: \u0026ParsedDocument) -\u003e String {\n    if let Some(fm) = \u0026doc.frontmatter\n        \u0026\u0026 !fm.fields.is_empty()\n    {\n        let yaml = serialize_frontmatter(\u0026fm.fields);\n        return format!(\"---\\n{}---\\n\\n{}\", yaml, doc.body);\n    }\n    doc.body.clone()\n}\n\n/// Serialize frontmatter fields to YAML string.\nfn serialize_frontmatter(fields: \u0026HashMap\u003cString, Value\u003e) -\u003e String {\n    serde_yaml::to_string(fields).unwrap_or_default()\n}\n\n/// Serialize a Frontmatter struct to YAML string (without delimiters).\npub fn frontmatter_to_yaml(fm: \u0026Frontmatter) -\u003e String {\n    serialize_frontmatter(\u0026fm.fields)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::frontmatter::parser::parse;\n\n    #[test]\n    fn serialize_document_without_frontmatter() {\n        let doc =\n            ParsedDocument { frontmatter: None, body: \"# Hello\\n\\nWorld\".to_string() };\n        assert_eq!(serialize(\u0026doc), \"# Hello\\n\\nWorld\");\n    }\n\n    #[test]\n    fn serialize_document_with_frontmatter() {\n        let mut fields = HashMap::new();\n        fields.insert(\"title\".to_string(), Value::String(\"Test\".to_string()));\n\n        let doc = ParsedDocument {\n            frontmatter: Some(Frontmatter { fields }),\n            body: \"# Content\".to_string(),\n        };\n\n        let result = serialize(\u0026doc);\n        assert!(result.starts_with(\"---\\n\"));\n        assert!(result.contains(\"title: Test\"));\n        assert!(result.ends_with(\"---\\n\\n# Content\"));\n    }\n\n    #[test]\n    fn roundtrip_frontmatter() {\n        let original = \"---\\ntitle: Hello\\ncount: 42\\n---\\n\\n# Body\";\n        let parsed = parse(original).unwrap();\n        let serialized = serialize(\u0026parsed);\n\n        // Re-parse and verify\n        let reparsed = parse(\u0026serialized).unwrap();\n        assert!(reparsed.frontmatter.is_some());\n        let fm = reparsed.frontmatter.unwrap();\n        assert_eq!(fm.fields.get(\"title\").and_then(|v| v.as_str()), Some(\"Hello\"));\n        assert_eq!(fm.fields.get(\"count\").and_then(|v| v.as_i64()), Some(42));\n        assert!(reparsed.body.contains(\"# Body\"));\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":18}},{"line":9,"address":[],"length":0,"stats":{"Line":28}},{"line":10,"address":[],"length":0,"stats":{"Line":10}},{"line":12,"address":[],"length":0,"stats":{"Line":30}},{"line":13,"address":[],"length":0,"stats":{"Line":20}},{"line":15,"address":[],"length":0,"stats":{"Line":16}},{"line":19,"address":[],"length":0,"stats":{"Line":10}},{"line":20,"address":[],"length":0,"stats":{"Line":30}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":10},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","frontmatter","types.rs"],"content":"//! Frontmatter types and data structures.\n\nuse serde::{Deserialize, Serialize};\nuse serde_yaml::Value;\nuse std::collections::HashMap;\n\nuse crate::vars::VarsMap;\n\n/// Represents parsed YAML frontmatter from a markdown document.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct Frontmatter {\n    /// Fields as key-value pairs.\n    #[serde(flatten)]\n    pub fields: HashMap\u003cString, Value\u003e,\n}\n\n/// Result of splitting frontmatter from markdown.\n#[derive(Debug, Clone)]\npub struct ParsedDocument {\n    /// Parsed frontmatter (if present).\n    pub frontmatter: Option\u003cFrontmatter\u003e,\n    /// The markdown body (everything after frontmatter).\n    pub body: String,\n}\n\n/// Template-specific frontmatter fields.\n#[derive(Debug, Clone, Deserialize, Default)]\npub struct TemplateFrontmatter {\n    /// Path to Lua script that defines this template's behavior.\n    /// When present, schema, prompts, output path, and hooks come from Lua.\n    pub lua: Option\u003cString\u003e,\n\n    /// Output path template (supports {{var}} placeholders).\n    /// DEPRECATED: Use Lua script's `output` field instead.\n    pub output: Option\u003cString\u003e,\n\n    /// Variable specifications with prompts and defaults.\n    /// DEPRECATED: Use Lua script's schema with `prompt` fields instead.\n    #[serde(default)]\n    pub vars: Option\u003cVarsMap\u003e,\n\n    /// Other fields are passed through to output.\n    #[serde(flatten)]\n    pub extra: HashMap\u003cString, Value\u003e,\n}\n\n/// Frontmatter operations specification.\n/// Supports both simple key-value pairs and explicit operations.\n#[derive(Debug, Clone, Deserialize)]\n#[serde(untagged)]\npub enum FrontmatterOps {\n    /// Simple map form: { field: value } implies \"set\".\n    Simple(HashMap\u003cString, Value\u003e),\n    /// List of explicit operations.\n    Operations(Vec\u003cFrontmatterOp\u003e),\n}\n\n/// A single frontmatter modification operation.\n#[derive(Debug, Clone, Deserialize)]\npub struct FrontmatterOp {\n    /// Field name to modify.\n    pub field: String,\n    /// Operation type.\n    pub op: FrontmatterOpType,\n    /// Value for set/append operations (supports {{var}} in string values).\n    #[serde(default)]\n    pub value: Option\u003cValue\u003e,\n}\n\n/// Type of frontmatter operation.\n#[derive(Debug, Clone, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum FrontmatterOpType {\n    /// Set field to value (creates if missing).\n    Set,\n    /// Toggle boolean field.\n    Toggle,\n    /// Increment numeric field.\n    Increment,\n    /// Append to list field.\n    Append,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","ids.rs"],"content":"//! ID generation utilities for projects and tasks.\n//!\n//! Projects get a 3-letter ID derived from their title.\n//! Tasks get the project ID + a 3-digit counter (e.g., \"MCP-001\").\n\n/// Generate a project ID from a title.\n///\n/// Takes up to 3 meaningful letters from the title:\n/// - If multiple words, takes first letter of each word (up to 3)\n/// - If single word, takes first 3 letters\n/// - Converts to uppercase\n///\n/// # Examples\n/// ```\n/// use mdvault_core::ids::generate_project_id;\n///\n/// assert_eq!(generate_project_id(\"My Cool Project\"), \"MCP\");\n/// assert_eq!(generate_project_id(\"Inventory\"), \"INV\");\n/// assert_eq!(generate_project_id(\"AI\"), \"AI\");\n/// assert_eq!(generate_project_id(\"a b c d e\"), \"ABC\");\n/// ```\npub fn generate_project_id(title: \u0026str) -\u003e String {\n    let words: Vec\u003c\u0026str\u003e = title.split_whitespace().filter(|w| !w.is_empty()).collect();\n\n    let id = if words.len() \u003e= 3 {\n        // Take first letter of first 3 words\n        words.iter().take(3).filter_map(|w| w.chars().next()).collect::\u003cString\u003e()\n    } else if words.len() == 2 {\n        // Two words: first letter of each, plus second letter of longer word\n        let mut chars: Vec\u003cchar\u003e =\n            words.iter().filter_map(|w| w.chars().next()).collect();\n        // Add one more char from the longer word\n        let longer = if words[0].len() \u003e= words[1].len() { words[0] } else { words[1] };\n        if let Some(c) = longer.chars().nth(1) {\n            chars.push(c);\n        }\n        chars.into_iter().collect()\n    } else if words.len() == 1 {\n        // Single word: take first 3 letters\n        words[0].chars().take(3).collect()\n    } else {\n        // Empty title, generate placeholder\n        \"XXX\".to_string()\n    };\n\n    id.to_uppercase()\n}\n\n/// Generate a task ID from a project ID and counter.\n///\n/// Format: `{project_id}-{counter:03}`\n///\n/// # Examples\n/// ```\n/// use mdvault_core::ids::generate_task_id;\n///\n/// assert_eq!(generate_task_id(\"MCP\", 1), \"MCP-001\");\n/// assert_eq!(generate_task_id(\"INV\", 42), \"INV-042\");\n/// assert_eq!(generate_task_id(\"AI\", 999), \"AI-999\");\n/// ```\npub fn generate_task_id(project_id: \u0026str, counter: u32) -\u003e String {\n    format!(\"{}-{:03}\", project_id, counter)\n}\n\n/// Parse a task ID to extract project ID and counter.\n///\n/// Returns None if the format is invalid.\n///\n/// # Examples\n/// ```\n/// use mdvault_core::ids::parse_task_id;\n///\n/// assert_eq!(parse_task_id(\"MCP-001\"), Some((\"MCP\".to_string(), 1)));\n/// assert_eq!(parse_task_id(\"INV-042\"), Some((\"INV\".to_string(), 42)));\n/// assert_eq!(parse_task_id(\"invalid\"), None);\n/// ```\npub fn parse_task_id(task_id: \u0026str) -\u003e Option\u003c(String, u32)\u003e {\n    let parts: Vec\u003c\u0026str\u003e = task_id.splitn(2, '-').collect();\n    if parts.len() != 2 {\n        return None;\n    }\n\n    let project_id = parts[0].to_string();\n    let counter = parts[1].parse::\u003cu32\u003e().ok()?;\n\n    Some((project_id, counter))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_project_id_multiple_words() {\n        assert_eq!(generate_project_id(\"My Cool Project\"), \"MCP\");\n        assert_eq!(generate_project_id(\"Knowledge Base System\"), \"KBS\");\n    }\n\n    #[test]\n    fn test_project_id_two_words() {\n        // Two words: first letter of each + second letter of longer word\n        assert_eq!(generate_project_id(\"Home Automation\"), \"HAU\");\n        assert_eq!(generate_project_id(\"AI Research\"), \"ARE\");\n    }\n\n    #[test]\n    fn test_project_id_single_word() {\n        assert_eq!(generate_project_id(\"Inventory\"), \"INV\");\n        assert_eq!(generate_project_id(\"AI\"), \"AI\");\n        assert_eq!(generate_project_id(\"X\"), \"X\");\n    }\n\n    #[test]\n    fn test_project_id_empty() {\n        assert_eq!(generate_project_id(\"\"), \"XXX\");\n        assert_eq!(generate_project_id(\"   \"), \"XXX\");\n    }\n\n    #[test]\n    fn test_project_id_lowercase() {\n        assert_eq!(generate_project_id(\"my cool project\"), \"MCP\");\n    }\n\n    #[test]\n    fn test_task_id_generation() {\n        assert_eq!(generate_task_id(\"MCP\", 1), \"MCP-001\");\n        assert_eq!(generate_task_id(\"MCP\", 42), \"MCP-042\");\n        assert_eq!(generate_task_id(\"MCP\", 999), \"MCP-999\");\n    }\n\n    #[test]\n    fn test_parse_task_id() {\n        assert_eq!(parse_task_id(\"MCP-001\"), Some((\"MCP\".to_string(), 1)));\n        assert_eq!(parse_task_id(\"INV-042\"), Some((\"INV\".to_string(), 42)));\n        assert_eq!(parse_task_id(\"invalid\"), None);\n        assert_eq!(parse_task_id(\"MCP-abc\"), None);\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":10}},{"line":23,"address":[],"length":0,"stats":{"Line":92}},{"line":25,"address":[],"length":0,"stats":{"Line":20}},{"line":27,"address":[],"length":0,"stats":{"Line":30}},{"line":28,"address":[],"length":0,"stats":{"Line":7}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":14}},{"line":33,"address":[],"length":0,"stats":{"Line":10}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":6}},{"line":38,"address":[],"length":0,"stats":{"Line":5}},{"line":40,"address":[],"length":0,"stats":{"Line":12}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":10}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":20}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":9}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":2}}],"covered":24,"coverable":24},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","builder.rs"],"content":"//! Index building orchestration.\n\nuse std::path::Path;\n\nuse chrono::{DateTime, Utc};\nuse thiserror::Error;\n\nuse super::db::{IndexDb, IndexError};\nuse super::types::{IndexedLink, IndexedNote};\nuse crate::vault::{\n    VaultWalker, VaultWalkerError, WalkedFile, content_hash, extract_note,\n};\n\n#[derive(Debug, Error)]\npub enum BuilderError {\n    #[error(\"Vault walker error: {0}\")]\n    Walker(#[from] VaultWalkerError),\n\n    #[error(\"Index database error: {0}\")]\n    Index(#[from] IndexError),\n\n    #[error(\"Failed to read file {path}: {source}\")]\n    FileRead {\n        path: String,\n        #[source]\n        source: std::io::Error,\n    },\n}\n\n/// Statistics from an indexing operation.\n#[derive(Debug, Clone, Default)]\npub struct IndexStats {\n    /// Number of files discovered.\n    pub files_found: usize,\n    /// Number of notes indexed (new or updated).\n    pub notes_indexed: usize,\n    /// Number of notes skipped due to errors.\n    pub notes_skipped: usize,\n    /// Number of links indexed.\n    pub links_indexed: usize,\n    /// Number of broken links found.\n    pub broken_links: usize,\n    /// Indexing duration in milliseconds.\n    pub duration_ms: u64,\n    /// Number of files unchanged (hash match) - incremental mode only.\n    pub files_unchanged: usize,\n    /// Number of files added (new to index) - incremental mode only.\n    pub files_added: usize,\n    /// Number of files updated (content changed) - incremental mode only.\n    pub files_updated: usize,\n    /// Number of files deleted (removed from vault) - incremental mode only.\n    pub files_deleted: usize,\n}\n\n/// File change classification for incremental updates.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum FileChange {\n    /// File is new (not in index).\n    Added,\n    /// File content has changed.\n    Modified,\n    /// File content unchanged.\n    Unchanged,\n}\n\n/// Progress callback for indexing operations.\n/// Parameters: (current, total, current_path)\npub type ProgressCallback = Box\u003cdyn Fn(usize, usize, \u0026str)\u003e;\n\n/// Builder for populating the vault index.\npub struct IndexBuilder\u003c'a\u003e {\n    db: \u0026'a IndexDb,\n    vault_root: \u0026'a Path,\n}\n\nimpl\u003c'a\u003e IndexBuilder\u003c'a\u003e {\n    /// Create a new index builder.\n    pub fn new(db: \u0026'a IndexDb, vault_root: \u0026'a Path) -\u003e Self {\n        Self { db, vault_root }\n    }\n\n    /// Perform a full reindex of the vault.\n    /// Clears existing data and rebuilds from scratch.\n    pub fn full_reindex(\n        \u0026self,\n        progress: Option\u003cProgressCallback\u003e,\n    ) -\u003e Result\u003cIndexStats, BuilderError\u003e {\n        let start = std::time::Instant::now();\n        let mut stats = IndexStats::default();\n\n        // Walk the vault\n        let walker = VaultWalker::new(self.vault_root)?;\n        let files = walker.walk()?;\n        stats.files_found = files.len();\n\n        // Clear existing index\n        self.db.clear_all()?;\n\n        // Phase 1: Index all notes\n        for (i, file) in files.iter().enumerate() {\n            if let Some(ref cb) = progress {\n                cb(i + 1, files.len(), \u0026file.relative_path.to_string_lossy());\n            }\n\n            match self.index_note(file) {\n                Ok(link_count) =\u003e {\n                    stats.notes_indexed += 1;\n                    stats.links_indexed += link_count;\n                }\n                Err(e) =\u003e {\n                    // Log error but continue indexing\n                    tracing::warn!(\n                        \"Failed to index {}: {}\",\n                        file.relative_path.display(),\n                        e\n                    );\n                    stats.notes_skipped += 1;\n                }\n            }\n        }\n\n        // Phase 2: Resolve link targets\n        self.db.resolve_link_targets()?;\n        stats.broken_links = self.db.count_broken_links()? as usize;\n\n        stats.duration_ms = start.elapsed().as_millis() as u64;\n        Ok(stats)\n    }\n\n    /// Perform an incremental reindex of the vault.\n    /// Only processes files that have changed since last index.\n    pub fn incremental_reindex(\n        \u0026self,\n        progress: Option\u003cProgressCallback\u003e,\n    ) -\u003e Result\u003cIndexStats, BuilderError\u003e {\n        let start = std::time::Instant::now();\n        let mut stats = IndexStats::default();\n\n        // Phase 1: Walk the vault and collect all current files\n        let walker = VaultWalker::new(self.vault_root)?;\n        let files = walker.walk()?;\n        stats.files_found = files.len();\n\n        // Phase 2: Get all currently indexed paths for deletion detection\n        let indexed_paths: std::collections::HashSet\u003cstd::path::PathBuf\u003e =\n            self.db.get_all_paths()?.into_iter().collect();\n\n        // Track which paths we've seen in the vault\n        let mut seen_paths: std::collections::HashSet\u003cstd::path::PathBuf\u003e =\n            std::collections::HashSet::with_capacity(files.len());\n\n        // Phase 3: Classify and process each file\n        for (i, file) in files.iter().enumerate() {\n            if let Some(ref cb) = progress {\n                cb(i + 1, files.len(), \u0026file.relative_path.to_string_lossy());\n            }\n\n            seen_paths.insert(file.relative_path.clone());\n\n            // Classify the change\n            let change = self.classify_change(file)?;\n\n            match change {\n                FileChange::Unchanged =\u003e {\n                    stats.files_unchanged += 1;\n                }\n                FileChange::Added | FileChange::Modified =\u003e match self.index_note(file) {\n                    Ok(link_count) =\u003e {\n                        stats.notes_indexed += 1;\n                        stats.links_indexed += link_count;\n                        if change == FileChange::Added {\n                            stats.files_added += 1;\n                        } else {\n                            stats.files_updated += 1;\n                        }\n                    }\n                    Err(e) =\u003e {\n                        tracing::warn!(\n                            \"Failed to index {}: {}\",\n                            file.relative_path.display(),\n                            e\n                        );\n                        stats.notes_skipped += 1;\n                    }\n                },\n            }\n        }\n\n        // Phase 4: Detect and delete removed files\n        for indexed_path in \u0026indexed_paths {\n            if !seen_paths.contains(indexed_path) \u0026\u0026 self.db.delete_note(indexed_path)? {\n                stats.files_deleted += 1;\n                tracing::debug!(\"Deleted from index: {}\", indexed_path.display());\n            }\n        }\n\n        // Phase 5: Resolve link targets (handles newly valid links)\n        self.db.resolve_link_targets()?;\n        stats.broken_links = self.db.count_broken_links()? as usize;\n\n        stats.duration_ms = start.elapsed().as_millis() as u64;\n        Ok(stats)\n    }\n\n    /// Classify a file's change status by comparing content hashes.\n    fn classify_change(\u0026self, file: \u0026WalkedFile) -\u003e Result\u003cFileChange, BuilderError\u003e {\n        // Get stored hash (if any)\n        let stored_hash = self.db.get_content_hash(\u0026file.relative_path)?;\n\n        match stored_hash {\n            None =\u003e Ok(FileChange::Added),\n            Some(stored) =\u003e {\n                // Compute current hash\n                let current = content_hash(\u0026file.absolute_path).map_err(|e| {\n                    BuilderError::FileRead {\n                        path: file.absolute_path.display().to_string(),\n                        source: e,\n                    }\n                })?;\n\n                if current == stored {\n                    Ok(FileChange::Unchanged)\n                } else {\n                    Ok(FileChange::Modified)\n                }\n            }\n        }\n    }\n\n    /// Index a single note file.\n    /// Returns the number of links indexed.\n    fn index_note(\u0026self, file: \u0026WalkedFile) -\u003e Result\u003cusize, BuilderError\u003e {\n        // Read file content\n        let content = std::fs::read_to_string(\u0026file.absolute_path).map_err(|e| {\n            BuilderError::FileRead {\n                path: file.absolute_path.display().to_string(),\n                source: e,\n            }\n        })?;\n\n        // Compute content hash\n        let hash =\n            content_hash(\u0026file.absolute_path).map_err(|e| BuilderError::FileRead {\n                path: file.absolute_path.display().to_string(),\n                source: e,\n            })?;\n\n        // Extract note metadata\n        let extracted = extract_note(\u0026content, \u0026file.relative_path);\n\n        // Convert modified time to DateTime\u003cUtc\u003e\n        let modified: DateTime\u003cUtc\u003e = file.modified.into();\n\n        // Create indexed note\n        let note = IndexedNote {\n            id: None,\n            path: file.relative_path.clone(),\n            note_type: extracted.note_type,\n            title: extracted.title,\n            created: None, // Could extract from frontmatter if present\n            modified,\n            frontmatter_json: extracted.frontmatter_json,\n            content_hash: hash,\n        };\n\n        // Insert note and get ID\n        let note_id = self.db.upsert_note(\u0026note)?;\n\n        // Delete existing links for this note (in case of update)\n        self.db.delete_links_from(note_id)?;\n\n        // Insert links\n        let link_count = extracted.links.len();\n        for link in extracted.links {\n            let indexed_link = IndexedLink {\n                id: None,\n                source_id: note_id,\n                target_id: None, // Resolved in phase 2\n                target_path: link.target,\n                link_text: link.text,\n                link_type: link.link_type,\n                context: link.context,\n                line_number: Some(link.line_number),\n            };\n            self.db.insert_link(\u0026indexed_link)?;\n        }\n\n        Ok(link_count)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    fn create_test_vault() -\u003e TempDir {\n        let dir = TempDir::new().unwrap();\n        let root = dir.path();\n\n        // Create some markdown files with links\n        fs::write(\n            root.join(\"note1.md\"),\n            r#\"---\ntitle: Note One\ntype: zettel\n---\n# Note One\n\nThis links to [[note2]] and [[missing-note]].\n\"#,\n        )\n        .unwrap();\n\n        fs::write(\n            root.join(\"note2.md\"),\n            r#\"---\ntitle: Note Two\ntype: task\nproject: note1\n---\n# Note Two\n\nBack to [[note1]].\n\"#,\n        )\n        .unwrap();\n\n        fs::create_dir(root.join(\"subdir\")).unwrap();\n        fs::write(\n            root.join(\"subdir/note3.md\"),\n            r#\"# Note Three\n\nLinks to [Note One](../note1.md).\n\"#,\n        )\n        .unwrap();\n\n        dir\n    }\n\n    #[test]\n    fn test_full_reindex() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n        let stats = builder.full_reindex(None).unwrap();\n\n        assert_eq!(stats.files_found, 3);\n        assert_eq!(stats.notes_indexed, 3);\n        assert_eq!(stats.notes_skipped, 0);\n        assert!(stats.links_indexed \u003e= 4); // At least 4 links across all notes\n    }\n\n    #[test]\n    fn test_notes_are_indexed_correctly() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n        builder.full_reindex(None).unwrap();\n\n        // Check note1 is indexed\n        let note1 = db\n            .get_note_by_path(Path::new(\"note1.md\"))\n            .unwrap()\n            .expect(\"note1 should exist\");\n        assert_eq!(note1.title, \"Note One\");\n        assert_eq!(note1.note_type, crate::index::types::NoteType::Zettel);\n\n        // Check note2 is indexed\n        let note2 = db\n            .get_note_by_path(Path::new(\"note2.md\"))\n            .unwrap()\n            .expect(\"note2 should exist\");\n        assert_eq!(note2.title, \"Note Two\");\n        assert_eq!(note2.note_type, crate::index::types::NoteType::Task);\n    }\n\n    #[test]\n    fn test_links_are_indexed() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n        builder.full_reindex(None).unwrap();\n\n        let note1 = db\n            .get_note_by_path(Path::new(\"note1.md\"))\n            .unwrap()\n            .expect(\"note1 should exist\");\n\n        let outgoing = db.get_outgoing_links(note1.id.unwrap()).unwrap();\n        assert_eq!(outgoing.len(), 2); // [[note2]] and [[missing-note]]\n    }\n\n    #[test]\n    fn test_link_targets_resolved() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n        let stats = builder.full_reindex(None).unwrap();\n\n        // At least one broken link (missing-note)\n        assert!(stats.broken_links \u003e= 1);\n\n        // Check that existing links have target_id resolved\n        let note2 = db\n            .get_note_by_path(Path::new(\"note2.md\"))\n            .unwrap()\n            .expect(\"note2 should exist\");\n\n        let backlinks = db.get_backlinks(note2.id.unwrap()).unwrap();\n        // note1 links to note2\n        assert!(!backlinks.is_empty());\n    }\n\n    #[test]\n    fn test_reindex_clears_old_data() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        // Index twice\n        builder.full_reindex(None).unwrap();\n        let stats = builder.full_reindex(None).unwrap();\n\n        // Should still have same counts (not doubled)\n        assert_eq!(stats.notes_indexed, 3);\n        assert_eq!(db.count_notes().unwrap(), 3);\n    }\n\n    // \n    // Incremental reindex tests\n    // \n\n    #[test]\n    fn test_incremental_first_run() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        let stats = builder.incremental_reindex(None).unwrap();\n\n        assert_eq!(stats.files_found, 3);\n        assert_eq!(stats.files_added, 3);\n        assert_eq!(stats.files_unchanged, 0);\n        assert_eq!(stats.files_updated, 0);\n        assert_eq!(stats.files_deleted, 0);\n        assert_eq!(stats.notes_indexed, 3);\n    }\n\n    #[test]\n    fn test_incremental_no_changes() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        builder.incremental_reindex(None).unwrap();\n        let stats = builder.incremental_reindex(None).unwrap();\n\n        assert_eq!(stats.files_found, 3);\n        assert_eq!(stats.files_unchanged, 3);\n        assert_eq!(stats.files_added, 0);\n        assert_eq!(stats.files_updated, 0);\n        assert_eq!(stats.files_deleted, 0);\n        assert_eq!(stats.notes_indexed, 0);\n    }\n\n    #[test]\n    fn test_incremental_file_modified() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        builder.incremental_reindex(None).unwrap();\n\n        // Modify a file\n        fs::write(vault.path().join(\"note1.md\"), \"# Note 1 Modified\\n\\nNew content.\")\n            .unwrap();\n\n        let stats = builder.incremental_reindex(None).unwrap();\n\n        assert_eq!(stats.files_unchanged, 2);\n        assert_eq!(stats.files_updated, 1);\n        assert_eq!(stats.files_added, 0);\n        assert_eq!(stats.notes_indexed, 1);\n    }\n\n    #[test]\n    fn test_incremental_file_added() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        builder.incremental_reindex(None).unwrap();\n\n        // Add a new file\n        fs::write(vault.path().join(\"note4.md\"), \"# Note 4\\n\\nBrand new note.\").unwrap();\n\n        let stats = builder.incremental_reindex(None).unwrap();\n\n        assert_eq!(stats.files_found, 4);\n        assert_eq!(stats.files_unchanged, 3);\n        assert_eq!(stats.files_added, 1);\n        assert_eq!(stats.files_updated, 0);\n        assert_eq!(stats.notes_indexed, 1);\n    }\n\n    #[test]\n    fn test_incremental_file_deleted() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        builder.incremental_reindex(None).unwrap();\n\n        // Delete a file\n        fs::remove_file(vault.path().join(\"note2.md\")).unwrap();\n\n        let stats = builder.incremental_reindex(None).unwrap();\n\n        assert_eq!(stats.files_found, 2);\n        assert_eq!(stats.files_deleted, 1);\n        assert_eq!(stats.files_unchanged, 2);\n\n        // Verify it's gone from the index\n        assert!(db.get_note_by_path(Path::new(\"note2.md\")).unwrap().is_none());\n        assert_eq!(db.count_notes().unwrap(), 2);\n    }\n\n    #[test]\n    fn test_incremental_links_updated_on_change() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        builder.incremental_reindex(None).unwrap();\n\n        let note1 = db.get_note_by_path(Path::new(\"note1.md\")).unwrap().unwrap();\n        let links_before = db.get_outgoing_links(note1.id.unwrap()).unwrap();\n        assert_eq!(links_before.len(), 2); // [[note2]] and [[missing-note]]\n\n        // Modify to have different links\n        fs::write(vault.path().join(\"note1.md\"), \"# Note 1\\n\\n[[note3]] only now.\")\n            .unwrap();\n        builder.incremental_reindex(None).unwrap();\n\n        let note1 = db.get_note_by_path(Path::new(\"note1.md\")).unwrap().unwrap();\n        let links_after = db.get_outgoing_links(note1.id.unwrap()).unwrap();\n        assert_eq!(links_after.len(), 1);\n        assert_eq!(links_after[0].target_path, \"note3\");\n    }\n\n    #[test]\n    fn test_incremental_broken_links_resolved() {\n        let vault = create_test_vault();\n        let db = IndexDb::open_in_memory().unwrap();\n        let builder = IndexBuilder::new(\u0026db, vault.path());\n\n        // note1 links to note2 and missing-note\n        let stats1 = builder.incremental_reindex(None).unwrap();\n        assert!(stats1.broken_links \u003e 0); // missing-note is broken\n\n        // Now create the missing note\n        fs::write(vault.path().join(\"missing-note.md\"), \"# Missing Note\\n\\nNow exists!\")\n            .unwrap();\n\n        let stats2 = builder.incremental_reindex(None).unwrap();\n        assert_eq!(stats2.files_added, 1);\n\n        // The link to missing-note should now be resolved\n        let missing = db.get_note_by_path(Path::new(\"missing-note.md\")).unwrap().unwrap();\n        let backlinks = db.get_backlinks(missing.id.unwrap()).unwrap();\n        assert!(!backlinks.is_empty());\n    }\n}\n","traces":[{"line":78,"address":[],"length":0,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":12}},{"line":89,"address":[],"length":0,"stats":{"Line":12}},{"line":92,"address":[],"length":0,"stats":{"Line":18}},{"line":93,"address":[],"length":0,"stats":{"Line":18}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":12}},{"line":100,"address":[],"length":0,"stats":{"Line":48}},{"line":101,"address":[],"length":0,"stats":{"Line":18}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":36}},{"line":106,"address":[],"length":0,"stats":{"Line":36}},{"line":107,"address":[],"length":0,"stats":{"Line":18}},{"line":108,"address":[],"length":0,"stats":{"Line":18}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":12}},{"line":124,"address":[],"length":0,"stats":{"Line":12}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":13}},{"line":136,"address":[],"length":0,"stats":{"Line":26}},{"line":137,"address":[],"length":0,"stats":{"Line":26}},{"line":140,"address":[],"length":0,"stats":{"Line":39}},{"line":141,"address":[],"length":0,"stats":{"Line":39}},{"line":142,"address":[],"length":0,"stats":{"Line":13}},{"line":145,"address":[],"length":0,"stats":{"Line":26}},{"line":146,"address":[],"length":0,"stats":{"Line":52}},{"line":149,"address":[],"length":0,"stats":{"Line":26}},{"line":150,"address":[],"length":0,"stats":{"Line":39}},{"line":153,"address":[],"length":0,"stats":{"Line":106}},{"line":154,"address":[],"length":0,"stats":{"Line":40}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":160}},{"line":161,"address":[],"length":0,"stats":{"Line":160}},{"line":163,"address":[],"length":0,"stats":{"Line":40}},{"line":164,"address":[],"length":0,"stats":{"Line":15}},{"line":165,"address":[],"length":0,"stats":{"Line":15}},{"line":167,"address":[],"length":0,"stats":{"Line":50}},{"line":168,"address":[],"length":0,"stats":{"Line":25}},{"line":169,"address":[],"length":0,"stats":{"Line":25}},{"line":170,"address":[],"length":0,"stats":{"Line":25}},{"line":171,"address":[],"length":0,"stats":{"Line":48}},{"line":172,"address":[],"length":0,"stats":{"Line":23}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":49}},{"line":191,"address":[],"length":0,"stats":{"Line":39}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":26}},{"line":199,"address":[],"length":0,"stats":{"Line":26}},{"line":201,"address":[],"length":0,"stats":{"Line":13}},{"line":202,"address":[],"length":0,"stats":{"Line":13}},{"line":206,"address":[],"length":0,"stats":{"Line":40}},{"line":208,"address":[],"length":0,"stats":{"Line":160}},{"line":210,"address":[],"length":0,"stats":{"Line":40}},{"line":211,"address":[],"length":0,"stats":{"Line":23}},{"line":212,"address":[],"length":0,"stats":{"Line":17}},{"line":214,"address":[],"length":0,"stats":{"Line":68}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":17}},{"line":222,"address":[],"length":0,"stats":{"Line":15}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":43}},{"line":234,"address":[],"length":0,"stats":{"Line":172}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":43}},{"line":243,"address":[],"length":0,"stats":{"Line":129}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":172}},{"line":252,"address":[],"length":0,"stats":{"Line":172}},{"line":257,"address":[],"length":0,"stats":{"Line":129}},{"line":258,"address":[],"length":0,"stats":{"Line":86}},{"line":259,"address":[],"length":0,"stats":{"Line":86}},{"line":262,"address":[],"length":0,"stats":{"Line":43}},{"line":267,"address":[],"length":0,"stats":{"Line":172}},{"line":270,"address":[],"length":0,"stats":{"Line":129}},{"line":273,"address":[],"length":0,"stats":{"Line":129}},{"line":274,"address":[],"length":0,"stats":{"Line":175}},{"line":279,"address":[],"length":0,"stats":{"Line":132}},{"line":280,"address":[],"length":0,"stats":{"Line":132}},{"line":281,"address":[],"length":0,"stats":{"Line":132}},{"line":282,"address":[],"length":0,"stats":{"Line":66}},{"line":283,"address":[],"length":0,"stats":{"Line":66}},{"line":285,"address":[],"length":0,"stats":{"Line":198}},{"line":288,"address":[],"length":0,"stats":{"Line":43}}],"covered":80,"coverable":102},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","db.rs"],"content":"//! Database connection and operations.\n\nuse std::path::Path;\n\nuse rusqlite::{Connection, OptionalExtension, params};\nuse thiserror::Error;\n\nuse super::schema::{SchemaError, init_schema};\nuse super::types::{IndexedLink, IndexedNote, LinkType, NoteQuery, NoteType};\n\n#[derive(Debug, Error)]\npub enum IndexError {\n    #[error(\"Database error: {0}\")]\n    Database(#[from] rusqlite::Error),\n\n    #[error(\"Schema error: {0}\")]\n    Schema(#[from] SchemaError),\n\n    #[error(\"Note not found: {0}\")]\n    NoteNotFound(String),\n\n    #[error(\"Invalid data: {0}\")]\n    InvalidData(String),\n}\n\n/// Vault index database handle.\npub struct IndexDb {\n    conn: Connection,\n}\n\nimpl IndexDb {\n    /// Open or create an index database at the given path.\n    pub fn open(path: \u0026Path) -\u003e Result\u003cSelf, IndexError\u003e {\n        let conn = Connection::open(path)?;\n        conn.execute_batch(\n            \"PRAGMA journal_mode = WAL;\n             PRAGMA foreign_keys = ON;\n             PRAGMA busy_timeout = 5000;\",\n        )?;\n        init_schema(\u0026conn)?;\n        Ok(Self { conn })\n    }\n\n    /// Create an in-memory database (for testing).\n    pub fn open_in_memory() -\u003e Result\u003cSelf, IndexError\u003e {\n        let conn = Connection::open_in_memory()?;\n        conn.execute_batch(\"PRAGMA foreign_keys = ON;\")?;\n        init_schema(\u0026conn)?;\n        Ok(Self { conn })\n    }\n\n    /// Get the underlying connection (for transactions).\n    pub fn connection(\u0026self) -\u003e \u0026Connection {\n        \u0026self.conn\n    }\n\n    // \n    // Notes CRUD\n    // \n\n    /// Insert a new note into the index.\n    pub fn insert_note(\u0026self, note: \u0026IndexedNote) -\u003e Result\u003ci64, IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO notes (path, note_type, title, created_at, modified_at, frontmatter_json, content_hash)\n             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)\",\n            params![\n                note.path.to_string_lossy(),\n                note.note_type.as_str(),\n                note.title,\n                note.created.map(|d| d.to_rfc3339()),\n                note.modified.to_rfc3339(),\n                note.frontmatter_json,\n                note.content_hash,\n            ],\n        )?;\n        Ok(self.conn.last_insert_rowid())\n    }\n\n    /// Update an existing note in the index.\n    pub fn update_note(\u0026self, note: \u0026IndexedNote) -\u003e Result\u003c(), IndexError\u003e {\n        let id = note.id.ok_or_else(|| {\n            IndexError::InvalidData(\"Note must have an ID for update\".to_string())\n        })?;\n\n        let rows = self.conn.execute(\n            \"UPDATE notes SET\n                path = ?1, note_type = ?2, title = ?3,\n                created_at = ?4, modified_at = ?5,\n                frontmatter_json = ?6, content_hash = ?7\n             WHERE id = ?8\",\n            params![\n                note.path.to_string_lossy(),\n                note.note_type.as_str(),\n                note.title,\n                note.created.map(|d| d.to_rfc3339()),\n                note.modified.to_rfc3339(),\n                note.frontmatter_json,\n                note.content_hash,\n                id,\n            ],\n        )?;\n\n        if rows == 0 {\n            return Err(IndexError::NoteNotFound(format!(\"ID {}\", id)));\n        }\n        Ok(())\n    }\n\n    /// Upsert a note (insert or update based on path).\n    pub fn upsert_note(\u0026self, note: \u0026IndexedNote) -\u003e Result\u003ci64, IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO notes (path, note_type, title, created_at, modified_at, frontmatter_json, content_hash)\n             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)\n             ON CONFLICT(path) DO UPDATE SET\n                note_type = excluded.note_type,\n                title = excluded.title,\n                created_at = excluded.created_at,\n                modified_at = excluded.modified_at,\n                frontmatter_json = excluded.frontmatter_json,\n                content_hash = excluded.content_hash\",\n            params![\n                note.path.to_string_lossy(),\n                note.note_type.as_str(),\n                note.title,\n                note.created.map(|d| d.to_rfc3339()),\n                note.modified.to_rfc3339(),\n                note.frontmatter_json,\n                note.content_hash,\n            ],\n        )?;\n\n        // Get the ID (either new or existing)\n        let id: i64 = self.conn.query_row(\n            \"SELECT id FROM notes WHERE path = ?1\",\n            [note.path.to_string_lossy()],\n            |row| row.get(0),\n        )?;\n\n        Ok(id)\n    }\n\n    /// Get a note by its path.\n    pub fn get_note_by_path(\n        \u0026self,\n        path: \u0026Path,\n    ) -\u003e Result\u003cOption\u003cIndexedNote\u003e, IndexError\u003e {\n        self.conn\n            .query_row(\n                \"SELECT id, path, note_type, title, created_at, modified_at, frontmatter_json, content_hash\n                 FROM notes WHERE path = ?1\",\n                [path.to_string_lossy()],\n                Self::row_to_note,\n            )\n            .optional()\n            .map_err(Into::into)\n    }\n\n    /// Get a note by its ID.\n    pub fn get_note_by_id(\u0026self, id: i64) -\u003e Result\u003cOption\u003cIndexedNote\u003e, IndexError\u003e {\n        self.conn\n            .query_row(\n                \"SELECT id, path, note_type, title, created_at, modified_at, frontmatter_json, content_hash\n                 FROM notes WHERE id = ?1\",\n                [id],\n                Self::row_to_note,\n            )\n            .optional()\n            .map_err(Into::into)\n    }\n\n    /// Query notes with filters.\n    pub fn query_notes(\u0026self, query: \u0026NoteQuery) -\u003e Result\u003cVec\u003cIndexedNote\u003e, IndexError\u003e {\n        let mut sql = String::from(\n            \"SELECT id, path, note_type, title, created_at, modified_at, frontmatter_json, content_hash\n             FROM notes WHERE 1=1\",\n        );\n        let mut params_vec: Vec\u003cBox\u003cdyn rusqlite::ToSql\u003e\u003e = Vec::new();\n\n        if let Some(note_type) = \u0026query.note_type {\n            sql.push_str(\" AND note_type = ?\");\n            params_vec.push(Box::new(note_type.as_str().to_string()));\n        }\n\n        if let Some(prefix) = \u0026query.path_prefix {\n            sql.push_str(\" AND path LIKE ?\");\n            params_vec.push(Box::new(format!(\"{}%\", prefix.to_string_lossy())));\n        }\n\n        if let Some(after) = \u0026query.modified_after {\n            sql.push_str(\" AND modified_at \u003e= ?\");\n            params_vec.push(Box::new(after.to_rfc3339()));\n        }\n\n        if let Some(before) = \u0026query.modified_before {\n            sql.push_str(\" AND modified_at \u003c= ?\");\n            params_vec.push(Box::new(before.to_rfc3339()));\n        }\n\n        sql.push_str(\" ORDER BY modified_at DESC\");\n\n        if let Some(limit) = query.limit {\n            sql.push_str(\u0026format!(\" LIMIT {}\", limit));\n        }\n\n        if let Some(offset) = query.offset {\n            sql.push_str(\u0026format!(\" OFFSET {}\", offset));\n        }\n\n        let params_refs: Vec\u003c\u0026dyn rusqlite::ToSql\u003e =\n            params_vec.iter().map(|p| p.as_ref()).collect();\n\n        let mut stmt = self.conn.prepare(\u0026sql)?;\n        let notes = stmt\n            .query_map(params_refs.as_slice(), Self::row_to_note)?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(notes)\n    }\n\n    /// Delete a note by path (also deletes associated links via CASCADE).\n    pub fn delete_note(\u0026self, path: \u0026Path) -\u003e Result\u003cbool, IndexError\u003e {\n        let rows = self\n            .conn\n            .execute(\"DELETE FROM notes WHERE path = ?1\", [path.to_string_lossy()])?;\n        Ok(rows \u003e 0)\n    }\n\n    /// Get content hash for a note path (for change detection).\n    pub fn get_content_hash(\u0026self, path: \u0026Path) -\u003e Result\u003cOption\u003cString\u003e, IndexError\u003e {\n        self.conn\n            .query_row(\n                \"SELECT content_hash FROM notes WHERE path = ?1\",\n                [path.to_string_lossy()],\n                |row| row.get(0),\n            )\n            .optional()\n            .map_err(Into::into)\n    }\n\n    /// Get all indexed note paths (for detecting deletions during incremental reindex).\n    pub fn get_all_paths(\u0026self) -\u003e Result\u003cVec\u003cstd::path::PathBuf\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\"SELECT path FROM notes\")?;\n        let paths = stmt\n            .query_map([], |row| {\n                let path_str: String = row.get(0)?;\n                Ok(std::path::PathBuf::from(path_str))\n            })?\n            .filter_map(|r| r.ok())\n            .collect();\n        Ok(paths)\n    }\n\n    fn row_to_note(row: \u0026rusqlite::Row) -\u003e Result\u003cIndexedNote, rusqlite::Error\u003e {\n        let path_str: String = row.get(1)?;\n        let type_str: String = row.get(2)?;\n        let created_str: Option\u003cString\u003e = row.get(4)?;\n        let modified_str: String = row.get(5)?;\n\n        Ok(IndexedNote {\n            id: Some(row.get(0)?),\n            path: path_str.into(),\n            note_type: type_str.parse().unwrap(),\n            title: row.get(3)?,\n            created: created_str.and_then(|s| {\n                chrono::DateTime::parse_from_rfc3339(\u0026s)\n                    .ok()\n                    .map(|d| d.with_timezone(\u0026chrono::Utc))\n            }),\n            modified: chrono::DateTime::parse_from_rfc3339(\u0026modified_str)\n                .map(|d| d.with_timezone(\u0026chrono::Utc))\n                .unwrap_or_else(|_| chrono::Utc::now()),\n            frontmatter_json: row.get(6)?,\n            content_hash: row.get(7)?,\n        })\n    }\n\n    // \n    // Links CRUD\n    // \n\n    /// Insert a link between notes.\n    pub fn insert_link(\u0026self, link: \u0026IndexedLink) -\u003e Result\u003ci64, IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO links (source_id, target_id, target_path, link_text, link_type, context, line_number)\n             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)\",\n            params![\n                link.source_id,\n                link.target_id,\n                link.target_path,\n                link.link_text,\n                link.link_type.as_str(),\n                link.context,\n                link.line_number,\n            ],\n        )?;\n        Ok(self.conn.last_insert_rowid())\n    }\n\n    /// Delete all links from a source note.\n    pub fn delete_links_from(\u0026self, source_id: i64) -\u003e Result\u003cusize, IndexError\u003e {\n        let rows =\n            self.conn.execute(\"DELETE FROM links WHERE source_id = ?1\", [source_id])?;\n        Ok(rows)\n    }\n\n    /// Get outgoing links from a note.\n    pub fn get_outgoing_links(\n        \u0026self,\n        source_id: i64,\n    ) -\u003e Result\u003cVec\u003cIndexedLink\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT id, source_id, target_id, target_path, link_text, link_type, context, line_number\n             FROM links WHERE source_id = ?1\",\n        )?;\n\n        let links = stmt\n            .query_map([source_id], Self::row_to_link)?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(links)\n    }\n\n    /// Get incoming links (backlinks) to a note.\n    pub fn get_backlinks(\u0026self, target_id: i64) -\u003e Result\u003cVec\u003cIndexedLink\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT id, source_id, target_id, target_path, link_text, link_type, context, line_number\n             FROM links WHERE target_id = ?1\",\n        )?;\n\n        let links = stmt\n            .query_map([target_id], Self::row_to_link)?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(links)\n    }\n\n    /// Find orphan notes (no incoming links).\n    pub fn find_orphans(\u0026self) -\u003e Result\u003cVec\u003cIndexedNote\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT n.id, n.path, n.note_type, n.title, n.created_at, n.modified_at, n.frontmatter_json, n.content_hash\n             FROM notes n\n             LEFT JOIN links l ON l.target_id = n.id\n             WHERE l.id IS NULL\",\n        )?;\n\n        let notes =\n            stmt.query_map([], Self::row_to_note)?.filter_map(|r| r.ok()).collect();\n\n        Ok(notes)\n    }\n\n    /// Resolve target_id for links by matching target_path to notes.\n    /// Returns the number of links that were successfully resolved.\n    pub fn resolve_link_targets(\u0026self) -\u003e Result\u003cusize, IndexError\u003e {\n        self.conn.execute(\n            \"UPDATE links SET target_id = (\n                SELECT n.id FROM notes n\n                WHERE links.target_path = n.path\n                   OR links.target_path || '.md' = n.path\n                   OR links.target_path = REPLACE(n.path, '.md', '')\n             )\n             WHERE target_id IS NULL\",\n            [],\n        )?;\n\n        // Count how many links now have a resolved target\n        let resolved: i64 = self.conn.query_row(\n            \"SELECT COUNT(*) FROM links WHERE target_id IS NOT NULL\",\n            [],\n            |row| row.get(0),\n        )?;\n        Ok(resolved as usize)\n    }\n\n    /// Count links that have no resolved target (broken links).\n    pub fn count_broken_links(\u0026self) -\u003e Result\u003ci64, IndexError\u003e {\n        let count: i64 = self.conn.query_row(\n            \"SELECT COUNT(*) FROM links WHERE target_id IS NULL\",\n            [],\n            |row| row.get(0),\n        )?;\n        Ok(count)\n    }\n\n    fn row_to_link(row: \u0026rusqlite::Row) -\u003e Result\u003cIndexedLink, rusqlite::Error\u003e {\n        let type_str: String = row.get(5)?;\n        Ok(IndexedLink {\n            id: Some(row.get(0)?),\n            source_id: row.get(1)?,\n            target_id: row.get(2)?,\n            target_path: row.get(3)?,\n            link_text: row.get(4)?,\n            link_type: LinkType::parse(\u0026type_str).unwrap_or(LinkType::Wikilink),\n            context: row.get(6)?,\n            line_number: row.get(7)?,\n        })\n    }\n\n    // \n    // Statistics\n    // \n\n    /// Get count of notes by type.\n    pub fn count_by_type(\u0026self) -\u003e Result\u003cVec\u003c(NoteType, i64)\u003e, IndexError\u003e {\n        let mut stmt = self\n            .conn\n            .prepare(\"SELECT note_type, COUNT(*) FROM notes GROUP BY note_type\")?;\n\n        let counts = stmt\n            .query_map([], |row| {\n                let type_str: String = row.get(0)?;\n                let count: i64 = row.get(1)?;\n                Ok((type_str.parse().unwrap(), count))\n            })?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(counts)\n    }\n\n    /// Get total note count.\n    pub fn count_notes(\u0026self) -\u003e Result\u003ci64, IndexError\u003e {\n        let count: i64 =\n            self.conn.query_row(\"SELECT COUNT(*) FROM notes\", [], |row| row.get(0))?;\n        Ok(count)\n    }\n\n    /// Get total link count.\n    pub fn count_links(\u0026self) -\u003e Result\u003ci64, IndexError\u003e {\n        let count: i64 =\n            self.conn.query_row(\"SELECT COUNT(*) FROM links\", [], |row| row.get(0))?;\n        Ok(count)\n    }\n\n    /// Clear all data from the index (for full reindex).\n    pub fn clear_all(\u0026self) -\u003e Result\u003c(), IndexError\u003e {\n        self.conn.execute_batch(\n            \"DELETE FROM links;\n             DELETE FROM temporal_activity;\n             DELETE FROM activity_summary;\n             DELETE FROM note_cooccurrence;\n             DELETE FROM notes;\",\n        )?;\n        Ok(())\n    }\n\n    // \n    // Derived Index Operations\n    // \n\n    /// Clear derived tables (temporal_activity, activity_summary, note_cooccurrence).\n    pub fn clear_derived_tables(\u0026self) -\u003e Result\u003c(), IndexError\u003e {\n        self.conn.execute_batch(\n            \"DELETE FROM temporal_activity;\n             DELETE FROM activity_summary;\n             DELETE FROM note_cooccurrence;\",\n        )?;\n        Ok(())\n    }\n\n    /// Get notes filtered by type.\n    pub fn get_notes_by_type(\n        \u0026self,\n        type_str: \u0026str,\n    ) -\u003e Result\u003cVec\u003cIndexedNote\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT id, path, note_type, title, created_at, modified_at, frontmatter_json, content_hash\n             FROM notes WHERE note_type = ?1\",\n        )?;\n\n        let notes = stmt\n            .query_map([type_str], Self::row_to_note)?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(notes)\n    }\n\n    /// Count temporal activity records.\n    pub fn count_temporal_activity(\u0026self) -\u003e Result\u003ci64, IndexError\u003e {\n        let count: i64 =\n            self.conn.query_row(\"SELECT COUNT(*) FROM temporal_activity\", [], |row| {\n                row.get(0)\n            })?;\n        Ok(count)\n    }\n\n    /// Insert a temporal activity record.\n    pub fn insert_temporal_activity(\n        \u0026self,\n        note_id: i64,\n        daily_id: i64,\n        activity_date: \u0026str,\n        context: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003ci64, IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO temporal_activity (note_id, daily_id, activity_date, context)\n             VALUES (?1, ?2, ?3, ?4)\",\n            params![note_id, daily_id, activity_date, context],\n        )?;\n        Ok(self.conn.last_insert_rowid())\n    }\n\n    /// Aggregate activity data for computing summaries.\n    ///\n    /// Returns aggregated activity counts for each note that has temporal activity.\n    pub fn aggregate_activity(\n        \u0026self,\n        thirty_days_ago: \u0026str,\n        ninety_days_ago: \u0026str,\n    ) -\u003e Result\u003cVec\u003csuper::types::AggregateActivity\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT\n                note_id,\n                MAX(activity_date) as last_seen,\n                SUM(CASE WHEN activity_date \u003e= ?1 THEN 1 ELSE 0 END) as count_30d,\n                SUM(CASE WHEN activity_date \u003e= ?2 THEN 1 ELSE 0 END) as count_90d\n             FROM temporal_activity\n             GROUP BY note_id\",\n        )?;\n\n        let results = stmt\n            .query_map([thirty_days_ago, ninety_days_ago], |row| {\n                Ok(super::types::AggregateActivity {\n                    note_id: row.get(0)?,\n                    last_seen: row.get(1)?,\n                    access_count_30d: row.get(2)?,\n                    access_count_90d: row.get(3)?,\n                })\n            })?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(results)\n    }\n\n    /// Upsert an activity summary for a note.\n    pub fn upsert_activity_summary(\n        \u0026self,\n        note_id: i64,\n        last_seen: Option\u003c\u0026str\u003e,\n        access_count_30d: i32,\n        access_count_90d: i32,\n        staleness_score: f64,\n    ) -\u003e Result\u003c(), IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO activity_summary (note_id, last_seen, access_count_30d, access_count_90d, staleness_score)\n             VALUES (?1, ?2, ?3, ?4, ?5)\n             ON CONFLICT(note_id) DO UPDATE SET\n                last_seen = excluded.last_seen,\n                access_count_30d = excluded.access_count_30d,\n                access_count_90d = excluded.access_count_90d,\n                staleness_score = excluded.staleness_score\",\n            params![note_id, last_seen, access_count_30d, access_count_90d, staleness_score],\n        )?;\n        Ok(())\n    }\n\n    /// Compute cooccurrence pairs from temporal activity.\n    ///\n    /// Finds pairs of notes that are referenced in the same daily notes.\n    pub fn compute_cooccurrence_pairs(\n        \u0026self,\n    ) -\u003e Result\u003cVec\u003csuper::types::CooccurrencePair\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT\n                a.note_id as note_a,\n                b.note_id as note_b,\n                COUNT(DISTINCT a.daily_id) as shared_count,\n                MAX(a.activity_date) as most_recent\n             FROM temporal_activity a\n             JOIN temporal_activity b ON a.daily_id = b.daily_id\n             WHERE a.note_id \u003c b.note_id\n             GROUP BY a.note_id, b.note_id\n             HAVING shared_count \u003e 0\",\n        )?;\n\n        let pairs = stmt\n            .query_map([], |row| {\n                Ok(super::types::CooccurrencePair {\n                    note_a_id: row.get(0)?,\n                    note_b_id: row.get(1)?,\n                    shared_count: row.get(2)?,\n                    most_recent: row.get(3)?,\n                })\n            })?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(pairs)\n    }\n\n    /// Upsert a note cooccurrence record.\n    pub fn upsert_cooccurrence(\n        \u0026self,\n        note_a: i64,\n        note_b: i64,\n        shared_count: i32,\n        most_recent: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003c(), IndexError\u003e {\n        self.conn.execute(\n            \"INSERT INTO note_cooccurrence (note_a_id, note_b_id, shared_daily_count, most_recent)\n             VALUES (?1, ?2, ?3, ?4)\n             ON CONFLICT(note_a_id, note_b_id) DO UPDATE SET\n                shared_daily_count = excluded.shared_daily_count,\n                most_recent = excluded.most_recent\",\n            params![note_a, note_b, shared_count, most_recent],\n        )?;\n        Ok(())\n    }\n\n    /// Get activity summary for a note.\n    pub fn get_activity_summary(\n        \u0026self,\n        note_id: i64,\n    ) -\u003e Result\u003cOption\u003csuper::types::ActivitySummary\u003e, IndexError\u003e {\n        self.conn\n            .query_row(\n                \"SELECT note_id, last_seen, access_count_30d, access_count_90d, staleness_score\n                 FROM activity_summary WHERE note_id = ?1\",\n                [note_id],\n                |row| {\n                    let last_seen_str: Option\u003cString\u003e = row.get(1)?;\n                    Ok(super::types::ActivitySummary {\n                        note_id: row.get(0)?,\n                        last_seen: last_seen_str.and_then(|s| {\n                            chrono::NaiveDate::parse_from_str(\u0026s, \"%Y-%m-%d\").ok()\n                        }),\n                        access_count_30d: row.get::\u003c_, i32\u003e(2)? as u32,\n                        access_count_90d: row.get::\u003c_, i32\u003e(3)? as u32,\n                        staleness_score: row.get(4)?,\n                    })\n                },\n            )\n            .optional()\n            .map_err(Into::into)\n    }\n\n    /// Get cooccurrent notes for a given note.\n    ///\n    /// Returns notes that frequently appear together with the given note in dailies.\n    pub fn get_cooccurrent_notes(\n        \u0026self,\n        note_id: i64,\n        limit: u32,\n    ) -\u003e Result\u003cVec\u003c(IndexedNote, i32)\u003e, IndexError\u003e {\n        let mut stmt = self.conn.prepare(\n            \"SELECT n.id, n.path, n.note_type, n.title, n.created_at, n.modified_at,\n                    n.frontmatter_json, n.content_hash, c.shared_daily_count\n             FROM note_cooccurrence c\n             JOIN notes n ON (\n                 CASE WHEN c.note_a_id = ?1 THEN c.note_b_id ELSE c.note_a_id END = n.id\n             )\n             WHERE c.note_a_id = ?1 OR c.note_b_id = ?1\n             ORDER BY c.shared_daily_count DESC\n             LIMIT ?2\",\n        )?;\n\n        let results = stmt\n            .query_map(params![note_id, limit], |row| {\n                let note = Self::row_to_note(row)?;\n                let count: i32 = row.get(8)?;\n                Ok((note, count))\n            })?\n            .filter_map(|r| r.ok())\n            .collect();\n\n        Ok(results)\n    }\n\n    /// Get stale notes (high staleness score).\n    ///\n    /// Returns notes ordered by staleness score descending.\n    pub fn get_stale_notes(\n        \u0026self,\n        min_staleness: f64,\n        note_type: Option\u003c\u0026str\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e Result\u003cVec\u003c(IndexedNote, f64)\u003e, IndexError\u003e {\n        let mut sql = String::from(\n            \"SELECT n.id, n.path, n.note_type, n.title, n.created_at, n.modified_at,\n                    n.frontmatter_json, n.content_hash, s.staleness_score\n             FROM notes n\n             LEFT JOIN activity_summary s ON n.id = s.note_id\n             WHERE COALESCE(s.staleness_score, 1.0) \u003e= ?1\",\n        );\n\n        if note_type.is_some() {\n            sql.push_str(\" AND n.note_type = ?2\");\n        }\n\n        sql.push_str(\" ORDER BY COALESCE(s.staleness_score, 1.0) DESC\");\n\n        if let Some(limit) = limit {\n            sql.push_str(\u0026format!(\" LIMIT {}\", limit));\n        }\n\n        let mut stmt = self.conn.prepare(\u0026sql)?;\n\n        let results = if let Some(nt) = note_type {\n            stmt.query_map(params![min_staleness, nt], |row| {\n                let note = Self::row_to_note(row)?;\n                let staleness: Option\u003cf64\u003e = row.get(8)?;\n                Ok((note, staleness.unwrap_or(1.0)))\n            })?\n            .filter_map(|r| r.ok())\n            .collect()\n        } else {\n            stmt.query_map([min_staleness], |row| {\n                let note = Self::row_to_note(row)?;\n                let staleness: Option\u003cf64\u003e = row.get(8)?;\n                Ok((note, staleness.unwrap_or(1.0)))\n            })?\n            .filter_map(|r| r.ok())\n            .collect()\n        };\n\n        Ok(results)\n    }\n\n    /// Get notes not seen in a number of days.\n    pub fn get_notes_not_seen_in_days(\n        \u0026self,\n        days: u32,\n        note_type: Option\u003c\u0026str\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e Result\u003cVec\u003c(IndexedNote, Option\u003cString\u003e)\u003e, IndexError\u003e {\n        let cutoff_date = (chrono::Utc::now() - chrono::Duration::days(days as i64))\n            .format(\"%Y-%m-%d\")\n            .to_string();\n\n        let mut sql = String::from(\n            \"SELECT n.id, n.path, n.note_type, n.title, n.created_at, n.modified_at,\n                    n.frontmatter_json, n.content_hash, s.last_seen\n             FROM notes n\n             LEFT JOIN activity_summary s ON n.id = s.note_id\n             WHERE s.last_seen IS NULL OR s.last_seen \u003c ?1\",\n        );\n\n        if note_type.is_some() {\n            sql.push_str(\" AND n.note_type = ?2\");\n        }\n\n        sql.push_str(\" ORDER BY s.last_seen ASC NULLS FIRST\");\n\n        if let Some(limit) = limit {\n            sql.push_str(\u0026format!(\" LIMIT {}\", limit));\n        }\n\n        let mut stmt = self.conn.prepare(\u0026sql)?;\n\n        let results = if let Some(nt) = note_type {\n            stmt.query_map(params![\u0026cutoff_date, nt], |row| {\n                let note = Self::row_to_note(row)?;\n                let last_seen: Option\u003cString\u003e = row.get(8)?;\n                Ok((note, last_seen))\n            })?\n            .filter_map(|r| r.ok())\n            .collect()\n        } else {\n            stmt.query_map([\u0026cutoff_date], |row| {\n                let note = Self::row_to_note(row)?;\n                let last_seen: Option\u003cString\u003e = row.get(8)?;\n                Ok((note, last_seen))\n            })?\n            .filter_map(|r| r.ok())\n            .collect()\n        };\n\n        Ok(results)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::Utc;\n    use std::path::PathBuf;\n\n    fn sample_note(path: \u0026str) -\u003e IndexedNote {\n        IndexedNote {\n            id: None,\n            path: PathBuf::from(path),\n            note_type: NoteType::Zettel,\n            title: \"Test Note\".to_string(),\n            created: Some(Utc::now()),\n            modified: Utc::now(),\n            frontmatter_json: Some(r#\"{\"tags\": [\"test\"]}\"#.to_string()),\n            content_hash: \"abc123\".to_string(),\n        }\n    }\n\n    #[test]\n    fn test_insert_and_get_note() {\n        let db = IndexDb::open_in_memory().unwrap();\n        let note = sample_note(\"test/note.md\");\n\n        let id = db.insert_note(\u0026note).unwrap();\n        assert!(id \u003e 0);\n\n        let retrieved = db.get_note_by_path(Path::new(\"test/note.md\")).unwrap();\n        assert!(retrieved.is_some());\n        let retrieved = retrieved.unwrap();\n        assert_eq!(retrieved.title, \"Test Note\");\n        assert_eq!(retrieved.note_type, NoteType::Zettel);\n    }\n\n    #[test]\n    fn test_upsert_note() {\n        let db = IndexDb::open_in_memory().unwrap();\n        let mut note = sample_note(\"test/note.md\");\n\n        let id1 = db.upsert_note(\u0026note).unwrap();\n        note.title = \"Updated Title\".to_string();\n        let id2 = db.upsert_note(\u0026note).unwrap();\n\n        assert_eq!(id1, id2); // Same ID after upsert\n\n        let retrieved = db.get_note_by_id(id1).unwrap().unwrap();\n        assert_eq!(retrieved.title, \"Updated Title\");\n    }\n\n    #[test]\n    fn test_query_by_type() {\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let mut zettel = sample_note(\"knowledge/note1.md\");\n        zettel.note_type = NoteType::Zettel;\n        db.insert_note(\u0026zettel).unwrap();\n\n        let mut task = sample_note(\"tasks/task1.md\");\n        task.note_type = NoteType::Task;\n        db.insert_note(\u0026task).unwrap();\n\n        let query = NoteQuery { note_type: Some(NoteType::Zettel), ..Default::default() };\n        let results = db.query_notes(\u0026query).unwrap();\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].note_type, NoteType::Zettel);\n    }\n\n    #[test]\n    fn test_links() {\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let note1 = sample_note(\"note1.md\");\n        let note2 = sample_note(\"note2.md\");\n        let id1 = db.insert_note(\u0026note1).unwrap();\n        let id2 = db.insert_note(\u0026note2).unwrap();\n\n        let link = IndexedLink {\n            id: None,\n            source_id: id1,\n            target_id: Some(id2),\n            target_path: \"note2.md\".to_string(),\n            link_text: Some(\"Note 2\".to_string()),\n            link_type: LinkType::Wikilink,\n            context: None,\n            line_number: Some(10),\n        };\n        db.insert_link(\u0026link).unwrap();\n\n        let outgoing = db.get_outgoing_links(id1).unwrap();\n        assert_eq!(outgoing.len(), 1);\n\n        let backlinks = db.get_backlinks(id2).unwrap();\n        assert_eq!(backlinks.len(), 1);\n    }\n\n    #[test]\n    fn test_orphans() {\n        let db = IndexDb::open_in_memory().unwrap();\n\n        let note1 = sample_note(\"note1.md\");\n        let note2 = sample_note(\"note2.md\");\n        let id1 = db.insert_note(\u0026note1).unwrap();\n        let id2 = db.insert_note(\u0026note2).unwrap();\n\n        // Link note1 -\u003e note2, so note1 is orphan (no incoming)\n        let link = IndexedLink {\n            id: None,\n            source_id: id1,\n            target_id: Some(id2),\n            target_path: \"note2.md\".to_string(),\n            link_text: None,\n            link_type: LinkType::Wikilink,\n            context: None,\n            line_number: None,\n        };\n        db.insert_link(\u0026link).unwrap();\n\n        let orphans = db.find_orphans().unwrap();\n        assert_eq!(orphans.len(), 1);\n        assert_eq!(orphans[0].path, PathBuf::from(\"note1.md\"));\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":25}},{"line":46,"address":[],"length":0,"stats":{"Line":50}},{"line":47,"address":[],"length":0,"stats":{"Line":75}},{"line":48,"address":[],"length":0,"stats":{"Line":50}},{"line":49,"address":[],"length":0,"stats":{"Line":25}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":17}},{"line":63,"address":[],"length":0,"stats":{"Line":34}},{"line":66,"address":[],"length":0,"stats":{"Line":17}},{"line":67,"address":[],"length":0,"stats":{"Line":17}},{"line":68,"address":[],"length":0,"stats":{"Line":34}},{"line":70,"address":[],"length":0,"stats":{"Line":68}},{"line":71,"address":[],"length":0,"stats":{"Line":34}},{"line":76,"address":[],"length":0,"stats":{"Line":17}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":45}},{"line":111,"address":[],"length":0,"stats":{"Line":90}},{"line":121,"address":[],"length":0,"stats":{"Line":45}},{"line":122,"address":[],"length":0,"stats":{"Line":45}},{"line":123,"address":[],"length":0,"stats":{"Line":90}},{"line":125,"address":[],"length":0,"stats":{"Line":94}},{"line":126,"address":[],"length":0,"stats":{"Line":90}},{"line":133,"address":[],"length":0,"stats":{"Line":180}},{"line":135,"address":[],"length":0,"stats":{"Line":45}},{"line":136,"address":[],"length":0,"stats":{"Line":90}},{"line":139,"address":[],"length":0,"stats":{"Line":45}},{"line":143,"address":[],"length":0,"stats":{"Line":14}},{"line":147,"address":[],"length":0,"stats":{"Line":14}},{"line":151,"address":[],"length":0,"stats":{"Line":14}},{"line":155,"address":[],"length":0,"stats":{"Line":14}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":6}},{"line":177,"address":[],"length":0,"stats":{"Line":18}},{"line":179,"address":[],"length":0,"stats":{"Line":10}},{"line":180,"address":[],"length":0,"stats":{"Line":8}},{"line":181,"address":[],"length":0,"stats":{"Line":8}},{"line":184,"address":[],"length":0,"stats":{"Line":6}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":6}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":6}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":18}},{"line":201,"address":[],"length":0,"stats":{"Line":6}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":6}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":12}},{"line":210,"address":[],"length":0,"stats":{"Line":22}},{"line":212,"address":[],"length":0,"stats":{"Line":24}},{"line":213,"address":[],"length":0,"stats":{"Line":12}},{"line":214,"address":[],"length":0,"stats":{"Line":18}},{"line":215,"address":[],"length":0,"stats":{"Line":24}},{"line":218,"address":[],"length":0,"stats":{"Line":6}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":3}},{"line":226,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":40}},{"line":231,"address":[],"length":0,"stats":{"Line":40}},{"line":234,"address":[],"length":0,"stats":{"Line":40}},{"line":235,"address":[],"length":0,"stats":{"Line":34}},{"line":238,"address":[],"length":0,"stats":{"Line":40}},{"line":242,"address":[],"length":0,"stats":{"Line":13}},{"line":243,"address":[],"length":0,"stats":{"Line":52}},{"line":244,"address":[],"length":0,"stats":{"Line":26}},{"line":245,"address":[],"length":0,"stats":{"Line":44}},{"line":246,"address":[],"length":0,"stats":{"Line":72}},{"line":247,"address":[],"length":0,"stats":{"Line":18}},{"line":249,"address":[],"length":0,"stats":{"Line":49}},{"line":251,"address":[],"length":0,"stats":{"Line":13}},{"line":254,"address":[],"length":0,"stats":{"Line":24}},{"line":255,"address":[],"length":0,"stats":{"Line":96}},{"line":256,"address":[],"length":0,"stats":{"Line":96}},{"line":257,"address":[],"length":0,"stats":{"Line":96}},{"line":258,"address":[],"length":0,"stats":{"Line":96}},{"line":261,"address":[],"length":0,"stats":{"Line":48}},{"line":262,"address":[],"length":0,"stats":{"Line":48}},{"line":263,"address":[],"length":0,"stats":{"Line":48}},{"line":264,"address":[],"length":0,"stats":{"Line":48}},{"line":265,"address":[],"length":0,"stats":{"Line":65}},{"line":266,"address":[],"length":0,"stats":{"Line":34}},{"line":267,"address":[],"length":0,"stats":{"Line":17}},{"line":268,"address":[],"length":0,"stats":{"Line":68}},{"line":270,"address":[],"length":0,"stats":{"Line":48}},{"line":271,"address":[],"length":0,"stats":{"Line":96}},{"line":272,"address":[],"length":0,"stats":{"Line":24}},{"line":273,"address":[],"length":0,"stats":{"Line":48}},{"line":274,"address":[],"length":0,"stats":{"Line":48}},{"line":283,"address":[],"length":0,"stats":{"Line":69}},{"line":284,"address":[],"length":0,"stats":{"Line":138}},{"line":287,"address":[],"length":0,"stats":{"Line":69}},{"line":292,"address":[],"length":0,"stats":{"Line":138}},{"line":297,"address":[],"length":0,"stats":{"Line":69}},{"line":301,"address":[],"length":0,"stats":{"Line":43}},{"line":302,"address":[],"length":0,"stats":{"Line":43}},{"line":303,"address":[],"length":0,"stats":{"Line":172}},{"line":304,"address":[],"length":0,"stats":{"Line":43}},{"line":308,"address":[],"length":0,"stats":{"Line":4}},{"line":312,"address":[],"length":0,"stats":{"Line":12}},{"line":317,"address":[],"length":0,"stats":{"Line":8}},{"line":318,"address":[],"length":0,"stats":{"Line":8}},{"line":319,"address":[],"length":0,"stats":{"Line":16}},{"line":322,"address":[],"length":0,"stats":{"Line":4}},{"line":326,"address":[],"length":0,"stats":{"Line":6}},{"line":327,"address":[],"length":0,"stats":{"Line":18}},{"line":332,"address":[],"length":0,"stats":{"Line":12}},{"line":333,"address":[],"length":0,"stats":{"Line":12}},{"line":334,"address":[],"length":0,"stats":{"Line":14}},{"line":337,"address":[],"length":0,"stats":{"Line":6}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":342,"address":[],"length":0,"stats":{"Line":3}},{"line":349,"address":[],"length":0,"stats":{"Line":1}},{"line":350,"address":[],"length":0,"stats":{"Line":7}},{"line":352,"address":[],"length":0,"stats":{"Line":1}},{"line":357,"address":[],"length":0,"stats":{"Line":21}},{"line":358,"address":[],"length":0,"stats":{"Line":42}},{"line":370,"address":[],"length":0,"stats":{"Line":84}},{"line":373,"address":[],"length":0,"stats":{"Line":42}},{"line":375,"address":[],"length":0,"stats":{"Line":21}},{"line":379,"address":[],"length":0,"stats":{"Line":19}},{"line":380,"address":[],"length":0,"stats":{"Line":76}},{"line":383,"address":[],"length":0,"stats":{"Line":38}},{"line":385,"address":[],"length":0,"stats":{"Line":19}},{"line":388,"address":[],"length":0,"stats":{"Line":10}},{"line":389,"address":[],"length":0,"stats":{"Line":40}},{"line":391,"address":[],"length":0,"stats":{"Line":20}},{"line":392,"address":[],"length":0,"stats":{"Line":20}},{"line":393,"address":[],"length":0,"stats":{"Line":20}},{"line":394,"address":[],"length":0,"stats":{"Line":20}},{"line":395,"address":[],"length":0,"stats":{"Line":20}},{"line":396,"address":[],"length":0,"stats":{"Line":40}},{"line":397,"address":[],"length":0,"stats":{"Line":20}},{"line":398,"address":[],"length":0,"stats":{"Line":20}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":4}},{"line":427,"address":[],"length":0,"stats":{"Line":12}},{"line":428,"address":[],"length":0,"stats":{"Line":2}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":6}},{"line":440,"address":[],"length":0,"stats":{"Line":12}},{"line":447,"address":[],"length":0,"stats":{"Line":6}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":3}},{"line":620,"address":[],"length":0,"stats":{"Line":3}},{"line":624,"address":[],"length":0,"stats":{"Line":3}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":3}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}}],"covered":144,"coverable":285},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","derived.rs"],"content":"//! Derived index computation.\n//!\n//! This module builds secondary indices from the primary note and link data:\n//! - `temporal_activity`: When notes are referenced in daily notes\n//! - `activity_summary`: Aggregated activity metrics per note\n//! - `note_cooccurrence`: Notes that appear together in daily notes\n\nuse chrono::{Duration, NaiveDate, Utc};\nuse thiserror::Error;\n\nuse super::IndexError;\nuse super::db::IndexDb;\n\n/// Errors that can occur during derived index computation.\n#[derive(Debug, Error)]\npub enum DerivedError {\n    #[error(\"Index database error: {0}\")]\n    Index(#[from] IndexError),\n\n    #[error(\"Failed to parse date: {0}\")]\n    DateParse(String),\n}\n\n/// Statistics from derived index computation.\n#[derive(Debug, Clone, Default)]\npub struct DerivedStats {\n    /// Number of daily notes processed.\n    pub dailies_processed: usize,\n    /// Number of temporal activity records created.\n    pub activity_records: usize,\n    /// Number of activity summaries computed.\n    pub summaries_computed: usize,\n    /// Number of cooccurrence pairs found.\n    pub cooccurrence_pairs: usize,\n    /// Duration in milliseconds.\n    pub duration_ms: u64,\n}\n\n/// Builder for computing derived indices.\npub struct DerivedIndexBuilder\u003c'a\u003e {\n    db: \u0026'a IndexDb,\n}\n\nimpl\u003c'a\u003e DerivedIndexBuilder\u003c'a\u003e {\n    /// Create a new derived index builder.\n    pub fn new(db: \u0026'a IndexDb) -\u003e Self {\n        Self { db }\n    }\n\n    /// Compute all derived indices.\n    ///\n    /// This should be called after the primary index is built/updated.\n    pub fn compute_all(\u0026self) -\u003e Result\u003cDerivedStats, DerivedError\u003e {\n        let start = std::time::Instant::now();\n        let mut stats = DerivedStats::default();\n\n        // Clear existing derived data\n        self.db.clear_derived_tables()?;\n\n        // Step 1: Build temporal activity from daily notes\n        stats.dailies_processed = self.build_temporal_activity()?;\n\n        // Step 2: Count activity records\n        stats.activity_records = self.db.count_temporal_activity()? as usize;\n\n        // Step 3: Compute activity summaries\n        stats.summaries_computed = self.compute_activity_summaries()?;\n\n        // Step 4: Compute cooccurrence matrix\n        stats.cooccurrence_pairs = self.compute_cooccurrence()?;\n\n        stats.duration_ms = start.elapsed().as_millis() as u64;\n        Ok(stats)\n    }\n\n    /// Build temporal activity records from daily notes.\n    ///\n    /// For each daily note, finds all outgoing links and creates\n    /// temporal_activity records linking the referenced note to the daily.\n    fn build_temporal_activity(\u0026self) -\u003e Result\u003cusize, DerivedError\u003e {\n        // Get all daily notes\n        let dailies = self.db.get_notes_by_type(\"daily\")?;\n        let mut count = 0;\n\n        for daily in \u0026dailies {\n            let daily_id = match daily.id {\n                Some(id) =\u003e id,\n                None =\u003e continue,\n            };\n\n            // Extract date from the daily note\n            // Daily notes typically have date in frontmatter or path\n            let activity_date = self.extract_daily_date(daily)?;\n\n            // Get all outgoing links from this daily\n            let links = self.db.get_outgoing_links(daily_id)?;\n\n            for link in \u0026links {\n                // Skip self-references and unresolved links\n                if link.target_id.is_none() {\n                    continue;\n                }\n\n                let target_id = link.target_id.unwrap();\n                if target_id == daily_id {\n                    continue; // Skip self-links\n                }\n\n                // Create temporal activity record\n                self.db.insert_temporal_activity(\n                    target_id,\n                    daily_id,\n                    \u0026activity_date,\n                    link.context.as_deref(),\n                )?;\n            }\n\n            count += 1;\n        }\n\n        Ok(count)\n    }\n\n    /// Extract the date from a daily note.\n    fn extract_daily_date(\n        \u0026self,\n        daily: \u0026super::types::IndexedNote,\n    ) -\u003e Result\u003cString, DerivedError\u003e {\n        // Try to get date from frontmatter first\n        if let Some(ref fm_json) = daily.frontmatter_json\n            \u0026\u0026 let Ok(fm) = serde_json::from_str::\u003cserde_json::Value\u003e(fm_json)\n            \u0026\u0026 let Some(date) = fm.get(\"date\").and_then(|v| v.as_str())\n        {\n            return Ok(date.to_string());\n        }\n\n        // Fall back to extracting date from path (e.g., \"daily/2025-01-15.md\")\n        let path_str = daily.path.to_string_lossy();\n        if let Some(date_str) = extract_date_from_path(\u0026path_str) {\n            return Ok(date_str);\n        }\n\n        // Fall back to modified date\n        Ok(daily.modified.format(\"%Y-%m-%d\").to_string())\n    }\n\n    /// Compute activity summaries for all notes.\n    fn compute_activity_summaries(\u0026self) -\u003e Result\u003cusize, DerivedError\u003e {\n        let today = Utc::now().date_naive();\n        let thirty_days_ago = today - Duration::days(30);\n        let ninety_days_ago = today - Duration::days(90);\n\n        // Get aggregated activity data\n        let summaries = self.db.aggregate_activity(\n            \u0026thirty_days_ago.to_string(),\n            \u0026ninety_days_ago.to_string(),\n        )?;\n\n        let mut count = 0;\n        for summary in summaries {\n            // Compute staleness score\n            let staleness = self.compute_staleness_score(\n                summary.last_seen.as_deref(),\n                summary.access_count_30d,\n                summary.access_count_90d,\n            );\n\n            self.db.upsert_activity_summary(\n                summary.note_id,\n                summary.last_seen.as_deref(),\n                summary.access_count_30d,\n                summary.access_count_90d,\n                staleness,\n            )?;\n            count += 1;\n        }\n\n        Ok(count)\n    }\n\n    /// Compute staleness score based on activity patterns.\n    ///\n    /// Score ranges from 0.0 (very active) to 1.0 (very stale).\n    fn compute_staleness_score(\n        \u0026self,\n        last_seen: Option\u003c\u0026str\u003e,\n        count_30d: i32,\n        count_90d: i32,\n    ) -\u003e f64 {\n        let today = Utc::now().date_naive();\n\n        // Days since last seen (default to 365 if never seen)\n        let days_since = last_seen\n            .and_then(|s| NaiveDate::parse_from_str(s, \"%Y-%m-%d\").ok())\n            .map(|d| (today - d).num_days() as f64)\n            .unwrap_or(365.0);\n\n        // Base staleness from recency (0.0 = today, 1.0 = 90+ days)\n        let recency_score = (days_since / 90.0).min(1.0);\n\n        // Activity factor (more activity = less stale)\n        let activity_factor = if count_30d \u003e 0 {\n            0.0 // Active in last 30 days - not stale\n        } else if count_90d \u003e 0 {\n            0.3 // Active in last 90 days - slightly stale\n        } else {\n            0.6 // No recent activity - more stale\n        };\n\n        // Combined score\n        (recency_score * 0.6 + activity_factor * 0.4).min(1.0)\n    }\n\n    /// Compute note cooccurrence matrix.\n    ///\n    /// Finds pairs of notes that are referenced together in daily notes.\n    fn compute_cooccurrence(\u0026self) -\u003e Result\u003cusize, DerivedError\u003e {\n        // Get cooccurrence data from temporal activity\n        let pairs = self.db.compute_cooccurrence_pairs()?;\n        let mut count = 0;\n\n        for pair in pairs {\n            self.db.upsert_cooccurrence(\n                pair.note_a_id,\n                pair.note_b_id,\n                pair.shared_count,\n                pair.most_recent.as_deref(),\n            )?;\n            count += 1;\n        }\n\n        Ok(count)\n    }\n}\n\n/// Extract a date string (YYYY-MM-DD) from a file path.\nfn extract_date_from_path(path: \u0026str) -\u003e Option\u003cString\u003e {\n    // Look for date patterns in the path\n    let re = regex::Regex::new(r\"(\\d{4}-\\d{2}-\\d{2})\").ok()?;\n    re.captures(path).map(|c| c[1].to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_extract_date_from_path() {\n        assert_eq!(\n            extract_date_from_path(\"daily/2025-01-15.md\"),\n            Some(\"2025-01-15\".to_string())\n        );\n        assert_eq!(\n            extract_date_from_path(\"2025-01-15-meeting.md\"),\n            Some(\"2025-01-15\".to_string())\n        );\n        assert_eq!(extract_date_from_path(\"notes/random.md\"), None);\n    }\n\n    #[test]\n    fn test_staleness_score() {\n        let builder = DerivedIndexBuilder { db: \u0026IndexDb::open_in_memory().unwrap() };\n\n        // Very active (accessed today, high count)\n        let score = builder.compute_staleness_score(\n            Some(\u0026Utc::now().format(\"%Y-%m-%d\").to_string()),\n            5,\n            10,\n        );\n        assert!(score \u003c 0.1, \"Active notes should have low staleness\");\n\n        // Never seen: days_since=365, recency_score=1.0, activity_factor=0.6\n        // Combined: 1.0*0.6 + 0.6*0.4 = 0.84\n        let score = builder.compute_staleness_score(None, 0, 0);\n        assert!(score \u003e 0.8, \"Never-seen notes should be stale (score: {})\", score);\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[],"length":0,"stats":{"Line":6}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":194,"address":[],"length":0,"stats":{"Line":6}},{"line":195,"address":[],"length":0,"stats":{"Line":4}},{"line":199,"address":[],"length":0,"stats":{"Line":6}},{"line":202,"address":[],"length":0,"stats":{"Line":4}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":12}},{"line":240,"address":[],"length":0,"stats":{"Line":16}}],"covered":14,"coverable":89},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","mod.rs"],"content":"//! Vault index for fast queries on notes and links.\n//!\n//! This module provides SQLite-based indexing for:\n//! - Note metadata (path, type, title, frontmatter)\n//! - Links between notes (wikilinks, markdown links, frontmatter refs)\n//! - Temporal activity (when notes are referenced in dailies)\n//!\n//! # Example\n//!\n//! ```no_run\n//! use mdvault_core::index::{IndexDb, IndexedNote, NoteType, NoteQuery};\n//! use std::path::Path;\n//!\n//! let db = IndexDb::open(Path::new(\".mdvault/index.db\")).unwrap();\n//!\n//! // Query all tasks\n//! let query = NoteQuery {\n//!     note_type: Some(NoteType::Task),\n//!     ..Default::default()\n//! };\n//! let tasks = db.query_notes(\u0026query).unwrap();\n//! ```\n\npub mod builder;\npub mod db;\npub mod derived;\npub mod schema;\npub mod search;\npub mod types;\n\npub use builder::{BuilderError, FileChange, IndexBuilder, IndexStats, ProgressCallback};\npub use db::{IndexDb, IndexError};\npub use derived::{DerivedError, DerivedIndexBuilder, DerivedStats};\npub use schema::{SCHEMA_VERSION, SchemaError};\npub use search::{MatchSource, SearchEngine, SearchMode, SearchQuery, SearchResult};\npub use types::{\n    ActivitySummary, AggregateActivity, CooccurrencePair, IndexedLink, IndexedNote,\n    LinkType, NoteQuery, NoteType, ProjectStatus, TaskStatus, TemporalActivity,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","schema.rs"],"content":"//! SQLite schema definition and migrations.\n\nuse rusqlite::Connection;\nuse thiserror::Error;\n\n/// Current schema version.\npub const SCHEMA_VERSION: i32 = 1;\n\n#[derive(Debug, Error)]\npub enum SchemaError {\n    #[error(\"Database error: {0}\")]\n    Database(#[from] rusqlite::Error),\n\n    #[error(\"Schema version {found} is newer than supported {supported}\")]\n    VersionTooNew { found: i32, supported: i32 },\n\n    #[error(\"Migration failed: {0}\")]\n    MigrationFailed(String),\n}\n\n/// Initialize or migrate the database schema.\npub fn init_schema(conn: \u0026Connection) -\u003e Result\u003c(), SchemaError\u003e {\n    let version = get_schema_version(conn)?;\n\n    if version == 0 {\n        // Fresh database - create all tables\n        create_schema_v1(conn)?;\n        set_schema_version(conn, SCHEMA_VERSION)?;\n    } else if version \u003c SCHEMA_VERSION {\n        // Run migrations\n        migrate(conn, version)?;\n    } else if version \u003e SCHEMA_VERSION {\n        return Err(SchemaError::VersionTooNew {\n            found: version,\n            supported: SCHEMA_VERSION,\n        });\n    }\n\n    Ok(())\n}\n\nfn get_schema_version(conn: \u0026Connection) -\u003e Result\u003ci32, SchemaError\u003e {\n    // Check if schema_version table exists\n    let exists: bool = conn.query_row(\n        \"SELECT COUNT(*) \u003e 0 FROM sqlite_master WHERE type='table' AND name='schema_version'\",\n        [],\n        |row| row.get(0),\n    )?;\n\n    if !exists {\n        return Ok(0);\n    }\n\n    let version: i32 =\n        conn.query_row(\"SELECT version FROM schema_version\", [], |row| row.get(0))?;\n\n    Ok(version)\n}\n\nfn set_schema_version(conn: \u0026Connection, version: i32) -\u003e Result\u003c(), SchemaError\u003e {\n    conn.execute(\n        \"INSERT OR REPLACE INTO schema_version (id, version) VALUES (1, ?1)\",\n        [version],\n    )?;\n    Ok(())\n}\n\nfn create_schema_v1(conn: \u0026Connection) -\u003e Result\u003c(), SchemaError\u003e {\n    conn.execute_batch(\n        r#\"\n        -- Schema version tracking\n        CREATE TABLE schema_version (\n            id INTEGER PRIMARY KEY CHECK (id = 1),\n            version INTEGER NOT NULL\n        );\n\n        -- Notes table: core metadata for each markdown file\n        CREATE TABLE notes (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            path TEXT NOT NULL UNIQUE,\n            note_type TEXT NOT NULL DEFAULT 'none',\n            title TEXT NOT NULL,\n            created_at TEXT,\n            modified_at TEXT NOT NULL,\n            frontmatter_json TEXT,\n            content_hash TEXT NOT NULL\n        );\n\n        -- Index for common queries\n        CREATE INDEX idx_notes_type ON notes(note_type);\n        CREATE INDEX idx_notes_modified ON notes(modified_at);\n        CREATE INDEX idx_notes_path ON notes(path);\n\n        -- Links table: relationships between notes\n        CREATE TABLE links (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            source_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,\n            target_id INTEGER REFERENCES notes(id) ON DELETE SET NULL,\n            target_path TEXT NOT NULL,\n            link_text TEXT,\n            link_type TEXT NOT NULL,\n            context TEXT,\n            line_number INTEGER\n        );\n\n        -- Indexes for link queries\n        CREATE INDEX idx_links_source ON links(source_id);\n        CREATE INDEX idx_links_target ON links(target_id);\n        CREATE INDEX idx_links_target_path ON links(target_path);\n\n        -- Temporal activity: when notes are referenced in dailies\n        CREATE TABLE temporal_activity (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            note_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,\n            daily_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,\n            activity_date TEXT NOT NULL,\n            context TEXT\n        );\n\n        CREATE INDEX idx_temporal_note ON temporal_activity(note_id);\n        CREATE INDEX idx_temporal_daily ON temporal_activity(daily_id);\n        CREATE INDEX idx_temporal_date ON temporal_activity(activity_date);\n\n        -- Activity summary: cached aggregations (can be rebuilt)\n        CREATE TABLE activity_summary (\n            note_id INTEGER PRIMARY KEY REFERENCES notes(id) ON DELETE CASCADE,\n            last_seen TEXT,\n            access_count_30d INTEGER NOT NULL DEFAULT 0,\n            access_count_90d INTEGER NOT NULL DEFAULT 0,\n            staleness_score REAL NOT NULL DEFAULT 0.0\n        );\n\n        -- Note cooccurrence: notes appearing together in dailies\n        CREATE TABLE note_cooccurrence (\n            note_a_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,\n            note_b_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,\n            shared_daily_count INTEGER NOT NULL DEFAULT 0,\n            most_recent TEXT,\n            PRIMARY KEY (note_a_id, note_b_id)\n        );\n\n        CREATE INDEX idx_cooccurrence_a ON note_cooccurrence(note_a_id);\n        CREATE INDEX idx_cooccurrence_b ON note_cooccurrence(note_b_id);\n\n        -- Full-text search virtual table (optional, for content search)\n        CREATE VIRTUAL TABLE IF NOT EXISTS notes_fts USING fts5(\n            title,\n            content,\n            content_rowid='id'\n        );\n        \"#,\n    )?;\n\n    Ok(())\n}\n\nfn migrate(_conn: \u0026Connection, from_version: i32) -\u003e Result\u003c(), SchemaError\u003e {\n    // Add migration steps here as schema evolves\n    // Example:\n    // match from_version {\n    //     1 =\u003e migrate_v1_to_v2(conn)?,\n    //     2 =\u003e migrate_v2_to_v3(conn)?,\n    //     _ =\u003e {}\n    // }\n\n    // For now, no migrations exist - we only have v1\n    Err(SchemaError::MigrationFailed(format!(\n        \"No migration path from version {} to {}\",\n        from_version, SCHEMA_VERSION\n    )))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rusqlite::Connection;\n\n    #[test]\n    fn test_init_fresh_database() {\n        let conn = Connection::open_in_memory().unwrap();\n        init_schema(\u0026conn).unwrap();\n\n        // Verify schema version\n        let version: i32 = conn\n            .query_row(\"SELECT version FROM schema_version\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(version, SCHEMA_VERSION);\n\n        // Verify tables exist\n        let tables: Vec\u003cString\u003e = conn\n            .prepare(\"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name\")\n            .unwrap()\n            .query_map([], |row| row.get(0))\n            .unwrap()\n            .filter_map(|r| r.ok())\n            .collect();\n\n        assert!(tables.contains(\u0026\"notes\".to_string()));\n        assert!(tables.contains(\u0026\"links\".to_string()));\n        assert!(tables.contains(\u0026\"temporal_activity\".to_string()));\n    }\n\n    #[test]\n    fn test_init_idempotent() {\n        let conn = Connection::open_in_memory().unwrap();\n        init_schema(\u0026conn).unwrap();\n        init_schema(\u0026conn).unwrap(); // Should not fail on second call\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":28}},{"line":23,"address":[],"length":0,"stats":{"Line":84}},{"line":25,"address":[],"length":0,"stats":{"Line":28}},{"line":27,"address":[],"length":0,"stats":{"Line":54}},{"line":28,"address":[],"length":0,"stats":{"Line":54}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":28}},{"line":42,"address":[],"length":0,"stats":{"Line":28}},{"line":44,"address":[],"length":0,"stats":{"Line":112}},{"line":47,"address":[],"length":0,"stats":{"Line":56}},{"line":50,"address":[],"length":0,"stats":{"Line":28}},{"line":51,"address":[],"length":0,"stats":{"Line":27}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":27}},{"line":61,"address":[],"length":0,"stats":{"Line":54}},{"line":63,"address":[],"length":0,"stats":{"Line":27}},{"line":65,"address":[],"length":0,"stats":{"Line":27}},{"line":68,"address":[],"length":0,"stats":{"Line":27}},{"line":69,"address":[],"length":0,"stats":{"Line":54}},{"line":154,"address":[],"length":0,"stats":{"Line":27}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}}],"covered":23,"coverable":31},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","search.rs"],"content":"//! Contextual search beyond keyword matching.\n//!\n//! This module provides multi-modal search capabilities:\n//! - Direct match: Notes matching a query string\n//! - Graph neighbourhood: Linked notes within N hops\n//! - Temporal context: Recent dailies referencing matches\n//! - Cooccurrence: Notes that appeared together in dailies\n\nuse std::collections::{HashMap, HashSet};\n\nuse super::IndexError;\nuse super::db::IndexDb;\nuse super::types::{IndexedNote, NoteType};\n\n/// Search mode determining how results are expanded.\n#[derive(Debug, Clone, Copy, Default)]\npub enum SearchMode {\n    /// Only return notes directly matching the query.\n    #[default]\n    Direct,\n    /// Include linked notes within N hops.\n    Neighbourhood { hops: u32 },\n    /// Include recent dailies referencing matching notes.\n    Temporal { days: u32 },\n    /// Include notes that cooccur with matches in dailies.\n    Cooccurrence { min_shared: u32 },\n    /// Combined: neighbourhood + temporal + cooccurrence.\n    Full,\n}\n\n/// Search query parameters.\n#[derive(Debug, Clone, Default)]\npub struct SearchQuery {\n    /// Text to search for (in title, path, or content).\n    pub text: Option\u003cString\u003e,\n    /// Filter by note type.\n    pub note_type: Option\u003cNoteType\u003e,\n    /// Path prefix filter.\n    pub path_prefix: Option\u003cString\u003e,\n    /// Search mode for result expansion.\n    pub mode: SearchMode,\n    /// Maximum results to return.\n    pub limit: Option\u003cu32\u003e,\n    /// Favour recently active notes.\n    pub temporal_boost: bool,\n}\n\n/// A search result with relevance information.\n#[derive(Debug, Clone)]\npub struct SearchResult {\n    /// The matching note.\n    pub note: IndexedNote,\n    /// Relevance score (higher = more relevant).\n    pub score: f64,\n    /// How this result was found.\n    pub match_source: MatchSource,\n    /// Staleness score if available (lower = more active).\n    pub staleness: Option\u003cf64\u003e,\n}\n\n/// How a search result was matched.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum MatchSource {\n    /// Direct text match.\n    Direct,\n    /// Linked from a direct match.\n    Linked { hops: u32 },\n    /// Referenced in a daily with a direct match.\n    Temporal { daily_path: String },\n    /// Cooccurs with a direct match.\n    Cooccurrence { shared_dailies: u32 },\n}\n\n/// Search engine using the vault index.\npub struct SearchEngine\u003c'a\u003e {\n    db: \u0026'a IndexDb,\n}\n\nimpl\u003c'a\u003e SearchEngine\u003c'a\u003e {\n    /// Create a new search engine.\n    pub fn new(db: \u0026'a IndexDb) -\u003e Self {\n        Self { db }\n    }\n\n    /// Execute a search query.\n    pub fn search(\u0026self, query: \u0026SearchQuery) -\u003e Result\u003cVec\u003cSearchResult\u003e, IndexError\u003e {\n        // Step 1: Find direct matches\n        let direct_matches = self.find_direct_matches(query)?;\n        let direct_ids: HashSet\u003ci64\u003e =\n            direct_matches.iter().filter_map(|n| n.id).collect();\n\n        let mut results: Vec\u003cSearchResult\u003e = direct_matches\n            .into_iter()\n            .map(|note| SearchResult {\n                staleness: self.get_staleness(note.id),\n                note,\n                score: 1.0,\n                match_source: MatchSource::Direct,\n            })\n            .collect();\n\n        // Step 2: Expand based on mode\n        match query.mode {\n            SearchMode::Direct =\u003e {}\n            SearchMode::Neighbourhood { hops } =\u003e {\n                let expanded = self.expand_neighbourhood(\u0026direct_ids, hops)?;\n                results.extend(expanded);\n            }\n            SearchMode::Temporal { days } =\u003e {\n                let expanded = self.expand_temporal(\u0026direct_ids, days)?;\n                results.extend(expanded);\n            }\n            SearchMode::Cooccurrence { min_shared } =\u003e {\n                let expanded = self.expand_cooccurrence(\u0026direct_ids, min_shared)?;\n                results.extend(expanded);\n            }\n            SearchMode::Full =\u003e {\n                // Combine all expansion modes\n                let neighbourhood = self.expand_neighbourhood(\u0026direct_ids, 2)?;\n                let temporal = self.expand_temporal(\u0026direct_ids, 30)?;\n                let cooccurrence = self.expand_cooccurrence(\u0026direct_ids, 2)?;\n                results.extend(neighbourhood);\n                results.extend(temporal);\n                results.extend(cooccurrence);\n            }\n        }\n\n        // Step 3: Apply temporal boost if requested\n        if query.temporal_boost {\n            for result in \u0026mut results {\n                if let Some(staleness) = result.staleness {\n                    // Boost score based on freshness (1 - staleness)\n                    result.score *= 1.0 + (1.0 - staleness) * 0.5;\n                }\n            }\n        }\n\n        // Step 4: Deduplicate and sort by score\n        results = self.deduplicate_results(results);\n        results.sort_by(|a, b| {\n            b.score.partial_cmp(\u0026a.score).unwrap_or(std::cmp::Ordering::Equal)\n        });\n\n        // Step 5: Apply limit\n        if let Some(limit) = query.limit {\n            results.truncate(limit as usize);\n        }\n\n        Ok(results)\n    }\n\n    /// Find notes directly matching the query.\n    fn find_direct_matches(\n        \u0026self,\n        query: \u0026SearchQuery,\n    ) -\u003e Result\u003cVec\u003cIndexedNote\u003e, IndexError\u003e {\n        // Build a NoteQuery from SearchQuery\n        let note_query = super::types::NoteQuery {\n            note_type: query.note_type,\n            path_prefix: query.path_prefix.as_ref().map(Into::into),\n            limit: query.limit,\n            ..Default::default()\n        };\n\n        let notes = self.db.query_notes(\u0026note_query)?;\n\n        // Filter by text if provided\n        if let Some(text) = \u0026query.text {\n            let text_lower = text.to_lowercase();\n            Ok(notes\n                .into_iter()\n                .filter(|n| {\n                    n.title.to_lowercase().contains(\u0026text_lower)\n                        || n.path.to_string_lossy().to_lowercase().contains(\u0026text_lower)\n                })\n                .collect())\n        } else {\n            Ok(notes)\n        }\n    }\n\n    /// Expand results by following links up to N hops.\n    fn expand_neighbourhood(\n        \u0026self,\n        seed_ids: \u0026HashSet\u003ci64\u003e,\n        max_hops: u32,\n    ) -\u003e Result\u003cVec\u003cSearchResult\u003e, IndexError\u003e {\n        let mut results = Vec::new();\n        let mut visited: HashSet\u003ci64\u003e = seed_ids.clone();\n        let mut frontier: HashSet\u003ci64\u003e = seed_ids.clone();\n\n        for hop in 1..=max_hops {\n            let mut next_frontier = HashSet::new();\n\n            for \u0026note_id in \u0026frontier {\n                // Get outgoing links\n                let outlinks = self.db.get_outgoing_links(note_id)?;\n                for link in outlinks {\n                    if let Some(target_id) = link.target_id\n                        \u0026\u0026 !visited.contains(\u0026target_id)\n                    {\n                        visited.insert(target_id);\n                        next_frontier.insert(target_id);\n\n                        if let Some(note) = self.db.get_note_by_id(target_id)? {\n                            results.push(SearchResult {\n                                staleness: self.get_staleness(note.id),\n                                note,\n                                score: 0.5 / (hop as f64), // Decay by distance\n                                match_source: MatchSource::Linked { hops: hop },\n                            });\n                        }\n                    }\n                }\n\n                // Get backlinks\n                let backlinks = self.db.get_backlinks(note_id)?;\n                for link in backlinks {\n                    if !visited.contains(\u0026link.source_id) {\n                        visited.insert(link.source_id);\n                        next_frontier.insert(link.source_id);\n\n                        if let Some(note) = self.db.get_note_by_id(link.source_id)? {\n                            results.push(SearchResult {\n                                staleness: self.get_staleness(note.id),\n                                note,\n                                score: 0.5 / (hop as f64),\n                                match_source: MatchSource::Linked { hops: hop },\n                            });\n                        }\n                    }\n                }\n            }\n\n            frontier = next_frontier;\n            if frontier.is_empty() {\n                break;\n            }\n        }\n\n        Ok(results)\n    }\n\n    /// Expand results by finding recent dailies referencing matches.\n    fn expand_temporal(\n        \u0026self,\n        seed_ids: \u0026HashSet\u003ci64\u003e,\n        _days: u32,\n    ) -\u003e Result\u003cVec\u003cSearchResult\u003e, IndexError\u003e {\n        let mut results = Vec::new();\n        let mut seen_dailies: HashSet\u003ci64\u003e = HashSet::new();\n\n        for \u0026note_id in seed_ids {\n            // Get backlinks to find dailies referencing this note\n            let backlinks = self.db.get_backlinks(note_id)?;\n            for link in backlinks {\n                if let Some(source_note) = self.db.get_note_by_id(link.source_id)?\n                    \u0026\u0026 source_note.note_type == NoteType::Daily\n                    \u0026\u0026 !seen_dailies.contains(\u0026link.source_id)\n                    \u0026\u0026 !seed_ids.contains(\u0026link.source_id)\n                {\n                    seen_dailies.insert(link.source_id);\n                    let path = source_note.path.to_string_lossy().to_string();\n                    results.push(SearchResult {\n                        staleness: self.get_staleness(source_note.id),\n                        note: source_note,\n                        score: 0.4,\n                        match_source: MatchSource::Temporal { daily_path: path },\n                    });\n                }\n            }\n        }\n\n        Ok(results)\n    }\n\n    /// Expand results by finding notes that cooccur with matches.\n    fn expand_cooccurrence(\n        \u0026self,\n        seed_ids: \u0026HashSet\u003ci64\u003e,\n        min_shared: u32,\n    ) -\u003e Result\u003cVec\u003cSearchResult\u003e, IndexError\u003e {\n        let mut results = Vec::new();\n        let mut seen: HashSet\u003ci64\u003e = seed_ids.clone();\n\n        for \u0026note_id in seed_ids {\n            let cooccurrent = self.db.get_cooccurrent_notes(note_id, 10)?;\n            for (note, shared_count) in cooccurrent {\n                if let Some(id) = note.id\n                    \u0026\u0026 shared_count \u003e= min_shared as i32\n                    \u0026\u0026 !seen.contains(\u0026id)\n                {\n                    seen.insert(id);\n                    results.push(SearchResult {\n                        staleness: self.get_staleness(note.id),\n                        note,\n                        score: 0.3 * (shared_count as f64 / 10.0).min(1.0),\n                        match_source: MatchSource::Cooccurrence {\n                            shared_dailies: shared_count as u32,\n                        },\n                    });\n                }\n            }\n        }\n\n        Ok(results)\n    }\n\n    /// Get staleness score for a note.\n    fn get_staleness(\u0026self, note_id: Option\u003ci64\u003e) -\u003e Option\u003cf64\u003e {\n        note_id.and_then(|id| {\n            self.db\n                .get_activity_summary(id)\n                .ok()\n                .flatten()\n                .map(|s| s.staleness_score as f64)\n        })\n    }\n\n    /// Deduplicate results, keeping highest score for each note.\n    fn deduplicate_results(\u0026self, results: Vec\u003cSearchResult\u003e) -\u003e Vec\u003cSearchResult\u003e {\n        let mut best: HashMap\u003ci64, SearchResult\u003e = HashMap::new();\n\n        for result in results {\n            if let Some(id) = result.note.id {\n                best.entry(id)\n                    .and_modify(|existing| {\n                        if result.score \u003e existing.score {\n                            *existing = result.clone();\n                        }\n                    })\n                    .or_insert(result);\n            }\n        }\n\n        best.into_values().collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::Utc;\n    use std::path::PathBuf;\n\n    fn sample_note(path: \u0026str, title: \u0026str, note_type: NoteType) -\u003e IndexedNote {\n        IndexedNote {\n            id: None,\n            path: PathBuf::from(path),\n            note_type,\n            title: title.to_string(),\n            created: Some(Utc::now()),\n            modified: Utc::now(),\n            frontmatter_json: None,\n            content_hash: format!(\"hash-{}\", path),\n        }\n    }\n\n    #[test]\n    fn test_direct_search() {\n        let db = IndexDb::open_in_memory().unwrap();\n\n        // Insert test notes\n        db.insert_note(\u0026sample_note(\n            \"tasks/task1.md\",\n            \"Fix bug in parser\",\n            NoteType::Task,\n        ))\n        .unwrap();\n        db.insert_note(\u0026sample_note(\n            \"tasks/task2.md\",\n            \"Write documentation\",\n            NoteType::Task,\n        ))\n        .unwrap();\n        db.insert_note(\u0026sample_note(\n            \"zettel/note1.md\",\n            \"Parser internals\",\n            NoteType::Zettel,\n        ))\n        .unwrap();\n\n        let engine = SearchEngine::new(\u0026db);\n\n        // Search for \"parser\"\n        let query = SearchQuery {\n            text: Some(\"parser\".to_string()),\n            mode: SearchMode::Direct,\n            ..Default::default()\n        };\n\n        let results = engine.search(\u0026query).unwrap();\n        assert_eq!(results.len(), 2);\n        assert!(results.iter().all(|r| r.match_source == MatchSource::Direct));\n    }\n\n    #[test]\n    fn test_type_filter() {\n        let db = IndexDb::open_in_memory().unwrap();\n\n        db.insert_note(\u0026sample_note(\"tasks/task1.md\", \"Task note\", NoteType::Task))\n            .unwrap();\n        db.insert_note(\u0026sample_note(\"zettel/note1.md\", \"Zettel note\", NoteType::Zettel))\n            .unwrap();\n\n        let engine = SearchEngine::new(\u0026db);\n\n        let query = SearchQuery {\n            note_type: Some(NoteType::Task),\n            mode: SearchMode::Direct,\n            ..Default::default()\n        };\n\n        let results = engine.search(\u0026query).unwrap();\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].note.note_type, NoteType::Task);\n    }\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":9}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":8}},{"line":140,"address":[],"length":0,"stats":{"Line":5}},{"line":141,"address":[],"length":0,"stats":{"Line":5}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":8}},{"line":168,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":6}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":3}},{"line":311,"address":[],"length":0,"stats":{"Line":9}},{"line":312,"address":[],"length":0,"stats":{"Line":3}},{"line":313,"address":[],"length":0,"stats":{"Line":6}},{"line":314,"address":[],"length":0,"stats":{"Line":3}},{"line":315,"address":[],"length":0,"stats":{"Line":3}},{"line":316,"address":[],"length":0,"stats":{"Line":3}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":6}},{"line":324,"address":[],"length":0,"stats":{"Line":8}},{"line":325,"address":[],"length":0,"stats":{"Line":6}},{"line":326,"address":[],"length":0,"stats":{"Line":9}},{"line":327,"address":[],"length":0,"stats":{"Line":3}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[],"length":0,"stats":{"Line":6}}],"covered":47,"coverable":139},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","index","types.rs"],"content":"//! Index data types for vault notes and links.\n\nuse chrono::{DateTime, NaiveDate, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse std::str::FromStr;\n\n/// Note type classification based on frontmatter `type:` field.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]\n#[serde(rename_all = \"lowercase\")]\npub enum NoteType {\n    /// Daily journal notes - temporal backbone of the vault.\n    Daily,\n    /// Weekly overview notes.\n    Weekly,\n    /// Individual actionable tasks.\n    Task,\n    /// Collections of related tasks.\n    Project,\n    /// Knowledge notes (Zettelkasten-style).\n    Zettel,\n    /// Uncategorised notes awaiting triage.\n    #[default]\n    None,\n}\n\nimpl NoteType {\n    /// Convert to database string representation.\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Daily =\u003e \"daily\",\n            Self::Weekly =\u003e \"weekly\",\n            Self::Task =\u003e \"task\",\n            Self::Project =\u003e \"project\",\n            Self::Zettel =\u003e \"zettel\",\n            Self::None =\u003e \"none\",\n        }\n    }\n}\n\nimpl FromStr for NoteType {\n    type Err = std::convert::Infallible;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        Ok(match s.to_lowercase().as_str() {\n            \"daily\" =\u003e Self::Daily,\n            \"weekly\" =\u003e Self::Weekly,\n            \"task\" =\u003e Self::Task,\n            \"project\" =\u003e Self::Project,\n            \"zettel\" | \"knowledge\" =\u003e Self::Zettel,\n            _ =\u003e Self::None,\n        })\n    }\n}\n\n/// Task status values.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\n#[serde(rename_all = \"lowercase\")]\npub enum TaskStatus {\n    #[default]\n    Open,\n    InProgress,\n    Blocked,\n    Done,\n    Cancelled,\n}\n\nimpl TaskStatus {\n    pub fn parse(s: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match s.to_lowercase().replace(['-', '_'], \"\").as_str() {\n            \"open\" =\u003e Some(Self::Open),\n            \"inprogress\" =\u003e Some(Self::InProgress),\n            \"blocked\" =\u003e Some(Self::Blocked),\n            \"done\" | \"completed\" =\u003e Some(Self::Done),\n            \"cancelled\" | \"canceled\" =\u003e Some(Self::Cancelled),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Open =\u003e \"open\",\n            Self::InProgress =\u003e \"in-progress\",\n            Self::Blocked =\u003e \"blocked\",\n            Self::Done =\u003e \"done\",\n            Self::Cancelled =\u003e \"cancelled\",\n        }\n    }\n}\n\n/// Project status values.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\n#[serde(rename_all = \"lowercase\")]\npub enum ProjectStatus {\n    #[default]\n    Planning,\n    Active,\n    Paused,\n    Completed,\n    Archived,\n}\n\nimpl ProjectStatus {\n    pub fn parse(s: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"planning\" =\u003e Some(Self::Planning),\n            \"active\" =\u003e Some(Self::Active),\n            \"paused\" =\u003e Some(Self::Paused),\n            \"completed\" | \"done\" =\u003e Some(Self::Completed),\n            \"archived\" =\u003e Some(Self::Archived),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Planning =\u003e \"planning\",\n            Self::Active =\u003e \"active\",\n            Self::Paused =\u003e \"paused\",\n            Self::Completed =\u003e \"completed\",\n            Self::Archived =\u003e \"archived\",\n        }\n    }\n}\n\n/// Type of link between notes.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum LinkType {\n    /// Wikilink: [[note]] or [[note|alias]]\n    Wikilink,\n    /// Markdown link: [text](path.md)\n    Markdown,\n    /// Frontmatter reference: project: note-name\n    Frontmatter,\n}\n\nimpl LinkType {\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Wikilink =\u003e \"wikilink\",\n            Self::Markdown =\u003e \"markdown\",\n            Self::Frontmatter =\u003e \"frontmatter\",\n        }\n    }\n\n    pub fn parse(s: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"wikilink\" =\u003e Some(Self::Wikilink),\n            \"markdown\" =\u003e Some(Self::Markdown),\n            \"frontmatter\" =\u003e Some(Self::Frontmatter),\n            _ =\u003e None,\n        }\n    }\n}\n\n/// A note in the vault index.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IndexedNote {\n    /// Database ID (None if not yet inserted).\n    pub id: Option\u003ci64\u003e,\n    /// Path relative to vault root.\n    pub path: PathBuf,\n    /// Note type from frontmatter.\n    pub note_type: NoteType,\n    /// Note title (from first heading or filename).\n    pub title: String,\n    /// File creation time.\n    pub created: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    /// File modification time.\n    pub modified: DateTime\u003cUtc\u003e,\n    /// Frontmatter as JSON string.\n    pub frontmatter_json: Option\u003cString\u003e,\n    /// Content hash for change detection.\n    pub content_hash: String,\n}\n\n/// A link between two notes.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IndexedLink {\n    /// Database ID (None if not yet inserted).\n    pub id: Option\u003ci64\u003e,\n    /// Source note ID.\n    pub source_id: i64,\n    /// Target note ID (None if broken link).\n    pub target_id: Option\u003ci64\u003e,\n    /// Raw target path from the link.\n    pub target_path: String,\n    /// Link display text (content within [[brackets]] or [text]).\n    pub link_text: Option\u003cString\u003e,\n    /// Type of link.\n    pub link_type: LinkType,\n    /// Surrounding context text.\n    pub context: Option\u003cString\u003e,\n    /// Line number in source file.\n    pub line_number: Option\u003cu32\u003e,\n}\n\n/// Temporal activity record - when a note was referenced in a daily.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TemporalActivity {\n    /// Database ID.\n    pub id: Option\u003ci64\u003e,\n    /// The note being referenced.\n    pub note_id: i64,\n    /// The daily note containing the reference.\n    pub daily_id: i64,\n    /// Date of the daily note.\n    pub activity_date: NaiveDate,\n    /// Context of the reference.\n    pub context: Option\u003cString\u003e,\n}\n\n/// Activity summary for a note (derived/cached).\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActivitySummary {\n    /// Note ID.\n    pub note_id: i64,\n    /// Last time note was referenced in a daily.\n    pub last_seen: Option\u003cNaiveDate\u003e,\n    /// Reference count in last 30 days.\n    pub access_count_30d: u32,\n    /// Reference count in last 90 days.\n    pub access_count_90d: u32,\n    /// Computed staleness score (higher = more stale).\n    pub staleness_score: f32,\n}\n\n/// Query filter for listing notes.\n#[derive(Debug, Clone, Default)]\npub struct NoteQuery {\n    /// Filter by note type.\n    pub note_type: Option\u003cNoteType\u003e,\n    /// Filter by path prefix.\n    pub path_prefix: Option\u003cPathBuf\u003e,\n    /// Modified after this date.\n    pub modified_after: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    /// Modified before this date.\n    pub modified_before: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    /// Maximum number of results.\n    pub limit: Option\u003cu32\u003e,\n    /// Offset for pagination.\n    pub offset: Option\u003cu32\u003e,\n}\n\n/// Aggregate activity data for computing summaries.\n#[derive(Debug, Clone)]\npub struct AggregateActivity {\n    /// Note ID.\n    pub note_id: i64,\n    /// Last seen date as ISO string.\n    pub last_seen: Option\u003cString\u003e,\n    /// Reference count in last 30 days.\n    pub access_count_30d: i32,\n    /// Reference count in last 90 days.\n    pub access_count_90d: i32,\n}\n\n/// A cooccurrence pair: two notes that appear together in daily notes.\n#[derive(Debug, Clone)]\npub struct CooccurrencePair {\n    /// First note ID.\n    pub note_a_id: i64,\n    /// Second note ID.\n    pub note_b_id: i64,\n    /// Number of daily notes they share.\n    pub shared_count: i32,\n    /// Most recent shared daily date.\n    pub most_recent: Option\u003cString\u003e,\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":64}},{"line":30,"address":[],"length":0,"stats":{"Line":64}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":18}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":24}},{"line":36,"address":[],"length":0,"stats":{"Line":22}},{"line":44,"address":[],"length":0,"stats":{"Line":52}},{"line":45,"address":[],"length":0,"stats":{"Line":52}},{"line":46,"address":[],"length":0,"stats":{"Line":52}},{"line":47,"address":[],"length":0,"stats":{"Line":52}},{"line":48,"address":[],"length":0,"stats":{"Line":72}},{"line":49,"address":[],"length":0,"stats":{"Line":32}},{"line":50,"address":[],"length":0,"stats":{"Line":64}},{"line":51,"address":[],"length":0,"stats":{"Line":11}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":69}},{"line":140,"address":[],"length":0,"stats":{"Line":69}},{"line":141,"address":[],"length":0,"stats":{"Line":43}},{"line":142,"address":[],"length":0,"stats":{"Line":13}},{"line":143,"address":[],"length":0,"stats":{"Line":13}},{"line":147,"address":[],"length":0,"stats":{"Line":10}},{"line":148,"address":[],"length":0,"stats":{"Line":10}},{"line":149,"address":[],"length":0,"stats":{"Line":20}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}}],"covered":21,"coverable":57},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","lib.rs"],"content":"pub fn version() -\u003e \u0026'static str {\n    env!(\"CARGO_PKG_VERSION\")\n}\n\npub fn rustc_version() -\u003e String {\n    std::env::var(\"RUSTC_VERSION\").unwrap_or_else(|_| \"unknown\".into())\n}\n\npub fn doctor_stub() -\u003e String {\n    format!(\n        \"mdvault-core v{} | rustc {} on {} \",\n        version(),\n        rustc_version(),\n        std::env::consts::OS\n    )\n}\n\npub mod captures;\npub mod config;\npub mod frontmatter;\npub mod ids;\npub mod index;\npub mod macros;\npub mod markdown_ast;\npub mod rename;\npub mod scripting;\npub mod templates;\npub mod types;\npub mod vars;\npub mod vault;\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":0}},{"line":2,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","macros","discovery.rs"],"content":"//! Macro discovery and repository.\n\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\nuse thiserror::Error;\nuse walkdir::WalkDir;\n\nuse super::types::{LoadedMacro, MacroInfo, MacroSpec};\n\n/// Error type for macro discovery.\n#[derive(Debug, Error)]\npub enum MacroDiscoveryError {\n    #[error(\"macros directory does not exist: {0}\")]\n    MissingDir(String),\n\n    #[error(\"failed to read macros directory {0}: {1}\")]\n    WalkError(String, #[source] walkdir::Error),\n}\n\n/// Error type for macro repository operations.\n#[derive(Debug, Error)]\npub enum MacroRepoError {\n    #[error(transparent)]\n    Discovery(#[from] MacroDiscoveryError),\n\n    #[error(\"macro not found: {0}\")]\n    NotFound(String),\n\n    #[error(\"failed to read macro file {path}: {source}\")]\n    Io {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    #[error(\"failed to parse macro YAML {path}: {source}\")]\n    Parse {\n        path: PathBuf,\n        #[source]\n        source: serde_yaml::Error,\n    },\n}\n\n/// Discover macro files in a directory.\n///\n/// Finds all `.yaml` files in the given directory and its subdirectories.\npub fn discover_macros(root: \u0026Path) -\u003e Result\u003cVec\u003cMacroInfo\u003e, MacroDiscoveryError\u003e {\n    let root = root\n        .canonicalize()\n        .map_err(|_| MacroDiscoveryError::MissingDir(root.display().to_string()))?;\n\n    if !root.exists() {\n        return Err(MacroDiscoveryError::MissingDir(root.display().to_string()));\n    }\n\n    let mut out = Vec::new();\n\n    for entry in WalkDir::new(\u0026root) {\n        let entry = entry\n            .map_err(|e| MacroDiscoveryError::WalkError(root.display().to_string(), e))?;\n\n        let path = entry.path();\n        if !path.is_file() {\n            continue;\n        }\n        if !is_yaml_file(path) {\n            continue;\n        }\n\n        let rel = path.strip_prefix(\u0026root).unwrap_or(path);\n        let logical = logical_name_from_relative(rel);\n\n        out.push(MacroInfo { logical_name: logical, path: path.to_path_buf() });\n    }\n\n    out.sort_by(|a, b| a.logical_name.cmp(\u0026b.logical_name));\n    Ok(out)\n}\n\nfn is_yaml_file(path: \u0026Path) -\u003e bool {\n    path.extension().and_then(|e| e.to_str()).is_some_and(|e| e == \"yaml\" || e == \"yml\")\n}\n\nfn logical_name_from_relative(rel: \u0026Path) -\u003e String {\n    let s = rel.to_string_lossy();\n    // Remove .yaml or .yml extension\n    if let Some(stripped) = s.strip_suffix(\".yaml\") {\n        return stripped.to_string();\n    }\n    if let Some(stripped) = s.strip_suffix(\".yml\") {\n        return stripped.to_string();\n    }\n    s.to_string()\n}\n\n/// Repository for discovering and loading macros.\npub struct MacroRepository {\n    pub root: PathBuf,\n    pub macros: Vec\u003cMacroInfo\u003e,\n}\n\nimpl MacroRepository {\n    /// Create a new macro repository from a directory.\n    pub fn new(root: \u0026Path) -\u003e Result\u003cSelf, MacroDiscoveryError\u003e {\n        let macros = discover_macros(root)?;\n        Ok(Self { root: root.to_path_buf(), macros })\n    }\n\n    /// List all discovered macros.\n    pub fn list_all(\u0026self) -\u003e \u0026[MacroInfo] {\n        \u0026self.macros\n    }\n\n    /// Get a macro by its logical name.\n    pub fn get_by_name(\u0026self, name: \u0026str) -\u003e Result\u003cLoadedMacro, MacroRepoError\u003e {\n        let info = self\n            .macros\n            .iter()\n            .find(|m| m.logical_name == name)\n            .ok_or_else(|| MacroRepoError::NotFound(name.to_string()))?;\n\n        let content = fs::read_to_string(\u0026info.path)\n            .map_err(|e| MacroRepoError::Io { path: info.path.clone(), source: e })?;\n\n        let spec: MacroSpec = serde_yaml::from_str(\u0026content)\n            .map_err(|e| MacroRepoError::Parse { path: info.path.clone(), source: e })?;\n\n        Ok(LoadedMacro {\n            logical_name: info.logical_name.clone(),\n            path: info.path.clone(),\n            spec,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_discover_macros() {\n        let temp = TempDir::new().unwrap();\n        let macros_dir = temp.path().join(\"macros\");\n        fs::create_dir_all(\u0026macros_dir).unwrap();\n\n        // Create some macro files\n        fs::write(\n            macros_dir.join(\"weekly-review.yaml\"),\n            \"name: weekly-review\\nsteps: []\",\n        )\n        .unwrap();\n        fs::write(macros_dir.join(\"daily-note.yml\"), \"name: daily-note\\nsteps: []\")\n            .unwrap();\n\n        // Create a subdirectory with another macro\n        let sub_dir = macros_dir.join(\"project\");\n        fs::create_dir_all(\u0026sub_dir).unwrap();\n        fs::write(sub_dir.join(\"setup.yaml\"), \"name: project-setup\\nsteps: []\").unwrap();\n\n        // Create a non-yaml file (should be ignored)\n        fs::write(macros_dir.join(\"notes.md\"), \"# Notes\").unwrap();\n\n        let macros = discover_macros(\u0026macros_dir).unwrap();\n\n        assert_eq!(macros.len(), 3);\n        assert!(macros.iter().any(|m| m.logical_name == \"daily-note\"));\n        assert!(macros.iter().any(|m| m.logical_name == \"weekly-review\"));\n        assert!(macros.iter().any(|m| m.logical_name == \"project/setup\"));\n    }\n\n    #[test]\n    fn test_macro_repository() {\n        let temp = TempDir::new().unwrap();\n        let macros_dir = temp.path().join(\"macros\");\n        fs::create_dir_all(\u0026macros_dir).unwrap();\n\n        fs::write(\n            macros_dir.join(\"test.yaml\"),\n            r#\"\nname: test\ndescription: A test macro\nsteps:\n  - template: meeting-note\n    with:\n      title: \"Test\"\n\"#,\n        )\n        .unwrap();\n\n        let repo = MacroRepository::new(\u0026macros_dir).unwrap();\n        assert_eq!(repo.list_all().len(), 1);\n\n        let loaded = repo.get_by_name(\"test\").unwrap();\n        assert_eq!(loaded.spec.name, \"test\");\n        assert_eq!(loaded.spec.description, \"A test macro\");\n        assert_eq!(loaded.spec.steps.len(), 1);\n    }\n\n    #[test]\n    fn test_macro_not_found() {\n        let temp = TempDir::new().unwrap();\n        let macros_dir = temp.path().join(\"macros\");\n        fs::create_dir_all(\u0026macros_dir).unwrap();\n\n        let repo = MacroRepository::new(\u0026macros_dir).unwrap();\n        let result = repo.get_by_name(\"nonexistent\");\n\n        assert!(matches!(result, Err(MacroRepoError::NotFound(_))));\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":24}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":24}},{"line":59,"address":[],"length":0,"stats":{"Line":53}},{"line":60,"address":[],"length":0,"stats":{"Line":58}},{"line":61,"address":[],"length":0,"stats":{"Line":29}},{"line":63,"address":[],"length":0,"stats":{"Line":87}},{"line":64,"address":[],"length":0,"stats":{"Line":29}},{"line":65,"address":[],"length":0,"stats":{"Line":13}},{"line":67,"address":[],"length":0,"stats":{"Line":16}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":90}},{"line":72,"address":[],"length":0,"stats":{"Line":45}},{"line":74,"address":[],"length":0,"stats":{"Line":60}},{"line":77,"address":[],"length":0,"stats":{"Line":36}},{"line":78,"address":[],"length":0,"stats":{"Line":12}},{"line":81,"address":[],"length":0,"stats":{"Line":16}},{"line":82,"address":[],"length":0,"stats":{"Line":114}},{"line":85,"address":[],"length":0,"stats":{"Line":15}},{"line":86,"address":[],"length":0,"stats":{"Line":45}},{"line":88,"address":[],"length":0,"stats":{"Line":29}},{"line":89,"address":[],"length":0,"stats":{"Line":28}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":11}},{"line":106,"address":[],"length":0,"stats":{"Line":33}},{"line":107,"address":[],"length":0,"stats":{"Line":22}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":13}},{"line":117,"address":[],"length":0,"stats":{"Line":24}},{"line":118,"address":[],"length":0,"stats":{"Line":13}},{"line":120,"address":[],"length":0,"stats":{"Line":41}},{"line":121,"address":[],"length":0,"stats":{"Line":19}},{"line":123,"address":[],"length":0,"stats":{"Line":33}},{"line":124,"address":[],"length":0,"stats":{"Line":11}},{"line":126,"address":[],"length":0,"stats":{"Line":44}},{"line":127,"address":[],"length":0,"stats":{"Line":11}},{"line":129,"address":[],"length":0,"stats":{"Line":11}},{"line":130,"address":[],"length":0,"stats":{"Line":33}},{"line":131,"address":[],"length":0,"stats":{"Line":22}},{"line":132,"address":[],"length":0,"stats":{"Line":11}}],"covered":44,"coverable":46},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","macros","mod.rs"],"content":"//! Macro system for multi-step workflows.\n//!\n//! Macros allow users to define sequences of template and capture operations\n//! that execute as a single workflow.\n\npub mod discovery;\npub mod runner;\npub mod types;\n\npub use discovery::{\n    MacroDiscoveryError, MacroRepoError, MacroRepository, discover_macros,\n};\npub use runner::{\n    MacroRunError, RunContext, RunOptions, StepExecutor, get_shell_commands,\n    requires_trust, run_macro,\n};\npub use types::{\n    CaptureStep, ErrorPolicy, LoadedMacro, MacroInfo, MacroResult, MacroSpec, MacroStep,\n    ShellStep, StepResult, TemplateStep,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","macros","runner.rs"],"content":"//! Macro runner for executing multi-step workflows.\n\nuse std::collections::HashMap;\n\nuse thiserror::Error;\n\nuse super::types::{\n    CaptureStep, ErrorPolicy, LoadedMacro, MacroResult, MacroSpec, MacroStep, ShellStep,\n    StepResult, TemplateStep,\n};\nuse crate::templates::engine::render_string;\n\n/// Error type for macro execution.\n#[derive(Debug, Error)]\npub enum MacroRunError {\n    #[error(\"step {step} failed: {message}\")]\n    StepFailed { step: usize, message: String },\n\n    #[error(\"shell execution requires --trust flag\")]\n    TrustRequired,\n\n    #[error(\"shell execution is disabled in config\")]\n    ShellDisabled,\n\n    #[error(\"template error: {0}\")]\n    TemplateError(String),\n\n    #[error(\"capture error: {0}\")]\n    CaptureError(String),\n\n    #[error(\"shell error: {0}\")]\n    ShellError(String),\n\n    #[error(\"variable error: {0}\")]\n    VariableError(String),\n}\n\n/// Options for macro execution.\n#[derive(Debug, Clone, Default)]\npub struct RunOptions {\n    /// Whether the --trust flag was provided.\n    pub trust: bool,\n\n    /// Whether shell execution is allowed by config.\n    pub allow_shell: bool,\n\n    /// Whether to run in dry-run mode (no actual changes).\n    pub dry_run: bool,\n}\n\n/// Context passed to step executors.\n#[derive(Debug, Clone)]\npub struct RunContext {\n    /// Current variable values (macro vars + step overrides).\n    pub vars: HashMap\u003cString, String\u003e,\n\n    /// Execution options.\n    pub options: RunOptions,\n\n    /// Results from previous steps (for chaining).\n    pub previous_results: Vec\u003cStepResult\u003e,\n}\n\nimpl RunContext {\n    /// Create a new run context with initial variables.\n    pub fn new(vars: HashMap\u003cString, String\u003e, options: RunOptions) -\u003e Self {\n        Self { vars, options, previous_results: Vec::new() }\n    }\n\n    /// Merge step-level variable overrides into context.\n    pub fn with_step_vars(\n        \u0026self,\n        step_vars: \u0026HashMap\u003cString, String\u003e,\n    ) -\u003e HashMap\u003cString, String\u003e {\n        let mut merged = self.vars.clone();\n\n        // Render step vars (they may reference macro vars)\n        for (key, value) in step_vars {\n            let rendered =\n                render_string(value, \u0026merged).unwrap_or_else(|_| value.clone());\n            merged.insert(key.clone(), rendered);\n        }\n\n        merged\n    }\n\n    /// Add a step result to the context.\n    pub fn add_result(\u0026mut self, result: StepResult) {\n        // If the step created a file, add it as a variable for subsequent steps\n        if let Some(ref path) = result.output_path {\n            let var_name = format!(\"step_{}_output\", result.step_index);\n            self.vars.insert(var_name, path.to_string_lossy().to_string());\n        }\n        self.previous_results.push(result);\n    }\n}\n\n/// Trait for executing individual macro steps.\n///\n/// This allows the CLI/TUI to provide their own implementations\n/// that integrate with their error handling and UI.\npub trait StepExecutor {\n    /// Execute a template step.\n    fn execute_template(\n        \u0026self,\n        step: \u0026TemplateStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e;\n\n    /// Execute a capture step.\n    fn execute_capture(\n        \u0026self,\n        step: \u0026CaptureStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e;\n\n    /// Execute a shell step.\n    fn execute_shell(\n        \u0026self,\n        step: \u0026ShellStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e;\n}\n\n/// Run a macro with the given executor and context.\npub fn run_macro\u003cE: StepExecutor\u003e(\n    loaded: \u0026LoadedMacro,\n    executor: \u0026E,\n    mut ctx: RunContext,\n) -\u003e MacroResult {\n    let spec = \u0026loaded.spec;\n    let mut all_success = true;\n    let mut step_results = Vec::new();\n\n    for (index, step) in spec.steps.iter().enumerate() {\n        let result = execute_step(executor, step, index, \u0026ctx);\n\n        match result {\n            Ok(step_result) =\u003e {\n                ctx.add_result(step_result.clone());\n                step_results.push(step_result);\n            }\n            Err(e) =\u003e {\n                all_success = false;\n                let error_result = StepResult {\n                    step_index: index,\n                    success: false,\n                    message: e.to_string(),\n                    output_path: None,\n                };\n                step_results.push(error_result);\n\n                // Check error policy\n                if spec.on_error == ErrorPolicy::Abort {\n                    break;\n                }\n            }\n        }\n    }\n\n    let message = if all_success {\n        format!(\"Completed {} steps successfully\", step_results.len())\n    } else {\n        let failed_count = step_results.iter().filter(|r| !r.success).count();\n        format!(\n            \"Completed with {} failures out of {} steps\",\n            failed_count,\n            step_results.len()\n        )\n    };\n\n    MacroResult {\n        macro_name: loaded.logical_name.clone(),\n        step_results,\n        success: all_success,\n        message,\n    }\n}\n\nfn execute_step\u003cE: StepExecutor\u003e(\n    executor: \u0026E,\n    step: \u0026MacroStep,\n    _index: usize,\n    ctx: \u0026RunContext,\n) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n    // Check trust requirements for shell steps\n    if step.requires_trust() {\n        if !ctx.options.trust {\n            return Err(MacroRunError::TrustRequired);\n        }\n        if !ctx.options.allow_shell {\n            return Err(MacroRunError::ShellDisabled);\n        }\n    }\n\n    match step {\n        MacroStep::Template(t) =\u003e executor.execute_template(t, ctx),\n        MacroStep::Capture(c) =\u003e executor.execute_capture(c, ctx),\n        MacroStep::Shell(s) =\u003e executor.execute_shell(s, ctx),\n    }\n}\n\n/// Check if a macro contains any steps that require trust.\npub fn requires_trust(spec: \u0026MacroSpec) -\u003e bool {\n    spec.steps.iter().any(|s| s.requires_trust())\n}\n\n/// Get descriptions of all shell commands in a macro.\npub fn get_shell_commands(spec: \u0026MacroSpec) -\u003e Vec\u003cString\u003e {\n    spec.steps\n        .iter()\n        .filter_map(|s| match s {\n            MacroStep::Shell(shell) =\u003e Some(shell.shell.clone()),\n            _ =\u003e None,\n        })\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n\n    struct MockExecutor;\n\n    impl StepExecutor for MockExecutor {\n        fn execute_template(\n            \u0026self,\n            step: \u0026TemplateStep,\n            _ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Created template: {}\", step.template),\n                output_path: Some(PathBuf::from(\"test.md\")),\n            })\n        }\n\n        fn execute_capture(\n            \u0026self,\n            step: \u0026CaptureStep,\n            _ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Executed capture: {}\", step.capture),\n                output_path: None,\n            })\n        }\n\n        fn execute_shell(\n            \u0026self,\n            step: \u0026ShellStep,\n            _ctx: \u0026RunContext,\n        ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n            Ok(StepResult {\n                step_index: 0,\n                success: true,\n                message: format!(\"Executed: {}\", step.shell),\n                output_path: None,\n            })\n        }\n    }\n\n    #[test]\n    fn test_run_macro_simple() {\n        let spec = MacroSpec {\n            name: \"test\".to_string(),\n            description: String::new(),\n            vars: None,\n            steps: vec![MacroStep::Template(TemplateStep {\n                template: \"meeting\".to_string(),\n                output: None,\n                vars_with: HashMap::new(),\n            })],\n            on_error: ErrorPolicy::Abort,\n        };\n\n        let loaded = LoadedMacro {\n            logical_name: \"test\".to_string(),\n            path: PathBuf::from(\"test.yaml\"),\n            spec,\n        };\n\n        let ctx = RunContext::new(HashMap::new(), RunOptions::default());\n        let result = run_macro(\u0026loaded, \u0026MockExecutor, ctx);\n\n        assert!(result.success);\n        assert_eq!(result.step_results.len(), 1);\n    }\n\n    #[test]\n    fn test_shell_requires_trust() {\n        let spec = MacroSpec {\n            name: \"test\".to_string(),\n            description: String::new(),\n            vars: None,\n            steps: vec![MacroStep::Shell(ShellStep {\n                shell: \"echo hello\".to_string(),\n                description: String::new(),\n            })],\n            on_error: ErrorPolicy::Abort,\n        };\n\n        let loaded = LoadedMacro {\n            logical_name: \"test\".to_string(),\n            path: PathBuf::from(\"test.yaml\"),\n            spec,\n        };\n\n        // Without trust\n        let ctx = RunContext::new(HashMap::new(), RunOptions::default());\n        let result = run_macro(\u0026loaded, \u0026MockExecutor, ctx);\n        assert!(!result.success);\n\n        // With trust but shell disabled\n        let ctx = RunContext::new(\n            HashMap::new(),\n            RunOptions { trust: true, allow_shell: false, dry_run: false },\n        );\n        let result = run_macro(\u0026loaded, \u0026MockExecutor, ctx);\n        assert!(!result.success);\n\n        // With trust and shell enabled\n        let ctx = RunContext::new(\n            HashMap::new(),\n            RunOptions { trust: true, allow_shell: true, dry_run: false },\n        );\n        let result = run_macro(\u0026loaded, \u0026MockExecutor, ctx);\n        assert!(result.success);\n    }\n\n    #[test]\n    fn test_requires_trust_check() {\n        let spec_with_shell = MacroSpec {\n            name: \"test\".to_string(),\n            description: String::new(),\n            vars: None,\n            steps: vec![\n                MacroStep::Template(TemplateStep {\n                    template: \"meeting\".to_string(),\n                    output: None,\n                    vars_with: HashMap::new(),\n                }),\n                MacroStep::Shell(ShellStep {\n                    shell: \"git add .\".to_string(),\n                    description: String::new(),\n                }),\n            ],\n            on_error: ErrorPolicy::Abort,\n        };\n\n        let spec_without_shell = MacroSpec {\n            name: \"test\".to_string(),\n            description: String::new(),\n            vars: None,\n            steps: vec![MacroStep::Template(TemplateStep {\n                template: \"meeting\".to_string(),\n                output: None,\n                vars_with: HashMap::new(),\n            })],\n            on_error: ErrorPolicy::Abort,\n        };\n\n        assert!(requires_trust(\u0026spec_with_shell));\n        assert!(!requires_trust(\u0026spec_without_shell));\n    }\n}\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":9}},{"line":67,"address":[],"length":0,"stats":{"Line":18}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":18}},{"line":78,"address":[],"length":0,"stats":{"Line":9}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":5}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":22}},{"line":91,"address":[],"length":0,"stats":{"Line":28}},{"line":92,"address":[],"length":0,"stats":{"Line":28}},{"line":94,"address":[],"length":0,"stats":{"Line":24}},{"line":126,"address":[],"length":0,"stats":{"Line":9}},{"line":131,"address":[],"length":0,"stats":{"Line":18}},{"line":132,"address":[],"length":0,"stats":{"Line":18}},{"line":133,"address":[],"length":0,"stats":{"Line":18}},{"line":135,"address":[],"length":0,"stats":{"Line":38}},{"line":136,"address":[],"length":0,"stats":{"Line":60}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":16}},{"line":140,"address":[],"length":0,"stats":{"Line":40}},{"line":141,"address":[],"length":0,"stats":{"Line":16}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":18}},{"line":162,"address":[],"length":0,"stats":{"Line":28}},{"line":164,"address":[],"length":0,"stats":{"Line":10}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":27}},{"line":180,"address":[],"length":0,"stats":{"Line":10}},{"line":187,"address":[],"length":0,"stats":{"Line":20}},{"line":188,"address":[],"length":0,"stats":{"Line":3}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":8}},{"line":197,"address":[],"length":0,"stats":{"Line":25}},{"line":198,"address":[],"length":0,"stats":{"Line":10}},{"line":199,"address":[],"length":0,"stats":{"Line":5}},{"line":204,"address":[],"length":0,"stats":{"Line":12}},{"line":205,"address":[],"length":0,"stats":{"Line":56}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":3}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":0}}],"covered":52,"coverable":54},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","macros","types.rs"],"content":"//! Macro specification types for multi-step workflows.\n\nuse serde::Deserialize;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\nuse crate::vars::VarsMap;\n\n/// A macro specification loaded from a YAML file.\n///\n/// Macros are multi-step workflows that can execute templates, captures,\n/// and (with trust) shell commands.\n#[derive(Debug, Clone, Deserialize)]\npub struct MacroSpec {\n    /// Logical name of the macro.\n    pub name: String,\n\n    /// Human-readable description.\n    #[serde(default)]\n    pub description: String,\n\n    /// Variable specifications with prompts and defaults.\n    #[serde(default)]\n    pub vars: Option\u003cVarsMap\u003e,\n\n    /// Steps to execute in order.\n    pub steps: Vec\u003cMacroStep\u003e,\n\n    /// Error handling policy.\n    #[serde(default)]\n    pub on_error: ErrorPolicy,\n}\n\n/// A single step in a macro workflow.\n#[derive(Debug, Clone, Deserialize)]\n#[serde(untagged)]\npub enum MacroStep {\n    /// Execute a template to create a new file.\n    Template(TemplateStep),\n    /// Execute a capture to insert content into an existing file.\n    Capture(CaptureStep),\n    /// Execute a shell command (requires --trust).\n    Shell(ShellStep),\n}\n\n/// Template step: create a new file from a template.\n#[derive(Debug, Clone, Deserialize)]\npub struct TemplateStep {\n    /// Logical template name.\n    pub template: String,\n\n    /// Output path (optional, can use template frontmatter).\n    #[serde(default)]\n    pub output: Option\u003cString\u003e,\n\n    /// Variable overrides for this step.\n    #[serde(default, rename = \"with\")]\n    pub vars_with: HashMap\u003cString, String\u003e,\n}\n\n/// Capture step: insert content into an existing file.\n#[derive(Debug, Clone, Deserialize)]\npub struct CaptureStep {\n    /// Logical capture name.\n    pub capture: String,\n\n    /// Variable overrides for this step.\n    #[serde(default, rename = \"with\")]\n    pub vars_with: HashMap\u003cString, String\u003e,\n}\n\n/// Shell step: execute a shell command.\n#[derive(Debug, Clone, Deserialize)]\npub struct ShellStep {\n    /// Shell command to execute (supports {{var}} substitution).\n    pub shell: String,\n\n    /// Human-readable description of what this command does.\n    #[serde(default)]\n    pub description: String,\n}\n\n/// Error handling policy for macro execution.\n#[derive(Debug, Clone, Default, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"lowercase\")]\npub enum ErrorPolicy {\n    /// Stop execution on first error (default).\n    #[default]\n    Abort,\n    /// Continue with remaining steps after an error.\n    Continue,\n}\n\n/// Information about a discovered macro file.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct MacroInfo {\n    /// Logical name (filename without .yaml extension).\n    pub logical_name: String,\n    /// Full path to the YAML file.\n    pub path: PathBuf,\n}\n\n/// A fully loaded macro ready for execution.\n#[derive(Debug, Clone)]\npub struct LoadedMacro {\n    pub logical_name: String,\n    pub path: PathBuf,\n    pub spec: MacroSpec,\n}\n\n/// Result of executing a single macro step.\n#[derive(Debug, Clone)]\npub struct StepResult {\n    /// Zero-based step index.\n    pub step_index: usize,\n    /// Whether the step succeeded.\n    pub success: bool,\n    /// Human-readable description of what happened.\n    pub message: String,\n    /// Output path if a file was created.\n    pub output_path: Option\u003cPathBuf\u003e,\n}\n\n/// Result of executing an entire macro.\n#[derive(Debug, Clone)]\npub struct MacroResult {\n    /// Name of the macro that was executed.\n    pub macro_name: String,\n    /// Results for each step.\n    pub step_results: Vec\u003cStepResult\u003e,\n    /// Whether all steps succeeded.\n    pub success: bool,\n    /// Summary message.\n    pub message: String,\n}\n\nimpl MacroStep {\n    /// Get a human-readable description of this step.\n    pub fn description(\u0026self) -\u003e String {\n        match self {\n            MacroStep::Template(t) =\u003e format!(\"template: {}\", t.template),\n            MacroStep::Capture(c) =\u003e format!(\"capture: {}\", c.capture),\n            MacroStep::Shell(s) =\u003e {\n                if s.description.is_empty() {\n                    format!(\"shell: {}\", s.shell)\n                } else {\n                    s.description.clone()\n                }\n            }\n        }\n    }\n\n    /// Check if this step requires trust (shell execution).\n    pub fn requires_trust(\u0026self) -\u003e bool {\n        matches!(self, MacroStep::Shell(_))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_macro_spec() {\n        let yaml = r#\"\nname: weekly-review\ndescription: Set up weekly review documents\nvars:\n  week_topic:\n    prompt: \"What's the focus this week?\"\nsteps:\n  - template: weekly-summary\n    with:\n      topic: \"{{week_topic}}\"\n  - capture: archive-tasks\n\"#;\n        let spec: MacroSpec = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(spec.name, \"weekly-review\");\n        assert_eq!(spec.steps.len(), 2);\n        assert!(spec.vars.is_some());\n    }\n\n    #[test]\n    fn test_parse_template_step() {\n        let yaml = r#\"\ntemplate: meeting-note\noutput: \"meetings/{{date}}.md\"\nwith:\n  title: \"Weekly sync\"\n\"#;\n        let step: TemplateStep = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(step.template, \"meeting-note\");\n        assert_eq!(step.output, Some(\"meetings/{{date}}.md\".to_string()));\n        assert_eq!(step.vars_with.get(\"title\"), Some(\u0026\"Weekly sync\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_capture_step() {\n        let yaml = r#\"\ncapture: inbox\nwith:\n  text: \"Review PR #42\"\n\"#;\n        let step: CaptureStep = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(step.capture, \"inbox\");\n        assert_eq!(step.vars_with.get(\"text\"), Some(\u0026\"Review PR #42\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_shell_step() {\n        let yaml = r#\"\nshell: \"git add {{file}}\"\ndescription: Stage file in git\n\"#;\n        let step: ShellStep = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(step.shell, \"git add {{file}}\");\n        assert_eq!(step.description, \"Stage file in git\");\n    }\n\n    #[test]\n    fn test_error_policy_default() {\n        let spec: MacroSpec = serde_yaml::from_str(\n            r#\"\nname: test\nsteps: []\n\"#,\n        )\n        .unwrap();\n        assert_eq!(spec.on_error, ErrorPolicy::Abort);\n    }\n\n    #[test]\n    fn test_error_policy_continue() {\n        let spec: MacroSpec = serde_yaml::from_str(\n            r#\"\nname: test\non_error: continue\nsteps: []\n\"#,\n        )\n        .unwrap();\n        assert_eq!(spec.on_error, ErrorPolicy::Continue);\n    }\n\n    #[test]\n    fn test_step_requires_trust() {\n        let template_step = MacroStep::Template(TemplateStep {\n            template: \"test\".to_string(),\n            output: None,\n            vars_with: HashMap::new(),\n        });\n        let shell_step = MacroStep::Shell(ShellStep {\n            shell: \"echo hello\".to_string(),\n            description: String::new(),\n        });\n\n        assert!(!template_step.requires_trust());\n        assert!(shell_step.requires_trust());\n    }\n}\n","traces":[{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":28}},{"line":155,"address":[],"length":0,"stats":{"Line":49}}],"covered":2,"coverable":10},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","markdown_ast","comrak.rs"],"content":"use comrak::nodes::{NodeValue, Sourcepos};\nuse comrak::{Arena, Options, parse_document};\n\nuse crate::markdown_ast::types::*;\n\n/// Information about a section's position in the document\n#[derive(Debug)]\nstruct SectionBounds {\n    /// The heading info\n    heading: HeadingInfo,\n    /// Byte offset where the heading line ends (after newline)\n    content_start: usize,\n    /// Byte offset where the section content ends (before next heading or EOF)\n    content_end: usize,\n}\n\n/// Parse markdown and insert fragment into the specified section.\n/// Uses string-based insertion to preserve original formatting (including wikilinks).\npub fn insert_into_section(\n    input: \u0026str,\n    section: \u0026SectionMatch,\n    fragment: \u0026str,\n    position: InsertPosition,\n) -\u003e Result\u003cInsertResult, MarkdownAstError\u003e {\n    let trimmed = input.trim();\n    if trimmed.is_empty() {\n        return Err(MarkdownAstError::EmptyDocument);\n    }\n\n    // Handle empty fragment (no-op)\n    if fragment.trim().is_empty() {\n        let headings = find_headings(input);\n        let matched = headings\n            .into_iter()\n            .find(|h| matches_title(\u0026h.title, \u0026section.title, section.case_sensitive))\n            .ok_or_else(|| MarkdownAstError::SectionNotFound(section.title.clone()))?;\n\n        return Ok(InsertResult { content: input.to_string(), matched_heading: matched });\n    }\n\n    // Find section bounds using comrak for parsing\n    let bounds = find_section_bounds(input, section)?;\n\n    // Perform string-based insertion\n    let content = match position {\n        InsertPosition::Begin =\u003e {\n            // Insert right after the heading line\n            let mut result = String::with_capacity(input.len() + fragment.len() + 2);\n            result.push_str(\u0026input[..bounds.content_start]);\n\n            // Add newline before fragment if needed\n            if !result.ends_with('\\n') {\n                result.push('\\n');\n            }\n\n            // Add the fragment\n            result.push_str(fragment);\n\n            // Ensure fragment ends with newline\n            if !fragment.ends_with('\\n') {\n                result.push('\\n');\n            }\n\n            // Add rest of document\n            result.push_str(\u0026input[bounds.content_start..]);\n            result\n        }\n        InsertPosition::End =\u003e {\n            // Insert at the end of the section content, but before trailing blank lines\n            // This preserves section separator formatting\n            let section_content = \u0026input[bounds.content_start..bounds.content_end];\n            let trimmed_end = find_content_end_before_blanks(section_content);\n            let insert_point = bounds.content_start + trimmed_end;\n\n            let mut result = String::with_capacity(input.len() + fragment.len() + 2);\n            result.push_str(\u0026input[..insert_point]);\n\n            // Ensure there's a newline before the fragment\n            if insert_point \u003e 0 \u0026\u0026 !input[..insert_point].ends_with('\\n') {\n                result.push('\\n');\n            }\n\n            // Add the fragment\n            result.push_str(fragment);\n\n            // Ensure fragment ends with newline\n            if !fragment.ends_with('\\n') {\n                result.push('\\n');\n            }\n\n            // Add the trailing blank lines and rest of document\n            // If there were trailing blanks, add one blank line for section separation\n            let had_trailing_blanks = trimmed_end \u003c section_content.len();\n            if had_trailing_blanks \u0026\u0026 bounds.content_end \u003c input.len() {\n                // There's a next section, add a blank line separator\n                result.push('\\n');\n            }\n\n            // Add rest of document (starting from the next section)\n            result.push_str(\u0026input[bounds.content_end..]);\n            result\n        }\n    };\n\n    Ok(InsertResult { content, matched_heading: bounds.heading })\n}\n\n/// Find the bounds of a section in the document\nfn find_section_bounds(\n    input: \u0026str,\n    section: \u0026SectionMatch,\n) -\u003e Result\u003cSectionBounds, MarkdownAstError\u003e {\n    let arena = Arena::new();\n    let options = default_options();\n    let root = parse_document(\u0026arena, input, \u0026options);\n\n    let mut target_heading: Option\u003c(HeadingInfo, Sourcepos)\u003e = None;\n    let mut headings_with_pos: Vec\u003c(HeadingInfo, Sourcepos)\u003e = Vec::new();\n\n    // Collect all headings with their source positions\n    for node in root.descendants() {\n        if let NodeValue::Heading(ref heading) = node.data.borrow().value {\n            let title = collect_text(node);\n            let sourcepos = node.data.borrow().sourcepos;\n            let info = HeadingInfo { title: title.clone(), level: heading.level };\n\n            if target_heading.is_none()\n                \u0026\u0026 matches_title(\u0026title, \u0026section.title, section.case_sensitive)\n            {\n                target_heading = Some((info.clone(), sourcepos));\n            }\n\n            headings_with_pos.push((info, sourcepos));\n        }\n    }\n\n    let (heading, heading_pos) = target_heading\n        .ok_or_else(|| MarkdownAstError::SectionNotFound(section.title.clone()))?;\n\n    // Calculate content_start: byte offset after the heading line\n    let content_start = line_end_offset(input, heading_pos.end.line);\n\n    // Calculate content_end: before the next heading of same or higher level, or EOF\n    let content_end =\n        find_section_end_offset(input, \u0026heading, \u0026headings_with_pos, heading_pos);\n\n    Ok(SectionBounds { heading, content_start, content_end })\n}\n\n/// Get the byte offset at the end of a line (after newline if present)\nfn line_end_offset(input: \u0026str, line_num: usize) -\u003e usize {\n    let mut current_line = 1;\n    let mut offset = 0;\n\n    for (i, ch) in input.char_indices() {\n        if current_line == line_num \u0026\u0026 ch == '\\n' {\n            return i + 1;\n        }\n        if ch == '\\n' {\n            current_line += 1;\n        }\n        offset = i + ch.len_utf8();\n    }\n\n    // If we reach EOF on the target line\n    offset\n}\n\n/// Find the byte offset where a section ends\nfn find_section_end_offset(\n    input: \u0026str,\n    target_heading: \u0026HeadingInfo,\n    all_headings: \u0026[(HeadingInfo, Sourcepos)],\n    target_pos: Sourcepos,\n) -\u003e usize {\n    // Find the next heading of same or higher level\n    for (heading, pos) in all_headings {\n        // Skip headings before or at the target\n        if pos.start.line \u003c= target_pos.start.line {\n            continue;\n        }\n\n        // Found a heading of same or higher level - section ends here\n        if heading.level \u003c= target_heading.level {\n            // Return the byte offset at the start of this heading's line\n            return line_start_offset(input, pos.start.line);\n        }\n    }\n\n    // Section extends to EOF\n    input.len()\n}\n\n/// Get the byte offset at the start of a line\nfn line_start_offset(input: \u0026str, line_num: usize) -\u003e usize {\n    if line_num \u003c= 1 {\n        return 0;\n    }\n\n    let mut current_line = 1;\n\n    for (i, ch) in input.char_indices() {\n        if ch == '\\n' {\n            current_line += 1;\n            if current_line == line_num {\n                return i + 1;\n            }\n        }\n    }\n\n    input.len()\n}\n\n/// Find the end of actual content, before any trailing blank lines.\n/// Returns a byte offset relative to the start of the input string.\nfn find_content_end_before_blanks(content: \u0026str) -\u003e usize {\n    // Work backwards from the end to find the last non-blank line\n    let bytes = content.as_bytes();\n    let mut end = bytes.len();\n\n    // Skip trailing whitespace/newlines\n    while end \u003e 0\n        \u0026\u0026 (bytes[end - 1] == b'\\n' || bytes[end - 1] == b' ' || bytes[end - 1] == b'\\t')\n    {\n        end -= 1;\n    }\n\n    // Now find the end of the last content line (include its newline)\n    // We want to return the position after the newline of the last content line\n    if end \u003c bytes.len() {\n        // Find the newline after the content\n        if let Some(newline_offset) = bytes[end..].iter().position(|\u0026b| b == b'\\n') {\n            return end + newline_offset + 1;\n        }\n    }\n\n    // No trailing newline found, return the trimmed position\n    end\n}\n\n/// Find all headings in the document\npub fn find_headings(input: \u0026str) -\u003e Vec\u003cHeadingInfo\u003e {\n    let arena = Arena::new();\n    let options = default_options();\n    let root = parse_document(\u0026arena, input, \u0026options);\n\n    let mut headings = Vec::new();\n\n    for node in root.descendants() {\n        if let NodeValue::Heading(ref heading) = node.data.borrow().value {\n            let title = collect_text(node);\n\n            headings.push(HeadingInfo { title, level: heading.level });\n        }\n    }\n\n    headings\n}\n\n/// Find section by match criteria (returns first match)\npub fn find_section(input: \u0026str, section: \u0026SectionMatch) -\u003e Option\u003cHeadingInfo\u003e {\n    find_headings(input)\n        .into_iter()\n        .find(|h| matches_title(\u0026h.title, \u0026section.title, section.case_sensitive))\n}\n\n// --- Internal helpers ---\n\nfn default_options() -\u003e Options\u003c'static\u003e {\n    let mut options = Options::default();\n    // Enable GFM extensions for compatibility\n    options.extension.strikethrough = true;\n    options.extension.table = true;\n    options.extension.autolink = true;\n    options.extension.tasklist = true;\n    options.extension.footnotes = true;\n    options.extension.description_lists = true;\n\n    // Parse options\n    options.parse.smart = false; // Don't convert quotes/dashes\n\n    // Render options for CommonMark output\n    options.render.hardbreaks = false;\n    options.render.github_pre_lang = true;\n    options.render.unsafe_ = true; // Allow raw HTML passthrough\n\n    options\n}\n\nfn matches_title(heading_title: \u0026str, search_title: \u0026str, case_sensitive: bool) -\u003e bool {\n    let h = heading_title.trim();\n    let s = search_title.trim();\n\n    if case_sensitive { h == s } else { h.eq_ignore_ascii_case(s) }\n}\n\nfn collect_text\u003c'a\u003e(node: \u0026'a comrak::nodes::AstNode\u003c'a\u003e) -\u003e String {\n    let mut text = String::new();\n    for child in node.descendants() {\n        if let NodeValue::Text(ref t) = child.data.borrow().value {\n            text.push_str(t);\n        }\n    }\n    text\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":57}},{"line":25,"address":[],"length":0,"stats":{"Line":171}},{"line":26,"address":[],"length":0,"stats":{"Line":114}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":106}},{"line":32,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":204}},{"line":45,"address":[],"length":0,"stats":{"Line":92}},{"line":48,"address":[],"length":0,"stats":{"Line":95}},{"line":49,"address":[],"length":0,"stats":{"Line":57}},{"line":52,"address":[],"length":0,"stats":{"Line":19}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":57}},{"line":60,"address":[],"length":0,"stats":{"Line":22}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":57}},{"line":66,"address":[],"length":0,"stats":{"Line":19}},{"line":71,"address":[],"length":0,"stats":{"Line":81}},{"line":72,"address":[],"length":0,"stats":{"Line":81}},{"line":73,"address":[],"length":0,"stats":{"Line":54}},{"line":75,"address":[],"length":0,"stats":{"Line":135}},{"line":76,"address":[],"length":0,"stats":{"Line":81}},{"line":79,"address":[],"length":0,"stats":{"Line":54}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":81}},{"line":87,"address":[],"length":0,"stats":{"Line":32}},{"line":88,"address":[],"length":0,"stats":{"Line":5}},{"line":93,"address":[],"length":0,"stats":{"Line":81}},{"line":94,"address":[],"length":0,"stats":{"Line":90}},{"line":96,"address":[],"length":0,"stats":{"Line":21}},{"line":100,"address":[],"length":0,"stats":{"Line":81}},{"line":101,"address":[],"length":0,"stats":{"Line":27}},{"line":105,"address":[],"length":0,"stats":{"Line":46}},{"line":109,"address":[],"length":0,"stats":{"Line":51}},{"line":113,"address":[],"length":0,"stats":{"Line":102}},{"line":114,"address":[],"length":0,"stats":{"Line":102}},{"line":115,"address":[],"length":0,"stats":{"Line":255}},{"line":117,"address":[],"length":0,"stats":{"Line":153}},{"line":118,"address":[],"length":0,"stats":{"Line":153}},{"line":121,"address":[],"length":0,"stats":{"Line":747}},{"line":122,"address":[],"length":0,"stats":{"Line":777}},{"line":123,"address":[],"length":0,"stats":{"Line":396}},{"line":124,"address":[],"length":0,"stats":{"Line":264}},{"line":125,"address":[],"length":0,"stats":{"Line":396}},{"line":127,"address":[],"length":0,"stats":{"Line":264}},{"line":128,"address":[],"length":0,"stats":{"Line":336}},{"line":130,"address":[],"length":0,"stats":{"Line":138}},{"line":133,"address":[],"length":0,"stats":{"Line":396}},{"line":137,"address":[],"length":0,"stats":{"Line":143}},{"line":138,"address":[],"length":0,"stats":{"Line":66}},{"line":141,"address":[],"length":0,"stats":{"Line":184}},{"line":144,"address":[],"length":0,"stats":{"Line":46}},{"line":145,"address":[],"length":0,"stats":{"Line":230}},{"line":147,"address":[],"length":0,"stats":{"Line":92}},{"line":151,"address":[],"length":0,"stats":{"Line":46}},{"line":152,"address":[],"length":0,"stats":{"Line":92}},{"line":153,"address":[],"length":0,"stats":{"Line":92}},{"line":155,"address":[],"length":0,"stats":{"Line":2802}},{"line":156,"address":[],"length":0,"stats":{"Line":1840}},{"line":157,"address":[],"length":0,"stats":{"Line":46}},{"line":159,"address":[],"length":0,"stats":{"Line":1390}},{"line":160,"address":[],"length":0,"stats":{"Line":81}},{"line":162,"address":[],"length":0,"stats":{"Line":2618}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":46}},{"line":177,"address":[],"length":0,"stats":{"Line":346}},{"line":179,"address":[],"length":0,"stats":{"Line":110}},{"line":180,"address":[],"length":0,"stats":{"Line":78}},{"line":184,"address":[],"length":0,"stats":{"Line":32}},{"line":186,"address":[],"length":0,"stats":{"Line":90}},{"line":191,"address":[],"length":0,"stats":{"Line":32}},{"line":195,"address":[],"length":0,"stats":{"Line":30}},{"line":196,"address":[],"length":0,"stats":{"Line":30}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":60}},{"line":202,"address":[],"length":0,"stats":{"Line":4178}},{"line":203,"address":[],"length":0,"stats":{"Line":2059}},{"line":204,"address":[],"length":0,"stats":{"Line":213}},{"line":205,"address":[],"length":0,"stats":{"Line":213}},{"line":206,"address":[],"length":0,"stats":{"Line":30}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":27}},{"line":218,"address":[],"length":0,"stats":{"Line":81}},{"line":219,"address":[],"length":0,"stats":{"Line":81}},{"line":222,"address":[],"length":0,"stats":{"Line":79}},{"line":223,"address":[],"length":0,"stats":{"Line":127}},{"line":225,"address":[],"length":0,"stats":{"Line":52}},{"line":230,"address":[],"length":0,"stats":{"Line":54}},{"line":232,"address":[],"length":0,"stats":{"Line":108}},{"line":233,"address":[],"length":0,"stats":{"Line":27}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":19}},{"line":243,"address":[],"length":0,"stats":{"Line":38}},{"line":244,"address":[],"length":0,"stats":{"Line":38}},{"line":245,"address":[],"length":0,"stats":{"Line":95}},{"line":247,"address":[],"length":0,"stats":{"Line":38}},{"line":249,"address":[],"length":0,"stats":{"Line":229}},{"line":250,"address":[],"length":0,"stats":{"Line":287}},{"line":251,"address":[],"length":0,"stats":{"Line":192}},{"line":253,"address":[],"length":0,"stats":{"Line":144}},{"line":257,"address":[],"length":0,"stats":{"Line":19}},{"line":261,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":8}},{"line":264,"address":[],"length":0,"stats":{"Line":20}},{"line":269,"address":[],"length":0,"stats":{"Line":70}},{"line":270,"address":[],"length":0,"stats":{"Line":140}},{"line":272,"address":[],"length":0,"stats":{"Line":70}},{"line":273,"address":[],"length":0,"stats":{"Line":70}},{"line":274,"address":[],"length":0,"stats":{"Line":70}},{"line":275,"address":[],"length":0,"stats":{"Line":70}},{"line":276,"address":[],"length":0,"stats":{"Line":70}},{"line":277,"address":[],"length":0,"stats":{"Line":70}},{"line":280,"address":[],"length":0,"stats":{"Line":70}},{"line":283,"address":[],"length":0,"stats":{"Line":70}},{"line":284,"address":[],"length":0,"stats":{"Line":70}},{"line":285,"address":[],"length":0,"stats":{"Line":70}},{"line":287,"address":[],"length":0,"stats":{"Line":70}},{"line":290,"address":[],"length":0,"stats":{"Line":90}},{"line":291,"address":[],"length":0,"stats":{"Line":270}},{"line":292,"address":[],"length":0,"stats":{"Line":270}},{"line":294,"address":[],"length":0,"stats":{"Line":352}},{"line":297,"address":[],"length":0,"stats":{"Line":180}},{"line":298,"address":[],"length":0,"stats":{"Line":360}},{"line":299,"address":[],"length":0,"stats":{"Line":720}},{"line":300,"address":[],"length":0,"stats":{"Line":720}},{"line":301,"address":[],"length":0,"stats":{"Line":360}},{"line":304,"address":[],"length":0,"stats":{"Line":180}}],"covered":125,"coverable":131},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","markdown_ast","editor.rs"],"content":"use crate::markdown_ast::comrak;\nuse crate::markdown_ast::types::*;\n\n/// High-level API for Markdown AST operations\npub struct MarkdownEditor;\n\nimpl MarkdownEditor {\n    /// Insert a fragment into a named section\n    ///\n    /// # Arguments\n    /// * `input` - The source Markdown document\n    /// * `section` - Section matching configuration\n    /// * `fragment` - Markdown content to insert\n    /// * `position` - Where in the section to insert (Begin or End)\n    ///\n    /// # Returns\n    /// The modified document and metadata about the matched section\n    ///\n    /// # Errors\n    /// * `SectionNotFound` - No heading matches the section specification\n    /// * `EmptyDocument` - Input is empty or whitespace-only\n    pub fn insert_into_section(\n        input: \u0026str,\n        section: \u0026SectionMatch,\n        fragment: \u0026str,\n        position: InsertPosition,\n    ) -\u003e Result\u003cInsertResult, MarkdownAstError\u003e {\n        comrak::insert_into_section(input, section, fragment, position)\n    }\n\n    /// Find all headings in a document\n    ///\n    /// Useful for validation, debugging, and building section selectors\n    pub fn find_headings(input: \u0026str) -\u003e Vec\u003cHeadingInfo\u003e {\n        comrak::find_headings(input)\n    }\n\n    /// Check if a section exists in the document\n    pub fn section_exists(input: \u0026str, section: \u0026SectionMatch) -\u003e bool {\n        comrak::find_section(input, section).is_some()\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":57}},{"line":28,"address":[],"length":0,"stats":{"Line":285}},{"line":34,"address":[],"length":0,"stats":{"Line":13}},{"line":35,"address":[],"length":0,"stats":{"Line":26}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":12}}],"covered":6,"coverable":6},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","markdown_ast","mod.rs"],"content":"pub mod comrak;\npub mod editor;\npub mod types;\n\n// Re-export primary API\npub use editor::MarkdownEditor;\npub use types::{\n    HeadingInfo, InsertPosition, InsertResult, MarkdownAstError, SectionMatch,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","markdown_ast","types.rs"],"content":"use thiserror::Error;\n\n/// Position within a section where content should be inserted\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum InsertPosition {\n    /// Insert immediately after the section heading\n    #[default]\n    Begin,\n    /// Insert at the end of the section, before the next heading\n    End,\n}\n\n/// Configuration for section matching\n#[derive(Debug, Clone)]\npub struct SectionMatch {\n    /// The section title to find (compared after trimming)\n    pub title: String,\n    /// Use case-sensitive matching (default: false)\n    pub case_sensitive: bool,\n}\n\nimpl SectionMatch {\n    pub fn new(title: impl Into\u003cString\u003e) -\u003e Self {\n        Self { title: title.into(), case_sensitive: false }\n    }\n\n    pub fn case_sensitive(mut self, value: bool) -\u003e Self {\n        self.case_sensitive = value;\n        self\n    }\n}\n\n/// Information about a heading found in the document\n#[derive(Debug, Clone)]\npub struct HeadingInfo {\n    /// The heading text content\n    pub title: String,\n    /// The heading level (1-6)\n    pub level: u8,\n}\n\n/// Result of an insertion operation\n#[derive(Debug, Clone)]\npub struct InsertResult {\n    /// The modified markdown content\n    pub content: String,\n    /// Information about the matched section\n    pub matched_heading: HeadingInfo,\n}\n\n#[derive(Debug, Error)]\npub enum MarkdownAstError {\n    #[error(\"section not found: {0}\")]\n    SectionNotFound(String),\n\n    #[error(\"document is empty or contains no content\")]\n    EmptyDocument,\n\n    #[error(\"failed to render markdown: {0}\")]\n    RenderError(String),\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":35}},{"line":24,"address":[],"length":0,"stats":{"Line":35}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":4}}],"covered":5,"coverable":5},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","rename","detector.rs"],"content":"//! Reference detection for rename operations.\n//!\n//! Finds all references to a note in other files, with exact byte positions\n//! for format-preserving updates.\n\nuse std::path::Path;\nuse std::sync::LazyLock;\n\nuse regex::Regex;\n\nuse crate::frontmatter;\nuse crate::rename::types::{Reference, ReferenceType, RenameError};\n\n// Regex patterns for reference detection\nstatic WIKILINK_RE: LazyLock\u003cRegex\u003e = LazyLock::new(|| {\n    // Matches [[target]] or [[target|alias]] or [[target#section]] or [[target#section|alias]]\n    // Captures:\n    // 1: target (note name/path, may include #section)\n    // 2: alias (if present)\n    Regex::new(r\"\\[\\[([^\\]|#]+(?:#[^\\]|]+)?)(?:\\|([^\\]]+))?\\]\\]\").unwrap()\n});\n\nstatic MARKDOWN_LINK_RE: LazyLock\u003cRegex\u003e = LazyLock::new(|| {\n    // Matches [text](url)\n    // Captures:\n    // 1: text\n    // 2: url\n    Regex::new(r\"\\[([^\\]]+)\\]\\(([^)]+)\\)\").unwrap()\n});\n\n/// Find all references to a target note in a file's content.\n///\n/// Returns references with exact byte positions for replacement.\npub fn find_references_in_content(\n    content: \u0026str,\n    source_path: \u0026Path,\n    target_path: \u0026Path,\n    vault_root: \u0026Path,\n) -\u003e Vec\u003cReference\u003e {\n    let mut references = Vec::new();\n\n    // Get the target's basename and relative path for matching\n    let target_basename = target_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n\n    let target_rel = target_path.strip_prefix(vault_root).unwrap_or(target_path);\n\n    // Find references in body content\n    let body_refs =\n        find_body_references(content, source_path, target_basename, target_rel);\n    references.extend(body_refs);\n\n    // Find references in frontmatter\n    let fm_refs = find_frontmatter_references(content, source_path, target_basename);\n    references.extend(fm_refs);\n\n    references\n}\n\nfn find_body_references(\n    content: \u0026str,\n    source_path: \u0026Path,\n    target_basename: \u0026str,\n    target_rel: \u0026Path,\n) -\u003e Vec\u003cReference\u003e {\n    let mut references = Vec::new();\n\n    // Track byte offset for each line\n    let mut line_start_offset = 0;\n\n    for (line_idx, line) in content.lines().enumerate() {\n        let line_number = (line_idx + 1) as u32;\n\n        // Find wikilinks in this line\n        for cap in WIKILINK_RE.captures_iter(line) {\n            let full_match = cap.get(0).unwrap();\n            let target_text = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n            let alias = cap.get(2).map(|m| m.as_str().to_string());\n\n            // Parse target (may include #section)\n            let (note_ref, section) = parse_wikilink_target(target_text);\n\n            if matches_target(note_ref, target_basename, target_rel) {\n                let start = line_start_offset + full_match.start();\n                let end = line_start_offset + full_match.end();\n                let column = (full_match.start() + 1) as u32;\n\n                let ref_type = match (\u0026section, \u0026alias) {\n                    (Some(_), Some(_)) =\u003e ReferenceType::WikilinkWithSectionAndAlias,\n                    (Some(_), None) =\u003e ReferenceType::WikilinkWithSection,\n                    (None, Some(_)) =\u003e ReferenceType::WikilinkWithAlias,\n                    (None, None) =\u003e ReferenceType::Wikilink,\n                };\n\n                references.push(Reference {\n                    source_path: source_path.to_path_buf(),\n                    line_number,\n                    column,\n                    start,\n                    end,\n                    original: full_match.as_str().to_string(),\n                    ref_type,\n                    alias,\n                    section,\n                    target_as_written: note_ref.to_string(),\n                });\n            }\n        }\n\n        // Find markdown links in this line\n        for cap in MARKDOWN_LINK_RE.captures_iter(line) {\n            let full_match = cap.get(0).unwrap();\n            let link_text = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n            let url = cap.get(2).map(|m| m.as_str()).unwrap_or(\"\");\n\n            // Skip external URLs\n            if url.starts_with(\"http://\") || url.starts_with(\"https://\") {\n                continue;\n            }\n\n            if matches_markdown_target(url, target_basename, target_rel) {\n                let start = line_start_offset + full_match.start();\n                let end = line_start_offset + full_match.end();\n                let column = (full_match.start() + 1) as u32;\n\n                references.push(Reference {\n                    source_path: source_path.to_path_buf(),\n                    line_number,\n                    column,\n                    start,\n                    end,\n                    original: full_match.as_str().to_string(),\n                    ref_type: ReferenceType::MarkdownLink,\n                    alias: Some(link_text.to_string()),\n                    section: None,\n                    target_as_written: url.to_string(),\n                });\n            }\n        }\n\n        // Move to next line (add line length + newline character)\n        line_start_offset += line.len() + 1; // +1 for \\n\n    }\n\n    references\n}\n\nfn find_frontmatter_references(\n    content: \u0026str,\n    source_path: \u0026Path,\n    target_basename: \u0026str,\n) -\u003e Vec\u003cReference\u003e {\n    let mut references = Vec::new();\n\n    // Parse frontmatter\n    let parsed = match frontmatter::parse(content) {\n        Ok(p) =\u003e p,\n        Err(_) =\u003e return references,\n    };\n\n    let fm = match parsed.frontmatter {\n        Some(fm) =\u003e fm,\n        None =\u003e return references,\n    };\n\n    // Known reference fields\n    let ref_fields = [\"project\", \"parent\", \"related\", \"blocks\", \"blocked_by\"];\n\n    // Find frontmatter section bounds\n    let fm_bounds = find_frontmatter_bounds(content);\n\n    for field in \u0026ref_fields {\n        if let Some(value) = fm.fields.get(*field) {\n            // Handle single string value\n            if let Some(s) = value.as_str()\n                \u0026\u0026 matches_frontmatter_ref(s, target_basename)\n                \u0026\u0026 let Some((start, end)) =\n                    find_frontmatter_field_value(content, field, s, \u0026fm_bounds)\n            {\n                references.push(Reference {\n                    source_path: source_path.to_path_buf(),\n                    line_number: 0, // Frontmatter\n                    column: 0,\n                    start,\n                    end,\n                    original: s.to_string(),\n                    ref_type: ReferenceType::FrontmatterField {\n                        field: field.to_string(),\n                    },\n                    alias: None,\n                    section: None,\n                    target_as_written: s.to_string(),\n                });\n            }\n\n            // Handle array of strings\n            if let Some(arr) = value.as_sequence() {\n                for (idx, item) in arr.iter().enumerate() {\n                    if let Some(s) = item.as_str()\n                        \u0026\u0026 matches_frontmatter_ref(s, target_basename)\n                        \u0026\u0026 let Some((start, end)) =\n                            find_frontmatter_list_item(content, field, s, idx, \u0026fm_bounds)\n                    {\n                        references.push(Reference {\n                            source_path: source_path.to_path_buf(),\n                            line_number: 0,\n                            column: 0,\n                            start,\n                            end,\n                            original: s.to_string(),\n                            ref_type: ReferenceType::FrontmatterList {\n                                field: field.to_string(),\n                                index: idx,\n                            },\n                            alias: None,\n                            section: None,\n                            target_as_written: s.to_string(),\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    references\n}\n\n/// Parse a wikilink target, separating the note reference from the section anchor.\nfn parse_wikilink_target(target: \u0026str) -\u003e (\u0026str, Option\u003cString\u003e) {\n    if let Some(hash_pos) = target.find('#') {\n        let note = \u0026target[..hash_pos];\n        let section = \u0026target[hash_pos + 1..];\n        (note, Some(section.to_string()))\n    } else {\n        (target, None)\n    }\n}\n\n/// Check if a wikilink reference matches the target note.\nfn matches_target(reference: \u0026str, target_basename: \u0026str, target_rel: \u0026Path) -\u003e bool {\n    let ref_lower = reference.to_lowercase();\n    let basename_lower = target_basename.to_lowercase();\n\n    // Direct basename match (most common case)\n    if ref_lower == basename_lower {\n        return true;\n    }\n\n    // Match with .md extension\n    if ref_lower == format!(\"{}.md\", basename_lower) {\n        return true;\n    }\n\n    // Match full relative path\n    let target_rel_str = target_rel.to_string_lossy().to_lowercase();\n    if ref_lower == target_rel_str {\n        return true;\n    }\n\n    // Match relative path without .md\n    let target_no_ext = target_rel_str.strip_suffix(\".md\").unwrap_or(\u0026target_rel_str);\n    if ref_lower == target_no_ext {\n        return true;\n    }\n\n    false\n}\n\n/// Check if a markdown link URL matches the target note.\nfn matches_markdown_target(url: \u0026str, target_basename: \u0026str, target_rel: \u0026Path) -\u003e bool {\n    // Normalize the URL path\n    let url_normalized = url.trim_start_matches(\"./\").trim_start_matches(\"../\");\n\n    let url_lower = url_normalized.to_lowercase();\n    let basename_lower = target_basename.to_lowercase();\n    let target_rel_str = target_rel.to_string_lossy().to_lowercase();\n\n    // Match basename with .md\n    if url_lower == format!(\"{}.md\", basename_lower) {\n        return true;\n    }\n\n    // Match relative path\n    if url_lower == target_rel_str {\n        return true;\n    }\n\n    // Check if URL ends with target path (for relative paths)\n    if url_lower.ends_with(\u0026target_rel_str) {\n        return true;\n    }\n\n    // Check basename match in URL\n    if let Some(filename) = Path::new(url_normalized).file_name() {\n        let filename_str = filename.to_string_lossy().to_lowercase();\n        if filename_str == format!(\"{}.md\", basename_lower) {\n            return true;\n        }\n    }\n\n    false\n}\n\n/// Check if a frontmatter reference matches the target note.\nfn matches_frontmatter_ref(reference: \u0026str, target_basename: \u0026str) -\u003e bool {\n    let ref_lower = reference.to_lowercase();\n    let basename_lower = target_basename.to_lowercase();\n\n    ref_lower == basename_lower || ref_lower == format!(\"{}.md\", basename_lower)\n}\n\n/// Find the bounds of the frontmatter section.\nfn find_frontmatter_bounds(content: \u0026str) -\u003e Option\u003c(usize, usize)\u003e {\n    if !content.starts_with(\"---\") {\n        return None;\n    }\n\n    let start = 4; // After \"---\\n\"\n    content[start..].find(\"\\n---\").map(|end_marker| (0, start + end_marker + 4))\n}\n\n/// Find the byte position of a frontmatter field value.\nfn find_frontmatter_field_value(\n    content: \u0026str,\n    field: \u0026str,\n    value: \u0026str,\n    bounds: \u0026Option\u003c(usize, usize)\u003e,\n) -\u003e Option\u003c(usize, usize)\u003e {\n    let (fm_start, fm_end) = bounds.as_ref()?;\n    let fm_content = \u0026content[*fm_start..*fm_end];\n\n    // Look for pattern: \"field: value\" or \"field: 'value'\" or 'field: \"value\"'\n    let patterns = [\n        format!(\"{}: {}\", field, value),\n        format!(\"{}: '{}'\", field, value),\n        format!(\"{}: \\\"{}\\\"\", field, value),\n    ];\n\n    for pattern in \u0026patterns {\n        if let Some(pos) = fm_content.find(pattern.as_str()) {\n            let value_start = pos + field.len() + 2; // +2 for \": \"\n            let start = *fm_start + value_start;\n\n            // Adjust for quotes if present\n            let actual_start = if fm_content[value_start..].starts_with('\\'')\n                || fm_content[value_start..].starts_with('\"')\n            {\n                start + 1\n            } else {\n                start\n            };\n\n            return Some((actual_start, actual_start + value.len()));\n        }\n    }\n\n    None\n}\n\n/// Find the byte position of a frontmatter list item.\nfn find_frontmatter_list_item(\n    content: \u0026str,\n    field: \u0026str,\n    value: \u0026str,\n    _index: usize,\n    bounds: \u0026Option\u003c(usize, usize)\u003e,\n) -\u003e Option\u003c(usize, usize)\u003e {\n    let (fm_start, fm_end) = bounds.as_ref()?;\n    let fm_content = \u0026content[*fm_start..*fm_end];\n\n    // Find the field first\n    let field_pattern = format!(\"{}:\", field);\n    let field_pos = fm_content.find(\u0026field_pattern)?;\n\n    // Search after the field for the value in list format\n    let after_field = \u0026fm_content[field_pos..];\n\n    // Look for \"- value\" pattern (YAML list item)\n    let list_patterns =\n        [format!(\"- {}\", value), format!(\"- '{}'\", value), format!(\"- \\\"{}\\\"\", value)];\n\n    for pattern in \u0026list_patterns {\n        if let Some(pos) = after_field.find(pattern.as_str()) {\n            let value_start = pos + 2; // +2 for \"- \"\n            let start = *fm_start + field_pos + value_start;\n\n            // Adjust for quotes\n            let actual_start = if after_field[value_start..].starts_with('\\'')\n                || after_field[value_start..].starts_with('\"')\n            {\n                start + 1\n            } else {\n                start\n            };\n\n            return Some((actual_start, actual_start + value.len()));\n        }\n    }\n\n    // Also check inline array format: [item1, item2]\n    let inline_patterns = [\n        format!(\"[{}\", value),\n        format!(\", {}\", value),\n        format!(\"['{}']\", value),\n        format!(\", '{}']\", value),\n        format!(\"[\\\"{}\\\"]\", value),\n        format!(\", \\\"{}\\\"]\", value),\n    ];\n\n    for pattern in \u0026inline_patterns {\n        if let Some(pos) = after_field.find(pattern.as_str()) {\n            // Find where the value actually starts\n            let pattern_value_offset = if pattern.starts_with('[') { 1 } else { 2 };\n            let value_start = pos + pattern_value_offset;\n            let start = *fm_start + field_pos + value_start;\n\n            // Adjust for quotes\n            let actual_start = if after_field[value_start..].starts_with('\\'')\n                || after_field[value_start..].starts_with('\"')\n            {\n                start + 1\n            } else {\n                start\n            };\n\n            return Some((actual_start, actual_start + value.len()));\n        }\n    }\n\n    None\n}\n\n/// Read a file and find all references to a target note.\n#[allow(dead_code)]\npub fn find_references_in_file(\n    source_path: \u0026Path,\n    target_path: \u0026Path,\n    vault_root: \u0026Path,\n) -\u003e Result\u003cVec\u003cReference\u003e, RenameError\u003e {\n    let content = std::fs::read_to_string(source_path).map_err(|e| {\n        RenameError::ReadError { path: source_path.to_path_buf(), source: e }\n    })?;\n\n    Ok(find_references_in_content(\u0026content, source_path, target_path, vault_root))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_find_wikilink_basic() {\n        let content = \"Here is a link to [[my-note]] in the text.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert_eq!(refs[0].original, \"[[my-note]]\");\n        assert_eq!(refs[0].ref_type, ReferenceType::Wikilink);\n        // \"Here is a link to \" = 18 chars, so [[my-note]] starts at 18\n        assert_eq!(refs[0].start, 18);\n        assert_eq!(refs[0].end, 29);\n    }\n\n    #[test]\n    fn test_find_wikilink_with_alias() {\n        let content = \"Link to [[my-note|My Note Title]] here.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert_eq!(refs[0].ref_type, ReferenceType::WikilinkWithAlias);\n        assert_eq!(refs[0].alias, Some(\"My Note Title\".to_string()));\n    }\n\n    #[test]\n    fn test_find_wikilink_with_section() {\n        let content = \"See [[my-note#section]] for details.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert_eq!(refs[0].ref_type, ReferenceType::WikilinkWithSection);\n        assert_eq!(refs[0].section, Some(\"section\".to_string()));\n    }\n\n    #[test]\n    fn test_find_markdown_link() {\n        let content = \"Check out [this note](./my-note.md) for more.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert_eq!(refs[0].ref_type, ReferenceType::MarkdownLink);\n        assert_eq!(refs[0].alias, Some(\"this note\".to_string()));\n    }\n\n    #[test]\n    fn test_find_multiple_references() {\n        let content = r#\"# Notes\n\nLink to [[my-note]] and also [[my-note|alias]].\nAnd a [markdown link](my-note.md) too.\n\"#;\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 3);\n    }\n\n    #[test]\n    fn test_case_insensitive_matching() {\n        let content = \"Link to [[My-Note]] here.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n    }\n\n    #[test]\n    fn test_no_match_different_note() {\n        let content = \"Link to [[other-note]] here.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 0);\n    }\n\n    #[test]\n    fn test_skip_external_urls() {\n        let content = \"See [example](https://example.com) for details.\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/example.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 0);\n    }\n\n    #[test]\n    fn test_line_numbers() {\n        let content = \"Line 1\\nLine 2 with [[my-note]]\\nLine 3\";\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert_eq!(refs[0].line_number, 2);\n    }\n\n    #[test]\n    fn test_frontmatter_field_reference() {\n        let content = r#\"---\ntitle: Test\nproject: my-note\n---\n# Content\n\"#;\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert!(matches!(refs[0].ref_type, ReferenceType::FrontmatterField { .. }));\n    }\n\n    #[test]\n    fn test_frontmatter_list_reference() {\n        let content = r#\"---\ntitle: Test\nrelated:\n  - other-note\n  - my-note\n  - another-note\n---\n# Content\n\"#;\n        let refs = find_references_in_content(\n            content,\n            Path::new(\"source.md\"),\n            Path::new(\"/vault/my-note.md\"),\n            Path::new(\"/vault\"),\n        );\n\n        assert_eq!(refs.len(), 1);\n        assert!(matches!(refs[0].ref_type, ReferenceType::FrontmatterList { .. }));\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":24}},{"line":43,"address":[],"length":0,"stats":{"Line":96}},{"line":45,"address":[],"length":0,"stats":{"Line":72}},{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":60}},{"line":50,"address":[],"length":0,"stats":{"Line":36}},{"line":53,"address":[],"length":0,"stats":{"Line":60}},{"line":54,"address":[],"length":0,"stats":{"Line":36}},{"line":56,"address":[],"length":0,"stats":{"Line":12}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":65,"address":[],"length":0,"stats":{"Line":24}},{"line":68,"address":[],"length":0,"stats":{"Line":24}},{"line":70,"address":[],"length":0,"stats":{"Line":96}},{"line":71,"address":[],"length":0,"stats":{"Line":60}},{"line":74,"address":[],"length":0,"stats":{"Line":99}},{"line":75,"address":[],"length":0,"stats":{"Line":36}},{"line":76,"address":[],"length":0,"stats":{"Line":72}},{"line":77,"address":[],"length":0,"stats":{"Line":40}},{"line":80,"address":[],"length":0,"stats":{"Line":27}},{"line":82,"address":[],"length":0,"stats":{"Line":36}},{"line":83,"address":[],"length":0,"stats":{"Line":24}},{"line":84,"address":[],"length":0,"stats":{"Line":24}},{"line":85,"address":[],"length":0,"stats":{"Line":16}},{"line":87,"address":[],"length":0,"stats":{"Line":24}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":5}},{"line":94,"address":[],"length":0,"stats":{"Line":24}},{"line":95,"address":[],"length":0,"stats":{"Line":24}},{"line":96,"address":[],"length":0,"stats":{"Line":16}},{"line":97,"address":[],"length":0,"stats":{"Line":16}},{"line":98,"address":[],"length":0,"stats":{"Line":16}},{"line":99,"address":[],"length":0,"stats":{"Line":16}},{"line":100,"address":[],"length":0,"stats":{"Line":24}},{"line":101,"address":[],"length":0,"stats":{"Line":16}},{"line":102,"address":[],"length":0,"stats":{"Line":16}},{"line":103,"address":[],"length":0,"stats":{"Line":16}},{"line":104,"address":[],"length":0,"stats":{"Line":8}},{"line":110,"address":[],"length":0,"stats":{"Line":93}},{"line":111,"address":[],"length":0,"stats":{"Line":12}},{"line":112,"address":[],"length":0,"stats":{"Line":24}},{"line":113,"address":[],"length":0,"stats":{"Line":24}},{"line":116,"address":[],"length":0,"stats":{"Line":12}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":10}},{"line":121,"address":[],"length":0,"stats":{"Line":8}},{"line":122,"address":[],"length":0,"stats":{"Line":8}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":30}},{"line":144,"address":[],"length":0,"stats":{"Line":12}},{"line":147,"address":[],"length":0,"stats":{"Line":12}},{"line":152,"address":[],"length":0,"stats":{"Line":24}},{"line":155,"address":[],"length":0,"stats":{"Line":24}},{"line":156,"address":[],"length":0,"stats":{"Line":24}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":14}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":10}},{"line":166,"address":[],"length":0,"stats":{"Line":8}},{"line":169,"address":[],"length":0,"stats":{"Line":6}},{"line":171,"address":[],"length":0,"stats":{"Line":22}},{"line":172,"address":[],"length":0,"stats":{"Line":22}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":3}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":3}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":187,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":197,"address":[],"length":0,"stats":{"Line":8}},{"line":198,"address":[],"length":0,"stats":{"Line":6}},{"line":199,"address":[],"length":0,"stats":{"Line":9}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":5}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":3}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":2}},{"line":208,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":3}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":9}},{"line":229,"address":[],"length":0,"stats":{"Line":10}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":8}},{"line":239,"address":[],"length":0,"stats":{"Line":9}},{"line":240,"address":[],"length":0,"stats":{"Line":27}},{"line":241,"address":[],"length":0,"stats":{"Line":27}},{"line":244,"address":[],"length":0,"stats":{"Line":9}},{"line":245,"address":[],"length":0,"stats":{"Line":8}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[],"length":0,"stats":{"Line":1}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":6}},{"line":273,"address":[],"length":0,"stats":{"Line":6}},{"line":274,"address":[],"length":0,"stats":{"Line":6}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[],"length":0,"stats":{"Line":4}},{"line":279,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":12}},{"line":306,"address":[],"length":0,"stats":{"Line":12}},{"line":308,"address":[],"length":0,"stats":{"Line":8}},{"line":312,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":2}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":4}},{"line":318,"address":[],"length":0,"stats":{"Line":8}},{"line":322,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":4}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":332,"address":[],"length":0,"stats":{"Line":2}},{"line":333,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":335,"address":[],"length":0,"stats":{"Line":1}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":3}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":344,"address":[],"length":0,"stats":{"Line":3}},{"line":345,"address":[],"length":0,"stats":{"Line":2}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":1}},{"line":352,"address":[],"length":0,"stats":{"Line":3}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":367,"address":[],"length":0,"stats":{"Line":4}},{"line":368,"address":[],"length":0,"stats":{"Line":3}},{"line":371,"address":[],"length":0,"stats":{"Line":3}},{"line":372,"address":[],"length":0,"stats":{"Line":4}},{"line":375,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":379,"address":[],"length":0,"stats":{"Line":5}},{"line":381,"address":[],"length":0,"stats":{"Line":2}},{"line":382,"address":[],"length":0,"stats":{"Line":4}},{"line":383,"address":[],"length":0,"stats":{"Line":2}},{"line":384,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":3}},{"line":388,"address":[],"length":0,"stats":{"Line":2}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":1}},{"line":395,"address":[],"length":0,"stats":{"Line":3}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}}],"covered":176,"coverable":216},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","rename","mod.rs"],"content":"//! Rename and reference management for mdvault.\n//!\n//! This module provides safe note renaming with automatic reference updates.\n//! It handles wikilinks, markdown links, and frontmatter references.\n\nmod detector;\nmod types;\nmod updater;\n\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\npub use types::*;\n\nuse crate::index::IndexDb;\n\nuse detector::find_references_in_content;\nuse updater::apply_updates;\n\n/// Generate a preview of what a rename operation would do.\n///\n/// This does not modify any files - it only calculates what changes would be made.\npub fn generate_preview(\n    db: \u0026IndexDb,\n    vault_root: \u0026Path,\n    old_path: \u0026Path,\n    new_path: \u0026Path,\n) -\u003e Result\u003cRenamePreview, RenameError\u003e {\n    // Validate paths\n    let old_abs = if old_path.is_absolute() {\n        old_path.to_path_buf()\n    } else {\n        vault_root.join(old_path)\n    };\n\n    let new_abs = if new_path.is_absolute() {\n        new_path.to_path_buf()\n    } else {\n        vault_root.join(new_path)\n    };\n\n    if !old_abs.exists() {\n        return Err(RenameError::SourceNotFound(old_abs));\n    }\n\n    if new_abs.exists() {\n        return Err(RenameError::TargetExists(new_abs));\n    }\n\n    // Find the note in the index\n    let old_rel = old_abs.strip_prefix(vault_root).unwrap_or(\u0026old_abs);\n    let note = db\n        .get_note_by_path(old_rel)\n        .map_err(|e| RenameError::IndexError(e.to_string()))?\n        .ok_or_else(|| RenameError::NoteNotInIndex(old_abs.clone()))?;\n\n    let note_id =\n        note.id.ok_or_else(|| RenameError::IndexError(\"Note has no ID\".to_string()))?;\n\n    // Get backlinks from index to find files that reference this note\n    let backlinks =\n        db.get_backlinks(note_id).map_err(|e| RenameError::IndexError(e.to_string()))?;\n\n    // Find all references by parsing the source files\n    let mut all_references = Vec::new();\n    let mut files_to_scan: HashMap\u003cPathBuf, ()\u003e = HashMap::new();\n\n    for link in \u0026backlinks {\n        if let Some(source_note) = db\n            .get_note_by_id(link.source_id)\n            .map_err(|e| RenameError::IndexError(e.to_string()))?\n        {\n            let source_path = vault_root.join(\u0026source_note.path);\n            files_to_scan.insert(source_path, ());\n        }\n    }\n\n    // Scan each file for exact reference positions\n    for source_path in files_to_scan.keys() {\n        let content = fs::read_to_string(source_path).map_err(|e| {\n            RenameError::ReadError { path: source_path.clone(), source: e }\n        })?;\n\n        let refs =\n            find_references_in_content(\u0026content, source_path, \u0026old_abs, vault_root);\n        all_references.extend(refs);\n    }\n\n    // Get the new basename for reference updates\n    let new_basename =\n        new_abs.file_stem().and_then(|s| s.to_str()).unwrap_or(\"unnamed\").to_string();\n\n    // Generate file changes\n    let mut changes = Vec::new();\n    let mut warnings = Vec::new();\n\n    // Group references by file\n    let mut refs_by_file: HashMap\u003cPathBuf, Vec\u003cReference\u003e\u003e = HashMap::new();\n    for reference in \u0026all_references {\n        refs_by_file\n            .entry(reference.source_path.clone())\n            .or_default()\n            .push(reference.clone());\n    }\n\n    for (source_path, refs) in refs_by_file {\n        let content = fs::read_to_string(\u0026source_path).map_err(|e| {\n            RenameError::ReadError { path: source_path.clone(), source: e }\n        })?;\n\n        let new_content = apply_updates(\u0026content, \u0026refs, \u0026new_basename);\n\n        changes.push(FileChange {\n            path: source_path,\n            original_content: content,\n            new_content,\n            references: refs,\n        });\n    }\n\n    // Check for potential ambiguity (multiple notes with same basename)\n    let new_basename_lower = new_basename.to_lowercase();\n    if let Ok(notes) = db.query_notes(\u0026Default::default()) {\n        let conflicts: Vec\u003c_\u003e = notes\n            .iter()\n            .filter(|n| {\n                let basename = n.path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n                basename.to_lowercase() == new_basename_lower \u0026\u0026 n.path != old_rel\n            })\n            .collect();\n\n        if !conflicts.is_empty() {\n            warnings.push(format!(\n                \"Warning: {} existing note(s) have the same basename '{}'. \\\n                 This may cause ambiguous wikilink references.\",\n                conflicts.len(),\n                new_basename\n            ));\n        }\n    }\n\n    Ok(RenamePreview {\n        old_path: old_abs,\n        new_path: new_abs,\n        references: all_references,\n        changes,\n        warnings,\n    })\n}\n\n/// Execute a rename operation.\n///\n/// This modifies files on disk and updates the index.\npub fn execute_rename(\n    db: \u0026IndexDb,\n    vault_root: \u0026Path,\n    old_path: \u0026Path,\n    new_path: \u0026Path,\n) -\u003e Result\u003cRenameResult, RenameError\u003e {\n    // Generate preview first to get all the info\n    let preview = generate_preview(db, vault_root, old_path, new_path)?;\n\n    // Apply changes to all affected files\n    let mut files_modified = Vec::new();\n    let mut references_updated = 0;\n\n    for change in \u0026preview.changes {\n        fs::write(\u0026change.path, \u0026change.new_content).map_err(|e| {\n            RenameError::WriteError { path: change.path.clone(), source: e }\n        })?;\n\n        files_modified.push(change.path.clone());\n        references_updated += change.references.len();\n    }\n\n    // Create parent directory for new path if needed\n    if let Some(parent) = preview.new_path.parent()\n        \u0026\u0026 !parent.exists()\n    {\n        fs::create_dir_all(parent).map_err(|e| RenameError::WriteError {\n            path: parent.to_path_buf(),\n            source: e,\n        })?;\n    }\n\n    // Rename the file itself\n    fs::rename(\u0026preview.old_path, \u0026preview.new_path).map_err(RenameError::RenameError)?;\n\n    // Update the index\n    let old_rel = preview.old_path.strip_prefix(vault_root).unwrap_or(\u0026preview.old_path);\n    let new_rel = preview.new_path.strip_prefix(vault_root).unwrap_or(\u0026preview.new_path);\n\n    update_note_path(db, old_rel, new_rel)\n        .map_err(|e| RenameError::IndexError(e.to_string()))?;\n\n    // Re-resolve link targets after the rename\n    db.resolve_link_targets().map_err(|e| RenameError::IndexError(e.to_string()))?;\n\n    Ok(RenameResult {\n        old_path: preview.old_path,\n        new_path: preview.new_path,\n        files_modified,\n        references_updated,\n        warnings: preview.warnings,\n    })\n}\n\n/// Update a note's path in the index.\nfn update_note_path(\n    db: \u0026IndexDb,\n    old_path: \u0026Path,\n    new_path: \u0026Path,\n) -\u003e Result\u003c(), crate::index::IndexError\u003e {\n    let conn = db.connection();\n\n    // Update the notes table\n    conn.execute(\n        \"UPDATE notes SET path = ?1 WHERE path = ?2\",\n        rusqlite::params![new_path.to_string_lossy(), old_path.to_string_lossy(),],\n    )?;\n\n    // Update target_path in links table where it matches the old path\n    let old_basename = old_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n    let new_basename = new_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\");\n\n    // Update exact matches\n    conn.execute(\n        \"UPDATE links SET target_path = ?1 WHERE target_path = ?2\",\n        rusqlite::params![new_path.to_string_lossy(), old_path.to_string_lossy(),],\n    )?;\n\n    // Update basename-only matches\n    conn.execute(\n        \"UPDATE links SET target_path = ?1 WHERE target_path = ?2\",\n        rusqlite::params![new_basename, old_basename],\n    )?;\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::index::types::{IndexedNote, NoteType};\n    use chrono::Utc;\n    use std::path::PathBuf;\n    use tempfile::TempDir;\n\n    fn setup_test_vault() -\u003e (TempDir, IndexDb) {\n        let temp_dir = TempDir::new().unwrap();\n        let db = IndexDb::open_in_memory().unwrap();\n        (temp_dir, db)\n    }\n\n    fn create_note(dir: \u0026Path, name: \u0026str, content: \u0026str) -\u003e PathBuf {\n        let path = dir.join(name);\n        if let Some(parent) = path.parent() {\n            fs::create_dir_all(parent).unwrap();\n        }\n        fs::write(\u0026path, content).unwrap();\n        path\n    }\n\n    fn sample_note(path: \u0026str) -\u003e IndexedNote {\n        IndexedNote {\n            id: None,\n            path: PathBuf::from(path),\n            note_type: NoteType::None,\n            title: \"Test\".to_string(),\n            created: Some(Utc::now()),\n            modified: Utc::now(),\n            frontmatter_json: None,\n            content_hash: \"hash\".to_string(),\n        }\n    }\n\n    #[test]\n    fn test_generate_preview_source_not_found() {\n        let (temp_dir, db) = setup_test_vault();\n        let result = generate_preview(\n            \u0026db,\n            temp_dir.path(),\n            Path::new(\"nonexistent.md\"),\n            Path::new(\"new.md\"),\n        );\n\n        assert!(matches!(result, Err(RenameError::SourceNotFound(_))));\n    }\n\n    #[test]\n    fn test_generate_preview_target_exists() {\n        let (temp_dir, db) = setup_test_vault();\n\n        create_note(temp_dir.path(), \"old.md\", \"# Old\");\n        create_note(temp_dir.path(), \"new.md\", \"# New\");\n\n        db.insert_note(\u0026sample_note(\"old.md\")).unwrap();\n\n        let result = generate_preview(\n            \u0026db,\n            temp_dir.path(),\n            Path::new(\"old.md\"),\n            Path::new(\"new.md\"),\n        );\n\n        assert!(matches!(result, Err(RenameError::TargetExists(_))));\n    }\n\n    #[test]\n    fn test_generate_preview_no_references() {\n        let (temp_dir, db) = setup_test_vault();\n\n        create_note(temp_dir.path(), \"old.md\", \"# Old Note\\n\\nContent here.\");\n        db.insert_note(\u0026sample_note(\"old.md\")).unwrap();\n\n        let preview = generate_preview(\n            \u0026db,\n            temp_dir.path(),\n            Path::new(\"old.md\"),\n            Path::new(\"new.md\"),\n        )\n        .unwrap();\n\n        assert_eq!(preview.references.len(), 0);\n        assert_eq!(preview.changes.len(), 0);\n    }\n\n    #[test]\n    fn test_execute_rename_simple() {\n        let (temp_dir, db) = setup_test_vault();\n\n        create_note(temp_dir.path(), \"old.md\", \"# Old Note\\n\\nContent.\");\n        db.insert_note(\u0026sample_note(\"old.md\")).unwrap();\n\n        let result = execute_rename(\n            \u0026db,\n            temp_dir.path(),\n            Path::new(\"old.md\"),\n            Path::new(\"new.md\"),\n        )\n        .unwrap();\n\n        // Old file should not exist\n        assert!(!temp_dir.path().join(\"old.md\").exists());\n\n        // New file should exist\n        assert!(temp_dir.path().join(\"new.md\").exists());\n\n        // Index should be updated\n        assert!(db.get_note_by_path(Path::new(\"old.md\")).unwrap().is_none());\n        assert!(db.get_note_by_path(Path::new(\"new.md\")).unwrap().is_some());\n\n        assert_eq!(result.references_updated, 0);\n    }\n\n    #[test]\n    fn test_execute_rename_with_references() {\n        let (temp_dir, db) = setup_test_vault();\n\n        // Create target note\n        create_note(temp_dir.path(), \"old.md\", \"# Old Note\\n\\nContent.\");\n        let old_id = db.insert_note(\u0026sample_note(\"old.md\")).unwrap();\n\n        // Create source note with reference\n        create_note(temp_dir.path(), \"source.md\", \"# Source\\n\\nSee [[old]] for details.\");\n        let source_id = db.insert_note(\u0026sample_note(\"source.md\")).unwrap();\n\n        // Add link in index\n        db.insert_link(\u0026crate::index::types::IndexedLink {\n            id: None,\n            source_id,\n            target_id: Some(old_id),\n            target_path: \"old\".to_string(),\n            link_text: None,\n            link_type: crate::index::types::LinkType::Wikilink,\n            context: None,\n            line_number: Some(3),\n        })\n        .unwrap();\n\n        // Execute rename\n        let result = execute_rename(\n            \u0026db,\n            temp_dir.path(),\n            Path::new(\"old.md\"),\n            Path::new(\"new.md\"),\n        )\n        .unwrap();\n\n        // Check reference was updated\n        assert_eq!(result.references_updated, 1);\n        assert_eq!(result.files_modified.len(), 1);\n\n        // Verify file content was updated\n        let source_content =\n            fs::read_to_string(temp_dir.path().join(\"source.md\")).unwrap();\n        assert!(source_content.contains(\"[[new]]\"));\n        assert!(!source_content.contains(\"[[old]]\"));\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":15}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":15}},{"line":37,"address":[],"length":0,"stats":{"Line":15}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":15}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":15}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":12}},{"line":66,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":9}},{"line":69,"address":[],"length":0,"stats":{"Line":5}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":7}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":5}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":21}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":9}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":5}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":9}},{"line":125,"address":[],"length":0,"stats":{"Line":9}},{"line":127,"address":[],"length":0,"stats":{"Line":7}},{"line":128,"address":[],"length":0,"stats":{"Line":28}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":3}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":6}},{"line":146,"address":[],"length":0,"stats":{"Line":6}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":12}},{"line":165,"address":[],"length":0,"stats":{"Line":4}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":8}},{"line":191,"address":[],"length":0,"stats":{"Line":10}},{"line":192,"address":[],"length":0,"stats":{"Line":10}},{"line":194,"address":[],"length":0,"stats":{"Line":8}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":6}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":4}},{"line":202,"address":[],"length":0,"stats":{"Line":4}},{"line":203,"address":[],"length":0,"stats":{"Line":4}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":6}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":220,"address":[],"length":0,"stats":{"Line":10}},{"line":224,"address":[],"length":0,"stats":{"Line":16}},{"line":225,"address":[],"length":0,"stats":{"Line":16}},{"line":228,"address":[],"length":0,"stats":{"Line":4}},{"line":230,"address":[],"length":0,"stats":{"Line":10}},{"line":234,"address":[],"length":0,"stats":{"Line":4}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":2}}],"covered":94,"coverable":107},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","rename","types.rs"],"content":"//! Data structures for the rename and reference management system.\n\nuse std::path::PathBuf;\nuse thiserror::Error;\n\n/// Errors that can occur during rename operations\n#[derive(Debug, Error)]\npub enum RenameError {\n    #[error(\"source file not found: {0}\")]\n    SourceNotFound(PathBuf),\n\n    #[error(\"target file already exists: {0}\")]\n    TargetExists(PathBuf),\n\n    #[error(\"failed to read file {path}: {source}\")]\n    ReadError {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    #[error(\"failed to write file {path}: {source}\")]\n    WriteError {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    #[error(\"failed to rename file: {0}\")]\n    RenameError(#[source] std::io::Error),\n\n    #[error(\"index error: {0}\")]\n    IndexError(String),\n\n    #[error(\"note not found in index: {0}\")]\n    NoteNotInIndex(PathBuf),\n}\n\n/// Type of reference found in a file\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ReferenceType {\n    /// Basic wikilink: [[note]] or [[path/note]]\n    Wikilink,\n    /// Wikilink with display alias: [[note|Display Text]]\n    WikilinkWithAlias,\n    /// Wikilink with section anchor: [[note#section]]\n    WikilinkWithSection,\n    /// Wikilink with both alias and section: [[note#section|Display Text]]\n    WikilinkWithSectionAndAlias,\n    /// Standard markdown link: [text](path.md)\n    MarkdownLink,\n    /// Frontmatter scalar field: project: note-name\n    FrontmatterField { field: String },\n    /// Frontmatter list item: related: [note1, note2]\n    FrontmatterList { field: String, index: usize },\n}\n\n/// A reference to a note found in a file\n#[derive(Debug, Clone)]\npub struct Reference {\n    /// File containing the reference\n    pub source_path: PathBuf,\n    /// Line number (1-based, 0 for frontmatter)\n    pub line_number: u32,\n    /// Column number (1-based)\n    pub column: u32,\n    /// Byte offset start in file\n    pub start: usize,\n    /// Byte offset end in file\n    pub end: usize,\n    /// Original text of the reference (e.g., \"[[old-note|Alias]]\")\n    pub original: String,\n    /// Reference type\n    pub ref_type: ReferenceType,\n    /// For wikilinks with aliases, the alias text\n    pub alias: Option\u003cString\u003e,\n    /// For wikilinks with sections, the section anchor\n    pub section: Option\u003cString\u003e,\n    /// The link target as written (may be basename or full path)\n    pub target_as_written: String,\n}\n\nimpl Reference {\n    /// Returns true if this is a wikilink-style reference\n    pub fn is_wikilink(\u0026self) -\u003e bool {\n        matches!(\n            self.ref_type,\n            ReferenceType::Wikilink\n                | ReferenceType::WikilinkWithAlias\n                | ReferenceType::WikilinkWithSection\n                | ReferenceType::WikilinkWithSectionAndAlias\n        )\n    }\n\n    /// Returns true if this is a markdown link reference\n    pub fn is_markdown_link(\u0026self) -\u003e bool {\n        matches!(self.ref_type, ReferenceType::MarkdownLink)\n    }\n\n    /// Returns true if this is a frontmatter reference\n    pub fn is_frontmatter(\u0026self) -\u003e bool {\n        matches!(\n            self.ref_type,\n            ReferenceType::FrontmatterField { .. }\n                | ReferenceType::FrontmatterList { .. }\n        )\n    }\n\n    /// Returns true if the original reference used a full path (not just basename)\n    pub fn uses_full_path(\u0026self) -\u003e bool {\n        self.target_as_written.contains('/')\n    }\n}\n\n/// A change to be made to a file\n#[derive(Debug, Clone)]\npub struct FileChange {\n    /// Path to the file\n    pub path: PathBuf,\n    /// Original content of the file\n    pub original_content: String,\n    /// New content after applying updates\n    pub new_content: String,\n    /// References in this file that will be updated\n    pub references: Vec\u003cReference\u003e,\n}\n\n/// Preview of what a rename operation would do\n#[derive(Debug)]\npub struct RenamePreview {\n    /// Original path of the note\n    pub old_path: PathBuf,\n    /// New path for the note\n    pub new_path: PathBuf,\n    /// All references found across the vault\n    pub references: Vec\u003cReference\u003e,\n    /// Changes that would be made to each file\n    pub changes: Vec\u003cFileChange\u003e,\n    /// Warnings about potential issues\n    pub warnings: Vec\u003cString\u003e,\n}\n\nimpl RenamePreview {\n    /// Total number of references that would be updated\n    pub fn total_references(\u0026self) -\u003e usize {\n        self.references.len()\n    }\n\n    /// Number of files that would be modified\n    pub fn files_affected(\u0026self) -\u003e usize {\n        self.changes.len()\n    }\n}\n\n/// Result of a successful rename operation\n#[derive(Debug)]\npub struct RenameResult {\n    /// Original path of the note\n    pub old_path: PathBuf,\n    /// New path of the note\n    pub new_path: PathBuf,\n    /// Files that were modified\n    pub files_modified: Vec\u003cPathBuf\u003e,\n    /// Number of references updated\n    pub references_updated: usize,\n    /// Warnings about potential issues\n    pub warnings: Vec\u003cString\u003e,\n}\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":8}},{"line":111,"address":[],"length":0,"stats":{"Line":8}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":14},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","rename","updater.rs"],"content":"//! Reference update logic for rename operations.\n//!\n//! Updates references in files while preserving their original format.\n\nuse std::path::Path;\n\nuse crate::rename::types::{Reference, ReferenceType};\n\n/// Generate the updated text for a reference.\n///\n/// Preserves the original format (wikilink style, alias, section, etc.)\n/// while updating the target path.\npub fn update_reference(reference: \u0026Reference, new_basename: \u0026str) -\u003e String {\n    match \u0026reference.ref_type {\n        ReferenceType::Wikilink =\u003e {\n            if reference.uses_full_path() {\n                // Preserve path structure: [[path/old]] -\u003e [[path/new]]\n                let new_path =\n                    update_path_in_reference(\u0026reference.target_as_written, new_basename);\n                format!(\"[[{}]]\", new_path)\n            } else {\n                format!(\"[[{}]]\", new_basename)\n            }\n        }\n\n        ReferenceType::WikilinkWithAlias =\u003e {\n            let alias = reference.alias.as_deref().unwrap_or(\"\");\n            if reference.uses_full_path() {\n                let new_path =\n                    update_path_in_reference(\u0026reference.target_as_written, new_basename);\n                format!(\"[[{}|{}]]\", new_path, alias)\n            } else {\n                format!(\"[[{}|{}]]\", new_basename, alias)\n            }\n        }\n\n        ReferenceType::WikilinkWithSection =\u003e {\n            let section = reference.section.as_deref().unwrap_or(\"\");\n            if reference.uses_full_path() {\n                let new_path =\n                    update_path_in_reference(\u0026reference.target_as_written, new_basename);\n                format!(\"[[{}#{}]]\", new_path, section)\n            } else {\n                format!(\"[[{}#{}]]\", new_basename, section)\n            }\n        }\n\n        ReferenceType::WikilinkWithSectionAndAlias =\u003e {\n            let section = reference.section.as_deref().unwrap_or(\"\");\n            let alias = reference.alias.as_deref().unwrap_or(\"\");\n            if reference.uses_full_path() {\n                let new_path =\n                    update_path_in_reference(\u0026reference.target_as_written, new_basename);\n                format!(\"[[{}#{}|{}]]\", new_path, section, alias)\n            } else {\n                format!(\"[[{}#{}|{}]]\", new_basename, section, alias)\n            }\n        }\n\n        ReferenceType::MarkdownLink =\u003e {\n            let link_text = reference.alias.as_deref().unwrap_or(\"\");\n            let new_url = update_markdown_url(\u0026reference.target_as_written, new_basename);\n            format!(\"[{}]({})\", link_text, new_url)\n        }\n\n        ReferenceType::FrontmatterField { .. }\n        | ReferenceType::FrontmatterList { .. } =\u003e {\n            // Frontmatter references are just the basename\n            new_basename.to_string()\n        }\n    }\n}\n\n/// Update a path-style reference, preserving the directory structure.\nfn update_path_in_reference(original: \u0026str, new_basename: \u0026str) -\u003e String {\n    if let Some(slash_pos) = original.rfind('/') {\n        // Preserve directory path\n        let dir = \u0026original[..=slash_pos];\n        format!(\"{}{}\", dir, new_basename)\n    } else {\n        new_basename.to_string()\n    }\n}\n\n/// Update a markdown URL, preserving relative path structure and .md extension.\nfn update_markdown_url(original: \u0026str, new_basename: \u0026str) -\u003e String {\n    // Preserve leading ./ or ../\n    let prefix = if original.starts_with(\"./\") {\n        \"./\"\n    } else if original.starts_with(\"../\") {\n        // Count how many ../ there are\n        let mut prefix = String::new();\n        let mut remaining = original;\n        while remaining.starts_with(\"../\") {\n            prefix.push_str(\"../\");\n            remaining = \u0026remaining[3..];\n        }\n        // Return the prefix portion for use\n        return format!(\"{}{}\", prefix, update_path_portion(remaining, new_basename));\n    } else {\n        \"\"\n    };\n\n    let without_prefix = original.strip_prefix(prefix).unwrap_or(original);\n    let new_path = update_path_portion(without_prefix, new_basename);\n\n    format!(\"{}{}\", prefix, new_path)\n}\n\n/// Update the path portion of a URL (after any leading ./ or ../).\nfn update_path_portion(path: \u0026str, new_basename: \u0026str) -\u003e String {\n    if let Some(slash_pos) = path.rfind('/') {\n        // Preserve directory structure\n        let dir = \u0026path[..=slash_pos];\n        format!(\"{}{}.md\", dir, new_basename)\n    } else {\n        // Just the filename\n        format!(\"{}.md\", new_basename)\n    }\n}\n\n/// Apply reference updates to file content.\n///\n/// References must be sorted by start position (will be processed in reverse order).\npub fn apply_updates(\n    content: \u0026str,\n    references: \u0026[Reference],\n    new_basename: \u0026str,\n) -\u003e String {\n    // Sort references by start position (descending) to apply from end to start\n    let mut sorted_refs: Vec\u003c_\u003e = references.iter().collect();\n    sorted_refs.sort_by(|a, b| b.start.cmp(\u0026a.start));\n\n    let mut result = content.to_string();\n\n    for reference in sorted_refs {\n        let replacement = update_reference(reference, new_basename);\n\n        // Verify bounds are valid\n        if reference.start \u003c= result.len() \u0026\u0026 reference.end \u003c= result.len() {\n            result.replace_range(reference.start..reference.end, \u0026replacement);\n        }\n    }\n\n    result\n}\n\n/// Compute the new relative path for a markdown link when the target moves.\n///\n/// This handles the case where we need to recalculate relative paths.\n#[allow(dead_code)]\npub fn compute_relative_path(\n    source_path: \u0026Path,\n    _old_target: \u0026Path,\n    new_target: \u0026Path,\n    vault_root: \u0026Path,\n) -\u003e String {\n    // Get paths relative to vault root\n    let source_rel = source_path.strip_prefix(vault_root).unwrap_or(source_path);\n    let new_target_rel = new_target.strip_prefix(vault_root).unwrap_or(new_target);\n\n    // Get parent directories\n    let source_dir = source_rel.parent().unwrap_or(Path::new(\"\"));\n    let target_dir = new_target_rel.parent().unwrap_or(Path::new(\"\"));\n\n    // If same directory, just use filename\n    if source_dir == target_dir {\n        return format!(\n            \"./{}.md\",\n            new_target_rel.file_stem().unwrap_or_default().to_string_lossy()\n        );\n    }\n\n    // Calculate relative path\n    let mut prefix = String::new();\n    let mut source_components: Vec\u003c_\u003e = source_dir.components().collect();\n    let mut target_components: Vec\u003c_\u003e = target_dir.components().collect();\n\n    // Find common prefix\n    while !source_components.is_empty()\n        \u0026\u0026 !target_components.is_empty()\n        \u0026\u0026 source_components[0] == target_components[0]\n    {\n        source_components.remove(0);\n        target_components.remove(0);\n    }\n\n    // Add ../ for each remaining source component\n    for _ in \u0026source_components {\n        prefix.push_str(\"../\");\n    }\n\n    // Add remaining target components\n    for comp in \u0026target_components {\n        prefix.push_str(\u0026comp.as_os_str().to_string_lossy());\n        prefix.push('/');\n    }\n\n    format!(\n        \"{}{}.md\",\n        prefix,\n        new_target_rel.file_stem().unwrap_or_default().to_string_lossy()\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n\n    fn make_reference(\n        original: \u0026str,\n        ref_type: ReferenceType,\n        start: usize,\n        end: usize,\n    ) -\u003e Reference {\n        Reference {\n            source_path: PathBuf::from(\"source.md\"),\n            line_number: 1,\n            column: 1,\n            start,\n            end,\n            original: original.to_string(),\n            ref_type,\n            alias: None,\n            section: None,\n            target_as_written: extract_target(original),\n        }\n    }\n\n    fn extract_target(original: \u0026str) -\u003e String {\n        // Simple extraction for tests\n        original\n            .trim_start_matches(\"[[\")\n            .trim_end_matches(\"]]\")\n            .split('|')\n            .next()\n            .unwrap_or(\"\")\n            .split('#')\n            .next()\n            .unwrap_or(\"\")\n            .to_string()\n    }\n\n    #[test]\n    fn test_update_basic_wikilink() {\n        let reference = make_reference(\"[[old-note]]\", ReferenceType::Wikilink, 0, 12);\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[[new-note]]\");\n    }\n\n    #[test]\n    fn test_update_wikilink_with_alias() {\n        let mut reference = make_reference(\n            \"[[old-note|My Alias]]\",\n            ReferenceType::WikilinkWithAlias,\n            0,\n            21,\n        );\n        reference.alias = Some(\"My Alias\".to_string());\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[[new-note|My Alias]]\");\n    }\n\n    #[test]\n    fn test_update_wikilink_with_section() {\n        let mut reference = make_reference(\n            \"[[old-note#section]]\",\n            ReferenceType::WikilinkWithSection,\n            0,\n            20,\n        );\n        reference.section = Some(\"section\".to_string());\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[[new-note#section]]\");\n    }\n\n    #[test]\n    fn test_update_wikilink_preserves_path() {\n        let mut reference =\n            make_reference(\"[[tasks/old-note]]\", ReferenceType::Wikilink, 0, 18);\n        reference.target_as_written = \"tasks/old-note\".to_string();\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[[tasks/new-note]]\");\n    }\n\n    #[test]\n    fn test_update_markdown_link() {\n        let mut reference = make_reference(\n            \"[link text](./old-note.md)\",\n            ReferenceType::MarkdownLink,\n            0,\n            26,\n        );\n        reference.alias = Some(\"link text\".to_string());\n        reference.target_as_written = \"./old-note.md\".to_string();\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[link text](./new-note.md)\");\n    }\n\n    #[test]\n    fn test_update_markdown_link_relative() {\n        let mut reference = make_reference(\n            \"[text](../tasks/old-note.md)\",\n            ReferenceType::MarkdownLink,\n            0,\n            28,\n        );\n        reference.alias = Some(\"text\".to_string());\n        reference.target_as_written = \"../tasks/old-note.md\".to_string();\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"[text](../tasks/new-note.md)\");\n    }\n\n    #[test]\n    fn test_update_frontmatter_field() {\n        let reference = Reference {\n            source_path: PathBuf::from(\"source.md\"),\n            line_number: 0,\n            column: 0,\n            start: 20,\n            end: 28,\n            original: \"old-note\".to_string(),\n            ref_type: ReferenceType::FrontmatterField { field: \"project\".to_string() },\n            alias: None,\n            section: None,\n            target_as_written: \"old-note\".to_string(),\n        };\n\n        let result = update_reference(\u0026reference, \"new-note\");\n        assert_eq!(result, \"new-note\");\n    }\n\n    #[test]\n    fn test_apply_updates_single() {\n        let content = \"Link to [[old-note]] here.\";\n        let reference = make_reference(\"[[old-note]]\", ReferenceType::Wikilink, 8, 20);\n\n        let result = apply_updates(content, \u0026[reference], \"new-note\");\n        assert_eq!(result, \"Link to [[new-note]] here.\");\n    }\n\n    #[test]\n    fn test_apply_updates_multiple() {\n        let content = \"First [[old-note]] and second [[old-note|alias]].\";\n        let ref1 = make_reference(\"[[old-note]]\", ReferenceType::Wikilink, 6, 18);\n        let mut ref2 = make_reference(\n            \"[[old-note|alias]]\",\n            ReferenceType::WikilinkWithAlias,\n            30,\n            48,\n        );\n        ref2.alias = Some(\"alias\".to_string());\n\n        let result = apply_updates(content, \u0026[ref1, ref2], \"new-note\");\n        assert_eq!(result, \"First [[new-note]] and second [[new-note|alias]].\");\n    }\n\n    #[test]\n    fn test_compute_relative_path_same_dir() {\n        let source = Path::new(\"/vault/notes/source.md\");\n        let old = Path::new(\"/vault/notes/old.md\");\n        let new = Path::new(\"/vault/notes/new.md\");\n        let vault = Path::new(\"/vault\");\n\n        let result = compute_relative_path(source, old, new, vault);\n        assert_eq!(result, \"./new.md\");\n    }\n\n    #[test]\n    fn test_compute_relative_path_parent_dir() {\n        let source = Path::new(\"/vault/notes/subdir/source.md\");\n        let old = Path::new(\"/vault/notes/old.md\");\n        let new = Path::new(\"/vault/notes/new.md\");\n        let vault = Path::new(\"/vault\");\n\n        let result = compute_relative_path(source, old, new, vault);\n        assert_eq!(result, \"../new.md\");\n    }\n\n    #[test]\n    fn test_compute_relative_path_different_branch() {\n        let source = Path::new(\"/vault/notes/source.md\");\n        let old = Path::new(\"/vault/tasks/old.md\");\n        let new = Path::new(\"/vault/tasks/new.md\");\n        let vault = Path::new(\"/vault\");\n\n        let result = compute_relative_path(source, old, new, vault);\n        assert_eq!(result, \"../tasks/new.md\");\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":11}},{"line":14,"address":[],"length":0,"stats":{"Line":11}},{"line":16,"address":[],"length":0,"stats":{"Line":10}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":3}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":10}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":5}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":10}},{"line":62,"address":[],"length":0,"stats":{"Line":8}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":5}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":5}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":5}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":15}},{"line":132,"address":[],"length":0,"stats":{"Line":9}},{"line":134,"address":[],"length":0,"stats":{"Line":9}},{"line":136,"address":[],"length":0,"stats":{"Line":11}},{"line":137,"address":[],"length":0,"stats":{"Line":16}},{"line":140,"address":[],"length":0,"stats":{"Line":20}},{"line":141,"address":[],"length":0,"stats":{"Line":12}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":18}},{"line":160,"address":[],"length":0,"stats":{"Line":18}},{"line":163,"address":[],"length":0,"stats":{"Line":15}},{"line":164,"address":[],"length":0,"stats":{"Line":15}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":4}},{"line":176,"address":[],"length":0,"stats":{"Line":10}},{"line":177,"address":[],"length":0,"stats":{"Line":10}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":3}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":6}},{"line":190,"address":[],"length":0,"stats":{"Line":4}},{"line":194,"address":[],"length":0,"stats":{"Line":5}},{"line":195,"address":[],"length":0,"stats":{"Line":4}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":6}}],"covered":72,"coverable":87},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","bindings.rs"],"content":"//! Lua bindings for mdvault functionality.\n//!\n//! This module provides the `mdv` global table with bindings to\n//! mdvault's date math and template rendering engines.\n\nuse mlua::{Function, Lua, Result as LuaResult, Table, Value};\nuse std::collections::HashMap;\n\nuse crate::templates::engine::{RenderContext, render_string};\nuse crate::vars::datemath::{evaluate_date_expr, is_date_expr, parse_date_expr};\n\n/// Register the `mdv` global table with all bindings.\n///\n/// After calling this function, Lua scripts can use:\n/// - `mdv.date(expr, format?)` - Evaluate date math expressions\n/// - `mdv.render(template, context)` - Render templates with variables\n/// - `mdv.is_date_expr(str)` - Check if string is a date expression\npub fn register_mdv_table(lua: \u0026Lua) -\u003e LuaResult\u003c()\u003e {\n    let mdv = lua.create_table()?;\n\n    mdv.set(\"date\", create_date_fn(lua)?)?;\n    mdv.set(\"render\", create_render_fn(lua)?)?;\n    mdv.set(\"is_date_expr\", create_is_date_expr_fn(lua)?)?;\n\n    lua.globals().set(\"mdv\", mdv)?;\n    Ok(())\n}\n\n/// Create the `mdv.date(expr, format?)` function.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// mdv.date(\"today\")           -- \"2025-12-29\"\n/// mdv.date(\"today + 7d\")      -- \"2026-01-05\"\n/// mdv.date(\"today\", \"%B %d\")  -- \"December 29\"\n/// mdv.date(\"now\", \"%H:%M\")    -- \"14:30\"\n/// ```\nfn create_date_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|_, args: (String, Option\u003cString\u003e)| {\n        let (expr, format_override) = args;\n\n        // Parse the expression\n        let mut parsed =\n            parse_date_expr(\u0026expr).map_err(|e| mlua::Error::runtime(e.to_string()))?;\n\n        // Override format if provided as second argument\n        if let Some(fmt) = format_override {\n            parsed.format = Some(fmt);\n        }\n\n        Ok(evaluate_date_expr(\u0026parsed))\n    })\n}\n\n/// Create the `mdv.render(template, context)` function.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// mdv.render(\"Hello {{name}}\", { name = \"World\" })  -- \"Hello World\"\n/// mdv.render(\"Count: {{n}}\", { n = 42 })            -- \"Count: 42\"\n/// ```\nfn create_render_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|_, args: (String, Table)| {\n        let (template, ctx_table) = args;\n\n        // Convert Lua table to RenderContext (HashMap\u003cString, String\u003e)\n        let mut ctx: RenderContext = HashMap::new();\n\n        for pair in ctx_table.pairs::\u003cString, Value\u003e() {\n            let (key, value) = pair?;\n            let str_value = lua_value_to_string(\u0026key, value)?;\n            ctx.insert(key, str_value);\n        }\n\n        render_string(\u0026template, \u0026ctx).map_err(|e| mlua::Error::runtime(e.to_string()))\n    })\n}\n\n/// Create the `mdv.is_date_expr(str)` function.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// mdv.is_date_expr(\"today + 1d\")  -- true\n/// mdv.is_date_expr(\"hello\")       -- false\n/// ```\nfn create_is_date_expr_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|_, s: String| Ok(is_date_expr(\u0026s)))\n}\n\n/// Convert a Lua value to a string for use in template context.\nfn lua_value_to_string(key: \u0026str, value: Value) -\u003e LuaResult\u003cString\u003e {\n    match value {\n        Value::String(s) =\u003e Ok(s.to_str()?.to_string()),\n        Value::Integer(i) =\u003e Ok(i.to_string()),\n        Value::Number(n) =\u003e Ok(n.to_string()),\n        Value::Boolean(b) =\u003e Ok(b.to_string()),\n        Value::Nil =\u003e Ok(String::new()),\n        _ =\u003e Err(mlua::Error::runtime(format!(\n            \"context value for '{}' must be string, number, boolean, or nil\",\n            key\n        ))),\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":46}},{"line":19,"address":[],"length":0,"stats":{"Line":138}},{"line":21,"address":[],"length":0,"stats":{"Line":184}},{"line":22,"address":[],"length":0,"stats":{"Line":184}},{"line":23,"address":[],"length":0,"stats":{"Line":184}},{"line":25,"address":[],"length":0,"stats":{"Line":138}},{"line":26,"address":[],"length":0,"stats":{"Line":46}},{"line":39,"address":[],"length":0,"stats":{"Line":46}},{"line":40,"address":[],"length":0,"stats":{"Line":138}},{"line":41,"address":[],"length":0,"stats":{"Line":138}},{"line":44,"address":[],"length":0,"stats":{"Line":45}},{"line":45,"address":[],"length":0,"stats":{"Line":142}},{"line":48,"address":[],"length":0,"stats":{"Line":63}},{"line":49,"address":[],"length":0,"stats":{"Line":9}},{"line":52,"address":[],"length":0,"stats":{"Line":45}},{"line":64,"address":[],"length":0,"stats":{"Line":46}},{"line":65,"address":[],"length":0,"stats":{"Line":96}},{"line":66,"address":[],"length":0,"stats":{"Line":12}},{"line":69,"address":[],"length":0,"stats":{"Line":12}},{"line":71,"address":[],"length":0,"stats":{"Line":12}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":16}},{"line":74,"address":[],"length":0,"stats":{"Line":16}},{"line":77,"address":[],"length":0,"stats":{"Line":16}},{"line":89,"address":[],"length":0,"stats":{"Line":46}},{"line":90,"address":[],"length":0,"stats":{"Line":98}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}}],"covered":30,"coverable":36},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","engine.rs"],"content":"//! Lua scripting engine with sandboxing.\n//!\n//! This module provides a sandboxed Lua execution environment for\n//! running user-defined scripts safely.\n\nuse mlua::{Lua, Result as LuaResult, StdLib, Value};\n\nuse super::bindings::register_mdv_table;\nuse super::index_bindings::register_index_bindings;\nuse super::types::{SandboxConfig, ScriptingError};\nuse super::vault_bindings::register_vault_bindings;\nuse super::vault_context::VaultContext;\n\n/// A sandboxed Lua execution environment.\n///\n/// The engine provides access to mdvault functionality through the `mdv`\n/// global table while restricting dangerous operations like file I/O\n/// and shell execution.\n///\n/// # Example\n///\n/// ```rust\n/// use mdvault_core::scripting::LuaEngine;\n///\n/// let engine = LuaEngine::sandboxed().unwrap();\n/// let result = engine.eval_string(r#\"mdv.date(\"today + 7d\")\"#).unwrap();\n/// println!(\"One week from now: {}\", result);\n/// ```\npub struct LuaEngine {\n    lua: Lua,\n    #[allow(dead_code)]\n    config: SandboxConfig,\n}\n\nimpl LuaEngine {\n    /// Create a new Lua engine with the given sandbox configuration.\n    pub fn new(config: SandboxConfig) -\u003e Result\u003cSelf, ScriptingError\u003e {\n        // Create Lua with restricted standard library\n        // Note: base functions (print, type, tostring, etc.) are always available\n        // We add: table, string, utf8, math\n        let libs = StdLib::TABLE | StdLib::STRING | StdLib::UTF8 | StdLib::MATH;\n\n        let lua = Lua::new_with(libs, mlua::LuaOptions::default())?;\n\n        // Apply memory limit if configured\n        if config.memory_limit \u003e 0 {\n            lua.set_memory_limit(config.memory_limit)?;\n        }\n\n        // Remove dangerous globals\n        Self::apply_sandbox(\u0026lua)?;\n\n        // Register mdv bindings\n        register_mdv_table(\u0026lua)?;\n\n        Ok(Self { lua, config })\n    }\n\n    /// Create a new engine with default restrictive sandbox.\n    pub fn sandboxed() -\u003e Result\u003cSelf, ScriptingError\u003e {\n        Self::new(SandboxConfig::restricted())\n    }\n\n    /// Create a new Lua engine with vault context for hook execution.\n    ///\n    /// This provides access to `mdv.template()`, `mdv.capture()`, `mdv.macro()`\n    /// and index query functions in addition to the standard sandboxed bindings.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// use mdvault_core::scripting::{LuaEngine, VaultContext, SandboxConfig};\n    ///\n    /// let vault_ctx = VaultContext::new(config, templates, captures, macros, types);\n    /// let engine = LuaEngine::with_vault_context(SandboxConfig::restricted(), vault_ctx)?;\n    ///\n    /// // Now Lua scripts can use vault operations\n    /// engine.eval_string(r#\"\n    ///     local ok, err = mdv.capture(\"log-to-daily\", { text = \"Hello\" })\n    /// \"#)?;\n    ///\n    /// // And query the index (if available)\n    /// engine.eval_string(r#\"\n    ///     local tasks = mdv.query({ type = \"task\" })\n    /// \"#)?;\n    /// ```\n    pub fn with_vault_context(\n        config: SandboxConfig,\n        vault_ctx: VaultContext,\n    ) -\u003e Result\u003cSelf, ScriptingError\u003e {\n        // Create Lua with restricted standard library\n        let libs = StdLib::TABLE | StdLib::STRING | StdLib::UTF8 | StdLib::MATH;\n        let lua = Lua::new_with(libs, mlua::LuaOptions::default())?;\n\n        // Apply memory limit if configured\n        if config.memory_limit \u003e 0 {\n            lua.set_memory_limit(config.memory_limit)?;\n        }\n\n        // Remove dangerous globals\n        Self::apply_sandbox(\u0026lua)?;\n\n        // Register standard mdv bindings\n        register_mdv_table(\u0026lua)?;\n\n        // Register vault operation bindings\n        register_vault_bindings(\u0026lua, vault_ctx)?;\n\n        // Register index query bindings (uses VaultContext from app_data)\n        register_index_bindings(\u0026lua)?;\n\n        Ok(Self { lua, config })\n    }\n\n    /// Execute a Lua script and return the result.\n    ///\n    /// Returns `None` if the script returns nil or no value.\n    pub fn eval(\u0026self, script: \u0026str) -\u003e Result\u003cOption\u003cString\u003e, ScriptingError\u003e {\n        let value: Value = self.lua.load(script).eval()?;\n\n        match value {\n            Value::Nil =\u003e Ok(None),\n            Value::String(s) =\u003e Ok(Some(s.to_str()?.to_string())),\n            Value::Integer(i) =\u003e Ok(Some(i.to_string())),\n            Value::Number(n) =\u003e Ok(Some(n.to_string())),\n            Value::Boolean(b) =\u003e Ok(Some(b.to_string())),\n            _ =\u003e Ok(Some(format!(\"{:?}\", value))),\n        }\n    }\n\n    /// Execute a Lua script that must return a string value.\n    ///\n    /// Returns an error if the script returns nil.\n    pub fn eval_string(\u0026self, script: \u0026str) -\u003e Result\u003cString, ScriptingError\u003e {\n        self.eval(script)?.ok_or_else(|| {\n            ScriptingError::Lua(mlua::Error::runtime(\"script returned nil\"))\n        })\n    }\n\n    /// Execute a Lua script that returns a boolean.\n    pub fn eval_bool(\u0026self, script: \u0026str) -\u003e Result\u003cbool, ScriptingError\u003e {\n        let value: Value = self.lua.load(script).eval()?;\n        match value {\n            Value::Boolean(b) =\u003e Ok(b),\n            Value::Nil =\u003e Ok(false),\n            _ =\u003e {\n                Err(ScriptingError::Lua(mlua::Error::runtime(\"expected boolean result\")))\n            }\n        }\n    }\n\n    /// Get a reference to the underlying Lua state (for advanced usage).\n    pub fn lua(\u0026self) -\u003e \u0026Lua {\n        \u0026self.lua\n    }\n\n    /// Apply sandbox restrictions by removing dangerous globals.\n    fn apply_sandbox(lua: \u0026Lua) -\u003e LuaResult\u003c()\u003e {\n        let globals = lua.globals();\n\n        // Remove dangerous functions that could:\n        // - Execute arbitrary code: load, loadfile, dofile\n        // - Access the filesystem: io\n        // - Execute system commands: os\n        // - Load external modules: require, package\n        // - Inspect/modify internals: debug\n        // - Cause resource exhaustion: collectgarbage\n\n        globals.set(\"dofile\", Value::Nil)?;\n        globals.set(\"loadfile\", Value::Nil)?;\n        globals.set(\"load\", Value::Nil)?;\n        globals.set(\"require\", Value::Nil)?;\n        globals.set(\"package\", Value::Nil)?;\n        globals.set(\"io\", Value::Nil)?;\n        globals.set(\"os\", Value::Nil)?;\n        globals.set(\"debug\", Value::Nil)?;\n        globals.set(\"collectgarbage\", Value::Nil)?;\n\n        Ok(())\n    }\n}\n\nimpl Default for LuaEngine {\n    fn default() -\u003e Self {\n        Self::sandboxed().expect(\"failed to create default Lua engine\")\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_date_basic() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"mdv.date(\"today\")\"#).unwrap();\n        // Should be in YYYY-MM-DD format\n        assert_eq!(result.len(), 10);\n        assert_eq!(result.chars().nth(4), Some('-'));\n        assert_eq!(result.chars().nth(7), Some('-'));\n    }\n\n    #[test]\n    fn test_date_with_offset() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        // Just verify it doesn't error - exact value depends on current date\n        let result = engine.eval_string(r#\"mdv.date(\"today + 1d\")\"#);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_date_with_format() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"mdv.date(\"today\", \"%A\")\"#).unwrap();\n        // Should be a weekday name\n        let valid_days = [\n            \"Monday\",\n            \"Tuesday\",\n            \"Wednesday\",\n            \"Thursday\",\n            \"Friday\",\n            \"Saturday\",\n            \"Sunday\",\n        ];\n        assert!(valid_days.contains(\u0026result.as_str()));\n    }\n\n    #[test]\n    fn test_date_week() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"mdv.date(\"week\")\"#).unwrap();\n        // Should be a number between 1 and 53\n        let week: u32 = result.parse().expect(\"week should be a number\");\n        assert!((1..=53).contains(\u0026week));\n    }\n\n    #[test]\n    fn test_date_year() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"mdv.date(\"year\")\"#).unwrap();\n        // Should be a 4-digit year\n        assert_eq!(result.len(), 4);\n        let year: u32 = result.parse().expect(\"year should be a number\");\n        assert!(year \u003e= 2020);\n    }\n\n    #[test]\n    fn test_render_basic() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine\n            .eval_string(r#\"mdv.render(\"Hello {{name}}\", { name = \"World\" })\"#)\n            .unwrap();\n        assert_eq!(result, \"Hello World\");\n    }\n\n    #[test]\n    fn test_render_multiple_vars() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine\n            .eval_string(r#\"mdv.render(\"{{greeting}}, {{name}}!\", { greeting = \"Hi\", name = \"Lua\" })\"#)\n            .unwrap();\n        assert_eq!(result, \"Hi, Lua!\");\n    }\n\n    #[test]\n    fn test_render_with_numbers() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result =\n            engine.eval_string(r#\"mdv.render(\"Count: {{n}}\", { n = 42 })\"#).unwrap();\n        assert_eq!(result, \"Count: 42\");\n    }\n\n    #[test]\n    fn test_render_with_date_expr() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        // Template engine should handle date expressions in templates\n        let result = engine.eval_string(r#\"mdv.render(\"Date: {{today}}\", {})\"#).unwrap();\n        // Should contain \"Date: \" followed by a date\n        assert!(result.starts_with(\"Date: \"));\n        assert_eq!(result.len(), 16); // \"Date: \" + \"YYYY-MM-DD\"\n    }\n\n    #[test]\n    fn test_is_date_expr_true() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_bool(r#\"mdv.is_date_expr(\"today + 1d\")\"#).unwrap();\n        assert!(result);\n    }\n\n    #[test]\n    fn test_is_date_expr_false() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_bool(r#\"mdv.is_date_expr(\"hello\")\"#).unwrap();\n        assert!(!result);\n    }\n\n    #[test]\n    fn test_is_date_expr_week() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_bool(r#\"mdv.is_date_expr(\"week/start\")\"#).unwrap();\n        assert!(result);\n    }\n\n    #[test]\n    fn test_sandbox_no_io() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"io\"#).unwrap();\n        assert!(result.is_none(), \"io should be nil in sandbox\");\n    }\n\n    #[test]\n    fn test_sandbox_no_os() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"os\"#).unwrap();\n        assert!(result.is_none(), \"os should be nil in sandbox\");\n    }\n\n    #[test]\n    fn test_sandbox_no_require() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"require\"#).unwrap();\n        assert!(result.is_none(), \"require should be nil in sandbox\");\n    }\n\n    #[test]\n    fn test_sandbox_no_load() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"load\"#).unwrap();\n        assert!(result.is_none(), \"load should be nil in sandbox\");\n    }\n\n    #[test]\n    fn test_sandbox_no_debug() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"debug\"#).unwrap();\n        assert!(result.is_none(), \"debug should be nil in sandbox\");\n    }\n\n    #[test]\n    fn test_date_error_handling() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"mdv.date(\"invalid_expr\")\"#);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_pure_lua_math() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"tostring(1 + 2)\"#).unwrap();\n        assert_eq!(result, \"3\");\n    }\n\n    #[test]\n    fn test_pure_lua_string() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"string.upper(\"hello\")\"#).unwrap();\n        assert_eq!(result, \"HELLO\");\n    }\n\n    #[test]\n    fn test_pure_lua_table() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result =\n            engine.eval_string(r#\"local t = {1, 2, 3}; return tostring(#t)\"#).unwrap();\n        assert_eq!(result, \"3\");\n    }\n\n    #[test]\n    fn test_pure_lua_math_functions() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval_string(r#\"tostring(math.floor(3.7))\"#).unwrap();\n        assert_eq!(result, \"3\");\n    }\n\n    #[test]\n    fn test_eval_returns_none_for_nil() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"nil\"#).unwrap();\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_eval_returns_none_for_no_return() {\n        let engine = LuaEngine::sandboxed().unwrap();\n        let result = engine.eval(r#\"local x = 1\"#).unwrap();\n        assert!(result.is_none());\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":46}},{"line":41,"address":[],"length":0,"stats":{"Line":92}},{"line":43,"address":[],"length":0,"stats":{"Line":184}},{"line":46,"address":[],"length":0,"stats":{"Line":46}},{"line":47,"address":[],"length":0,"stats":{"Line":138}},{"line":51,"address":[],"length":0,"stats":{"Line":92}},{"line":54,"address":[],"length":0,"stats":{"Line":92}},{"line":56,"address":[],"length":0,"stats":{"Line":46}},{"line":60,"address":[],"length":0,"stats":{"Line":46}},{"line":61,"address":[],"length":0,"stats":{"Line":92}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":21}},{"line":119,"address":[],"length":0,"stats":{"Line":125}},{"line":121,"address":[],"length":0,"stats":{"Line":20}},{"line":122,"address":[],"length":0,"stats":{"Line":7}},{"line":123,"address":[],"length":0,"stats":{"Line":52}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":14}},{"line":135,"address":[],"length":0,"stats":{"Line":56}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":18}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":22}},{"line":154,"address":[],"length":0,"stats":{"Line":22}},{"line":158,"address":[],"length":0,"stats":{"Line":46}},{"line":159,"address":[],"length":0,"stats":{"Line":138}},{"line":169,"address":[],"length":0,"stats":{"Line":138}},{"line":170,"address":[],"length":0,"stats":{"Line":138}},{"line":171,"address":[],"length":0,"stats":{"Line":138}},{"line":172,"address":[],"length":0,"stats":{"Line":138}},{"line":173,"address":[],"length":0,"stats":{"Line":138}},{"line":174,"address":[],"length":0,"stats":{"Line":138}},{"line":175,"address":[],"length":0,"stats":{"Line":138}},{"line":176,"address":[],"length":0,"stats":{"Line":138}},{"line":177,"address":[],"length":0,"stats":{"Line":138}},{"line":179,"address":[],"length":0,"stats":{"Line":46}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}}],"covered":35,"coverable":54},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","hook_runner.rs"],"content":"//! Hook execution for lifecycle events.\n//!\n//! This module provides functions to run lifecycle hooks defined in type definitions.\n\nuse super::engine::LuaEngine;\nuse super::hooks::{HookError, NoteContext};\nuse super::types::SandboxConfig;\nuse super::vault_context::VaultContext;\nuse crate::types::definition::TypeDefinition;\nuse crate::types::validation::yaml_to_lua_table;\n\n/// Result of running a hook that may modify the note.\n#[derive(Debug)]\npub struct HookResult {\n    /// Whether the hook made changes to the note.\n    pub modified: bool,\n    /// The updated frontmatter (if modified).\n    pub frontmatter: Option\u003cserde_yaml::Value\u003e,\n    /// The updated content (if modified).\n    pub content: Option\u003cString\u003e,\n}\n\n/// Alias for backwards compatibility.\npub type UpdateHookResult = HookResult;\n\n/// Run the `on_create` hook for a type definition.\n///\n/// This function is called after a note is created to allow the type definition\n/// to perform additional operations like logging to daily notes, updating indexes,\n/// or modifying the note's frontmatter.\n///\n/// # Arguments\n///\n/// * `typedef` - The type definition containing the hook\n/// * `note_ctx` - Context about the created note\n/// * `vault_ctx` - Vault context with access to repositories\n///\n/// # Returns\n///\n/// * `Ok(HookResult)` with any modifications from the hook\n/// * `Err(HookError)` on failure\n///\n/// # Example\n///\n/// ```ignore\n/// use mdvault_core::scripting::{run_on_create_hook, NoteContext, VaultContext};\n///\n/// let note_ctx = NoteContext::new(path, \"task\".into(), frontmatter, content);\n/// let result = run_on_create_hook(\u0026typedef, \u0026note_ctx, vault_ctx)?;\n/// if result.modified {\n///     // Write back the updated content\n/// }\n/// ```\npub fn run_on_create_hook(\n    typedef: \u0026TypeDefinition,\n    note_ctx: \u0026NoteContext,\n    vault_ctx: VaultContext,\n) -\u003e Result\u003cHookResult, HookError\u003e {\n    // Skip if no hook defined\n    if !typedef.has_on_create_hook {\n        return Ok(HookResult { modified: false, frontmatter: None, content: None });\n    }\n\n    // Create engine with vault context\n    let engine = LuaEngine::with_vault_context(SandboxConfig::restricted(), vault_ctx)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    let lua = engine.lua();\n\n    // Load and evaluate the type definition to get the table\n    let typedef_table: mlua::Table =\n        lua.load(\u0026typedef.lua_source).eval().map_err(|e| {\n            HookError::LuaError(format!(\"failed to load type definition: {}\", e))\n        })?;\n\n    // Build note table for the hook\n    let note_table =\n        lua.create_table().map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"path\", note_ctx.path.to_string_lossy().to_string())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"type\", note_ctx.note_type.clone())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"content\", note_ctx.content.clone())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    // Convert frontmatter to Lua table\n    let fm_table = yaml_to_lua_table(lua, \u0026note_ctx.frontmatter)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"frontmatter\", fm_table)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    // Get on_create function\n    let on_create_fn: mlua::Function = typedef_table.get(\"on_create\").map_err(|e| {\n        HookError::LuaError(format!(\"on_create function not found: {}\", e))\n    })?;\n\n    // Call the hook - it may return a modified note table\n    let result: mlua::Value = on_create_fn\n        .call(note_table)\n        .map_err(|e| HookError::Execution(format!(\"on_create hook failed: {}\", e)))?;\n\n    // Check if hook returned a modified note\n    match result {\n        mlua::Value::Table(returned_note) =\u003e {\n            // Extract frontmatter and content if present\n            let frontmatter: Option\u003cserde_yaml::Value\u003e =\n                if let Ok(fm_table) = returned_note.get::\u003cmlua::Table\u003e(\"frontmatter\") {\n                    Some(lua_table_to_yaml(\u0026fm_table)?)\n                } else {\n                    None\n                };\n\n            let content: Option\u003cString\u003e = returned_note.get(\"content\").ok();\n\n            let modified = frontmatter.is_some() || content.is_some();\n            Ok(HookResult { modified, frontmatter, content })\n        }\n        mlua::Value::Nil =\u003e {\n            // Hook returned nil, no modifications\n            Ok(HookResult { modified: false, frontmatter: None, content: None })\n        }\n        _ =\u003e {\n            // Unexpected return type\n            Ok(HookResult { modified: false, frontmatter: None, content: None })\n        }\n    }\n}\n\n/// Run the `on_update` hook for a type definition.\n///\n/// This function is called after a note is modified (via capture operations) to allow\n/// the type definition to perform additional operations like updating timestamps.\n///\n/// Unlike `on_create`, this hook can return a modified note which will be written back.\n///\n/// # Arguments\n///\n/// * `typedef` - The type definition containing the hook\n/// * `note_ctx` - Context about the updated note\n/// * `vault_ctx` - Vault context with access to repositories\n///\n/// # Returns\n///\n/// * `Ok(UpdateHookResult)` with any modifications from the hook\n/// * `Err(HookError)` on failure\n///\n/// # Example\n///\n/// ```ignore\n/// use mdvault_core::scripting::{run_on_update_hook, NoteContext, VaultContext};\n///\n/// let note_ctx = NoteContext::new(path, \"task\".into(), frontmatter, content);\n/// let result = run_on_update_hook(\u0026typedef, \u0026note_ctx, vault_ctx)?;\n/// if result.modified {\n///     // Write back the updated content\n/// }\n/// ```\npub fn run_on_update_hook(\n    typedef: \u0026TypeDefinition,\n    note_ctx: \u0026NoteContext,\n    vault_ctx: VaultContext,\n) -\u003e Result\u003cUpdateHookResult, HookError\u003e {\n    // Skip if no hook defined\n    if !typedef.has_on_update_hook {\n        return Ok(UpdateHookResult {\n            modified: false,\n            frontmatter: None,\n            content: None,\n        });\n    }\n\n    // Create engine with vault context\n    let engine = LuaEngine::with_vault_context(SandboxConfig::restricted(), vault_ctx)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    let lua = engine.lua();\n\n    // Load and evaluate the type definition to get the table\n    let typedef_table: mlua::Table =\n        lua.load(\u0026typedef.lua_source).eval().map_err(|e| {\n            HookError::LuaError(format!(\"failed to load type definition: {}\", e))\n        })?;\n\n    // Build note table for the hook\n    let note_table =\n        lua.create_table().map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"path\", note_ctx.path.to_string_lossy().to_string())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"type\", note_ctx.note_type.clone())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"content\", note_ctx.content.clone())\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    // Convert frontmatter to Lua table\n    let fm_table = yaml_to_lua_table(lua, \u0026note_ctx.frontmatter)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"frontmatter\", fm_table)\n        .map_err(|e| HookError::LuaError(e.to_string()))?;\n\n    // Get on_update function\n    let on_update_fn: mlua::Function = typedef_table.get(\"on_update\").map_err(|e| {\n        HookError::LuaError(format!(\"on_update function not found: {}\", e))\n    })?;\n\n    // Call the hook - it may return a modified note table\n    let result: mlua::Value = on_update_fn\n        .call(note_table)\n        .map_err(|e| HookError::Execution(format!(\"on_update hook failed: {}\", e)))?;\n\n    // Check if hook returned a modified note\n    match result {\n        mlua::Value::Table(returned_note) =\u003e {\n            // Extract frontmatter and content if present\n            let frontmatter: Option\u003cserde_yaml::Value\u003e =\n                if let Ok(fm_table) = returned_note.get::\u003cmlua::Table\u003e(\"frontmatter\") {\n                    Some(lua_table_to_yaml(\u0026fm_table)?)\n                } else {\n                    None\n                };\n\n            let content: Option\u003cString\u003e = returned_note.get(\"content\").ok();\n\n            let modified = frontmatter.is_some() || content.is_some();\n            Ok(UpdateHookResult { modified, frontmatter, content })\n        }\n        mlua::Value::Nil =\u003e {\n            // Hook returned nil, no modifications\n            Ok(UpdateHookResult { modified: false, frontmatter: None, content: None })\n        }\n        _ =\u003e {\n            // Unexpected return type\n            Ok(UpdateHookResult { modified: false, frontmatter: None, content: None })\n        }\n    }\n}\n\n/// Convert a Lua table to serde_yaml::Value.\nfn lua_table_to_yaml(table: \u0026mlua::Table) -\u003e Result\u003cserde_yaml::Value, HookError\u003e {\n    let mut map = serde_yaml::Mapping::new();\n\n    for pair in table.pairs::\u003cmlua::Value, mlua::Value\u003e() {\n        let (key, value) = pair.map_err(|e| HookError::LuaError(e.to_string()))?;\n\n        let yaml_key = match key {\n            mlua::Value::String(s) =\u003e {\n                let str_val =\n                    s.to_str().map_err(|e| HookError::LuaError(e.to_string()))?;\n                serde_yaml::Value::String(str_val.to_string())\n            }\n            mlua::Value::Integer(i) =\u003e serde_yaml::Value::Number(i.into()),\n            _ =\u003e continue, // Skip non-string/integer keys\n        };\n\n        let yaml_value = lua_value_to_yaml(value)?;\n        map.insert(yaml_key, yaml_value);\n    }\n\n    Ok(serde_yaml::Value::Mapping(map))\n}\n\n/// Convert a single Lua value to serde_yaml::Value.\nfn lua_value_to_yaml(value: mlua::Value) -\u003e Result\u003cserde_yaml::Value, HookError\u003e {\n    match value {\n        mlua::Value::Nil =\u003e Ok(serde_yaml::Value::Null),\n        mlua::Value::Boolean(b) =\u003e Ok(serde_yaml::Value::Bool(b)),\n        mlua::Value::Integer(i) =\u003e Ok(serde_yaml::Value::Number(i.into())),\n        mlua::Value::Number(n) =\u003e {\n            Ok(serde_yaml::Value::Number(serde_yaml::Number::from(n)))\n        }\n        mlua::Value::String(s) =\u003e {\n            let str_val = s.to_str().map_err(|e| HookError::LuaError(e.to_string()))?;\n            Ok(serde_yaml::Value::String(str_val.to_string()))\n        }\n        mlua::Value::Table(t) =\u003e {\n            // Check if it's an array or a map\n            if is_lua_array(\u0026t) {\n                let mut seq = Vec::new();\n                for pair in t.pairs::\u003ci64, mlua::Value\u003e() {\n                    let (_, v) = pair.map_err(|e| HookError::LuaError(e.to_string()))?;\n                    seq.push(lua_value_to_yaml(v)?);\n                }\n                Ok(serde_yaml::Value::Sequence(seq))\n            } else {\n                lua_table_to_yaml(\u0026t)\n            }\n        }\n        _ =\u003e Ok(serde_yaml::Value::Null),\n    }\n}\n\n/// Check if a Lua table is an array (sequential integer keys starting from 1).\nfn is_lua_array(table: \u0026mlua::Table) -\u003e bool {\n    let len = table.raw_len();\n    if len == 0 {\n        // Could be empty table, check for any keys\n        table.pairs::\u003cmlua::Value, mlua::Value\u003e().next().is_none()\n    } else {\n        // Check if keys are 1..=len\n        for i in 1..=len {\n            if table.raw_get::\u003cmlua::Value\u003e(i).is_err() {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use std::path::PathBuf;\n\n    fn make_typedef_with_hook(lua_source: \u0026str) -\u003e TypeDefinition {\n        TypeDefinition {\n            name: \"test\".to_string(),\n            description: None,\n            source_path: PathBuf::new(),\n            schema: HashMap::new(),\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: true,\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: lua_source.to_string(),\n        }\n    }\n\n    fn make_note_ctx() -\u003e NoteContext {\n        NoteContext {\n            path: PathBuf::from(\"test.md\"),\n            note_type: \"test\".to_string(),\n            frontmatter: serde_yaml::Value::Mapping(serde_yaml::Mapping::new()),\n            content: \"# Test\".to_string(),\n        }\n    }\n\n    #[test]\n    fn test_skip_if_no_hook() {\n        let typedef = TypeDefinition {\n            name: \"test\".to_string(),\n            description: None,\n            source_path: PathBuf::new(),\n            schema: HashMap::new(),\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: false, // No hook\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: String::new(),\n        };\n\n        // Create a minimal vault context - this won't be used since there's no hook\n        // We can't easily create a VaultContext in tests without real repositories,\n        // but since has_on_create_hook is false, it will return early\n        let _note_ctx = make_note_ctx();\n\n        // This test verifies that when has_on_create_hook is false,\n        // the function returns Ok(()) without trying to access vault_ctx\n        // However, we need a VaultContext to call the function...\n        // For now, just test the hook detection logic works.\n        assert!(!typedef.has_on_create_hook);\n    }\n\n    #[test]\n    fn test_hook_receives_note_context() {\n        // This test verifies the Lua hook structure works\n        // We create a hook that just returns true without vault operations\n        let lua_source = r#\"\n            return {\n                on_create = function(note)\n                    -- Just verify we can access note fields\n                    local _ = note.path\n                    local _ = note.type\n                    local _ = note.content\n                    local _ = note.frontmatter\n                    return note\n                end\n            }\n        \"#;\n\n        let _typedef = make_typedef_with_hook(lua_source);\n        let _note_ctx = make_note_ctx();\n\n        // Create a sandboxed engine to test the Lua code directly\n        let engine = LuaEngine::sandboxed().unwrap();\n        let lua = engine.lua();\n\n        // Load the typedef\n        let typedef_table: mlua::Table = lua.load(lua_source).eval().unwrap();\n\n        // Build note table\n        let note_table = lua.create_table().unwrap();\n        note_table.set(\"path\", \"test.md\").unwrap();\n        note_table.set(\"type\", \"test\").unwrap();\n        note_table.set(\"content\", \"# Test\").unwrap();\n        let fm = lua.create_table().unwrap();\n        note_table.set(\"frontmatter\", fm).unwrap();\n\n        // Call on_create\n        let on_create: mlua::Function = typedef_table.get(\"on_create\").unwrap();\n        let result = on_create.call::\u003cmlua::Value\u003e(note_table);\n\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":126},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","hooks.rs"],"content":"//! Hook types and errors.\n//!\n//! This module provides types for hook execution, including the note context\n//! passed to hooks and error types for hook failures.\n\nuse std::path::PathBuf;\n\nuse thiserror::Error;\n\n/// Note context passed to Lua hooks.\n///\n/// Contains all information about a note that hooks might need to access.\n#[derive(Debug, Clone)]\npub struct NoteContext {\n    /// Path to the note file (relative to vault root).\n    pub path: PathBuf,\n    /// Note type from frontmatter (e.g., \"task\", \"meeting\").\n    pub note_type: String,\n    /// Parsed frontmatter as YAML value.\n    pub frontmatter: serde_yaml::Value,\n    /// Full content of the note (including frontmatter).\n    pub content: String,\n}\n\nimpl NoteContext {\n    /// Create a new NoteContext.\n    pub fn new(\n        path: PathBuf,\n        note_type: String,\n        frontmatter: serde_yaml::Value,\n        content: String,\n    ) -\u003e Self {\n        Self { path, note_type, frontmatter, content }\n    }\n}\n\n/// Errors that can occur during hook execution.\n#[derive(Debug, Error)]\npub enum HookError {\n    /// Template not found.\n    #[error(\"template not found: {0}\")]\n    TemplateNotFound(String),\n\n    /// Capture not found.\n    #[error(\"capture not found: {0}\")]\n    CaptureNotFound(String),\n\n    /// Macro not found.\n    #[error(\"macro not found: {0}\")]\n    MacroNotFound(String),\n\n    /// Hook execution failed.\n    #[error(\"hook execution failed: {0}\")]\n    Execution(String),\n\n    /// Lua runtime error.\n    #[error(\"Lua error: {0}\")]\n    LuaError(String),\n\n    /// Template rendering error.\n    #[error(\"template render error: {0}\")]\n    TemplateRender(String),\n\n    /// Capture execution error.\n    #[error(\"capture execution error: {0}\")]\n    CaptureExecution(String),\n\n    /// Macro execution error.\n    #[error(\"macro execution error: {0}\")]\n    MacroExecution(String),\n\n    /// IO error during hook execution.\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","index_bindings.rs"],"content":"//! Index query bindings for Lua.\n//!\n//! This module provides Lua bindings for querying the vault index:\n//! - `mdv.current_note()` - Get the current note being processed\n//! - `mdv.backlinks(path)` - Get notes linking to a path\n//! - `mdv.outlinks(path)` - Get notes a path links to\n//! - `mdv.query(opts)` - Query the vault index\n\nuse std::path::Path;\n\nuse mlua::{Function, Lua, Result as LuaResult, Table, Value};\n\nuse super::vault_context::VaultContext;\nuse crate::index::NoteQuery;\nuse crate::types::validation::yaml_to_lua_table;\n\n/// Register index query bindings on an existing mdv table.\n///\n/// This adds `mdv.current_note()`, `mdv.backlinks()`, `mdv.outlinks()`, and\n/// `mdv.query()` functions that have access to the vault index.\npub fn register_index_bindings(lua: \u0026Lua) -\u003e LuaResult\u003c()\u003e {\n    let mdv: Table = lua.globals().get(\"mdv\")?;\n\n    mdv.set(\"current_note\", create_current_note_fn(lua)?)?;\n    mdv.set(\"backlinks\", create_backlinks_fn(lua)?)?;\n    mdv.set(\"outlinks\", create_outlinks_fn(lua)?)?;\n    mdv.set(\"query\", create_query_fn(lua)?)?;\n\n    Ok(())\n}\n\n/// Create the `mdv.current_note()` function.\n///\n/// Returns the current note being processed, or nil if not available.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local note = mdv.current_note()\n/// if note then\n///     print(\"Processing: \" .. note.path)\n///     print(\"Type: \" .. note.type)\n/// end\n/// ```\nfn create_current_note_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, ()| {\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        let current = match \u0026ctx.current_note {\n            Some(note) =\u003e note,\n            None =\u003e return Ok(Value::Nil),\n        };\n\n        // Build note table\n        let note_table = lua.create_table()?;\n        note_table.set(\"path\", current.path.as_str())?;\n        note_table.set(\"type\", current.note_type.as_str())?;\n        note_table.set(\"content\", current.content.as_str())?;\n\n        if let Some(title) = \u0026current.title {\n            note_table.set(\"title\", title.as_str())?;\n        }\n\n        if let Some(fm) = \u0026current.frontmatter {\n            let fm_table = yaml_to_lua_table(lua, fm)?;\n            note_table.set(\"frontmatter\", fm_table)?;\n        }\n\n        Ok(Value::Table(note_table))\n    })\n}\n\n/// Create the `mdv.backlinks(path)` function.\n///\n/// Returns a list of notes that link to the specified path.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local links = mdv.backlinks(\"projects/my-project.md\")\n/// for _, link in ipairs(links) do\n///     print(link.source_path .. \" links to this note\")\n/// end\n/// ```\nfn create_backlinks_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, path: String| {\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        let db = match \u0026ctx.index_db {\n            Some(db) =\u003e db,\n            None =\u003e {\n                return Err(mlua::Error::runtime(\n                    \"Index database not available. Run 'mdv reindex' first.\",\n                ));\n            }\n        };\n\n        // Resolve path\n        let resolved_path = resolve_note_path(\u0026ctx.vault_root, \u0026path);\n\n        // Get note ID\n        let note = match db.get_note_by_path(Path::new(\u0026resolved_path)) {\n            Ok(Some(n)) =\u003e n,\n            Ok(None) =\u003e {\n                // Return empty table if note not found\n                return Ok(Value::Table(lua.create_table()?));\n            }\n            Err(e) =\u003e return Err(mlua::Error::runtime(format!(\"Index error: {}\", e))),\n        };\n\n        let note_id = match note.id {\n            Some(id) =\u003e id,\n            None =\u003e return Ok(Value::Table(lua.create_table()?)),\n        };\n\n        // Get backlinks\n        let backlinks = db\n            .get_backlinks(note_id)\n            .map_err(|e| mlua::Error::runtime(format!(\"Index error: {}\", e)))?;\n\n        // Convert to Lua table\n        let result = lua.create_table()?;\n        for (i, link) in backlinks.iter().enumerate() {\n            let link_table = lua.create_table()?;\n\n            // Get source note path\n            if let Ok(Some(source_note)) = db.get_note_by_id(link.source_id) {\n                link_table\n                    .set(\"source_path\", source_note.path.to_string_lossy().to_string())?;\n                link_table.set(\"source_title\", source_note.title)?;\n                link_table.set(\"source_type\", source_note.note_type.as_str())?;\n            }\n\n            if let Some(text) = \u0026link.link_text {\n                link_table.set(\"link_text\", text.as_str())?;\n            }\n            if let Some(context) = \u0026link.context {\n                link_table.set(\"context\", context.as_str())?;\n            }\n            link_table.set(\"link_type\", link.link_type.as_str())?;\n\n            result.set(i + 1, link_table)?;\n        }\n\n        Ok(Value::Table(result))\n    })\n}\n\n/// Create the `mdv.outlinks(path)` function.\n///\n/// Returns a list of notes that the specified path links to.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local links = mdv.outlinks(\"projects/my-project.md\")\n/// for _, link in ipairs(links) do\n///     print(\"Links to: \" .. link.target_path)\n/// end\n/// ```\nfn create_outlinks_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, path: String| {\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        let db = match \u0026ctx.index_db {\n            Some(db) =\u003e db,\n            None =\u003e {\n                return Err(mlua::Error::runtime(\n                    \"Index database not available. Run 'mdv reindex' first.\",\n                ));\n            }\n        };\n\n        // Resolve path\n        let resolved_path = resolve_note_path(\u0026ctx.vault_root, \u0026path);\n\n        // Get note ID\n        let note = match db.get_note_by_path(Path::new(\u0026resolved_path)) {\n            Ok(Some(n)) =\u003e n,\n            Ok(None) =\u003e {\n                // Return empty table if note not found\n                return Ok(Value::Table(lua.create_table()?));\n            }\n            Err(e) =\u003e return Err(mlua::Error::runtime(format!(\"Index error: {}\", e))),\n        };\n\n        let note_id = match note.id {\n            Some(id) =\u003e id,\n            None =\u003e return Ok(Value::Table(lua.create_table()?)),\n        };\n\n        // Get outgoing links\n        let outlinks = db\n            .get_outgoing_links(note_id)\n            .map_err(|e| mlua::Error::runtime(format!(\"Index error: {}\", e)))?;\n\n        // Convert to Lua table\n        let result = lua.create_table()?;\n        for (i, link) in outlinks.iter().enumerate() {\n            let link_table = lua.create_table()?;\n\n            link_table.set(\"target_path\", link.target_path.as_str())?;\n\n            // Get target note info if resolved\n            if let Some(target_id) = link.target_id {\n                if let Ok(Some(target_note)) = db.get_note_by_id(target_id) {\n                    link_table.set(\"target_title\", target_note.title)?;\n                    link_table.set(\"target_type\", target_note.note_type.as_str())?;\n                    link_table.set(\"resolved\", true)?;\n                } else {\n                    link_table.set(\"resolved\", false)?;\n                }\n            } else {\n                link_table.set(\"resolved\", false)?;\n            }\n\n            if let Some(text) = \u0026link.link_text {\n                link_table.set(\"link_text\", text.as_str())?;\n            }\n            link_table.set(\"link_type\", link.link_type.as_str())?;\n\n            result.set(i + 1, link_table)?;\n        }\n\n        Ok(Value::Table(result))\n    })\n}\n\n/// Create the `mdv.query(opts)` function.\n///\n/// Query the vault index with filters.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// -- Find all open tasks\n/// local tasks = mdv.query({ type = \"task\" })\n/// for _, note in ipairs(tasks) do\n///     print(note.path .. \": \" .. note.title)\n/// end\n///\n/// -- Find recent notes\n/// local recent = mdv.query({ limit = 10 })\n/// ```\nfn create_query_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, opts: Option\u003cTable\u003e| {\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        let db = match \u0026ctx.index_db {\n            Some(db) =\u003e db,\n            None =\u003e {\n                return Err(mlua::Error::runtime(\n                    \"Index database not available. Run 'mdv reindex' first.\",\n                ));\n            }\n        };\n\n        // Build query from options\n        let mut query = NoteQuery::default();\n\n        if let Some(opts) = opts {\n            // Type filter\n            if let Ok(type_str) = opts.get::\u003cString\u003e(\"type\") {\n                query.note_type = Some(type_str.parse().unwrap_or_default());\n            }\n\n            // Path prefix filter\n            if let Ok(prefix) = opts.get::\u003cString\u003e(\"path_prefix\") {\n                query.path_prefix = Some(std::path::PathBuf::from(prefix));\n            }\n\n            // Limit\n            if let Ok(limit) = opts.get::\u003ci64\u003e(\"limit\") {\n                query.limit = Some(limit as u32);\n            }\n\n            // Offset\n            if let Ok(offset) = opts.get::\u003ci64\u003e(\"offset\") {\n                query.offset = Some(offset as u32);\n            }\n        }\n\n        // Execute query\n        let notes = db\n            .query_notes(\u0026query)\n            .map_err(|e| mlua::Error::runtime(format!(\"Query error: {}\", e)))?;\n\n        // Convert to Lua table\n        let result = lua.create_table()?;\n        for (i, note) in notes.iter().enumerate() {\n            let note_table = lua.create_table()?;\n            note_table.set(\"path\", note.path.to_string_lossy().to_string())?;\n            note_table.set(\"type\", note.note_type.as_str())?;\n            note_table.set(\"title\", note.title.clone())?;\n            note_table.set(\"modified\", note.modified.to_rfc3339())?;\n\n            if let Some(created) = note.created {\n                note_table.set(\"created\", created.to_rfc3339())?;\n            }\n\n            // Parse and include frontmatter if available\n            if let Some(fm_json) = \u0026note.frontmatter_json\n                \u0026\u0026 let Ok(fm) = serde_json::from_str::\u003cserde_json::Value\u003e(fm_json)\n            {\n                let fm_yaml = json_to_yaml(\u0026fm);\n                let fm_lua = yaml_to_lua_table(lua, \u0026fm_yaml)?;\n                note_table.set(\"frontmatter\", fm_lua)?;\n            }\n\n            result.set(i + 1, note_table)?;\n        }\n\n        Ok(Value::Table(result))\n    })\n}\n\n/// Resolve a note path relative to vault root.\nfn resolve_note_path(_vault_root: \u0026std::path::Path, path: \u0026str) -\u003e String {\n    // If path doesn't end with .md, append it\n    if path.ends_with(\".md\") { path.to_string() } else { format!(\"{}.md\", path) }\n}\n\n/// Convert serde_json::Value to serde_yaml::Value.\nfn json_to_yaml(json: \u0026serde_json::Value) -\u003e serde_yaml::Value {\n    match json {\n        serde_json::Value::Null =\u003e serde_yaml::Value::Null,\n        serde_json::Value::Bool(b) =\u003e serde_yaml::Value::Bool(*b),\n        serde_json::Value::Number(n) =\u003e {\n            if let Some(i) = n.as_i64() {\n                serde_yaml::Value::Number(i.into())\n            } else if let Some(f) = n.as_f64() {\n                serde_yaml::Value::Number(serde_yaml::Number::from(f))\n            } else {\n                serde_yaml::Value::Null\n            }\n        }\n        serde_json::Value::String(s) =\u003e serde_yaml::Value::String(s.clone()),\n        serde_json::Value::Array(arr) =\u003e {\n            serde_yaml::Value::Sequence(arr.iter().map(json_to_yaml).collect())\n        }\n        serde_json::Value::Object(obj) =\u003e {\n            let mut map = serde_yaml::Mapping::new();\n            for (k, v) in obj {\n                map.insert(serde_yaml::Value::String(k.clone()), json_to_yaml(v));\n            }\n            serde_yaml::Value::Mapping(map)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_resolve_note_path_with_extension() {\n        let vault_root = std::path::Path::new(\"/vault\");\n        let result = resolve_note_path(vault_root, \"notes/test.md\");\n        assert_eq!(result, \"notes/test.md\");\n    }\n\n    #[test]\n    fn test_resolve_note_path_without_extension() {\n        let vault_root = std::path::Path::new(\"/vault\");\n        let result = resolve_note_path(vault_root, \"notes/test\");\n        assert_eq!(result, \"notes/test.md\");\n    }\n\n    #[test]\n    fn test_json_to_yaml() {\n        let json = serde_json::json!({\n            \"string\": \"value\",\n            \"number\": 42,\n            \"bool\": true,\n            \"array\": [1, 2, 3]\n        });\n\n        let yaml = json_to_yaml(\u0026json);\n\n        if let serde_yaml::Value::Mapping(map) = yaml {\n            assert!(map.contains_key(serde_yaml::Value::String(\"string\".into())));\n            assert!(map.contains_key(serde_yaml::Value::String(\"number\".into())));\n        } else {\n            panic!(\"Expected mapping\");\n        }\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":8}},{"line":332,"address":[],"length":0,"stats":{"Line":8}},{"line":333,"address":[],"length":0,"stats":{"Line":8}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":2}},{"line":336,"address":[],"length":0,"stats":{"Line":4}},{"line":337,"address":[],"length":0,"stats":{"Line":8}},{"line":338,"address":[],"length":0,"stats":{"Line":4}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":2}},{"line":346,"address":[],"length":0,"stats":{"Line":1}},{"line":347,"address":[],"length":0,"stats":{"Line":2}},{"line":349,"address":[],"length":0,"stats":{"Line":1}},{"line":350,"address":[],"length":0,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":17}},{"line":352,"address":[],"length":0,"stats":{"Line":16}},{"line":354,"address":[],"length":0,"stats":{"Line":1}}],"covered":16,"coverable":154},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","mod.rs"],"content":"//! Lua scripting support for mdvault.\n//!\n//! This module provides a sandboxed Lua environment with access to\n//! mdvault's date math and template rendering engines.\n//!\n//! # Overview\n//!\n//! The scripting layer allows users to define custom validation logic,\n//! type definitions, and automation rules in Lua while having access\n//! to mdvault's core functionality.\n//!\n//! # Example\n//!\n//! ```rust\n//! use mdvault_core::scripting::LuaEngine;\n//!\n//! let engine = LuaEngine::sandboxed().unwrap();\n//!\n//! // Use date math\n//! let date = engine.eval_string(r#\"mdv.date(\"today + 7d\")\"#).unwrap();\n//! println!(\"One week from now: {}\", date);\n//!\n//! // Render templates\n//! let greeting = engine.eval_string(\n//!     r#\"mdv.render(\"Hello {{name}}!\", { name = \"World\" })\"#\n//! ).unwrap();\n//! println!(\"{}\", greeting);\n//! ```\n//!\n//! # Available Lua Functions\n//!\n//! The `mdv` global table provides:\n//!\n//! - `mdv.date(expr, format?)` - Evaluate date math expressions\n//! - `mdv.render(template, context)` - Render templates with variables\n//! - `mdv.is_date_expr(str)` - Check if a string is a date expression\n//!\n//! With vault context (via `LuaEngine::with_vault_context`):\n//! - `mdv.template(name, vars?)` - Render a template by name\n//! - `mdv.capture(name, vars?)` - Execute a capture workflow\n//! - `mdv.macro(name, vars?)` - Execute a macro workflow\n//! - `mdv.read_note(path)` - Read a note's content and frontmatter\n//! - `mdv.current_note()` - Get the current note being processed\n//! - `mdv.backlinks(path)` - Get notes linking to a path\n//! - `mdv.outlinks(path)` - Get notes a path links to\n//! - `mdv.query(opts)` - Query the vault index\n//!\n//! # Security\n//!\n//! By default, the Lua environment is sandboxed to prevent:\n//! - File system access (`io` library removed)\n//! - Shell command execution (`os` library removed)\n//! - Loading external modules (`require` removed)\n//! - Arbitrary code loading (`load`, `loadfile`, `dofile` removed)\n//! - Debug library access (`debug` removed)\n\npub mod bindings;\npub mod engine;\npub mod hook_runner;\npub mod hooks;\npub mod index_bindings;\npub mod types;\npub mod vault_bindings;\npub mod vault_context;\n\npub use engine::LuaEngine;\npub use hook_runner::{\n    HookResult, UpdateHookResult, run_on_create_hook, run_on_update_hook,\n};\npub use hooks::{HookError, NoteContext};\npub use types::{SandboxConfig, ScriptingError};\npub use vault_context::{CurrentNote, VaultContext};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","types.rs"],"content":"//! Scripting types and error definitions.\n\nuse thiserror::Error;\n\n/// Errors that can occur during Lua script execution.\n#[derive(Debug, Error)]\npub enum ScriptingError {\n    /// Error from the Lua runtime.\n    #[error(\"Lua error: {0}\")]\n    Lua(#[from] mlua::Error),\n\n    /// Error evaluating a date math expression.\n    #[error(\"date math error: {0}\")]\n    DateMath(String),\n\n    /// Error rendering a template.\n    #[error(\"template render error: {0}\")]\n    TemplateRender(String),\n\n    /// Sandbox security violation.\n    #[error(\"sandbox violation: {0}\")]\n    SandboxViolation(String),\n}\n\n/// Configuration for the Lua sandbox.\n#[derive(Debug, Clone)]\npub struct SandboxConfig {\n    /// Maximum memory the Lua VM can allocate (in bytes). 0 = unlimited.\n    pub memory_limit: usize,\n\n    /// Maximum instructions before timeout. 0 = unlimited.\n    pub instruction_limit: u32,\n\n    /// Whether to allow `require` for loading modules.\n    pub allow_require: bool,\n}\n\nimpl Default for SandboxConfig {\n    fn default() -\u003e Self {\n        Self::restricted()\n    }\n}\n\nimpl SandboxConfig {\n    /// A restrictive sandbox suitable for user scripts.\n    pub fn restricted() -\u003e Self {\n        Self {\n            memory_limit: 10 * 1024 * 1024, // 10 MB\n            instruction_limit: 100_000,\n            allow_require: false,\n        }\n    }\n\n    /// An unrestricted configuration (use with caution).\n    pub fn unrestricted() -\u003e Self {\n        Self { memory_limit: 0, instruction_limit: 0, allow_require: true }\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":46}},{"line":48,"address":[],"length":0,"stats":{"Line":46}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":5},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","vault_bindings.rs"],"content":"//! Vault operation bindings for Lua.\n//!\n//! This module provides Lua bindings for vault operations:\n//! - `mdv.template(name, vars?)` - Render a template by name\n//! - `mdv.capture(name, vars?)` - Execute a capture workflow\n//! - `mdv.macro(name, vars?)` - Execute a macro workflow\n//! - `mdv.read_note(path)` - Read a note's content and frontmatter\n\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\nuse chrono::Local;\nuse mlua::{Function, Lua, MultiValue, Result as LuaResult, Table, Value};\n\nuse super::vault_context::VaultContext;\nuse crate::captures::CaptureSpec;\nuse crate::config::types::ResolvedConfig;\nuse crate::frontmatter::{apply_ops, parse, serialize};\nuse crate::macros::runner::{MacroRunError, RunContext, RunOptions, StepExecutor};\nuse crate::macros::types::{CaptureStep, ShellStep, StepResult, TemplateStep};\nuse crate::markdown_ast::{MarkdownEditor, SectionMatch};\nuse crate::templates::engine::render_string;\nuse crate::types::validation::yaml_to_lua_table;\n\n/// Register vault operation bindings on an existing mdv table.\n///\n/// This adds `mdv.template()`, `mdv.capture()`, and `mdv.macro()` functions\n/// that have access to the vault context for executing operations.\npub fn register_vault_bindings(lua: \u0026Lua, ctx: VaultContext) -\u003e LuaResult\u003c()\u003e {\n    // Store context in Lua app data\n    lua.set_app_data(ctx);\n\n    let mdv: Table = lua.globals().get(\"mdv\")?;\n\n    mdv.set(\"template\", create_template_fn(lua)?)?;\n    mdv.set(\"capture\", create_capture_fn(lua)?)?;\n    mdv.set(\"macro\", create_macro_fn(lua)?)?;\n    mdv.set(\"read_note\", create_read_note_fn(lua)?)?;\n\n    Ok(())\n}\n\n/// Create the `mdv.template(name, vars?)` function.\n///\n/// Returns: `(content, nil)` on success, `(nil, error)` on failure.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local content, err = mdv.template(\"meeting\", { title = \"Standup\" })\n/// if err then\n///     print(\"Error: \" .. err)\n/// else\n///     print(content)\n/// end\n/// ```\nfn create_template_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, args: (String, Option\u003cTable\u003e)| {\n        let (template_name, vars_table) = args;\n\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        // Load template\n        let loaded = match ctx.template_repo.get_by_name(\u0026template_name) {\n            Ok(t) =\u003e t,\n            Err(e) =\u003e {\n                return Ok(MultiValue::from_vec(vec![\n                    Value::Nil,\n                    Value::String(lua.create_string(format!(\n                        \"template '{}' not found: {}\",\n                        template_name, e\n                    ))?),\n                ]));\n            }\n        };\n\n        // Build render context\n        let mut render_ctx = build_base_context(\u0026ctx.config);\n        if let Some(table) = vars_table {\n            for pair in table.pairs::\u003cString, Value\u003e() {\n                let (key, value) = pair?;\n                let str_value = lua_value_to_string(\u0026key, value)?;\n                render_ctx.insert(key, str_value);\n            }\n        }\n\n        // Render template body\n        match render_string(\u0026loaded.body, \u0026render_ctx) {\n            Ok(rendered) =\u003e Ok(MultiValue::from_vec(vec![\n                Value::String(lua.create_string(\u0026rendered)?),\n                Value::Nil,\n            ])),\n            Err(e) =\u003e Ok(MultiValue::from_vec(vec![\n                Value::Nil,\n                Value::String(\n                    lua.create_string(format!(\"template render error: {}\", e))?,\n                ),\n            ])),\n        }\n    })\n}\n\n/// Create the `mdv.capture(name, vars?)` function.\n///\n/// Returns: `(true, nil)` on success, `(false, error)` on failure.\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local ok, err = mdv.capture(\"log-to-daily\", { text = \"Created note\" })\n/// if not ok then\n///     print(\"Error: \" .. err)\n/// end\n/// ```\nfn create_capture_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, args: (String, Option\u003cTable\u003e)| {\n        let (capture_name, vars_table) = args;\n\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        // Load capture\n        let loaded = match ctx.capture_repo.get_by_name(\u0026capture_name) {\n            Ok(c) =\u003e c,\n            Err(e) =\u003e {\n                return Ok(MultiValue::from_vec(vec![\n                    Value::Boolean(false),\n                    Value::String(lua.create_string(format!(\n                        \"capture '{}' not found: {}\",\n                        capture_name, e\n                    ))?),\n                ]));\n            }\n        };\n\n        // Build context\n        let mut vars = build_base_context(\u0026ctx.config);\n        if let Some(table) = vars_table {\n            for pair in table.pairs::\u003cString, Value\u003e() {\n                let (key, value) = pair?;\n                let str_value = lua_value_to_string(\u0026key, value)?;\n                vars.insert(key, str_value);\n            }\n        }\n\n        // Execute capture\n        match execute_capture(\u0026ctx.config, \u0026loaded.spec, \u0026vars) {\n            Ok(_) =\u003e Ok(MultiValue::from_vec(vec![Value::Boolean(true), Value::Nil])),\n            Err(e) =\u003e Ok(MultiValue::from_vec(vec![\n                Value::Boolean(false),\n                Value::String(lua.create_string(\u0026e)?),\n            ])),\n        }\n    })\n}\n\n/// Create the `mdv.macro(name, vars?)` function.\n///\n/// Returns: `(true, nil)` on success, `(false, error)` on failure.\n///\n/// Note: Shell steps in macros are NOT executed from hooks (no --trust context).\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local ok, err = mdv.macro(\"on-task-created\", { task_path = note.path })\n/// if not ok then\n///     print(\"Error: \" .. err)\n/// end\n/// ```\nfn create_macro_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, args: (String, Option\u003cTable\u003e)| {\n        let (macro_name, vars_table) = args;\n\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        // Load macro\n        let loaded = match ctx.macro_repo.get_by_name(\u0026macro_name) {\n            Ok(m) =\u003e m,\n            Err(e) =\u003e {\n                return Ok(MultiValue::from_vec(vec![\n                    Value::Boolean(false),\n                    Value::String(lua.create_string(format!(\n                        \"macro '{}' not found: {}\",\n                        macro_name, e\n                    ))?),\n                ]));\n            }\n        };\n\n        // Build context\n        let mut vars = build_base_context(\u0026ctx.config);\n        if let Some(table) = vars_table {\n            for pair in table.pairs::\u003cString, Value\u003e() {\n                let (key, value) = pair?;\n                let str_value = lua_value_to_string(\u0026key, value)?;\n                vars.insert(key, str_value);\n            }\n        }\n\n        // Create a hook step executor (no shell support)\n        let executor = HookStepExecutor {\n            config: ctx.config.clone(),\n            template_repo: ctx.template_repo.clone(),\n            capture_repo: ctx.capture_repo.clone(),\n        };\n\n        // Run macro with shell disabled (no --trust in hooks)\n        let run_ctx = RunContext::new(\n            vars,\n            RunOptions { trust: false, allow_shell: false, dry_run: false },\n        );\n\n        let result = crate::macros::runner::run_macro(\u0026loaded, \u0026executor, run_ctx);\n\n        if result.success {\n            Ok(MultiValue::from_vec(vec![Value::Boolean(true), Value::Nil]))\n        } else {\n            Ok(MultiValue::from_vec(vec![\n                Value::Boolean(false),\n                Value::String(lua.create_string(\u0026result.message)?),\n            ]))\n        }\n    })\n}\n\n/// Create the `mdv.read_note(path)` function.\n///\n/// Reads a note from the vault and returns its content and frontmatter.\n///\n/// Returns: `(note_table, nil)` on success, `(nil, error)` on failure.\n///\n/// The note table contains:\n/// - `path`: The resolved path to the note\n/// - `content`: The full file content including frontmatter\n/// - `body`: The note body without frontmatter\n/// - `frontmatter`: A table with frontmatter fields (if present)\n/// - `title`: The title from frontmatter (if present)\n/// - `type`: The note type from frontmatter (if present)\n///\n/// # Examples (in Lua)\n///\n/// ```lua\n/// local note, err = mdv.read_note(\"projects/my-project.md\")\n/// if err then\n///     print(\"Error: \" .. err)\n/// else\n///     print(\"Title: \" .. (note.title or \"untitled\"))\n///     if note.frontmatter then\n///         print(\"Status: \" .. (note.frontmatter.status or \"unknown\"))\n///     end\n/// end\n/// ```\nfn create_read_note_fn(lua: \u0026Lua) -\u003e LuaResult\u003cFunction\u003e {\n    lua.create_function(|lua, path: String| {\n        let ctx = lua\n            .app_data_ref::\u003cVaultContext\u003e()\n            .ok_or_else(|| mlua::Error::runtime(\"VaultContext not available\"))?;\n\n        // Resolve path relative to vault root\n        let resolved_path =\n            if path.ends_with(\".md\") { path.clone() } else { format!(\"{}.md\", path) };\n\n        let full_path = if Path::new(\u0026resolved_path).is_absolute() {\n            std::path::PathBuf::from(\u0026resolved_path)\n        } else {\n            ctx.vault_root.join(\u0026resolved_path)\n        };\n\n        // Read file content\n        let content = match fs::read_to_string(\u0026full_path) {\n            Ok(c) =\u003e c,\n            Err(e) =\u003e {\n                return Ok(MultiValue::from_vec(vec![\n                    Value::Nil,\n                    Value::String(lua.create_string(format!(\n                        \"failed to read '{}': {}\",\n                        full_path.display(),\n                        e\n                    ))?),\n                ]));\n            }\n        };\n\n        // Parse frontmatter\n        let parsed = match parse(\u0026content) {\n            Ok(p) =\u003e p,\n            Err(e) =\u003e {\n                return Ok(MultiValue::from_vec(vec![\n                    Value::Nil,\n                    Value::String(\n                        lua.create_string(format!(\"failed to parse frontmatter: {}\", e))?,\n                    ),\n                ]));\n            }\n        };\n\n        // Build note table\n        let note_table = lua.create_table()?;\n        note_table.set(\"path\", resolved_path)?;\n        note_table.set(\"content\", content)?;\n        note_table.set(\"body\", parsed.body.clone())?;\n\n        // Add frontmatter if present\n        if let Some(ref fm) = parsed.frontmatter {\n            // Convert frontmatter to serde_yaml::Value for yaml_to_lua_table\n            let fm_yaml = serde_yaml::to_value(fm).map_err(|e| {\n                mlua::Error::runtime(format!(\"failed to serialize frontmatter: {}\", e))\n            })?;\n\n            let fm_table = yaml_to_lua_table(lua, \u0026fm_yaml)?;\n            note_table.set(\"frontmatter\", fm_table)?;\n\n            // Extract common fields for convenience\n            if let Some(title) = fm.fields.get(\"title\").and_then(|v| v.as_str()) {\n                note_table.set(\"title\", title)?;\n            }\n            if let Some(note_type) = fm.fields.get(\"type\").and_then(|v| v.as_str()) {\n                note_table.set(\"type\", note_type)?;\n            }\n        }\n\n        Ok(MultiValue::from_vec(vec![Value::Table(note_table), Value::Nil]))\n    })\n}\n\n/// Build base context with date/time and config paths.\nfn build_base_context(config: \u0026ResolvedConfig) -\u003e HashMap\u003cString, String\u003e {\n    let mut ctx = HashMap::new();\n    let now = Local::now();\n\n    // Date/time\n    ctx.insert(\"date\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"time\".into(), now.format(\"%H:%M\").to_string());\n    ctx.insert(\"datetime\".into(), now.to_rfc3339());\n    ctx.insert(\"today\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"now\".into(), now.format(\"%Y-%m-%dT%H:%M:%S\").to_string());\n\n    // Config paths\n    ctx.insert(\"vault_root\".into(), config.vault_root.to_string_lossy().to_string());\n    ctx.insert(\n        \"templates_dir\".into(),\n        config.templates_dir.to_string_lossy().to_string(),\n    );\n    ctx.insert(\"captures_dir\".into(), config.captures_dir.to_string_lossy().to_string());\n    ctx.insert(\"macros_dir\".into(), config.macros_dir.to_string_lossy().to_string());\n\n    ctx\n}\n\n/// Convert a Lua value to a string.\nfn lua_value_to_string(key: \u0026str, value: Value) -\u003e LuaResult\u003cString\u003e {\n    match value {\n        Value::String(s) =\u003e Ok(s.to_str()?.to_string()),\n        Value::Integer(i) =\u003e Ok(i.to_string()),\n        Value::Number(n) =\u003e Ok(n.to_string()),\n        Value::Boolean(b) =\u003e Ok(b.to_string()),\n        Value::Nil =\u003e Ok(String::new()),\n        _ =\u003e Err(mlua::Error::runtime(format!(\n            \"context value for '{}' must be string, number, boolean, or nil\",\n            key\n        ))),\n    }\n}\n\n/// Execute a capture operation.\nfn execute_capture(\n    config: \u0026ResolvedConfig,\n    spec: \u0026CaptureSpec,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(), String\u003e {\n    // Render target file path\n    let target_file_raw =\n        render_string(\u0026spec.target.file, vars).map_err(|e| e.to_string())?;\n    let target_file = resolve_target_path(\u0026config.vault_root, \u0026target_file_raw);\n\n    // Read existing file or create if missing\n    let existing_content = match fs::read_to_string(\u0026target_file) {\n        Ok(content) =\u003e content,\n        Err(e)\n            if e.kind() == std::io::ErrorKind::NotFound\n                \u0026\u0026 spec.target.create_if_missing =\u003e\n        {\n            // Create the file with minimal structure\n            let content = create_minimal_note(vars, spec.target.section.as_deref());\n\n            // Ensure parent directory exists\n            if let Some(parent) = target_file.parent() {\n                fs::create_dir_all(parent).map_err(|e| {\n                    format!(\"failed to create directory {}: {}\", parent.display(), e)\n                })?;\n            }\n\n            // Write the new file\n            fs::write(\u0026target_file, \u0026content).map_err(|e| {\n                format!(\"failed to create target file {}: {}\", target_file.display(), e)\n            })?;\n\n            content\n        }\n        Err(e) =\u003e {\n            return Err(format!(\n                \"failed to read target file {}: {}\",\n                target_file.display(),\n                e\n            ));\n        }\n    };\n\n    // Execute capture operations\n    let (result_content, _section_info) =\n        execute_capture_operations(\u0026existing_content, spec, vars)?;\n\n    // Write back to file\n    fs::write(\u0026target_file, \u0026result_content)\n        .map_err(|e| format!(\"failed to write to {}: {}\", target_file.display(), e))?;\n\n    Ok(())\n}\n\n/// Create a minimal note structure for auto-created files.\nfn create_minimal_note(vars: \u0026HashMap\u003cString, String\u003e, section: Option\u003c\u0026str\u003e) -\u003e String {\n    let date = vars.get(\"date\").map(|s| s.as_str()).unwrap_or(\"unknown\");\n    let title = vars.get(\"title\").map(|s| s.as_str()).unwrap_or(date);\n\n    let mut content = format!(\"---\\ntype: daily\\ndate: {}\\n---\\n\\n# {}\\n\", date, title);\n\n    // Add the target section if specified\n    if let Some(section_name) = section {\n        content.push_str(\u0026format!(\"\\n## {}\\n\", section_name));\n    }\n\n    content\n}\n\n/// Execute capture operations: frontmatter modification and/or content insertion.\nfn execute_capture_operations(\n    existing_content: \u0026str,\n    spec: \u0026CaptureSpec,\n    ctx: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(String, Option\u003c(String, u8)\u003e), String\u003e {\n    // Parse frontmatter from existing content\n    let mut parsed = parse(existing_content)\n        .map_err(|e| format!(\"failed to parse frontmatter: {}\", e))?;\n    let mut section_info = None;\n\n    // Apply frontmatter operations if specified\n    if let Some(fm_ops) = \u0026spec.frontmatter {\n        parsed = apply_ops(parsed, fm_ops, ctx)\n            .map_err(|e| format!(\"failed to apply frontmatter ops: {}\", e))?;\n    }\n\n    // Insert content if specified\n    if let Some(content_template) = \u0026spec.content {\n        let section = spec.target.section.as_ref().ok_or_else(|| {\n            \"capture has content but no target section specified\".to_string()\n        })?;\n\n        let rendered_section = render_string(section, ctx).map_err(|e| e.to_string())?;\n        let rendered_content =\n            render_string(content_template, ctx).map_err(|e| e.to_string())?;\n\n        let section_match = SectionMatch::new(\u0026rendered_section);\n        let position = spec.target.position.clone().into();\n\n        let result = MarkdownEditor::insert_into_section(\n            \u0026parsed.body,\n            \u0026section_match,\n            \u0026rendered_content,\n            position,\n        )\n        .map_err(|e| format!(\"section insertion failed: {}\", e))?;\n\n        section_info = Some((result.matched_heading.title, result.matched_heading.level));\n        parsed.body = result.content;\n    }\n\n    // Serialize the document\n    let final_content = serialize(\u0026parsed);\n    Ok((final_content, section_info))\n}\n\nfn resolve_target_path(vault_root: \u0026Path, target: \u0026str) -\u003e std::path::PathBuf {\n    let path = Path::new(target);\n    if path.is_absolute() { path.to_path_buf() } else { vault_root.join(path) }\n}\n\n/// Step executor for hooks (no shell support).\nstruct HookStepExecutor {\n    config: std::sync::Arc\u003cResolvedConfig\u003e,\n    template_repo: std::sync::Arc\u003ccrate::templates::repository::TemplateRepository\u003e,\n    capture_repo: std::sync::Arc\u003ccrate::captures::CaptureRepository\u003e,\n}\n\nimpl StepExecutor for HookStepExecutor {\n    fn execute_template(\n        \u0026self,\n        step: \u0026TemplateStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        // Load template\n        let loaded = self\n            .template_repo\n            .get_by_name(\u0026step.template)\n            .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n        // Merge step vars\n        let vars = ctx.with_step_vars(\u0026step.vars_with);\n\n        // Resolve output path\n        let output_path = if let Some(output) = step.output.as_ref() {\n            let rendered = render_string(output, \u0026vars)\n                .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n            resolve_target_path(\u0026self.config.vault_root, \u0026rendered)\n        } else if let Some(fm) = loaded.frontmatter.as_ref() {\n            if let Some(output) = fm.output.as_ref() {\n                let rendered = render_string(output, \u0026vars)\n                    .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n                resolve_target_path(\u0026self.config.vault_root, \u0026rendered)\n            } else {\n                return Err(MacroRunError::TemplateError(\n                    \"template has no output path and none specified in step\".to_string(),\n                ));\n            }\n        } else {\n            return Err(MacroRunError::TemplateError(\n                \"template has no output path and none specified in step\".to_string(),\n            ));\n        };\n\n        // Render template\n        let rendered = render_string(\u0026loaded.body, \u0026vars)\n            .map_err(|e| MacroRunError::TemplateError(e.to_string()))?;\n\n        // Create parent directories if needed\n        if let Some(parent) = output_path.parent() {\n            fs::create_dir_all(parent).map_err(|e| {\n                MacroRunError::TemplateError(format!(\"failed to create directory: {}\", e))\n            })?;\n        }\n\n        // Write file\n        fs::write(\u0026output_path, \u0026rendered).map_err(|e| {\n            MacroRunError::TemplateError(format!(\n                \"failed to write {}: {}\",\n                output_path.display(),\n                e\n            ))\n        })?;\n\n        Ok(StepResult {\n            step_index: 0,\n            success: true,\n            message: format!(\"Created {}\", output_path.display()),\n            output_path: Some(output_path),\n        })\n    }\n\n    fn execute_capture(\n        \u0026self,\n        step: \u0026CaptureStep,\n        ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        // Load capture\n        let loaded = self\n            .capture_repo\n            .get_by_name(\u0026step.capture)\n            .map_err(|e| MacroRunError::CaptureError(e.to_string()))?;\n\n        // Merge step vars\n        let vars = ctx.with_step_vars(\u0026step.vars_with);\n\n        // Execute capture\n        execute_capture(\u0026self.config, \u0026loaded.spec, \u0026vars)\n            .map_err(MacroRunError::CaptureError)?;\n\n        Ok(StepResult {\n            step_index: 0,\n            success: true,\n            message: format!(\"Executed capture: {}\", step.capture),\n            output_path: None,\n        })\n    }\n\n    fn execute_shell(\n        \u0026self,\n        _step: \u0026ShellStep,\n        _ctx: \u0026RunContext,\n    ) -\u003e Result\u003cStepResult, MacroRunError\u003e {\n        // Shell steps are not supported in hooks\n        Err(MacroRunError::TrustRequired)\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":262},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","scripting","vault_context.rs"],"content":"//! Vault context for Lua scripting.\n//!\n//! This module provides the `VaultContext` struct which holds references\n//! to all vault repositories needed for executing vault operations from Lua.\n\nuse std::path::PathBuf;\nuse std::sync::Arc;\n\nuse crate::captures::CaptureRepository;\nuse crate::config::types::ResolvedConfig;\nuse crate::index::IndexDb;\nuse crate::macros::MacroRepository;\nuse crate::templates::repository::TemplateRepository;\nuse crate::types::TypeRegistry;\n\n/// Information about the current note being processed.\n///\n/// This is set when validating or processing a specific note,\n/// allowing Lua hooks to access note metadata.\n#[derive(Clone, Debug)]\npub struct CurrentNote {\n    /// Path to the note relative to vault root.\n    pub path: String,\n    /// Note type from frontmatter.\n    pub note_type: String,\n    /// Note title.\n    pub title: Option\u003cString\u003e,\n    /// Frontmatter as YAML value.\n    pub frontmatter: Option\u003cserde_yaml::Value\u003e,\n    /// Note content.\n    pub content: String,\n}\n\n/// Context for vault operations accessible from Lua hooks.\n///\n/// This struct holds Arc references to avoid cloning large repositories.\n/// It's designed to be passed to Lua bindings for template/capture/macro execution.\n#[derive(Clone)]\npub struct VaultContext {\n    /// Resolved configuration with paths.\n    pub config: Arc\u003cResolvedConfig\u003e,\n    /// Template repository for loading templates.\n    pub template_repo: Arc\u003cTemplateRepository\u003e,\n    /// Capture repository for loading captures.\n    pub capture_repo: Arc\u003cCaptureRepository\u003e,\n    /// Macro repository for loading macros.\n    pub macro_repo: Arc\u003cMacroRepository\u003e,\n    /// Type registry for type definitions.\n    pub type_registry: Arc\u003cTypeRegistry\u003e,\n    /// Optional index database for query operations.\n    pub index_db: Option\u003cArc\u003cIndexDb\u003e\u003e,\n    /// Optional current note being processed.\n    pub current_note: Option\u003cCurrentNote\u003e,\n    /// Vault root path for resolving relative paths.\n    pub vault_root: PathBuf,\n}\n\nimpl VaultContext {\n    /// Create a new VaultContext from owned values.\n    pub fn new(\n        config: ResolvedConfig,\n        template_repo: TemplateRepository,\n        capture_repo: CaptureRepository,\n        macro_repo: MacroRepository,\n        type_registry: TypeRegistry,\n    ) -\u003e Self {\n        let vault_root = config.vault_root.clone();\n        Self {\n            config: Arc::new(config),\n            template_repo: Arc::new(template_repo),\n            capture_repo: Arc::new(capture_repo),\n            macro_repo: Arc::new(macro_repo),\n            type_registry: Arc::new(type_registry),\n            index_db: None,\n            current_note: None,\n            vault_root,\n        }\n    }\n\n    /// Create a new VaultContext from Arc references.\n    pub fn from_arcs(\n        config: Arc\u003cResolvedConfig\u003e,\n        template_repo: Arc\u003cTemplateRepository\u003e,\n        capture_repo: Arc\u003cCaptureRepository\u003e,\n        macro_repo: Arc\u003cMacroRepository\u003e,\n        type_registry: Arc\u003cTypeRegistry\u003e,\n    ) -\u003e Self {\n        let vault_root = config.vault_root.clone();\n        Self {\n            config,\n            template_repo,\n            capture_repo,\n            macro_repo,\n            type_registry,\n            index_db: None,\n            current_note: None,\n            vault_root,\n        }\n    }\n\n    /// Set the index database for query operations.\n    pub fn with_index(mut self, index_db: Arc\u003cIndexDb\u003e) -\u003e Self {\n        self.index_db = Some(index_db);\n        self\n    }\n\n    /// Set the current note being processed.\n    pub fn with_current_note(mut self, note: CurrentNote) -\u003e Self {\n        self.current_note = Some(note);\n        self\n    }\n}\n","traces":[{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","templates","discovery.rs"],"content":"use std::path::{Path, PathBuf};\nuse thiserror::Error;\nuse walkdir::WalkDir;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct TemplateInfo {\n    pub logical_name: String,\n    pub path: PathBuf,\n}\n\n#[derive(Debug, Error)]\npub enum TemplateDiscoveryError {\n    #[error(\"templates directory does not exist: {0}\")]\n    MissingDir(String),\n\n    #[error(\"failed to read templates directory {0} : {1}\")]\n    WalkError(String, #[source] walkdir::Error),\n}\n\npub fn discover_templates(\n    root: \u0026Path,\n) -\u003e Result\u003cVec\u003cTemplateInfo\u003e, TemplateDiscoveryError\u003e {\n    let root = root\n        .canonicalize()\n        .map_err(|_| TemplateDiscoveryError::MissingDir(root.display().to_string()))?;\n\n    if !root.exists() {\n        return Err(TemplateDiscoveryError::MissingDir(root.display().to_string()));\n    }\n\n    let mut out = Vec::new();\n\n    for entry in WalkDir::new(\u0026root) {\n        let entry = entry.map_err(|e| {\n            TemplateDiscoveryError::WalkError(root.display().to_string(), e)\n        })?;\n\n        let path = entry.path();\n        if !path.is_file() {\n            continue;\n        }\n        if !is_markdown_file(path) {\n            continue;\n        }\n\n        let rel = path.strip_prefix(\u0026root).unwrap_or(path);\n        let logical = logical_name_from_relative(rel);\n\n        out.push(TemplateInfo { logical_name: logical, path: path.to_path_buf() });\n    }\n\n    out.sort_by(|a, b| a.logical_name.cmp(\u0026b.logical_name));\n    Ok(out)\n}\n\nfn is_markdown_file(path: \u0026Path) -\u003e bool {\n    let name = path.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n    name.ends_with(\".md\") \u0026\u0026 !(name.ends_with(\".tpl.md\") || name.ends_with(\".tmpl.md\"))\n}\n\nfn logical_name_from_relative(rel: \u0026Path) -\u003e String {\n    let s = rel.to_string_lossy();\n    let suffix = \".md\";\n    if s.ends_with(suffix) {\n        let cut = s.len() - suffix.len();\n        return s[..cut].to_string();\n    }\n    s.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs::File;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_discover_templates_simple() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        File::create(root.join(\"daily.md\")).unwrap();\n        File::create(root.join(\"meeting.md\")).unwrap();\n        File::create(root.join(\"readme.txt\")).unwrap(); // Should be ignored\n\n        let templates = discover_templates(root).unwrap();\n\n        assert_eq!(templates.len(), 2);\n        assert_eq!(templates[0].logical_name, \"daily\");\n        assert_eq!(templates[1].logical_name, \"meeting\");\n    }\n\n    #[test]\n    fn test_discover_templates_ignores_partials() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        File::create(root.join(\"valid.md\")).unwrap();\n        File::create(root.join(\"partial.tpl.md\")).unwrap();\n        File::create(root.join(\"other.tmpl.md\")).unwrap();\n\n        let templates = discover_templates(root).unwrap();\n\n        assert_eq!(templates.len(), 1);\n        assert_eq!(templates[0].logical_name, \"valid\");\n    }\n\n    #[test]\n    fn test_discover_templates_nested() {\n        let dir = tempdir().unwrap();\n        let root = dir.path();\n\n        std::fs::create_dir(root.join(\"work\")).unwrap();\n        File::create(root.join(\"work/report.md\")).unwrap();\n\n        let templates = discover_templates(root).unwrap();\n\n        assert_eq!(templates.len(), 1);\n        assert_eq!(templates[0].logical_name, \"work/report\");\n    }\n\n    #[test]\n    fn test_discover_templates_missing_dir() {\n        let dir = tempdir().unwrap();\n        let missing = dir.path().join(\"missing\");\n\n        let result = discover_templates(\u0026missing);\n        assert!(matches!(result, Err(TemplateDiscoveryError::MissingDir(_))));\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":18}},{"line":23,"address":[],"length":0,"stats":{"Line":36}},{"line":25,"address":[],"length":0,"stats":{"Line":18}},{"line":27,"address":[],"length":0,"stats":{"Line":18}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":36}},{"line":33,"address":[],"length":0,"stats":{"Line":86}},{"line":34,"address":[],"length":0,"stats":{"Line":150}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":150}},{"line":39,"address":[],"length":0,"stats":{"Line":50}},{"line":40,"address":[],"length":0,"stats":{"Line":23}},{"line":42,"address":[],"length":0,"stats":{"Line":27}},{"line":43,"address":[],"length":0,"stats":{"Line":7}},{"line":46,"address":[],"length":0,"stats":{"Line":120}},{"line":47,"address":[],"length":0,"stats":{"Line":60}},{"line":49,"address":[],"length":0,"stats":{"Line":80}},{"line":52,"address":[],"length":0,"stats":{"Line":45}},{"line":53,"address":[],"length":0,"stats":{"Line":18}},{"line":56,"address":[],"length":0,"stats":{"Line":27}},{"line":57,"address":[],"length":0,"stats":{"Line":216}},{"line":58,"address":[],"length":0,"stats":{"Line":140}},{"line":61,"address":[],"length":0,"stats":{"Line":20}},{"line":62,"address":[],"length":0,"stats":{"Line":60}},{"line":63,"address":[],"length":0,"stats":{"Line":40}},{"line":64,"address":[],"length":0,"stats":{"Line":40}},{"line":65,"address":[],"length":0,"stats":{"Line":60}},{"line":66,"address":[],"length":0,"stats":{"Line":40}},{"line":68,"address":[],"length":0,"stats":{"Line":0}}],"covered":26,"coverable":29},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","templates","engine.rs"],"content":"use regex::Regex;\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\n\nuse chrono::Local;\nuse serde_yaml::Value;\nuse thiserror::Error;\n\nuse crate::config::types::ResolvedConfig;\nuse crate::vars::datemath::{evaluate_date_expr, is_date_expr, parse_date_expr};\n\nuse super::discovery::TemplateInfo;\nuse super::repository::LoadedTemplate;\n\n#[derive(Debug, Error)]\npub enum TemplateRenderError {\n    #[error(\"invalid regex for template placeholder: {0}\")]\n    Regex(String),\n}\n\npub type RenderContext = HashMap\u003cString, String\u003e;\n\n/// Build a minimal render context with date/time and config variables.\n///\n/// This is useful for resolving template output paths from frontmatter\n/// before the actual output path is known.\npub fn build_minimal_context(\n    cfg: \u0026ResolvedConfig,\n    template: \u0026TemplateInfo,\n) -\u003e RenderContext {\n    let mut ctx = RenderContext::new();\n\n    // Date/time (basic versions - date math expressions are handled separately)\n    let now = Local::now();\n    ctx.insert(\"date\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"time\".into(), now.format(\"%H:%M\").to_string());\n    ctx.insert(\"datetime\".into(), now.to_rfc3339());\n    // Add today/now as aliases\n    ctx.insert(\"today\".into(), now.format(\"%Y-%m-%d\").to_string());\n    ctx.insert(\"now\".into(), now.to_rfc3339());\n\n    // From config\n    ctx.insert(\"vault_root\".into(), cfg.vault_root.to_string_lossy().to_string());\n    ctx.insert(\"templates_dir\".into(), cfg.templates_dir.to_string_lossy().to_string());\n    ctx.insert(\"captures_dir\".into(), cfg.captures_dir.to_string_lossy().to_string());\n    ctx.insert(\"macros_dir\".into(), cfg.macros_dir.to_string_lossy().to_string());\n\n    // Template info\n    ctx.insert(\"template_name\".into(), template.logical_name.clone());\n    ctx.insert(\"template_path\".into(), template.path.to_string_lossy().to_string());\n\n    ctx\n}\n\npub fn build_render_context(\n    cfg: \u0026ResolvedConfig,\n    template: \u0026TemplateInfo,\n    output_path: \u0026Path,\n) -\u003e RenderContext {\n    let mut ctx = build_minimal_context(cfg, template);\n\n    // Output info\n    let output_abs = absolutize(output_path);\n    ctx.insert(\"output_path\".into(), output_abs.to_string_lossy().to_string());\n    if let Some(name) = output_abs.file_name().and_then(|s| s.to_str()) {\n        ctx.insert(\"output_filename\".into(), name.to_string());\n    }\n    if let Some(parent) = output_abs.parent() {\n        ctx.insert(\"output_dir\".into(), parent.to_string_lossy().to_string());\n    }\n\n    ctx\n}\n\nfn absolutize(path: \u0026Path) -\u003e PathBuf {\n    if path.is_absolute() {\n        path.to_path_buf()\n    } else {\n        std::env::current_dir().unwrap_or_else(|_| PathBuf::from(\".\")).join(path)\n    }\n}\n\npub fn render(\n    template: \u0026LoadedTemplate,\n    ctx: \u0026RenderContext,\n) -\u003e Result\u003cString, TemplateRenderError\u003e {\n    let rendered_body = render_string(\u0026template.body, ctx)?;\n\n    // Check if template has extra frontmatter fields to include in output\n    // Note: can't use let chains (Rust 2024) so we nest the if statements\n    #[allow(clippy::collapsible_if)]\n    if let Some(ref fm) = template.frontmatter {\n        if !fm.extra.is_empty() {\n            // Render variable placeholders in frontmatter values\n            let rendered_fm = render_frontmatter_values(\u0026fm.extra, ctx)?;\n            // Serialize as YAML frontmatter\n            let yaml = serde_yaml::to_string(\u0026rendered_fm).unwrap_or_default();\n            return Ok(format!(\"---\\n{}---\\n\\n{}\", yaml, rendered_body));\n        }\n    }\n\n    Ok(rendered_body)\n}\n\n/// Render variable placeholders in frontmatter values.\nfn render_frontmatter_values(\n    fields: \u0026HashMap\u003cString, Value\u003e,\n    ctx: \u0026RenderContext,\n) -\u003e Result\u003cHashMap\u003cString, Value\u003e, TemplateRenderError\u003e {\n    let mut rendered = HashMap::new();\n    for (key, value) in fields {\n        let rendered_value = render_yaml_value(value, ctx)?;\n        rendered.insert(key.clone(), rendered_value);\n    }\n    Ok(rendered)\n}\n\n/// Recursively render variable placeholders in a YAML value.\nfn render_yaml_value(\n    value: \u0026Value,\n    ctx: \u0026RenderContext,\n) -\u003e Result\u003cValue, TemplateRenderError\u003e {\n    match value {\n        Value::String(s) =\u003e {\n            let rendered = render_string(s, ctx)?;\n            Ok(Value::String(rendered))\n        }\n        Value::Sequence(seq) =\u003e {\n            let rendered: Result\u003cVec\u003cValue\u003e, _\u003e =\n                seq.iter().map(|v| render_yaml_value(v, ctx)).collect();\n            Ok(Value::Sequence(rendered?))\n        }\n        Value::Mapping(map) =\u003e {\n            let mut rendered_map = serde_yaml::Mapping::new();\n            for (k, v) in map {\n                let rendered_v = render_yaml_value(v, ctx)?;\n                rendered_map.insert(k.clone(), rendered_v);\n            }\n            Ok(Value::Mapping(rendered_map))\n        }\n        // Other types (numbers, bools, null) pass through unchanged\n        _ =\u003e Ok(value.clone()),\n    }\n}\n\n/// Render a string template with variable substitution.\n///\n/// Supports:\n/// - Simple variables: `{{var_name}}`\n/// - Date math expressions: `{{today + 1d}}`, `{{now - 2h}}`, `{{today | %Y-%m-%d}}`\n/// - Filters: `{{var_name | filter}}` (currently supports: slugify)\npub fn render_string(\n    template: \u0026str,\n    ctx: \u0026RenderContext,\n) -\u003e Result\u003cString, TemplateRenderError\u003e {\n    // Match both simple vars and date math expressions\n    // Captures everything between {{ and }} that looks like a valid expression\n    let re = Regex::new(r\"\\{\\{([^{}]+)\\}\\}\")\n        .map_err(|e| TemplateRenderError::Regex(e.to_string()))?;\n\n    let result = re.replace_all(template, |caps: \u0026regex::Captures\u003c'_\u003e| {\n        let expr = caps[1].trim();\n\n        // First, check if it's a date math expression\n        if is_date_expr(expr)\n            \u0026\u0026 let Ok(parsed) = parse_date_expr(expr)\n        {\n            return evaluate_date_expr(\u0026parsed);\n        }\n\n        // Check for filter syntax: \"var_name | filter\"\n        if let Some((var_name, filter)) = parse_filter_expr(expr) {\n            if let Some(value) = ctx.get(var_name) {\n                return apply_filter(value, filter);\n            }\n            // Variable not found, return original\n            return caps[0].to_string();\n        }\n\n        // Otherwise, try simple variable lookup\n        ctx.get(expr).cloned().unwrap_or_else(|| caps[0].to_string())\n    });\n\n    Ok(result.into_owned())\n}\n\n/// Parse a filter expression like \"var_name | filter_name\".\n/// Returns (var_name, filter_name) if valid, None otherwise.\nfn parse_filter_expr(expr: \u0026str) -\u003e Option\u003c(\u0026str, \u0026str)\u003e {\n    // Don't parse date expressions with format as filters (e.g., \"today | %Y-%m-%d\")\n    if is_date_expr(expr) {\n        return None;\n    }\n\n    let parts: Vec\u003c\u0026str\u003e = expr.splitn(2, '|').collect();\n    if parts.len() == 2 {\n        let var_name = parts[0].trim();\n        let filter = parts[1].trim();\n        if !var_name.is_empty() \u0026\u0026 !filter.is_empty() {\n            return Some((var_name, filter));\n        }\n    }\n    None\n}\n\n/// Apply a filter to a value.\nfn apply_filter(value: \u0026str, filter: \u0026str) -\u003e String {\n    match filter {\n        \"slugify\" =\u003e slugify(value),\n        \"lowercase\" | \"lower\" =\u003e value.to_lowercase(),\n        \"uppercase\" | \"upper\" =\u003e value.to_uppercase(),\n        \"trim\" =\u003e value.trim().to_string(),\n        _ =\u003e value.to_string(), // Unknown filter, return unchanged\n    }\n}\n\n/// Convert a string to a URL-friendly slug.\n///\n/// - Converts to lowercase\n/// - Replaces spaces and underscores with hyphens\n/// - Removes non-alphanumeric characters (except hyphens)\n/// - Collapses multiple hyphens into one\n/// - Trims leading/trailing hyphens\nfn slugify(s: \u0026str) -\u003e String {\n    let mut result = String::with_capacity(s.len());\n\n    for c in s.chars() {\n        if c.is_ascii_alphanumeric() {\n            result.push(c.to_ascii_lowercase());\n        } else if c == ' ' || c == '_' || c == '-' {\n            // Only add hyphen if last char wasn't already a hyphen\n            if !result.ends_with('-') {\n                result.push('-');\n            }\n        }\n        // Other characters are skipped\n    }\n\n    // Trim leading/trailing hyphens\n    result.trim_matches('-').to_string()\n}\n\n/// Resolve the output path for a template.\n///\n/// If the template has frontmatter with an `output` field, render it with the context.\n/// Otherwise, return None.\npub fn resolve_template_output_path(\n    template: \u0026LoadedTemplate,\n    cfg: \u0026ResolvedConfig,\n    ctx: \u0026RenderContext,\n) -\u003e Result\u003cOption\u003cPathBuf\u003e, TemplateRenderError\u003e {\n    if let Some(ref fm) = template.frontmatter\n        \u0026\u0026 let Some(ref output) = fm.output\n    {\n        let rendered = render_string(output, ctx)?;\n        let path = cfg.vault_root.join(\u0026rendered);\n        return Ok(Some(path));\n    }\n    Ok(None)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_slugify_basic() {\n        assert_eq!(slugify(\"Hello World\"), \"hello-world\");\n        assert_eq!(slugify(\"Test Task\"), \"test-task\");\n    }\n\n    #[test]\n    fn test_slugify_special_chars() {\n        assert_eq!(slugify(\"Hello, World!\"), \"hello-world\");\n        assert_eq!(slugify(\"What's up?\"), \"whats-up\");\n        assert_eq!(slugify(\"foo@bar.com\"), \"foobarcom\");\n    }\n\n    #[test]\n    fn test_slugify_underscores() {\n        assert_eq!(slugify(\"hello_world\"), \"hello-world\");\n        assert_eq!(slugify(\"foo_bar_baz\"), \"foo-bar-baz\");\n    }\n\n    #[test]\n    fn test_slugify_multiple_spaces() {\n        assert_eq!(slugify(\"hello   world\"), \"hello-world\");\n        assert_eq!(slugify(\"  leading and trailing  \"), \"leading-and-trailing\");\n    }\n\n    #[test]\n    fn test_slugify_mixed() {\n        assert_eq!(slugify(\"My Task: Do Something!\"), \"my-task-do-something\");\n        assert_eq!(slugify(\"2024-01-15 Meeting Notes\"), \"2024-01-15-meeting-notes\");\n    }\n\n    #[test]\n    fn test_render_string_with_slugify_filter() {\n        let mut ctx = RenderContext::new();\n        ctx.insert(\"title\".into(), \"Hello World\".into());\n\n        let result = render_string(\"{{title | slugify}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"hello-world\");\n    }\n\n    #[test]\n    fn test_render_string_with_lowercase_filter() {\n        let mut ctx = RenderContext::new();\n        ctx.insert(\"name\".into(), \"HELLO\".into());\n\n        let result = render_string(\"{{name | lowercase}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"hello\");\n\n        let result = render_string(\"{{name | lower}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"hello\");\n    }\n\n    #[test]\n    fn test_render_string_with_uppercase_filter() {\n        let mut ctx = RenderContext::new();\n        ctx.insert(\"name\".into(), \"hello\".into());\n\n        let result = render_string(\"{{name | uppercase}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"HELLO\");\n    }\n\n    #[test]\n    fn test_render_string_filter_in_path() {\n        let mut ctx = RenderContext::new();\n        ctx.insert(\"vault_root\".into(), \"/vault\".into());\n        ctx.insert(\"title\".into(), \"My New Task\".into());\n\n        let result =\n            render_string(\"{{vault_root}}/tasks/{{title | slugify}}.md\", \u0026ctx).unwrap();\n        assert_eq!(result, \"/vault/tasks/my-new-task.md\");\n    }\n\n    #[test]\n    fn test_render_string_unknown_filter() {\n        let mut ctx = RenderContext::new();\n        ctx.insert(\"name\".into(), \"hello\".into());\n\n        // Unknown filter returns value unchanged\n        let result = render_string(\"{{name | unknown}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"hello\");\n    }\n\n    #[test]\n    fn test_render_string_missing_var_with_filter() {\n        let ctx = RenderContext::new();\n\n        // Missing variable with filter returns original placeholder\n        let result = render_string(\"{{missing | slugify}}\", \u0026ctx).unwrap();\n        assert_eq!(result, \"{{missing | slugify}}\");\n    }\n\n    #[test]\n    fn test_date_format_not_parsed_as_filter() {\n        let ctx = RenderContext::new();\n\n        // Date expressions with format should still work\n        let result = render_string(\"{{today | %Y-%m-%d}}\", \u0026ctx).unwrap();\n        // Should be a date, not \"today\" with filter \"%Y-%m-%d\"\n        assert!(result.contains('-'));\n        assert!(!result.contains(\"today\"));\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":14}},{"line":31,"address":[],"length":0,"stats":{"Line":28}},{"line":34,"address":[],"length":0,"stats":{"Line":28}},{"line":35,"address":[],"length":0,"stats":{"Line":98}},{"line":36,"address":[],"length":0,"stats":{"Line":98}},{"line":37,"address":[],"length":0,"stats":{"Line":84}},{"line":39,"address":[],"length":0,"stats":{"Line":98}},{"line":40,"address":[],"length":0,"stats":{"Line":84}},{"line":43,"address":[],"length":0,"stats":{"Line":84}},{"line":44,"address":[],"length":0,"stats":{"Line":84}},{"line":45,"address":[],"length":0,"stats":{"Line":84}},{"line":46,"address":[],"length":0,"stats":{"Line":84}},{"line":49,"address":[],"length":0,"stats":{"Line":84}},{"line":50,"address":[],"length":0,"stats":{"Line":84}},{"line":52,"address":[],"length":0,"stats":{"Line":14}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":13}},{"line":87,"address":[],"length":0,"stats":{"Line":52}},{"line":92,"address":[],"length":0,"stats":{"Line":18}},{"line":93,"address":[],"length":0,"stats":{"Line":5}},{"line":95,"address":[],"length":0,"stats":{"Line":8}},{"line":97,"address":[],"length":0,"stats":{"Line":8}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":11}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":14}},{"line":112,"address":[],"length":0,"stats":{"Line":16}},{"line":113,"address":[],"length":0,"stats":{"Line":20}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":5}},{"line":125,"address":[],"length":0,"stats":{"Line":20}},{"line":126,"address":[],"length":0,"stats":{"Line":5}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":9}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":67}},{"line":158,"address":[],"length":0,"stats":{"Line":201}},{"line":159,"address":[],"length":0,"stats":{"Line":67}},{"line":161,"address":[],"length":0,"stats":{"Line":335}},{"line":162,"address":[],"length":0,"stats":{"Line":201}},{"line":165,"address":[],"length":0,"stats":{"Line":134}},{"line":166,"address":[],"length":0,"stats":{"Line":46}},{"line":168,"address":[],"length":0,"stats":{"Line":46}},{"line":172,"address":[],"length":0,"stats":{"Line":58}},{"line":173,"address":[],"length":0,"stats":{"Line":20}},{"line":174,"address":[],"length":0,"stats":{"Line":18}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":189}},{"line":184,"address":[],"length":0,"stats":{"Line":67}},{"line":189,"address":[],"length":0,"stats":{"Line":44}},{"line":191,"address":[],"length":0,"stats":{"Line":88}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":220}},{"line":196,"address":[],"length":0,"stats":{"Line":44}},{"line":197,"address":[],"length":0,"stats":{"Line":21}},{"line":198,"address":[],"length":0,"stats":{"Line":21}},{"line":199,"address":[],"length":0,"stats":{"Line":14}},{"line":200,"address":[],"length":0,"stats":{"Line":7}},{"line":203,"address":[],"length":0,"stats":{"Line":37}},{"line":207,"address":[],"length":0,"stats":{"Line":6}},{"line":208,"address":[],"length":0,"stats":{"Line":6}},{"line":209,"address":[],"length":0,"stats":{"Line":10}},{"line":210,"address":[],"length":0,"stats":{"Line":11}},{"line":211,"address":[],"length":0,"stats":{"Line":5}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":13}},{"line":225,"address":[],"length":0,"stats":{"Line":52}},{"line":227,"address":[],"length":0,"stats":{"Line":207}},{"line":228,"address":[],"length":0,"stats":{"Line":509}},{"line":229,"address":[],"length":0,"stats":{"Line":441}},{"line":230,"address":[],"length":0,"stats":{"Line":204}},{"line":232,"address":[],"length":0,"stats":{"Line":48}},{"line":233,"address":[],"length":0,"stats":{"Line":22}},{"line":240,"address":[],"length":0,"stats":{"Line":26}},{"line":247,"address":[],"length":0,"stats":{"Line":9}},{"line":252,"address":[],"length":0,"stats":{"Line":17}},{"line":253,"address":[],"length":0,"stats":{"Line":16}},{"line":255,"address":[],"length":0,"stats":{"Line":32}},{"line":256,"address":[],"length":0,"stats":{"Line":24}},{"line":257,"address":[],"length":0,"stats":{"Line":8}},{"line":259,"address":[],"length":0,"stats":{"Line":1}}],"covered":84,"coverable":105},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","templates","mod.rs"],"content":"pub mod discovery;\npub mod engine;\npub mod repository;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","templates","repository.rs"],"content":"use std::fs;\nuse std::path::{Path, PathBuf};\n\nuse thiserror::Error;\n\nuse crate::frontmatter::{\n    FrontmatterParseError, TemplateFrontmatter, parse_template_frontmatter,\n};\nuse crate::templates::discovery::{\n    TemplateDiscoveryError, TemplateInfo, discover_templates,\n};\n\n#[derive(Debug, Error)]\npub enum TemplateRepoError {\n    #[error(transparent)]\n    Discovery(#[from] TemplateDiscoveryError),\n\n    #[error(\"template not found: {0}\")]\n    NotFound(String),\n\n    #[error(\"failed to read template file {path}: {source}\")]\n    Io {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    #[error(\"failed to parse frontmatter in {path}: {source}\")]\n    FrontmatterParse {\n        path: PathBuf,\n        #[source]\n        source: FrontmatterParseError,\n    },\n}\n\n#[derive(Debug, Clone)]\npub struct LoadedTemplate {\n    pub logical_name: String,\n    pub path: PathBuf,\n    /// Raw content (includes frontmatter if present).\n    pub content: String,\n    /// Parsed template frontmatter (if present).\n    pub frontmatter: Option\u003cTemplateFrontmatter\u003e,\n    /// Body content (excludes frontmatter).\n    pub body: String,\n}\n\npub struct TemplateRepository {\n    pub root: PathBuf,\n    pub templates: Vec\u003cTemplateInfo\u003e,\n}\n\nimpl TemplateRepository {\n    pub fn new(root: \u0026Path) -\u003e Result\u003cSelf, TemplateDiscoveryError\u003e {\n        let templates = discover_templates(root)?;\n        Ok(Self { root: root.to_path_buf(), templates })\n    }\n\n    pub fn list_all(\u0026self) -\u003e \u0026[TemplateInfo] {\n        \u0026self.templates\n    }\n\n    pub fn get_by_name(\u0026self, name: \u0026str) -\u003e Result\u003cLoadedTemplate, TemplateRepoError\u003e {\n        let info = self\n            .templates\n            .iter()\n            .find(|t| t.logical_name == name)\n            .ok_or_else(|| TemplateRepoError::NotFound(name.to_lowercase()))?;\n\n        let content = fs::read_to_string(\u0026info.path)\n            .map_err(|e| TemplateRepoError::Io { path: info.path.clone(), source: e })?;\n\n        let (frontmatter, body) = parse_template_frontmatter(\u0026content).map_err(|e| {\n            TemplateRepoError::FrontmatterParse { path: info.path.clone(), source: e }\n        })?;\n\n        Ok(LoadedTemplate {\n            logical_name: info.logical_name.clone(),\n            path: info.path.clone(),\n            content,\n            frontmatter,\n            body,\n        })\n    }\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":15}},{"line":55,"address":[],"length":0,"stats":{"Line":45}},{"line":56,"address":[],"length":0,"stats":{"Line":30}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":14}},{"line":64,"address":[],"length":0,"stats":{"Line":28}},{"line":65,"address":[],"length":0,"stats":{"Line":14}},{"line":67,"address":[],"length":0,"stats":{"Line":42}},{"line":68,"address":[],"length":0,"stats":{"Line":14}},{"line":70,"address":[],"length":0,"stats":{"Line":42}},{"line":71,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":70}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":14}},{"line":78,"address":[],"length":0,"stats":{"Line":42}},{"line":79,"address":[],"length":0,"stats":{"Line":42}},{"line":80,"address":[],"length":0,"stats":{"Line":28}},{"line":81,"address":[],"length":0,"stats":{"Line":14}},{"line":82,"address":[],"length":0,"stats":{"Line":14}}],"covered":17,"coverable":20},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","autofix.rs"],"content":"//! Auto-fix functionality for note validation issues.\n//!\n//! Provides safe auto-corrections for common validation errors:\n//! - Adding missing required fields with default values\n//! - Normalizing enum value case\n//! - Adding missing frontmatter block\n\nuse std::collections::HashMap;\nuse std::path::Path;\n\nuse super::definition::TypeDefinition;\nuse super::errors::ValidationError;\nuse super::registry::TypeRegistry;\nuse crate::frontmatter::{Frontmatter, ParsedDocument, parse as parse_frontmatter};\n\n/// Result of attempting to fix a note.\n#[derive(Debug)]\npub struct FixResult {\n    /// Whether any fixes were applied.\n    pub fixed: bool,\n    /// Description of fixes applied.\n    pub fixes: Vec\u003cString\u003e,\n    /// The corrected content (if fixes were applied).\n    pub content: Option\u003cString\u003e,\n}\n\nimpl FixResult {\n    pub fn no_fix() -\u003e Self {\n        Self { fixed: false, fixes: Vec::new(), content: None }\n    }\n}\n\n/// Attempt to auto-fix validation errors in a note.\n///\n/// Returns a FixResult with the corrected content if fixes were applied.\npub fn try_fix_note(\n    registry: \u0026TypeRegistry,\n    note_type: \u0026str,\n    content: \u0026str,\n    errors: \u0026[ValidationError],\n) -\u003e FixResult {\n    let typedef = match registry.get(note_type) {\n        Some(td) =\u003e td,\n        None =\u003e return FixResult::no_fix(),\n    };\n\n    // Parse existing frontmatter\n    let parsed = match parse_frontmatter(content) {\n        Ok(p) =\u003e p,\n        Err(_) =\u003e return FixResult::no_fix(),\n    };\n\n    let mut frontmatter = parsed.frontmatter.map(|fm| fm.fields).unwrap_or_default();\n    let mut fixes = Vec::new();\n\n    for error in errors {\n        match error {\n            ValidationError::MissingRequired { field } =\u003e {\n                if let Some(fix) = fix_missing_required(\u0026typedef, field, \u0026mut frontmatter)\n                {\n                    fixes.push(fix);\n                }\n            }\n            ValidationError::EnumViolation { field, value, allowed } =\u003e {\n                if let Some(fix) = fix_enum_case(field, value, allowed, \u0026mut frontmatter)\n                {\n                    fixes.push(fix);\n                }\n            }\n            _ =\u003e {} // Other errors can't be auto-fixed\n        }\n    }\n\n    if fixes.is_empty() {\n        return FixResult::no_fix();\n    }\n\n    // Reconstruct the document with fixed frontmatter\n    let new_doc = ParsedDocument {\n        frontmatter: Some(Frontmatter { fields: frontmatter }),\n        body: parsed.body,\n    };\n    let new_content = crate::frontmatter::serialize(\u0026new_doc);\n\n    FixResult { fixed: true, fixes, content: Some(new_content) }\n}\n\n/// Fix a missing required field by adding its default value.\nfn fix_missing_required(\n    typedef: \u0026TypeDefinition,\n    field: \u0026str,\n    frontmatter: \u0026mut HashMap\u003cString, serde_yaml::Value\u003e,\n) -\u003e Option\u003cString\u003e {\n    let schema = typedef.schema.get(field)?;\n\n    // Only fix if there's a default value\n    let default = schema.default.as_ref()?;\n\n    frontmatter.insert(field.to_string(), default.clone());\n\n    let default_str = match default {\n        serde_yaml::Value::String(s) =\u003e s.clone(),\n        serde_yaml::Value::Number(n) =\u003e n.to_string(),\n        serde_yaml::Value::Bool(b) =\u003e b.to_string(),\n        _ =\u003e format!(\"{:?}\", default),\n    };\n\n    Some(format!(\"Added missing field '{}' with default '{}'\", field, default_str))\n}\n\n/// Fix enum case mismatch by normalizing to the correct case.\nfn fix_enum_case(\n    field: \u0026str,\n    value: \u0026str,\n    allowed: \u0026[String],\n    frontmatter: \u0026mut HashMap\u003cString, serde_yaml::Value\u003e,\n) -\u003e Option\u003cString\u003e {\n    // Find a case-insensitive match\n    let lowercase_value = value.to_lowercase();\n    let correct_value = allowed.iter().find(|v| v.to_lowercase() == lowercase_value)?;\n\n    if correct_value == value {\n        return None; // No fix needed\n    }\n\n    frontmatter\n        .insert(field.to_string(), serde_yaml::Value::String(correct_value.clone()));\n\n    Some(format!(\"Fixed case for '{}': '{}' -\u003e '{}'\", field, value, correct_value))\n}\n\n/// Apply fixes to a note file.\npub fn apply_fixes(path: \u0026Path, content: \u0026str) -\u003e Result\u003c(), String\u003e {\n    std::fs::write(path, content)\n        .map_err(|e| format!(\"Failed to write {}: {}\", path.display(), e))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::schema::{FieldSchema, FieldType};\n\n    fn make_typedef_with_defaults() -\u003e TypeDefinition {\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"status\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                enum_values: Some(vec![\"open\".to_string(), \"done\".to_string()]),\n                default: Some(serde_yaml::Value::String(\"open\".to_string())),\n                ..Default::default()\n            },\n        );\n        schema.insert(\n            \"priority\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: false,\n                enum_values: Some(vec![\n                    \"low\".to_string(),\n                    \"medium\".to_string(),\n                    \"high\".to_string(),\n                ]),\n                default: Some(serde_yaml::Value::String(\"medium\".to_string())),\n                ..Default::default()\n            },\n        );\n\n        TypeDefinition {\n            name: \"task\".to_string(),\n            description: None,\n            source_path: std::path::PathBuf::new(),\n            schema,\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: false,\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: String::new(),\n        }\n    }\n\n    #[test]\n    fn test_fix_missing_required_with_default() {\n        let mut registry = TypeRegistry::new();\n        registry.register(make_typedef_with_defaults()).unwrap();\n\n        let content = \"---\\ntype: task\\ntitle: Test\\n---\\n\\n# Test\\n\";\n        let errors =\n            vec![ValidationError::MissingRequired { field: \"status\".to_string() }];\n\n        let result = try_fix_note(\u0026registry, \"task\", content, \u0026errors);\n        assert!(result.fixed);\n        assert_eq!(result.fixes.len(), 1);\n        assert!(result.fixes[0].contains(\"status\"));\n        assert!(result.content.unwrap().contains(\"status: open\"));\n    }\n\n    #[test]\n    fn test_fix_enum_case() {\n        let mut registry = TypeRegistry::new();\n        registry.register(make_typedef_with_defaults()).unwrap();\n\n        let content = \"---\\ntype: task\\nstatus: OPEN\\n---\\n\\n# Test\\n\";\n        let errors = vec![ValidationError::EnumViolation {\n            field: \"status\".to_string(),\n            value: \"OPEN\".to_string(),\n            allowed: vec![\"open\".to_string(), \"done\".to_string()],\n        }];\n\n        let result = try_fix_note(\u0026registry, \"task\", content, \u0026errors);\n        assert!(result.fixed);\n        assert!(result.fixes[0].contains(\"OPEN\"));\n        assert!(result.fixes[0].contains(\"open\"));\n    }\n\n    #[test]\n    fn test_no_fix_without_default() {\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"project\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                default: None, // No default\n                ..Default::default()\n            },\n        );\n\n        let typedef = TypeDefinition {\n            name: \"task\".to_string(),\n            description: None,\n            source_path: std::path::PathBuf::new(),\n            schema,\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: false,\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: String::new(),\n        };\n\n        let mut registry = TypeRegistry::new();\n        registry.register(typedef).unwrap();\n\n        let content = \"---\\ntype: task\\n---\\n\\n# Test\\n\";\n        let errors =\n            vec![ValidationError::MissingRequired { field: \"project\".to_string() }];\n\n        let result = try_fix_note(\u0026registry, \"task\", content, \u0026errors);\n        assert!(!result.fixed);\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":9}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":56,"address":[],"length":0,"stats":{"Line":9}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":7}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":5}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":8}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":5}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}}],"covered":37,"coverable":47},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","definition.rs"],"content":"//! Type definition structures.\n\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\nuse super::schema::FieldSchema;\n\n/// A loaded type definition from a Lua file.\n#[derive(Debug, Clone)]\npub struct TypeDefinition {\n    /// Type name (from filename).\n    pub name: String,\n\n    /// Human-readable description.\n    pub description: Option\u003cString\u003e,\n\n    /// Path to the source .lua file.\n    pub source_path: PathBuf,\n\n    /// Field schemas for frontmatter validation.\n    pub schema: HashMap\u003cString, FieldSchema\u003e,\n\n    /// Output path template (supports {{var}} placeholders).\n    pub output: Option\u003cString\u003e,\n\n    /// Whether this type has a custom validate() function.\n    pub has_validate_fn: bool,\n\n    /// Whether this type has an on_create() hook.\n    pub has_on_create_hook: bool,\n\n    /// Whether this type has an on_update() hook.\n    pub has_on_update_hook: bool,\n\n    /// Whether this overrides a built-in type.\n    pub is_builtin_override: bool,\n\n    /// Raw Lua source (for re-execution of hooks).\n    pub lua_source: String,\n}\n\nimpl TypeDefinition {\n    /// Create an empty type definition (for testing).\n    pub fn empty(name: \u0026str) -\u003e Self {\n        Self {\n            name: name.to_string(),\n            description: None,\n            source_path: PathBuf::new(),\n            schema: HashMap::new(),\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: false,\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: String::new(),\n        }\n    }\n\n    /// Check if this type has any hooks.\n    pub fn has_hooks(\u0026self) -\u003e bool {\n        self.has_validate_fn || self.has_on_create_hook || self.has_on_update_hook\n    }\n\n    /// Get a list of required fields.\n    pub fn required_fields(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        self.schema\n            .iter()\n            .filter(|(_, schema)| schema.required)\n            .map(|(name, _)| name.as_str())\n            .collect()\n    }\n\n    /// Check if the type has a schema for a given field.\n    pub fn has_field(\u0026self, name: \u0026str) -\u003e bool {\n        self.schema.contains_key(name)\n    }\n\n    /// Get the schema for a field.\n    pub fn get_field(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026FieldSchema\u003e {\n        self.schema.get(name)\n    }\n}\n\n/// Information about a discovered type definition file.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct TypedefInfo {\n    /// Type name (filename without .lua extension).\n    pub name: String,\n\n    /// Full path to the .lua file.\n    pub path: PathBuf,\n}\n\nimpl TypedefInfo {\n    /// Create new typedef info.\n    pub fn new(name: String, path: PathBuf) -\u003e Self {\n        Self { name, path }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::schema::FieldType;\n\n    #[test]\n    fn test_empty_typedef() {\n        let td = TypeDefinition::empty(\"test\");\n        assert_eq!(td.name, \"test\");\n        assert!(td.schema.is_empty());\n        assert!(!td.has_hooks());\n    }\n\n    #[test]\n    fn test_required_fields() {\n        let mut td = TypeDefinition::empty(\"test\");\n        td.schema.insert(\n            \"title\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                ..Default::default()\n            },\n        );\n        td.schema.insert(\n            \"description\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: false,\n                ..Default::default()\n            },\n        );\n\n        let required = td.required_fields();\n        assert_eq!(required.len(), 1);\n        assert!(required.contains(\u0026\"title\"));\n    }\n\n    #[test]\n    fn test_has_hooks() {\n        let mut td = TypeDefinition::empty(\"test\");\n        assert!(!td.has_hooks());\n\n        td.has_validate_fn = true;\n        assert!(td.has_hooks());\n    }\n\n    #[test]\n    fn test_typedef_info() {\n        let info = TypedefInfo::new(\n            \"meeting\".to_string(),\n            PathBuf::from(\"/path/to/meeting.lua\"),\n        );\n        assert_eq!(info.name, \"meeting\");\n        assert_eq!(info.path, PathBuf::from(\"/path/to/meeting.lua\"));\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":14}},{"line":46,"address":[],"length":0,"stats":{"Line":42}},{"line":48,"address":[],"length":0,"stats":{"Line":28}},{"line":49,"address":[],"length":0,"stats":{"Line":28}},{"line":55,"address":[],"length":0,"stats":{"Line":14}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":7}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":24}}],"covered":12,"coverable":16},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","discovery.rs"],"content":"//! Type definition discovery and loading.\n\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\nuse walkdir::WalkDir;\n\nuse super::definition::{TypeDefinition, TypedefInfo};\nuse super::errors::TypedefError;\nuse super::schema::{FieldSchema, FieldType};\nuse crate::scripting::LuaEngine;\n\n/// Built-in type names that can be overridden by Lua definitions.\nconst BUILTIN_TYPES: \u0026[\u0026str] = \u0026[\"daily\", \"weekly\", \"task\", \"project\", \"zettel\"];\n\n/// Discover type definition files in a directory.\n///\n/// Finds all `.lua` files in the given directory (non-recursive).\n/// Returns an empty list if the directory doesn't exist.\npub fn discover_typedefs(root: \u0026Path) -\u003e Result\u003cVec\u003cTypedefInfo\u003e, TypedefError\u003e {\n    // Gracefully handle missing directory\n    if !root.exists() {\n        return Ok(vec![]);\n    }\n\n    let root = root\n        .canonicalize()\n        .map_err(|_| TypedefError::MissingDir(root.display().to_string()))?;\n\n    let mut out = Vec::new();\n\n    // Only look at direct children (max_depth = 1)\n    for entry in WalkDir::new(\u0026root).max_depth(1) {\n        let entry =\n            entry.map_err(|e| TypedefError::WalkError(root.display().to_string(), e))?;\n\n        let path = entry.path();\n        if !path.is_file() {\n            continue;\n        }\n        if !is_lua_file(path) {\n            continue;\n        }\n\n        let name = path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"\").to_string();\n\n        if !name.is_empty() {\n            out.push(TypedefInfo::new(name, path.to_path_buf()));\n        }\n    }\n\n    out.sort_by(|a, b| a.name.cmp(\u0026b.name));\n    Ok(out)\n}\n\nfn is_lua_file(path: \u0026Path) -\u003e bool {\n    path.extension().and_then(|e| e.to_str()) == Some(\"lua\")\n}\n\n/// Repository for discovering and loading type definitions.\npub struct TypedefRepository {\n    /// Root directory for type definitions.\n    pub root: PathBuf,\n    /// Discovered type definition files.\n    pub typedefs: Vec\u003cTypedefInfo\u003e,\n}\n\nimpl TypedefRepository {\n    /// Create a new repository from a directory.\n    ///\n    /// Returns an empty repository if the directory doesn't exist.\n    pub fn new(root: \u0026Path) -\u003e Result\u003cSelf, TypedefError\u003e {\n        let typedefs = discover_typedefs(root)?;\n        Ok(Self { root: root.to_path_buf(), typedefs })\n    }\n\n    /// List all discovered type definitions.\n    pub fn list_all(\u0026self) -\u003e \u0026[TypedefInfo] {\n        \u0026self.typedefs\n    }\n\n    /// Check if a type definition exists.\n    pub fn has_typedef(\u0026self, name: \u0026str) -\u003e bool {\n        self.typedefs.iter().any(|t| t.name == name)\n    }\n\n    /// Load a type definition by name.\n    pub fn load_typedef(\u0026self, name: \u0026str) -\u003e Result\u003cTypeDefinition, TypedefError\u003e {\n        let info = self\n            .typedefs\n            .iter()\n            .find(|t| t.name == name)\n            .ok_or_else(|| TypedefError::NotFound(name.to_string()))?;\n\n        load_typedef_from_file(\u0026info.path)\n    }\n\n    /// Load all type definitions.\n    pub fn load_all(\u0026self) -\u003e Result\u003cVec\u003cTypeDefinition\u003e, TypedefError\u003e {\n        let mut result = Vec::new();\n        for info in \u0026self.typedefs {\n            result.push(load_typedef_from_file(\u0026info.path)?);\n        }\n        Ok(result)\n    }\n}\n\n/// Load and parse a type definition from a Lua file.\npub fn load_typedef_from_file(path: \u0026Path) -\u003e Result\u003cTypeDefinition, TypedefError\u003e {\n    let source = fs::read_to_string(path)\n        .map_err(|e| TypedefError::Io { path: path.to_path_buf(), source: e })?;\n\n    let name = path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"unknown\").to_string();\n\n    parse_typedef(\u0026name, \u0026source, path)\n}\n\n/// Parse a type definition from Lua source.\nfn parse_typedef(\n    name: \u0026str,\n    source: \u0026str,\n    path: \u0026Path,\n) -\u003e Result\u003cTypeDefinition, TypedefError\u003e {\n    let engine = LuaEngine::sandboxed()\n        .map_err(|e| TypedefError::LuaParse { path: path.to_path_buf(), source: e })?;\n\n    let lua = engine.lua();\n\n    // Execute the Lua file - it should return a table\n    let value: mlua::Value =\n        lua.load(source).eval().map_err(|e| TypedefError::LuaParse {\n            path: path.to_path_buf(),\n            source: crate::scripting::ScriptingError::Lua(e),\n        })?;\n\n    let table = match value {\n        mlua::Value::Table(t) =\u003e t,\n        _ =\u003e {\n            return Err(TypedefError::InvalidDefinition {\n                path: path.to_path_buf(),\n                message: \"Type definition must return a table\".to_string(),\n            });\n        }\n    };\n\n    // Extract optional description\n    let description: Option\u003cString\u003e = table.get(\"description\").ok();\n\n    // Extract output path template\n    let output: Option\u003cString\u003e = table.get(\"output\").ok();\n\n    // Extract schema\n    let schema = extract_schema(\u0026table, path)?;\n\n    // Check for hook functions\n    let has_validate_fn = table.get::\u003cmlua::Function\u003e(\"validate\").is_ok();\n    let has_on_create_hook = table.get::\u003cmlua::Function\u003e(\"on_create\").is_ok();\n    let has_on_update_hook = table.get::\u003cmlua::Function\u003e(\"on_update\").is_ok();\n\n    // Check if this overrides a built-in\n    let is_builtin_override = BUILTIN_TYPES.contains(\u0026name);\n\n    Ok(TypeDefinition {\n        name: name.to_string(),\n        description,\n        source_path: path.to_path_buf(),\n        schema,\n        output,\n        has_validate_fn,\n        has_on_create_hook,\n        has_on_update_hook,\n        is_builtin_override,\n        lua_source: source.to_string(),\n    })\n}\n\n/// Extract schema from Lua table.\nfn extract_schema(\n    table: \u0026mlua::Table,\n    path: \u0026Path,\n) -\u003e Result\u003cHashMap\u003cString, FieldSchema\u003e, TypedefError\u003e {\n    let mut schema = HashMap::new();\n\n    let schema_table: mlua::Table = match table.get(\"schema\") {\n        Ok(t) =\u003e t,\n        Err(_) =\u003e return Ok(schema), // No schema defined is valid\n    };\n\n    for pair in schema_table.pairs::\u003cString, mlua::Table\u003e() {\n        let (field_name, field_def) = pair.map_err(|e| TypedefError::LuaParse {\n            path: path.to_path_buf(),\n            source: crate::scripting::ScriptingError::Lua(e),\n        })?;\n\n        let field_schema = parse_field_schema(\u0026field_def, \u0026field_name, path)?;\n        schema.insert(field_name, field_schema);\n    }\n\n    Ok(schema)\n}\n\n/// Parse a field schema from a Lua table.\nfn parse_field_schema(\n    table: \u0026mlua::Table,\n    field_name: \u0026str,\n    _path: \u0026Path,\n) -\u003e Result\u003cFieldSchema, TypedefError\u003e {\n    // Get field type\n    let field_type: Option\u003cFieldType\u003e =\n        table.get::\u003cString\u003e(\"type\").ok().and_then(|s| s.parse().ok());\n\n    // Get required flag\n    let required: bool = table.get(\"required\").unwrap_or(false);\n\n    // Get description\n    let description: Option\u003cString\u003e = table.get(\"description\").ok();\n\n    // Get default value (convert Lua value to serde_yaml::Value)\n    let default: Option\u003cserde_yaml::Value\u003e =\n        table.get::\u003cmlua::Value\u003e(\"default\").ok().and_then(|v| lua_to_yaml_value(\u0026v));\n\n    // Get enum values\n    let enum_values: Option\u003cVec\u003cString\u003e\u003e =\n        table.get::\u003cmlua::Table\u003e(\"enum\").ok().map(|t| {\n            t.pairs::\u003ci64, String\u003e().filter_map(|r| r.ok()).map(|(_, v)| v).collect()\n        });\n\n    // Get string constraints\n    let pattern: Option\u003cString\u003e = table.get(\"pattern\").ok();\n    let min_length: Option\u003cusize\u003e =\n        table.get::\u003ci64\u003e(\"min_length\").ok().map(|v| v as usize);\n    let max_length: Option\u003cusize\u003e =\n        table.get::\u003ci64\u003e(\"max_length\").ok().map(|v| v as usize);\n\n    // Get number constraints\n    let min: Option\u003cf64\u003e = table.get(\"min\").ok();\n    let max: Option\u003cf64\u003e = table.get(\"max\").ok();\n    let integer: Option\u003cbool\u003e = table.get(\"integer\").ok();\n\n    // Get list constraints\n    let min_items: Option\u003cusize\u003e = table.get::\u003ci64\u003e(\"min_items\").ok().map(|v| v as usize);\n    let max_items: Option\u003cusize\u003e = table.get::\u003ci64\u003e(\"max_items\").ok().map(|v| v as usize);\n\n    // Get nested items schema (for lists)\n    let items: Option\u003cBox\u003cFieldSchema\u003e\u003e = table\n        .get::\u003cmlua::Table\u003e(\"items\")\n        .ok()\n        .map(|t| parse_field_schema(\u0026t, \u0026format!(\"{}[]\", field_name), _path))\n        .transpose()?\n        .map(Box::new);\n\n    // Get reference constraint\n    let note_type: Option\u003cString\u003e = table.get(\"note_type\").ok();\n\n    // Get prompt text for interactive input\n    let prompt: Option\u003cString\u003e = table.get(\"prompt\").ok();\n\n    // Get core flag (whether this is a Rust-managed field)\n    let core: bool = table.get(\"core\").unwrap_or(false);\n\n    // Get multiline flag for string fields\n    let multiline: bool = table.get(\"multiline\").unwrap_or(false);\n\n    Ok(FieldSchema {\n        field_type,\n        required,\n        description,\n        default,\n        enum_values,\n        pattern,\n        min_length,\n        max_length,\n        min,\n        max,\n        integer,\n        items,\n        min_items,\n        max_items,\n        note_type,\n        prompt,\n        core,\n        multiline,\n    })\n}\n\n/// Convert a Lua value to a serde_yaml::Value.\n/// Returns None for Nil (missing values in Lua).\nfn lua_to_yaml_value(value: \u0026mlua::Value) -\u003e Option\u003cserde_yaml::Value\u003e {\n    match value {\n        mlua::Value::Nil =\u003e None, // Nil means \"no value\" in Lua\n        mlua::Value::Boolean(b) =\u003e Some(serde_yaml::Value::Bool(*b)),\n        mlua::Value::Integer(i) =\u003e Some(serde_yaml::Value::Number((*i).into())),\n        mlua::Value::Number(n) =\u003e {\n            // Convert float to integer if it's a whole number, otherwise use string representation\n            if n.fract() == 0.0 {\n                Some(serde_yaml::Value::Number((*n as i64).into()))\n            } else {\n                Some(serde_yaml::Value::String(n.to_string()))\n            }\n        }\n        mlua::Value::String(s) =\u003e {\n            s.to_str().ok().map(|s| serde_yaml::Value::String(s.to_string()))\n        }\n        _ =\u003e None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_discover_typedefs_empty_dir() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        let typedefs = discover_typedefs(\u0026types_dir).unwrap();\n        assert!(typedefs.is_empty());\n    }\n\n    #[test]\n    fn test_discover_typedefs_missing_dir() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"nonexistent\");\n\n        // Should return empty list, not error\n        let typedefs = discover_typedefs(\u0026types_dir).unwrap();\n        assert!(typedefs.is_empty());\n    }\n\n    #[test]\n    fn test_discover_typedefs() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        // Create some type definition files\n        fs::write(types_dir.join(\"meeting.lua\"), \"return { schema = {} }\").unwrap();\n        fs::write(types_dir.join(\"project.lua\"), \"return { schema = {} }\").unwrap();\n\n        // Create a non-lua file (should be ignored)\n        fs::write(types_dir.join(\"readme.md\"), \"# Types\").unwrap();\n\n        let typedefs = discover_typedefs(\u0026types_dir).unwrap();\n\n        assert_eq!(typedefs.len(), 2);\n        assert!(typedefs.iter().any(|t| t.name == \"meeting\"));\n        assert!(typedefs.iter().any(|t| t.name == \"project\"));\n    }\n\n    #[test]\n    fn test_load_simple_typedef() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        fs::write(\n            types_dir.join(\"meeting.lua\"),\n            r#\"\nreturn {\n    description = \"Meeting notes\",\n    schema = {\n        title = { type = \"string\", required = true },\n        date = { type = \"date\", required = true },\n        attendees = { type = \"list\" },\n    }\n}\n\"#,\n        )\n        .unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let typedef = repo.load_typedef(\"meeting\").unwrap();\n\n        assert_eq!(typedef.name, \"meeting\");\n        assert_eq!(typedef.description, Some(\"Meeting notes\".to_string()));\n        assert_eq!(typedef.schema.len(), 3);\n        assert!(typedef.schema.contains_key(\"title\"));\n        assert!(typedef.schema.get(\"title\").unwrap().required);\n        assert!(!typedef.has_validate_fn);\n        assert!(!typedef.has_on_create_hook);\n    }\n\n    #[test]\n    fn test_load_typedef_with_hooks() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        fs::write(\n            types_dir.join(\"task.lua\"),\n            r#\"\nreturn {\n    schema = {\n        status = { type = \"string\", enum = { \"open\", \"done\" } },\n    },\n    validate = function(note)\n        return true\n    end,\n    on_create = function(note)\n        return note\n    end,\n    on_update = function(note, previous)\n        return note\n    end\n}\n\"#,\n        )\n        .unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let typedef = repo.load_typedef(\"task\").unwrap();\n\n        assert!(typedef.has_validate_fn);\n        assert!(typedef.has_on_create_hook);\n        assert!(typedef.has_on_update_hook);\n        assert!(typedef.is_builtin_override); // \"task\" is a built-in\n    }\n\n    #[test]\n    fn test_load_typedef_with_enum() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        fs::write(\n            types_dir.join(\"status.lua\"),\n            r#\"\nreturn {\n    schema = {\n        priority = {\n            type = \"string\",\n            enum = { \"low\", \"medium\", \"high\" },\n            default = \"medium\"\n        },\n    }\n}\n\"#,\n        )\n        .unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let typedef = repo.load_typedef(\"status\").unwrap();\n\n        let priority = typedef.schema.get(\"priority\").unwrap();\n        assert_eq!(\n            priority.enum_values,\n            Some(vec![\"low\".to_string(), \"medium\".to_string(), \"high\".to_string()])\n        );\n        assert_eq!(\n            priority.default,\n            Some(serde_yaml::Value::String(\"medium\".to_string()))\n        );\n    }\n\n    #[test]\n    fn test_load_typedef_with_number_constraints() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        fs::write(\n            types_dir.join(\"meeting.lua\"),\n            r#\"\nreturn {\n    schema = {\n        duration_minutes = {\n            type = \"number\",\n            min = 1,\n            max = 480,\n            integer = true\n        },\n    }\n}\n\"#,\n        )\n        .unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let typedef = repo.load_typedef(\"meeting\").unwrap();\n\n        let duration = typedef.schema.get(\"duration_minutes\").unwrap();\n        assert_eq!(duration.min, Some(1.0));\n        assert_eq!(duration.max, Some(480.0));\n        assert_eq!(duration.integer, Some(true));\n    }\n\n    #[test]\n    fn test_typedef_not_found() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let result = repo.load_typedef(\"nonexistent\");\n\n        assert!(matches!(result, Err(TypedefError::NotFound(_))));\n    }\n\n    #[test]\n    fn test_invalid_typedef_not_table() {\n        let temp = TempDir::new().unwrap();\n        let types_dir = temp.path().join(\"types\");\n        fs::create_dir_all(\u0026types_dir).unwrap();\n\n        fs::write(types_dir.join(\"invalid.lua\"), r#\"return \"not a table\"\"#).unwrap();\n\n        let repo = TypedefRepository::new(\u0026types_dir).unwrap();\n        let result = repo.load_typedef(\"invalid\");\n\n        assert!(matches!(result, Err(TypedefError::InvalidDefinition { .. })));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":13}},{"line":23,"address":[],"length":0,"stats":{"Line":13}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":27,"address":[],"length":0,"stats":{"Line":24}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":31,"address":[],"length":0,"stats":{"Line":24}},{"line":34,"address":[],"length":0,"stats":{"Line":72}},{"line":35,"address":[],"length":0,"stats":{"Line":36}},{"line":36,"address":[],"length":0,"stats":{"Line":72}},{"line":38,"address":[],"length":0,"stats":{"Line":108}},{"line":39,"address":[],"length":0,"stats":{"Line":36}},{"line":40,"address":[],"length":0,"stats":{"Line":12}},{"line":42,"address":[],"length":0,"stats":{"Line":24}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":207}},{"line":48,"address":[],"length":0,"stats":{"Line":46}},{"line":49,"address":[],"length":0,"stats":{"Line":115}},{"line":53,"address":[],"length":0,"stats":{"Line":99}},{"line":54,"address":[],"length":0,"stats":{"Line":12}},{"line":57,"address":[],"length":0,"stats":{"Line":24}},{"line":58,"address":[],"length":0,"stats":{"Line":144}},{"line":73,"address":[],"length":0,"stats":{"Line":10}},{"line":74,"address":[],"length":0,"stats":{"Line":30}},{"line":75,"address":[],"length":0,"stats":{"Line":20}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":22}},{"line":90,"address":[],"length":0,"stats":{"Line":43}},{"line":91,"address":[],"length":0,"stats":{"Line":22}},{"line":93,"address":[],"length":0,"stats":{"Line":112}},{"line":94,"address":[],"length":0,"stats":{"Line":25}},{"line":96,"address":[],"length":0,"stats":{"Line":42}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":21}},{"line":111,"address":[],"length":0,"stats":{"Line":63}},{"line":112,"address":[],"length":0,"stats":{"Line":21}},{"line":114,"address":[],"length":0,"stats":{"Line":189}},{"line":116,"address":[],"length":0,"stats":{"Line":84}},{"line":120,"address":[],"length":0,"stats":{"Line":21}},{"line":125,"address":[],"length":0,"stats":{"Line":42}},{"line":126,"address":[],"length":0,"stats":{"Line":21}},{"line":128,"address":[],"length":0,"stats":{"Line":63}},{"line":131,"address":[],"length":0,"stats":{"Line":42}},{"line":132,"address":[],"length":0,"stats":{"Line":105}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":41}},{"line":138,"address":[],"length":0,"stats":{"Line":40}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":100}},{"line":151,"address":[],"length":0,"stats":{"Line":100}},{"line":154,"address":[],"length":0,"stats":{"Line":80}},{"line":157,"address":[],"length":0,"stats":{"Line":60}},{"line":158,"address":[],"length":0,"stats":{"Line":60}},{"line":159,"address":[],"length":0,"stats":{"Line":60}},{"line":162,"address":[],"length":0,"stats":{"Line":80}},{"line":164,"address":[],"length":0,"stats":{"Line":20}},{"line":165,"address":[],"length":0,"stats":{"Line":60}},{"line":166,"address":[],"length":0,"stats":{"Line":40}},{"line":167,"address":[],"length":0,"stats":{"Line":60}},{"line":168,"address":[],"length":0,"stats":{"Line":40}},{"line":169,"address":[],"length":0,"stats":{"Line":40}},{"line":170,"address":[],"length":0,"stats":{"Line":40}},{"line":171,"address":[],"length":0,"stats":{"Line":40}},{"line":172,"address":[],"length":0,"stats":{"Line":40}},{"line":173,"address":[],"length":0,"stats":{"Line":40}},{"line":174,"address":[],"length":0,"stats":{"Line":20}},{"line":179,"address":[],"length":0,"stats":{"Line":20}},{"line":183,"address":[],"length":0,"stats":{"Line":40}},{"line":185,"address":[],"length":0,"stats":{"Line":60}},{"line":186,"address":[],"length":0,"stats":{"Line":40}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":130}},{"line":191,"address":[],"length":0,"stats":{"Line":360}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":450}},{"line":197,"address":[],"length":0,"stats":{"Line":360}},{"line":200,"address":[],"length":0,"stats":{"Line":20}},{"line":204,"address":[],"length":0,"stats":{"Line":90}},{"line":210,"address":[],"length":0,"stats":{"Line":180}},{"line":211,"address":[],"length":0,"stats":{"Line":540}},{"line":214,"address":[],"length":0,"stats":{"Line":450}},{"line":217,"address":[],"length":0,"stats":{"Line":450}},{"line":220,"address":[],"length":0,"stats":{"Line":180}},{"line":221,"address":[],"length":0,"stats":{"Line":540}},{"line":224,"address":[],"length":0,"stats":{"Line":180}},{"line":225,"address":[],"length":0,"stats":{"Line":370}},{"line":226,"address":[],"length":0,"stats":{"Line":140}},{"line":230,"address":[],"length":0,"stats":{"Line":450}},{"line":231,"address":[],"length":0,"stats":{"Line":180}},{"line":232,"address":[],"length":0,"stats":{"Line":360}},{"line":233,"address":[],"length":0,"stats":{"Line":180}},{"line":234,"address":[],"length":0,"stats":{"Line":360}},{"line":237,"address":[],"length":0,"stats":{"Line":450}},{"line":238,"address":[],"length":0,"stats":{"Line":450}},{"line":239,"address":[],"length":0,"stats":{"Line":450}},{"line":242,"address":[],"length":0,"stats":{"Line":540}},{"line":243,"address":[],"length":0,"stats":{"Line":540}},{"line":246,"address":[],"length":0,"stats":{"Line":270}},{"line":249,"address":[],"length":0,"stats":{"Line":90}},{"line":251,"address":[],"length":0,"stats":{"Line":90}},{"line":254,"address":[],"length":0,"stats":{"Line":450}},{"line":257,"address":[],"length":0,"stats":{"Line":450}},{"line":260,"address":[],"length":0,"stats":{"Line":450}},{"line":263,"address":[],"length":0,"stats":{"Line":450}},{"line":265,"address":[],"length":0,"stats":{"Line":90}},{"line":266,"address":[],"length":0,"stats":{"Line":180}},{"line":267,"address":[],"length":0,"stats":{"Line":180}},{"line":268,"address":[],"length":0,"stats":{"Line":180}},{"line":269,"address":[],"length":0,"stats":{"Line":180}},{"line":270,"address":[],"length":0,"stats":{"Line":180}},{"line":271,"address":[],"length":0,"stats":{"Line":180}},{"line":272,"address":[],"length":0,"stats":{"Line":180}},{"line":273,"address":[],"length":0,"stats":{"Line":180}},{"line":274,"address":[],"length":0,"stats":{"Line":180}},{"line":275,"address":[],"length":0,"stats":{"Line":180}},{"line":276,"address":[],"length":0,"stats":{"Line":180}},{"line":277,"address":[],"length":0,"stats":{"Line":180}},{"line":278,"address":[],"length":0,"stats":{"Line":180}},{"line":279,"address":[],"length":0,"stats":{"Line":180}},{"line":280,"address":[],"length":0,"stats":{"Line":180}},{"line":281,"address":[],"length":0,"stats":{"Line":180}},{"line":282,"address":[],"length":0,"stats":{"Line":90}},{"line":283,"address":[],"length":0,"stats":{"Line":90}},{"line":289,"address":[],"length":0,"stats":{"Line":90}},{"line":290,"address":[],"length":0,"stats":{"Line":90}},{"line":291,"address":[],"length":0,"stats":{"Line":21}},{"line":292,"address":[],"length":0,"stats":{"Line":32}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":53}},{"line":303,"address":[],"length":0,"stats":{"Line":318}},{"line":305,"address":[],"length":0,"stats":{"Line":0}}],"covered":127,"coverable":145},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","errors.rs"],"content":"//! Error types for type definitions and validation.\n\nuse std::path::PathBuf;\nuse thiserror::Error;\n\n/// Errors that can occur when loading type definitions.\n#[derive(Debug, Error)]\npub enum TypedefError {\n    /// Type definitions directory does not exist.\n    #[error(\"type definitions directory does not exist: {0}\")]\n    MissingDir(String),\n\n    /// Error walking the type definitions directory.\n    #[error(\"failed to read types directory {0}: {1}\")]\n    WalkError(String, #[source] walkdir::Error),\n\n    /// Error reading a type definition file.\n    #[error(\"failed to read type definition file {path}: {source}\")]\n    Io {\n        path: PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n\n    /// Error parsing a Lua type definition.\n    #[error(\"failed to parse type definition {path}: {source}\")]\n    LuaParse {\n        path: PathBuf,\n        #[source]\n        source: crate::scripting::ScriptingError,\n    },\n\n    /// Invalid type definition structure.\n    #[error(\"invalid type definition in {path}: {message}\")]\n    InvalidDefinition { path: PathBuf, message: String },\n\n    /// Type not found.\n    #[error(\"type not found: {0}\")]\n    NotFound(String),\n\n    /// Duplicate type definition.\n    #[error(\"duplicate type definition: {0}\")]\n    Duplicate(String),\n}\n\n/// Errors that occur during note validation.\n#[derive(Debug, Clone, Error)]\npub enum ValidationError {\n    /// A required field is missing.\n    #[error(\"missing required field: {field}\")]\n    MissingRequired { field: String },\n\n    /// Field value has wrong type.\n    #[error(\"invalid type for field '{field}': expected {expected}, got {actual}\")]\n    TypeMismatch { field: String, expected: String, actual: String },\n\n    /// Field value is invalid.\n    #[error(\"invalid value for field '{field}': {message}\")]\n    InvalidValue { field: String, message: String },\n\n    /// Enum constraint violated.\n    #[error(\"enum constraint violated for '{field}': '{value}' not in {allowed:?}\")]\n    EnumViolation { field: String, value: String, allowed: Vec\u003cString\u003e },\n\n    /// Custom validation function failed.\n    #[error(\"custom validation failed: {message}\")]\n    CustomValidation { message: String },\n\n    /// Lua execution error during validation.\n    #[error(\"Lua error during validation: {0}\")]\n    LuaError(String),\n}\n\n/// Result of validating a note against its type definition.\n#[derive(Debug, Clone, Default)]\npub struct ValidationResult {\n    /// Whether the note is valid.\n    pub valid: bool,\n    /// Validation errors (empty if valid).\n    pub errors: Vec\u003cValidationError\u003e,\n    /// Non-fatal warnings.\n    pub warnings: Vec\u003cString\u003e,\n}\n\nimpl ValidationResult {\n    /// Create a successful validation result.\n    pub fn success() -\u003e Self {\n        Self { valid: true, errors: vec![], warnings: vec![] }\n    }\n\n    /// Create a failed validation result.\n    pub fn failure(errors: Vec\u003cValidationError\u003e) -\u003e Self {\n        Self { valid: false, errors, warnings: vec![] }\n    }\n\n    /// Create a failed validation result with a single error.\n    pub fn single_error(error: ValidationError) -\u003e Self {\n        Self::failure(vec![error])\n    }\n\n    /// Add an error to the result.\n    pub fn add_error(\u0026mut self, error: ValidationError) {\n        self.errors.push(error);\n        self.valid = false;\n    }\n\n    /// Add a warning to the result.\n    pub fn add_warning(\u0026mut self, warning: String) {\n        self.warnings.push(warning);\n    }\n\n    /// Merge another validation result into this one.\n    pub fn merge(\u0026mut self, other: ValidationResult) {\n        self.errors.extend(other.errors);\n        self.warnings.extend(other.warnings);\n        if !other.valid {\n            self.valid = false;\n        }\n    }\n}\n","traces":[{"line":87,"address":[],"length":0,"stats":{"Line":45}},{"line":88,"address":[],"length":0,"stats":{"Line":45}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":9}},{"line":103,"address":[],"length":0,"stats":{"Line":27}},{"line":104,"address":[],"length":0,"stats":{"Line":9}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":29}},{"line":114,"address":[],"length":0,"stats":{"Line":87}},{"line":115,"address":[],"length":0,"stats":{"Line":87}},{"line":116,"address":[],"length":0,"stats":{"Line":46}},{"line":117,"address":[],"length":0,"stats":{"Line":17}}],"covered":10,"coverable":16},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","mod.rs"],"content":"//! Lua-based type definitions for note validation.\n//!\n//! This module provides a system for defining custom note types with:\n//! - Field schemas (required fields, types, constraints)\n//! - Custom validation functions\n//! - Lifecycle hooks (on_create, on_update)\n//!\n//! Type definitions are loaded from Lua files in `~/.config/mdvault/types/`.\n//!\n//! # Example Type Definition\n//!\n//! ```lua\n//! -- ~/.config/mdvault/types/meeting.lua\n//! return {\n//!     name = \"meeting\",\n//!     description = \"Meeting notes with attendees\",\n//!\n//!     schema = {\n//!         attendees = { type = \"list\", required = true },\n//!         status = { type = \"string\", enum = { \"scheduled\", \"completed\" } },\n//!     },\n//!\n//!     validate = function(note)\n//!         if note.frontmatter.status == \"completed\" and not note.frontmatter.summary then\n//!             return false, \"Completed meetings must have a summary\"\n//!         end\n//!         return true\n//!     end,\n//! }\n//! ```\n\npub mod autofix;\npub mod definition;\npub mod discovery;\npub mod errors;\npub mod registry;\npub mod scaffolding;\npub mod schema;\npub mod validation;\n\n// Re-export commonly used types\npub use autofix::{FixResult, apply_fixes, try_fix_note};\npub use definition::{TypeDefinition, TypedefInfo};\npub use discovery::TypedefRepository;\npub use errors::{TypedefError, ValidationError, ValidationResult};\npub use registry::TypeRegistry;\npub use scaffolding::{\n    default_output_path, generate_scaffolding, get_missing_required_fields,\n};\npub use schema::{FieldSchema, FieldType};\npub use validation::{\n    BrokenLink, LinkIntegrityResult, add_link_integrity_warnings, check_link_integrity,\n    validate_note,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","registry.rs"],"content":"//! Type registry for managing note type definitions.\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse super::definition::TypeDefinition;\nuse super::discovery::TypedefRepository;\nuse super::errors::TypedefError;\nuse crate::index::types::NoteType;\n\n/// Registry of all known note types (built-in + custom).\n///\n/// The registry maintains:\n/// - Custom type definitions loaded from Lua files\n/// - Overrides for built-in types (when a Lua file matches a built-in name)\n#[derive(Debug, Default)]\npub struct TypeRegistry {\n    /// Custom type definitions loaded from Lua.\n    custom_types: HashMap\u003cString, Arc\u003cTypeDefinition\u003e\u003e,\n\n    /// Built-in type overrides (Lua files that extend built-in types).\n    builtin_overrides: HashMap\u003cNoteType, Arc\u003cTypeDefinition\u003e\u003e,\n}\n\nimpl TypeRegistry {\n    /// Create an empty registry.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Create a registry from a TypedefRepository.\n    pub fn from_repository(repo: \u0026TypedefRepository) -\u003e Result\u003cSelf, TypedefError\u003e {\n        let mut registry = Self::new();\n\n        for info in repo.list_all() {\n            let typedef = repo.load_typedef(\u0026info.name)?;\n            registry.register(typedef)?;\n        }\n\n        Ok(registry)\n    }\n\n    /// Register a type definition.\n    pub fn register(\u0026mut self, typedef: TypeDefinition) -\u003e Result\u003c(), TypedefError\u003e {\n        let name = typedef.name.clone();\n        let typedef = Arc::new(typedef);\n\n        // Check if it's a built-in type override\n        if let Some(builtin) = Self::parse_builtin(\u0026name) {\n            self.builtin_overrides.insert(builtin, typedef);\n            return Ok(());\n        }\n\n        // Otherwise, register as custom type\n        if self.custom_types.contains_key(\u0026name) {\n            return Err(TypedefError::Duplicate(name));\n        }\n        self.custom_types.insert(name, typedef);\n        Ok(())\n    }\n\n    /// Get a type definition by name.\n    ///\n    /// Returns custom types and built-in overrides.\n    pub fn get(\u0026self, name: \u0026str) -\u003e Option\u003cArc\u003cTypeDefinition\u003e\u003e {\n        // First check custom types\n        if let Some(td) = self.custom_types.get(name) {\n            return Some(Arc::clone(td));\n        }\n\n        // Then check built-in overrides\n        Self::parse_builtin(name)\n            .and_then(|builtin| self.builtin_overrides.get(\u0026builtin).cloned())\n    }\n\n    /// Get override for a built-in type (if any).\n    pub fn get_builtin_override(\n        \u0026self,\n        note_type: NoteType,\n    ) -\u003e Option\u003cArc\u003cTypeDefinition\u003e\u003e {\n        self.builtin_overrides.get(\u0026note_type).cloned()\n    }\n\n    /// Check if a type name is known (built-in or custom).\n    pub fn is_known_type(\u0026self, name: \u0026str) -\u003e bool {\n        // Check custom types\n        if self.custom_types.contains_key(name) {\n            return true;\n        }\n\n        // Check if it's a valid built-in type\n        Self::parse_builtin(name).is_some()\n    }\n\n    /// Check if there's a definition for a type (custom or override).\n    pub fn has_definition(\u0026self, name: \u0026str) -\u003e bool {\n        self.get(name).is_some()\n    }\n\n    /// List all custom type names.\n    pub fn list_custom_types(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        self.custom_types.keys().map(|s| s.as_str()).collect()\n    }\n\n    /// List all overridden built-in types.\n    pub fn list_overridden_builtins(\u0026self) -\u003e Vec\u003cNoteType\u003e {\n        self.builtin_overrides.keys().copied().collect()\n    }\n\n    /// List all types (built-in names + custom names).\n    pub fn list_all_types(\u0026self) -\u003e Vec\u003cString\u003e {\n        let mut types: Vec\u003cString\u003e = vec![\n            \"daily\".to_string(),\n            \"weekly\".to_string(),\n            \"task\".to_string(),\n            \"project\".to_string(),\n            \"zettel\".to_string(),\n        ];\n        types.extend(self.custom_types.keys().cloned());\n        types.sort();\n        types.dedup();\n        types\n    }\n\n    /// Get the number of custom types registered.\n    pub fn custom_type_count(\u0026self) -\u003e usize {\n        self.custom_types.len()\n    }\n\n    /// Get the number of builtin overrides registered.\n    pub fn override_count(\u0026self) -\u003e usize {\n        self.builtin_overrides.len()\n    }\n\n    /// Parse a type name to a built-in NoteType, excluding None.\n    fn parse_builtin(name: \u0026str) -\u003e Option\u003cNoteType\u003e {\n        match name.to_lowercase().as_str() {\n            \"daily\" =\u003e Some(NoteType::Daily),\n            \"weekly\" =\u003e Some(NoteType::Weekly),\n            \"task\" =\u003e Some(NoteType::Task),\n            \"project\" =\u003e Some(NoteType::Project),\n            \"zettel\" | \"knowledge\" =\u003e Some(NoteType::Zettel),\n            _ =\u003e None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::schema::{FieldSchema, FieldType};\n\n    fn make_typedef(name: \u0026str) -\u003e TypeDefinition {\n        TypeDefinition::empty(name)\n    }\n\n    #[test]\n    fn test_empty_registry() {\n        let registry = TypeRegistry::new();\n        assert_eq!(registry.custom_type_count(), 0);\n        assert_eq!(registry.override_count(), 0);\n        assert!(!registry.has_definition(\"anything\"));\n    }\n\n    #[test]\n    fn test_register_custom_type() {\n        let mut registry = TypeRegistry::new();\n        let typedef = make_typedef(\"meeting\");\n\n        registry.register(typedef).unwrap();\n\n        assert_eq!(registry.custom_type_count(), 1);\n        assert!(registry.has_definition(\"meeting\"));\n        assert!(registry.is_known_type(\"meeting\"));\n    }\n\n    #[test]\n    fn test_register_builtin_override() {\n        let mut registry = TypeRegistry::new();\n        let typedef = make_typedef(\"task\");\n\n        registry.register(typedef).unwrap();\n\n        // Should be an override, not a custom type\n        assert_eq!(registry.custom_type_count(), 0);\n        assert_eq!(registry.override_count(), 1);\n        assert!(registry.has_definition(\"task\"));\n        assert!(registry.get_builtin_override(NoteType::Task).is_some());\n    }\n\n    #[test]\n    fn test_duplicate_custom_type() {\n        let mut registry = TypeRegistry::new();\n        registry.register(make_typedef(\"meeting\")).unwrap();\n\n        let result = registry.register(make_typedef(\"meeting\"));\n        assert!(matches!(result, Err(TypedefError::Duplicate(_))));\n    }\n\n    #[test]\n    fn test_builtin_override_replaces() {\n        let mut registry = TypeRegistry::new();\n\n        let mut first = make_typedef(\"task\");\n        first.description = Some(\"First\".to_string());\n        registry.register(first).unwrap();\n\n        let mut second = make_typedef(\"task\");\n        second.description = Some(\"Second\".to_string());\n        registry.register(second).unwrap();\n\n        // Second should replace first (no duplicate error for overrides)\n        let td = registry.get(\"task\").unwrap();\n        assert_eq!(td.description, Some(\"Second\".to_string()));\n    }\n\n    #[test]\n    fn test_is_known_type() {\n        let registry = TypeRegistry::new();\n\n        // Built-ins are always known\n        assert!(registry.is_known_type(\"daily\"));\n        assert!(registry.is_known_type(\"weekly\"));\n        assert!(registry.is_known_type(\"task\"));\n        assert!(registry.is_known_type(\"project\"));\n        assert!(registry.is_known_type(\"zettel\"));\n\n        // Unknown types\n        assert!(!registry.is_known_type(\"meeting\"));\n        assert!(!registry.is_known_type(\"custom\"));\n    }\n\n    #[test]\n    fn test_list_all_types() {\n        let mut registry = TypeRegistry::new();\n        registry.register(make_typedef(\"meeting\")).unwrap();\n        registry.register(make_typedef(\"agenda\")).unwrap();\n\n        let types = registry.list_all_types();\n\n        // Should include all built-ins and custom types\n        assert!(types.contains(\u0026\"daily\".to_string()));\n        assert!(types.contains(\u0026\"task\".to_string()));\n        assert!(types.contains(\u0026\"meeting\".to_string()));\n        assert!(types.contains(\u0026\"agenda\".to_string()));\n    }\n\n    #[test]\n    fn test_list_custom_types() {\n        let mut registry = TypeRegistry::new();\n        registry.register(make_typedef(\"meeting\")).unwrap();\n        registry.register(make_typedef(\"task\")).unwrap(); // Override\n\n        let custom = registry.list_custom_types();\n\n        assert_eq!(custom.len(), 1);\n        assert!(custom.contains(\u0026\"meeting\"));\n    }\n\n    #[test]\n    fn test_get_with_schema() {\n        let mut registry = TypeRegistry::new();\n\n        let mut typedef = make_typedef(\"meeting\");\n        typedef.schema.insert(\n            \"attendees\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::List),\n                required: true,\n                ..Default::default()\n            },\n        );\n\n        registry.register(typedef).unwrap();\n\n        let td = registry.get(\"meeting\").unwrap();\n        assert!(td.schema.contains_key(\"attendees\"));\n        assert!(td.schema.get(\"attendees\").unwrap().required);\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":25}},{"line":28,"address":[],"length":0,"stats":{"Line":25}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":8}},{"line":35,"address":[],"length":0,"stats":{"Line":24}},{"line":36,"address":[],"length":0,"stats":{"Line":64}},{"line":37,"address":[],"length":0,"stats":{"Line":48}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":38}},{"line":45,"address":[],"length":0,"stats":{"Line":114}},{"line":46,"address":[],"length":0,"stats":{"Line":114}},{"line":49,"address":[],"length":0,"stats":{"Line":61}},{"line":50,"address":[],"length":0,"stats":{"Line":92}},{"line":51,"address":[],"length":0,"stats":{"Line":23}},{"line":55,"address":[],"length":0,"stats":{"Line":45}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":56}},{"line":59,"address":[],"length":0,"stats":{"Line":14}},{"line":65,"address":[],"length":0,"stats":{"Line":24}},{"line":67,"address":[],"length":0,"stats":{"Line":65}},{"line":68,"address":[],"length":0,"stats":{"Line":17}},{"line":72,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":27}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":24}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":14}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":9}},{"line":101,"address":[],"length":0,"stats":{"Line":5}},{"line":102,"address":[],"length":0,"stats":{"Line":22}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":5}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":52}},{"line":137,"address":[],"length":0,"stats":{"Line":52}},{"line":138,"address":[],"length":0,"stats":{"Line":57}},{"line":139,"address":[],"length":0,"stats":{"Line":52}},{"line":140,"address":[],"length":0,"stats":{"Line":59}},{"line":141,"address":[],"length":0,"stats":{"Line":30}},{"line":142,"address":[],"length":0,"stats":{"Line":40}},{"line":143,"address":[],"length":0,"stats":{"Line":19}}],"covered":56,"coverable":58},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","scaffolding.rs"],"content":"//! Scaffolding generation for note creation.\n//!\n//! This module provides functions to generate note content based on type schemas.\n\nuse std::collections::HashMap;\n\nuse chrono::Local;\n\nuse super::definition::TypeDefinition;\nuse super::schema::FieldType;\n\n/// Generate scaffolding content for a new note.\n///\n/// Creates frontmatter with:\n/// - `type` field set to the type name\n/// - `title` field if provided\n/// - `created` field with current date\n/// - Fields from schema with provided values or defaults\n///\n/// # Arguments\n///\n/// * `type_name` - The note type (e.g., \"task\", \"project\")\n/// * `typedef` - Optional type definition with schema\n/// * `title` - The note title\n/// * `vars` - User-provided field values\n///\n/// # Returns\n///\n/// The complete note content with frontmatter and body.\npub fn generate_scaffolding(\n    type_name: \u0026str,\n    typedef: Option\u003c\u0026TypeDefinition\u003e,\n    title: \u0026str,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e String {\n    let mut frontmatter = serde_yaml::Mapping::new();\n\n    // Always include type\n    frontmatter.insert(\n        serde_yaml::Value::String(\"type\".to_string()),\n        serde_yaml::Value::String(type_name.to_string()),\n    );\n\n    // Always include title\n    frontmatter.insert(\n        serde_yaml::Value::String(\"title\".to_string()),\n        serde_yaml::Value::String(title.to_string()),\n    );\n\n    // Add fields from schema\n    if let Some(td) = typedef {\n        for (field, schema) in \u0026td.schema {\n            // Skip if already set (type, title)\n            if field == \"type\" || field == \"title\" {\n                continue;\n            }\n\n            let value = if let Some(v) = vars.get(field) {\n                // User provided value\n                Some(string_to_yaml_value(v, schema.field_type))\n            } else {\n                // Schema default\n                schema.default.clone()\n            };\n\n            if let Some(v) = value {\n                frontmatter.insert(serde_yaml::Value::String(field.clone()), v);\n            }\n        }\n    }\n\n    // Add any extra vars not in schema\n    for (key, value) in vars {\n        if key == \"type\" || key == \"title\" {\n            continue;\n        }\n        // Only add if not already in frontmatter\n        let key_value = serde_yaml::Value::String(key.clone());\n        if !frontmatter.contains_key(\u0026key_value) {\n            frontmatter.insert(key_value, serde_yaml::Value::String(value.clone()));\n        }\n    }\n\n    // Add created date\n    let today = Local::now().format(\"%Y-%m-%d\").to_string();\n    frontmatter.insert(\n        serde_yaml::Value::String(\"created\".to_string()),\n        serde_yaml::Value::String(today),\n    );\n\n    // Serialize frontmatter\n    let yaml = serde_yaml::to_string(\u0026frontmatter).unwrap_or_default();\n\n    format!(\"---\\n{}---\\n\\n# {}\\n\\n\", yaml, title)\n}\n\n/// Convert a string value to appropriate YAML type based on field type.\nfn string_to_yaml_value(s: \u0026str, field_type: Option\u003cFieldType\u003e) -\u003e serde_yaml::Value {\n    match field_type {\n        Some(FieldType::Number) =\u003e {\n            if let Ok(n) = s.parse::\u003ci64\u003e() {\n                serde_yaml::Value::Number(n.into())\n            } else if let Ok(n) = s.parse::\u003cf64\u003e() {\n                serde_yaml::Value::Number(serde_yaml::Number::from(n))\n            } else {\n                serde_yaml::Value::String(s.to_string())\n            }\n        }\n        Some(FieldType::Boolean) =\u003e {\n            serde_yaml::Value::Bool(s.eq_ignore_ascii_case(\"true\") || s == \"1\")\n        }\n        Some(FieldType::List) =\u003e {\n            // Parse comma-separated values\n            let items: Vec\u003cserde_yaml::Value\u003e = s\n                .split(',')\n                .map(|item| serde_yaml::Value::String(item.trim().to_string()))\n                .collect();\n            serde_yaml::Value::Sequence(items)\n        }\n        _ =\u003e serde_yaml::Value::String(s.to_string()),\n    }\n}\n\n/// Get required fields that are missing from the provided vars.\n///\n/// Returns a list of (field_name, field_schema) for fields that:\n/// - Are marked as required in the schema\n/// - Have no default value\n/// - Are not provided in vars\npub fn get_missing_required_fields\u003c'a\u003e(\n    typedef: \u0026'a TypeDefinition,\n    vars: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Vec\u003c(\u0026'a String, \u0026'a super::schema::FieldSchema)\u003e {\n    typedef\n        .schema\n        .iter()\n        .filter(|(field, schema)| {\n            schema.required\n                \u0026\u0026 schema.default.is_none()\n                \u0026\u0026 !vars.contains_key(*field)\n                \u0026\u0026 *field != \"title\"\n                \u0026\u0026 *field != \"type\"\n        })\n        .collect()\n}\n\n/// Generate default output path for a note.\n///\n/// Pattern: `\u003ctype\u003es/\u003ctitle-slugified\u003e.md`\n/// Examples:\n/// - task, \"Fix bug\" -\u003e \"tasks/fix-bug.md\"\n/// - project, \"My Project\" -\u003e \"projects/my-project.md\"\npub fn default_output_path(type_name: \u0026str, title: \u0026str) -\u003e String {\n    let slug = slugify(title);\n    format!(\"{}s/{}.md\", type_name, slug)\n}\n\n/// Convert a string to a URL-friendly slug.\nfn slugify(s: \u0026str) -\u003e String {\n    let mut result = String::with_capacity(s.len());\n\n    for c in s.chars() {\n        if c.is_ascii_alphanumeric() {\n            result.push(c.to_ascii_lowercase());\n        } else if (c == ' ' || c == '_' || c == '-') \u0026\u0026 !result.ends_with('-') {\n            result.push('-');\n        }\n    }\n\n    result.trim_matches('-').to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_generate_scaffolding_minimal() {\n        let content = generate_scaffolding(\"task\", None, \"My Task\", \u0026HashMap::new());\n\n        assert!(content.contains(\"type: task\"));\n        assert!(content.contains(\"title: My Task\"));\n        assert!(content.contains(\"# My Task\"));\n        assert!(content.contains(\"created:\"));\n    }\n\n    #[test]\n    fn test_generate_scaffolding_with_vars() {\n        let mut vars = HashMap::new();\n        vars.insert(\"status\".to_string(), \"open\".to_string());\n        vars.insert(\"project\".to_string(), \"myproject\".to_string());\n\n        let content = generate_scaffolding(\"task\", None, \"My Task\", \u0026vars);\n\n        assert!(content.contains(\"status: open\"));\n        assert!(content.contains(\"project: myproject\"));\n    }\n\n    #[test]\n    fn test_default_output_path() {\n        assert_eq!(default_output_path(\"task\", \"Fix bug\"), \"tasks/fix-bug.md\");\n        assert_eq!(\n            default_output_path(\"project\", \"My New Project\"),\n            \"projects/my-new-project.md\"\n        );\n        assert_eq!(\n            default_output_path(\"zettel\", \"Random Thought!\"),\n            \"zettels/random-thought.md\"\n        );\n    }\n\n    #[test]\n    fn test_slugify() {\n        assert_eq!(slugify(\"Hello World\"), \"hello-world\");\n        assert_eq!(slugify(\"My Task: Do Something!\"), \"my-task-do-something\");\n        assert_eq!(slugify(\"  spaced  out  \"), \"spaced-out\");\n    }\n\n    #[test]\n    fn test_string_to_yaml_value_number() {\n        let v = string_to_yaml_value(\"42\", Some(FieldType::Number));\n        assert_eq!(v, serde_yaml::Value::Number(42.into()));\n    }\n\n    #[test]\n    fn test_string_to_yaml_value_boolean() {\n        let v = string_to_yaml_value(\"true\", Some(FieldType::Boolean));\n        assert_eq!(v, serde_yaml::Value::Bool(true));\n\n        let v = string_to_yaml_value(\"false\", Some(FieldType::Boolean));\n        assert_eq!(v, serde_yaml::Value::Bool(false));\n    }\n\n    #[test]\n    fn test_string_to_yaml_value_list() {\n        let v = string_to_yaml_value(\"a, b, c\", Some(FieldType::List));\n        if let serde_yaml::Value::Sequence(items) = v {\n            assert_eq!(items.len(), 3);\n            assert_eq!(items[0], serde_yaml::Value::String(\"a\".to_string()));\n            assert_eq!(items[1], serde_yaml::Value::String(\"b\".to_string()));\n            assert_eq!(items[2], serde_yaml::Value::String(\"c\".to_string()));\n        } else {\n            panic!(\"Expected sequence\");\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":8}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":7}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":7}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":9}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":159,"address":[],"length":0,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":24}},{"line":162,"address":[],"length":0,"stats":{"Line":96}},{"line":163,"address":[],"length":0,"stats":{"Line":235}},{"line":164,"address":[],"length":0,"stats":{"Line":201}},{"line":165,"address":[],"length":0,"stats":{"Line":115}},{"line":166,"address":[],"length":0,"stats":{"Line":11}},{"line":170,"address":[],"length":0,"stats":{"Line":12}}],"covered":39,"coverable":61},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","schema.rs"],"content":"//! Field type and schema definitions for type definitions.\n\nuse serde::{Deserialize, Serialize};\n\n/// Type of a frontmatter field.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum FieldType {\n    /// String value.\n    String,\n    /// Numeric value (integer or float).\n    Number,\n    /// Boolean value.\n    Boolean,\n    /// Date in YYYY-MM-DD format.\n    Date,\n    /// ISO 8601 datetime.\n    Datetime,\n    /// Array of values.\n    List,\n    /// Link to another note.\n    Reference,\n}\n\nimpl FieldType {\n    /// Get the display name for this field type.\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::String =\u003e \"string\",\n            Self::Number =\u003e \"number\",\n            Self::Boolean =\u003e \"boolean\",\n            Self::Date =\u003e \"date\",\n            Self::Datetime =\u003e \"datetime\",\n            Self::List =\u003e \"list\",\n            Self::Reference =\u003e \"reference\",\n        }\n    }\n}\n\nimpl std::fmt::Display for FieldType {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl std::str::FromStr for FieldType {\n    type Err = String;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s.to_lowercase().as_str() {\n            \"string\" | \"str\" =\u003e Ok(Self::String),\n            \"number\" | \"num\" | \"int\" | \"integer\" | \"float\" =\u003e Ok(Self::Number),\n            \"boolean\" | \"bool\" =\u003e Ok(Self::Boolean),\n            \"date\" =\u003e Ok(Self::Date),\n            \"datetime\" =\u003e Ok(Self::Datetime),\n            \"list\" | \"array\" =\u003e Ok(Self::List),\n            \"reference\" | \"ref\" | \"link\" | \"wikilink\" =\u003e Ok(Self::Reference),\n            _ =\u003e Err(format!(\"unknown field type: {}\", s)),\n        }\n    }\n}\n\n/// Schema definition for a single frontmatter field.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct FieldSchema {\n    /// Field type.\n    #[serde(rename = \"type\")]\n    pub field_type: Option\u003cFieldType\u003e,\n\n    /// Whether the field is required.\n    #[serde(default)]\n    pub required: bool,\n\n    /// Human-readable description.\n    #[serde(default)]\n    pub description: Option\u003cString\u003e,\n\n    /// Default value (as serde_yaml::Value for flexibility).\n    #[serde(default)]\n    pub default: Option\u003cserde_yaml::Value\u003e,\n\n    /// Prompt text for interactive input.\n    /// If set, user will be prompted for this field during note creation.\n    #[serde(default)]\n    pub prompt: Option\u003cString\u003e,\n\n    /// Whether this is a core field managed by Rust (not user-modifiable).\n    #[serde(default)]\n    pub core: bool,\n\n    /// Whether to allow multiline input for string fields.\n    #[serde(default)]\n    pub multiline: bool,\n\n    // String constraints\n    /// Allowed values for enum fields.\n    #[serde(default, rename = \"enum\")]\n    pub enum_values: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Regex pattern for validation.\n    #[serde(default)]\n    pub pattern: Option\u003cString\u003e,\n\n    /// Minimum string length.\n    #[serde(default)]\n    pub min_length: Option\u003cusize\u003e,\n\n    /// Maximum string length.\n    #[serde(default)]\n    pub max_length: Option\u003cusize\u003e,\n\n    // Number constraints\n    /// Minimum numeric value.\n    #[serde(default)]\n    pub min: Option\u003cf64\u003e,\n\n    /// Maximum numeric value.\n    #[serde(default)]\n    pub max: Option\u003cf64\u003e,\n\n    /// Whether the number must be an integer.\n    #[serde(default)]\n    pub integer: Option\u003cbool\u003e,\n\n    // List constraints\n    /// Schema for list items.\n    #[serde(default)]\n    pub items: Option\u003cBox\u003cFieldSchema\u003e\u003e,\n\n    /// Minimum number of items.\n    #[serde(default)]\n    pub min_items: Option\u003cusize\u003e,\n\n    /// Maximum number of items.\n    #[serde(default)]\n    pub max_items: Option\u003cusize\u003e,\n\n    // Reference constraints\n    /// Restrict to notes of a specific type.\n    #[serde(default)]\n    pub note_type: Option\u003cString\u003e,\n}\n\nimpl FieldSchema {\n    /// Create a new required string field.\n    pub fn required_string() -\u003e Self {\n        Self { field_type: Some(FieldType::String), required: true, ..Default::default() }\n    }\n\n    /// Create a new optional string field.\n    pub fn optional_string() -\u003e Self {\n        Self {\n            field_type: Some(FieldType::String),\n            required: false,\n            ..Default::default()\n        }\n    }\n\n    /// Create a new required field with an enum constraint.\n    pub fn required_enum(values: Vec\u003cString\u003e) -\u003e Self {\n        Self {\n            field_type: Some(FieldType::String),\n            required: true,\n            enum_values: Some(values),\n            ..Default::default()\n        }\n    }\n\n    /// Get the effective field type, defaulting to String if not specified.\n    pub fn effective_type(\u0026self) -\u003e FieldType {\n        self.field_type.unwrap_or(FieldType::String)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_field_type_from_str() {\n        assert_eq!(\"string\".parse::\u003cFieldType\u003e().unwrap(), FieldType::String);\n        assert_eq!(\"number\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Number);\n        assert_eq!(\"boolean\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Boolean);\n        assert_eq!(\"date\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Date);\n        assert_eq!(\"datetime\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Datetime);\n        assert_eq!(\"list\".parse::\u003cFieldType\u003e().unwrap(), FieldType::List);\n        assert_eq!(\"reference\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Reference);\n        // Aliases\n        assert_eq!(\"bool\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Boolean);\n        assert_eq!(\"array\".parse::\u003cFieldType\u003e().unwrap(), FieldType::List);\n        assert_eq!(\"wikilink\".parse::\u003cFieldType\u003e().unwrap(), FieldType::Reference);\n    }\n\n    #[test]\n    fn test_field_type_display() {\n        assert_eq!(FieldType::String.to_string(), \"string\");\n        assert_eq!(FieldType::Number.to_string(), \"number\");\n    }\n\n    #[test]\n    fn test_field_schema_defaults() {\n        let schema = FieldSchema::default();\n        assert!(!schema.required);\n        assert!(schema.field_type.is_none());\n        assert!(schema.enum_values.is_none());\n    }\n\n    #[test]\n    fn test_required_string() {\n        let schema = FieldSchema::required_string();\n        assert!(schema.required);\n        assert_eq!(schema.effective_type(), FieldType::String);\n    }\n\n    #[test]\n    fn test_required_enum() {\n        let schema = FieldSchema::required_enum(vec![\"a\".to_string(), \"b\".to_string()]);\n        assert!(schema.required);\n        assert_eq!(schema.enum_values, Some(vec![\"a\".to_string(), \"b\".to_string()]));\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":20}},{"line":49,"address":[],"length":0,"stats":{"Line":100}},{"line":50,"address":[],"length":0,"stats":{"Line":100}},{"line":51,"address":[],"length":0,"stats":{"Line":200}},{"line":52,"address":[],"length":0,"stats":{"Line":314}},{"line":53,"address":[],"length":0,"stats":{"Line":125}},{"line":54,"address":[],"length":0,"stats":{"Line":70}},{"line":55,"address":[],"length":0,"stats":{"Line":27}},{"line":56,"address":[],"length":0,"stats":{"Line":19}},{"line":57,"address":[],"length":0,"stats":{"Line":15}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":15}},{"line":171,"address":[],"length":0,"stats":{"Line":45}}],"covered":23,"coverable":30},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","types","validation.rs"],"content":"//! Note validation against type definitions.\n\nuse std::path::Path;\n\nuse regex::Regex;\n\nuse super::definition::TypeDefinition;\nuse super::errors::{ValidationError, ValidationResult};\nuse super::registry::TypeRegistry;\nuse super::schema::{FieldSchema, FieldType};\nuse crate::index::IndexDb;\nuse crate::scripting::LuaEngine;\n\n/// Validate a note's frontmatter against its type definition.\n///\n/// Returns a ValidationResult with any errors and warnings found.\npub fn validate_note(\n    registry: \u0026TypeRegistry,\n    note_type: \u0026str,\n    note_path: \u0026str,\n    frontmatter: \u0026serde_yaml::Value,\n    content: \u0026str,\n) -\u003e ValidationResult {\n    // Get type definition (if any)\n    let typedef = match registry.get(note_type) {\n        Some(td) =\u003e td,\n        None =\u003e return ValidationResult::success(), // Unknown types pass by default\n    };\n\n    let mut result = ValidationResult::success();\n\n    // Phase 1: Schema validation\n    if let serde_yaml::Value::Mapping(map) = frontmatter {\n        let schema_result = validate_schema(\u0026typedef, map);\n        result.merge(schema_result);\n    }\n\n    // Phase 2: Custom validate() function\n    if typedef.has_validate_fn {\n        match run_validate_hook(\u0026typedef, note_type, note_path, frontmatter, content) {\n            Ok((valid, message)) =\u003e {\n                if !valid {\n                    result.add_error(ValidationError::CustomValidation {\n                        message: message\n                            .unwrap_or_else(|| \"Custom validation failed\".to_string()),\n                    });\n                }\n            }\n            Err(e) =\u003e result.add_error(e),\n        }\n    }\n\n    result\n}\n\n/// Validate frontmatter against schema.\nfn validate_schema(\n    typedef: \u0026TypeDefinition,\n    frontmatter: \u0026serde_yaml::Mapping,\n) -\u003e ValidationResult {\n    let mut result = ValidationResult::success();\n\n    for (field_name, schema) in \u0026typedef.schema {\n        let value = frontmatter.get(serde_yaml::Value::String(field_name.clone()));\n\n        // Check required fields\n        if schema.required \u0026\u0026 value.is_none() {\n            result.add_error(ValidationError::MissingRequired {\n                field: field_name.clone(),\n            });\n            continue;\n        }\n\n        // Validate value if present\n        if let Some(val) = value {\n            let field_result = validate_field(field_name, schema, val);\n            result.merge(field_result);\n        }\n    }\n\n    result\n}\n\n/// Validate a single field value against its schema.\nfn validate_field(\n    field: \u0026str,\n    schema: \u0026FieldSchema,\n    value: \u0026serde_yaml::Value,\n) -\u003e ValidationResult {\n    let mut result = ValidationResult::success();\n\n    let expected_type = schema.effective_type();\n\n    // Type checking\n    let type_ok = match (\u0026expected_type, value) {\n        (FieldType::String, serde_yaml::Value::String(_)) =\u003e true,\n        (FieldType::Number, serde_yaml::Value::Number(_)) =\u003e true,\n        (FieldType::Boolean, serde_yaml::Value::Bool(_)) =\u003e true,\n        (FieldType::List, serde_yaml::Value::Sequence(_)) =\u003e true,\n        (FieldType::Date, serde_yaml::Value::String(s)) =\u003e is_valid_date(s),\n        (FieldType::Datetime, serde_yaml::Value::String(s)) =\u003e is_valid_datetime(s),\n        (FieldType::Reference, serde_yaml::Value::String(_)) =\u003e true,\n        _ =\u003e false,\n    };\n\n    if !type_ok {\n        result.add_error(ValidationError::TypeMismatch {\n            field: field.to_string(),\n            expected: expected_type.to_string(),\n            actual: yaml_type_name(value),\n        });\n        return result;\n    }\n\n    // Enum constraint\n    if let (Some(enum_values), serde_yaml::Value::String(s)) =\n        (\u0026schema.enum_values, value)\n        \u0026\u0026 !enum_values.contains(s)\n    {\n        result.add_error(ValidationError::EnumViolation {\n            field: field.to_string(),\n            value: s.clone(),\n            allowed: enum_values.clone(),\n        });\n    }\n\n    // Number constraints\n    if let serde_yaml::Value::Number(n) = value\n        \u0026\u0026 let Some(f) = n.as_f64()\n    {\n        if let Some(min) = schema.min\n            \u0026\u0026 f \u003c min\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"value {} is less than minimum {}\", f, min),\n            });\n        }\n        if let Some(max) = schema.max\n            \u0026\u0026 f \u003e max\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"value {} is greater than maximum {}\", f, max),\n            });\n        }\n        if let Some(true) = schema.integer\n            \u0026\u0026 f.fract() != 0.0\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"value {} must be an integer\", f),\n            });\n        }\n    }\n\n    // String length constraints\n    if let serde_yaml::Value::String(s) = value {\n        if let Some(min) = schema.min_length\n            \u0026\u0026 s.len() \u003c min\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\n                    \"string length {} is less than minimum {}\",\n                    s.len(),\n                    min\n                ),\n            });\n        }\n        if let Some(max) = schema.max_length\n            \u0026\u0026 s.len() \u003e max\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\n                    \"string length {} is greater than maximum {}\",\n                    s.len(),\n                    max\n                ),\n            });\n        }\n        if let Some(pattern) = \u0026schema.pattern\n            \u0026\u0026 let Ok(re) = Regex::new(pattern)\n            \u0026\u0026 !re.is_match(s)\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"value '{}' does not match pattern '{}'\", s, pattern),\n            });\n        }\n    }\n\n    // List constraints\n    if let serde_yaml::Value::Sequence(seq) = value {\n        if let Some(min) = schema.min_items\n            \u0026\u0026 seq.len() \u003c min\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"list has {} items, minimum is {}\", seq.len(), min),\n            });\n        }\n        if let Some(max) = schema.max_items\n            \u0026\u0026 seq.len() \u003e max\n        {\n            result.add_error(ValidationError::InvalidValue {\n                field: field.to_string(),\n                message: format!(\"list has {} items, maximum is {}\", seq.len(), max),\n            });\n        }\n\n        // Validate items if schema provided\n        if let Some(item_schema) = \u0026schema.items {\n            for (i, item) in seq.iter().enumerate() {\n                let item_field = format!(\"{}[{}]\", field, i);\n                let item_result = validate_field(\u0026item_field, item_schema, item);\n                result.merge(item_result);\n            }\n        }\n    }\n\n    result\n}\n\n/// Check if a string is a valid date (YYYY-MM-DD format).\nfn is_valid_date(s: \u0026str) -\u003e bool {\n    // Simple validation: YYYY-MM-DD\n    if s.len() != 10 {\n        return false;\n    }\n    let parts: Vec\u003c\u0026str\u003e = s.split('-').collect();\n    if parts.len() != 3 {\n        return false;\n    }\n    parts[0].len() == 4\n        \u0026\u0026 parts[1].len() == 2\n        \u0026\u0026 parts[2].len() == 2\n        \u0026\u0026 parts[0].chars().all(|c| c.is_ascii_digit())\n        \u0026\u0026 parts[1].chars().all(|c| c.is_ascii_digit())\n        \u0026\u0026 parts[2].chars().all(|c| c.is_ascii_digit())\n}\n\n/// Check if a string is a valid datetime (ISO 8601 format).\nfn is_valid_datetime(s: \u0026str) -\u003e bool {\n    // Accept various ISO 8601 formats\n    // YYYY-MM-DDTHH:MM:SS or YYYY-MM-DD HH:MM:SS or YYYY-MM-DDTHH:MM:SSZ\n    chrono::DateTime::parse_from_rfc3339(s).is_ok()\n        || chrono::NaiveDateTime::parse_from_str(s, \"%Y-%m-%dT%H:%M:%S\").is_ok()\n        || chrono::NaiveDateTime::parse_from_str(s, \"%Y-%m-%d %H:%M:%S\").is_ok()\n}\n\n/// Get a human-readable type name for a YAML value.\nfn yaml_type_name(value: \u0026serde_yaml::Value) -\u003e String {\n    match value {\n        serde_yaml::Value::Null =\u003e \"null\".to_string(),\n        serde_yaml::Value::Bool(_) =\u003e \"boolean\".to_string(),\n        serde_yaml::Value::Number(_) =\u003e \"number\".to_string(),\n        serde_yaml::Value::String(_) =\u003e \"string\".to_string(),\n        serde_yaml::Value::Sequence(_) =\u003e \"list\".to_string(),\n        serde_yaml::Value::Mapping(_) =\u003e \"mapping\".to_string(),\n        serde_yaml::Value::Tagged(_) =\u003e \"tagged\".to_string(),\n    }\n}\n\n/// Run custom validate() Lua hook.\nfn run_validate_hook(\n    typedef: \u0026TypeDefinition,\n    note_type: \u0026str,\n    note_path: \u0026str,\n    frontmatter: \u0026serde_yaml::Value,\n    content: \u0026str,\n) -\u003e Result\u003c(bool, Option\u003cString\u003e), ValidationError\u003e {\n    let engine =\n        LuaEngine::sandboxed().map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    let lua = engine.lua();\n\n    // Load the type definition\n    lua.load(\u0026typedef.lua_source)\n        .exec()\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    // Build note table for validation\n    let note_table =\n        lua.create_table().map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    note_table\n        .set(\"type\", note_type)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n    note_table\n        .set(\"path\", note_path)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n    note_table\n        .set(\"content\", content)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    // Convert frontmatter to Lua table\n    let fm_table = yaml_to_lua_table(lua, frontmatter)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n    note_table\n        .set(\"frontmatter\", fm_table)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    // Get the type definition table by re-evaluating\n    let typedef_table: mlua::Table = lua\n        .load(\u0026typedef.lua_source)\n        .eval()\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    // Call validate function\n    let validate_fn: mlua::Function = typedef_table\n        .get(\"validate\")\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    let result = validate_fn\n        .call::\u003cmlua::MultiValue\u003e(note_table)\n        .map_err(|e| ValidationError::LuaError(e.to_string()))?;\n\n    // Parse result: (true) or (false, \"error message\")\n    let values: Vec\u003cmlua::Value\u003e = result.into_iter().collect();\n    match values.as_slice() {\n        [mlua::Value::Boolean(true)] | [mlua::Value::Boolean(true), _] =\u003e {\n            Ok((true, None))\n        }\n        [mlua::Value::Boolean(false)] =\u003e Ok((false, None)),\n        [mlua::Value::Boolean(false), mlua::Value::String(msg)] =\u003e {\n            let msg_str = msg.to_str().map(|s| s.to_string()).unwrap_or_default();\n            Ok((false, Some(msg_str)))\n        }\n        [mlua::Value::Nil] =\u003e Ok((true, None)), // nil treated as success\n        [] =\u003e Ok((true, None)),                 // no return treated as success\n        _ =\u003e Ok((true, None)),\n    }\n}\n\n/// Convert a serde_yaml::Value to a Lua value.\n///\n/// This is used to pass frontmatter data to Lua hooks.\npub fn yaml_to_lua_table(\n    lua: \u0026mlua::Lua,\n    value: \u0026serde_yaml::Value,\n) -\u003e mlua::Result\u003cmlua::Value\u003e {\n    match value {\n        serde_yaml::Value::Null =\u003e Ok(mlua::Value::Nil),\n        serde_yaml::Value::Bool(b) =\u003e Ok(mlua::Value::Boolean(*b)),\n        serde_yaml::Value::Number(n) =\u003e {\n            if let Some(i) = n.as_i64() {\n                Ok(mlua::Value::Integer(i))\n            } else if let Some(f) = n.as_f64() {\n                Ok(mlua::Value::Number(f))\n            } else {\n                Ok(mlua::Value::Nil)\n            }\n        }\n        serde_yaml::Value::String(s) =\u003e Ok(mlua::Value::String(lua.create_string(s)?)),\n        serde_yaml::Value::Sequence(seq) =\u003e {\n            let table = lua.create_table()?;\n            for (i, item) in seq.iter().enumerate() {\n                table.set(i + 1, yaml_to_lua_table(lua, item)?)?;\n            }\n            Ok(mlua::Value::Table(table))\n        }\n        serde_yaml::Value::Mapping(map) =\u003e {\n            let table = lua.create_table()?;\n            for (k, v) in map {\n                if let serde_yaml::Value::String(key) = k {\n                    table.set(key.as_str(), yaml_to_lua_table(lua, v)?)?;\n                }\n            }\n            Ok(mlua::Value::Table(table))\n        }\n        serde_yaml::Value::Tagged(tagged) =\u003e yaml_to_lua_table(lua, \u0026tagged.value),\n    }\n}\n\n/// Result of link integrity check.\n#[derive(Debug, Clone, Default)]\npub struct LinkIntegrityResult {\n    /// Total number of outgoing links checked.\n    pub total_links: usize,\n    /// Number of broken links (unresolved targets).\n    pub broken_links: usize,\n    /// List of broken link details: (target_path, link_text, link_type).\n    pub broken_details: Vec\u003cBrokenLink\u003e,\n}\n\n/// Information about a broken link.\n#[derive(Debug, Clone)]\npub struct BrokenLink {\n    /// The target path that doesn't exist.\n    pub target_path: String,\n    /// The display text of the link (if any).\n    pub link_text: Option\u003cString\u003e,\n    /// The type of link (wikilink, markdown, frontmatter).\n    pub link_type: String,\n}\n\n/// Check link integrity for a note.\n///\n/// This function checks all outgoing links from a note and reports which ones\n/// point to non-existent targets. Broken links are returned as part of the result\n/// so they can be added as warnings to the validation output.\n///\n/// # Arguments\n///\n/// * `db` - The vault index database\n/// * `note_path` - Path to the note (relative to vault root)\n///\n/// # Returns\n///\n/// A `LinkIntegrityResult` containing the total links checked and any broken links found.\npub fn check_link_integrity(db: \u0026IndexDb, note_path: \u0026Path) -\u003e LinkIntegrityResult {\n    let mut result = LinkIntegrityResult::default();\n\n    // Get the note from the index\n    let note = match db.get_note_by_path(note_path) {\n        Ok(Some(n)) =\u003e n,\n        Ok(None) =\u003e return result, // Note not in index\n        Err(_) =\u003e return result,   // DB error, skip\n    };\n\n    let note_id = match note.id {\n        Some(id) =\u003e id,\n        None =\u003e return result,\n    };\n\n    // Get all outgoing links\n    let links = match db.get_outgoing_links(note_id) {\n        Ok(l) =\u003e l,\n        Err(_) =\u003e return result,\n    };\n\n    result.total_links = links.len();\n\n    // Check each link for resolution\n    for link in links {\n        if link.target_id.is_none() {\n            // This link is unresolved (broken)\n            result.broken_links += 1;\n            result.broken_details.push(BrokenLink {\n                target_path: link.target_path.clone(),\n                link_text: link.link_text.clone(),\n                link_type: link.link_type.as_str().to_string(),\n            });\n        }\n    }\n\n    result\n}\n\n/// Add link integrity warnings to a validation result.\n///\n/// This is a convenience function that checks link integrity and adds\n/// any broken links as warnings to the validation result.\npub fn add_link_integrity_warnings(\n    result: \u0026mut ValidationResult,\n    db: \u0026IndexDb,\n    note_path: \u0026Path,\n) {\n    let integrity = check_link_integrity(db, note_path);\n\n    for broken in integrity.broken_details {\n        let warning = if let Some(text) = broken.link_text {\n            format!(\n                \"broken {} link '{}' -\u003e '{}' (target does not exist)\",\n                broken.link_type, text, broken.target_path\n            )\n        } else {\n            format!(\n                \"broken {} link to '{}' (target does not exist)\",\n                broken.link_type, broken.target_path\n            )\n        };\n        result.add_warning(warning);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::definition::TypeDefinition;\n    use std::collections::HashMap;\n\n    fn make_frontmatter(fields: \u0026[(\u0026str, serde_yaml::Value)]) -\u003e serde_yaml::Value {\n        let mut map = serde_yaml::Mapping::new();\n        for (k, v) in fields {\n            map.insert(serde_yaml::Value::String(k.to_string()), v.clone());\n        }\n        serde_yaml::Value::Mapping(map)\n    }\n\n    fn make_typedef_with_schema(schema: HashMap\u003cString, FieldSchema\u003e) -\u003e TypeDefinition {\n        TypeDefinition {\n            name: \"test\".to_string(),\n            description: None,\n            source_path: std::path::PathBuf::new(),\n            schema,\n            output: None,\n            has_validate_fn: false,\n            has_on_create_hook: false,\n            has_on_update_hook: false,\n            is_builtin_override: false,\n            lua_source: String::new(),\n        }\n    }\n\n    #[test]\n    fn test_validate_required_field_present() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"title\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        let frontmatter =\n            make_frontmatter(\u0026[(\"title\", serde_yaml::Value::String(\"Hello\".into()))]);\n\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n        assert!(result.errors.is_empty());\n    }\n\n    #[test]\n    fn test_validate_required_field_missing() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"title\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        let frontmatter = make_frontmatter(\u0026[]);\n\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n        assert_eq!(result.errors.len(), 1);\n        assert!(\n            matches!(\u0026result.errors[0], ValidationError::MissingRequired { field } if field == \"title\")\n        );\n    }\n\n    #[test]\n    fn test_validate_type_mismatch() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"count\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::Number),\n                required: true,\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        let frontmatter = make_frontmatter(\u0026[(\n            \"count\",\n            serde_yaml::Value::String(\"not a number\".into()),\n        )]);\n\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n        assert!(matches!(\u0026result.errors[0], ValidationError::TypeMismatch { .. }));\n    }\n\n    #[test]\n    fn test_validate_enum() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"status\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                enum_values: Some(vec![\"open\".to_string(), \"done\".to_string()]),\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        // Valid enum value\n        let frontmatter =\n            make_frontmatter(\u0026[(\"status\", serde_yaml::Value::String(\"open\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n\n        // Invalid enum value\n        let frontmatter =\n            make_frontmatter(\u0026[(\"status\", serde_yaml::Value::String(\"invalid\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n        assert!(matches!(\u0026result.errors[0], ValidationError::EnumViolation { .. }));\n    }\n\n    #[test]\n    fn test_validate_number_range() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"priority\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::Number),\n                required: true,\n                min: Some(1.0),\n                max: Some(5.0),\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        // Valid range\n        let frontmatter =\n            make_frontmatter(\u0026[(\"priority\", serde_yaml::Value::Number(3.into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n\n        // Below minimum\n        let frontmatter =\n            make_frontmatter(\u0026[(\"priority\", serde_yaml::Value::Number(0.into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n\n        // Above maximum\n        let frontmatter =\n            make_frontmatter(\u0026[(\"priority\", serde_yaml::Value::Number(10.into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n    }\n\n    #[test]\n    fn test_validate_string_length() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"code\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::String),\n                required: true,\n                min_length: Some(3),\n                max_length: Some(10),\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        // Valid length\n        let frontmatter =\n            make_frontmatter(\u0026[(\"code\", serde_yaml::Value::String(\"ABC123\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n\n        // Too short\n        let frontmatter =\n            make_frontmatter(\u0026[(\"code\", serde_yaml::Value::String(\"AB\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n\n        // Too long\n        let frontmatter = make_frontmatter(\u0026[(\n            \"code\",\n            serde_yaml::Value::String(\"ABCDEFGHIJK\".into()),\n        )]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n    }\n\n    #[test]\n    fn test_validate_list_items() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"tags\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::List),\n                required: true,\n                min_items: Some(1),\n                max_items: Some(5),\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        // Valid list\n        let frontmatter = make_frontmatter(\u0026[(\n            \"tags\",\n            serde_yaml::Value::Sequence(vec![\n                serde_yaml::Value::String(\"a\".into()),\n                serde_yaml::Value::String(\"b\".into()),\n            ]),\n        )]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n\n        // Empty list (below minimum)\n        let frontmatter =\n            make_frontmatter(\u0026[(\"tags\", serde_yaml::Value::Sequence(vec![]))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n    }\n\n    #[test]\n    fn test_validate_date_format() {\n        let mut registry = TypeRegistry::new();\n        let mut schema = HashMap::new();\n        schema.insert(\n            \"due\".to_string(),\n            FieldSchema {\n                field_type: Some(FieldType::Date),\n                required: true,\n                ..Default::default()\n            },\n        );\n        registry.register(make_typedef_with_schema(schema)).unwrap();\n\n        // Valid date\n        let frontmatter =\n            make_frontmatter(\u0026[(\"due\", serde_yaml::Value::String(\"2025-12-29\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n\n        // Invalid date format\n        let frontmatter =\n            make_frontmatter(\u0026[(\"due\", serde_yaml::Value::String(\"29-12-2025\".into()))]);\n        let result = validate_note(\u0026registry, \"test\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(!result.valid);\n    }\n\n    #[test]\n    fn test_validate_unknown_type() {\n        let registry = TypeRegistry::new();\n\n        // Unknown types should pass\n        let frontmatter =\n            make_frontmatter(\u0026[(\"anything\", serde_yaml::Value::String(\"value\".into()))]);\n        let result = validate_note(\u0026registry, \"unknown\", \"/test.md\", \u0026frontmatter, \"\");\n        assert!(result.valid);\n    }\n\n    #[test]\n    fn test_is_valid_date() {\n        assert!(is_valid_date(\"2025-12-29\"));\n        assert!(is_valid_date(\"2000-01-01\"));\n        assert!(!is_valid_date(\"2025-1-29\")); // Month not zero-padded\n        assert!(!is_valid_date(\"25-12-29\")); // Year not 4 digits\n        assert!(!is_valid_date(\"2025/12/29\")); // Wrong separator\n        assert!(!is_valid_date(\"not a date\"));\n    }\n\n    #[test]\n    fn test_is_valid_datetime() {\n        assert!(is_valid_datetime(\"2025-12-29T14:30:00Z\"));\n        assert!(is_valid_datetime(\"2025-12-29T14:30:00+00:00\"));\n        assert!(is_valid_datetime(\"2025-12-29T14:30:00\"));\n        assert!(!is_valid_datetime(\"not a datetime\"));\n        assert!(!is_valid_datetime(\"2025-12-29\")); // Just a date\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":16}},{"line":25,"address":[],"length":0,"stats":{"Line":47}},{"line":26,"address":[],"length":0,"stats":{"Line":30}},{"line":27,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":30}},{"line":33,"address":[],"length":0,"stats":{"Line":45}},{"line":34,"address":[],"length":0,"stats":{"Line":75}},{"line":35,"address":[],"length":0,"stats":{"Line":30}},{"line":39,"address":[],"length":0,"stats":{"Line":15}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":15}},{"line":57,"address":[],"length":0,"stats":{"Line":15}},{"line":61,"address":[],"length":0,"stats":{"Line":30}},{"line":63,"address":[],"length":0,"stats":{"Line":60}},{"line":64,"address":[],"length":0,"stats":{"Line":60}},{"line":67,"address":[],"length":0,"stats":{"Line":45}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":42}},{"line":76,"address":[],"length":0,"stats":{"Line":84}},{"line":77,"address":[],"length":0,"stats":{"Line":28}},{"line":81,"address":[],"length":0,"stats":{"Line":15}},{"line":85,"address":[],"length":0,"stats":{"Line":14}},{"line":90,"address":[],"length":0,"stats":{"Line":28}},{"line":92,"address":[],"length":0,"stats":{"Line":42}},{"line":95,"address":[],"length":0,"stats":{"Line":42}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":14}},{"line":107,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":6}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":24}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":3}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":15}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":134,"address":[],"length":0,"stats":{"Line":3}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":6}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":19}},{"line":159,"address":[],"length":0,"stats":{"Line":10}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":10}},{"line":172,"address":[],"length":0,"stats":{"Line":6}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":3}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":7}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":14}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":4}},{"line":199,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":3}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":205,"address":[],"length":0,"stats":{"Line":4}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":12}},{"line":227,"address":[],"length":0,"stats":{"Line":8}},{"line":229,"address":[],"length":0,"stats":{"Line":8}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":30}},{"line":233,"address":[],"length":0,"stats":{"Line":6}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":4}},{"line":237,"address":[],"length":0,"stats":{"Line":3}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":30}},{"line":240,"address":[],"length":0,"stats":{"Line":18}},{"line":241,"address":[],"length":0,"stats":{"Line":18}},{"line":245,"address":[],"length":0,"stats":{"Line":5}},{"line":248,"address":[],"length":0,"stats":{"Line":10}},{"line":249,"address":[],"length":0,"stats":{"Line":9}},{"line":250,"address":[],"length":0,"stats":{"Line":6}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[],"length":0,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}}],"covered":104,"coverable":228},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vars","datemath.rs"],"content":"//! Date math expression parser and evaluator.\n//!\n//! Supports expressions like:\n//! - `{{today}}`, `{{now}}`, `{{time}}`, `{{week}}`, `{{year}}`\n//! - `{{today + 1d}}`, `{{today - 1w}}`, `{{now + 2h}}`\n//! - `{{today | %Y-%m-%d}}` (with format specifier)\n//! - `{{today - monday}}`, `{{today + friday}}` (relative weekday)\n//! - `{{week}}` returns ISO week number (1-53), `{{week | %Y-W%V}}` for \"2025-W51\"\n\nuse chrono::{\n    Datelike, Duration, IsoWeek, Local, NaiveDate, NaiveDateTime, NaiveTime, Timelike,\n    Weekday,\n};\nuse regex::Regex;\nuse thiserror::Error;\n\n/// Error type for date math parsing and evaluation.\n#[derive(Debug, Error, PartialEq, Eq)]\npub enum DateMathError {\n    #[error(\"invalid date math expression: {0}\")]\n    InvalidExpression(String),\n\n    #[error(\"invalid duration unit: {0}\")]\n    InvalidUnit(String),\n\n    #[error(\"invalid number in expression: {0}\")]\n    InvalidNumber(String),\n\n    #[error(\"invalid weekday: {0}\")]\n    InvalidWeekday(String),\n}\n\n/// A parsed date/time base value.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum DateBase {\n    /// Current date (YYYY-MM-DD)\n    Today,\n    /// Current datetime (ISO 8601)\n    Now,\n    /// Current time (HH:MM)\n    Time,\n    /// Current date (alias for today)\n    Date,\n    /// Current ISO week number (1-53)\n    Week,\n    /// Current year (YYYY)\n    Year,\n    /// Literal date (e.g., 2025-01-15)\n    Literal(NaiveDate),\n    /// Monday of current week\n    WeekStart,\n    /// Sunday of current week\n    WeekEnd,\n    /// ISO week notation (e.g., 2025-W01) - resolves to Monday of that week\n    IsoWeek { year: i32, week: u32 },\n}\n\n/// A duration offset to apply.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum DateOffset {\n    /// No offset\n    None,\n    /// Duration: +/- N units (days, weeks, months, hours, minutes)\n    Duration { amount: i64, unit: DurationUnit },\n    /// Relative weekday: previous/next Monday, Tuesday, etc.\n    Weekday { weekday: Weekday, direction: Direction },\n}\n\n/// Units for duration offsets.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum DurationUnit {\n    Minutes,\n    Hours,\n    Days,\n    Weeks,\n    Months,\n    Years,\n}\n\n/// Direction for relative weekday.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Direction {\n    Previous, // - (go back to previous weekday)\n    Next,     // + (go forward to next weekday)\n}\n\n/// A fully parsed date math expression.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct DateExpr {\n    pub base: DateBase,\n    pub offset: DateOffset,\n    pub format: Option\u003cString\u003e,\n}\n\n/// Parse a date math expression.\n///\n/// Examples:\n/// - `today` -\u003e DateExpr { base: Today, offset: None, format: None }\n/// - `today + 1d` -\u003e DateExpr { base: Today, offset: Duration { amount: 1, unit: Days }, format: None }\n/// - `now | %H:%M` -\u003e DateExpr { base: Now, offset: None, format: Some(\"%H:%M\") }\n/// - `today - monday` -\u003e DateExpr { base: Today, offset: Weekday { weekday: Monday, direction: Previous }, format: None }\npub fn parse_date_expr(input: \u0026str) -\u003e Result\u003cDateExpr, DateMathError\u003e {\n    let input = input.trim();\n\n    // Split by format specifier first\n    let (expr_part, format) = if let Some(idx) = input.find('|') {\n        let (e, f) = input.split_at(idx);\n        (e.trim(), Some(f[1..].trim().to_string()))\n    } else {\n        (input, None)\n    };\n\n    // Parse base and offset\n    // The base can be a keyword (today, now, etc.) or an ISO date (2025-01-15)\n    // ISO dates contain hyphens, so we need a more flexible pattern\n    let re = Regex::new(r\"^([\\w-]+)\\s*([+-])?\\s*(\\w+)?$\").expect(\"valid regex\");\n\n    if let Some(caps) = re.captures(expr_part) {\n        let base_str = \u0026caps[1];\n        let base = parse_base(base_str)?;\n\n        let offset = if let (Some(op), Some(operand)) = (caps.get(2), caps.get(3)) {\n            let op_str = op.as_str();\n            let operand_str = operand.as_str();\n            parse_offset(op_str, operand_str)?\n        } else {\n            DateOffset::None\n        };\n\n        Ok(DateExpr { base, offset, format })\n    } else {\n        Err(DateMathError::InvalidExpression(input.to_string()))\n    }\n}\n\nfn parse_base(s: \u0026str) -\u003e Result\u003cDateBase, DateMathError\u003e {\n    match s.to_lowercase().as_str() {\n        \"today\" =\u003e Ok(DateBase::Today),\n        \"now\" =\u003e Ok(DateBase::Now),\n        \"time\" =\u003e Ok(DateBase::Time),\n        \"date\" =\u003e Ok(DateBase::Date),\n        \"week\" =\u003e Ok(DateBase::Week),\n        \"year\" =\u003e Ok(DateBase::Year),\n        \"week_start\" =\u003e Ok(DateBase::WeekStart),\n        \"week_end\" =\u003e Ok(DateBase::WeekEnd),\n        _ =\u003e {\n            // Try parsing as ISO week notation (YYYY-Www or YYYY-Ww)\n            if let Some(iso_week) = parse_iso_week_notation(s) {\n                return Ok(iso_week);\n            }\n            // Try parsing as ISO 8601 date literal (YYYY-MM-DD)\n            if let Ok(date) = NaiveDate::parse_from_str(s, \"%Y-%m-%d\") {\n                return Ok(DateBase::Literal(date));\n            }\n            Err(DateMathError::InvalidExpression(format!(\"unknown base: {s}\")))\n        }\n    }\n}\n\n/// Parse ISO week notation (e.g., 2025-W01, 2025-W1)\nfn parse_iso_week_notation(s: \u0026str) -\u003e Option\u003cDateBase\u003e {\n    let re = Regex::new(r\"^(\\d{4})-[Ww](\\d{1,2})$\").expect(\"valid regex\");\n    if let Some(caps) = re.captures(s) {\n        let year: i32 = caps[1].parse().ok()?;\n        let week: u32 = caps[2].parse().ok()?;\n        // Validate week number (1-53)\n        if (1..=53).contains(\u0026week) {\n            return Some(DateBase::IsoWeek { year, week });\n        }\n    }\n    None\n}\n\nfn parse_offset(op: \u0026str, operand: \u0026str) -\u003e Result\u003cDateOffset, DateMathError\u003e {\n    let direction = match op {\n        \"+\" =\u003e Direction::Next,\n        \"-\" =\u003e Direction::Previous,\n        _ =\u003e {\n            return Err(DateMathError::InvalidExpression(format!(\n                \"invalid operator: {op}\"\n            )));\n        }\n    };\n\n    // Try parsing as weekday first\n    if let Ok(weekday) = parse_weekday(operand) {\n        return Ok(DateOffset::Weekday { weekday, direction });\n    }\n\n    // Try parsing as duration (e.g., \"1d\", \"2w\", \"3M\")\n    let re = Regex::new(r\"^(\\d+)([dmMyhwY])$\").expect(\"valid regex\");\n    if let Some(caps) = re.captures(operand) {\n        let amount: i64 = caps[1]\n            .parse()\n            .map_err(|_| DateMathError::InvalidNumber(caps[1].to_string()))?;\n\n        let unit = match \u0026caps[2] {\n            \"m\" =\u003e DurationUnit::Minutes,\n            \"h\" =\u003e DurationUnit::Hours,\n            \"d\" =\u003e DurationUnit::Days,\n            \"w\" =\u003e DurationUnit::Weeks,\n            \"M\" =\u003e DurationUnit::Months,\n            \"y\" | \"Y\" =\u003e DurationUnit::Years,\n            u =\u003e return Err(DateMathError::InvalidUnit(u.to_string())),\n        };\n\n        let signed_amount = match direction {\n            Direction::Next =\u003e amount,\n            Direction::Previous =\u003e -amount,\n        };\n\n        return Ok(DateOffset::Duration { amount: signed_amount, unit });\n    }\n\n    Err(DateMathError::InvalidExpression(format!(\"invalid offset: {operand}\")))\n}\n\nfn parse_weekday(s: \u0026str) -\u003e Result\u003cWeekday, DateMathError\u003e {\n    match s.to_lowercase().as_str() {\n        \"monday\" | \"mon\" =\u003e Ok(Weekday::Mon),\n        \"tuesday\" | \"tue\" =\u003e Ok(Weekday::Tue),\n        \"wednesday\" | \"wed\" =\u003e Ok(Weekday::Wed),\n        \"thursday\" | \"thu\" =\u003e Ok(Weekday::Thu),\n        \"friday\" | \"fri\" =\u003e Ok(Weekday::Fri),\n        \"saturday\" | \"sat\" =\u003e Ok(Weekday::Sat),\n        \"sunday\" | \"sun\" =\u003e Ok(Weekday::Sun),\n        _ =\u003e Err(DateMathError::InvalidWeekday(s.to_string())),\n    }\n}\n\n/// Evaluate a date expression and return the formatted result.\npub fn evaluate_date_expr(expr: \u0026DateExpr) -\u003e String {\n    let now = Local::now();\n    let today = now.date_naive();\n    let current_time = now.time();\n\n    match expr.base {\n        DateBase::Today | DateBase::Date =\u003e {\n            let date = apply_date_offset(today, \u0026expr.offset);\n            format_date(date, expr.format.as_deref())\n        }\n        DateBase::Now =\u003e {\n            let datetime = apply_datetime_offset(now.naive_local(), \u0026expr.offset);\n            format_datetime(datetime, expr.format.as_deref())\n        }\n        DateBase::Time =\u003e {\n            let time = apply_time_offset(current_time, \u0026expr.offset);\n            format_time(time, expr.format.as_deref())\n        }\n        DateBase::Week =\u003e {\n            let date = apply_date_offset(today, \u0026expr.offset);\n            format_week(date.iso_week(), expr.format.as_deref())\n        }\n        DateBase::Year =\u003e {\n            let date = apply_date_offset(today, \u0026expr.offset);\n            format_year(date, expr.format.as_deref())\n        }\n        DateBase::Literal(base_date) =\u003e {\n            let date = apply_date_offset(base_date, \u0026expr.offset);\n            format_date(date, expr.format.as_deref())\n        }\n        DateBase::WeekStart =\u003e {\n            let monday = get_week_start(today);\n            let date = apply_date_offset(monday, \u0026expr.offset);\n            format_date(date, expr.format.as_deref())\n        }\n        DateBase::WeekEnd =\u003e {\n            let sunday = get_week_end(today);\n            let date = apply_date_offset(sunday, \u0026expr.offset);\n            format_date(date, expr.format.as_deref())\n        }\n        DateBase::IsoWeek { year, week } =\u003e {\n            // Get Monday of the specified ISO week\n            let monday =\n                NaiveDate::from_isoywd_opt(year, week, Weekday::Mon).unwrap_or(today);\n            let date = apply_date_offset(monday, \u0026expr.offset);\n            format_date(date, expr.format.as_deref())\n        }\n    }\n}\n\n/// Get the Monday of the week containing the given date.\nfn get_week_start(date: NaiveDate) -\u003e NaiveDate {\n    let days_from_monday = date.weekday().num_days_from_monday() as i64;\n    date - Duration::days(days_from_monday)\n}\n\n/// Get the Sunday of the week containing the given date.\nfn get_week_end(date: NaiveDate) -\u003e NaiveDate {\n    let days_to_sunday = 6 - date.weekday().num_days_from_monday() as i64;\n    date + Duration::days(days_to_sunday)\n}\n\nfn apply_date_offset(date: NaiveDate, offset: \u0026DateOffset) -\u003e NaiveDate {\n    match offset {\n        DateOffset::None =\u003e date,\n        DateOffset::Duration { amount, unit } =\u003e match unit {\n            DurationUnit::Days =\u003e date + Duration::days(*amount),\n            DurationUnit::Weeks =\u003e date + Duration::weeks(*amount),\n            DurationUnit::Months =\u003e add_months(date, *amount),\n            DurationUnit::Years =\u003e add_months(date, amount * 12),\n            DurationUnit::Hours | DurationUnit::Minutes =\u003e date, // hours/minutes don't affect date\n        },\n        DateOffset::Weekday { weekday, direction } =\u003e {\n            find_relative_weekday(date, *weekday, *direction)\n        }\n    }\n}\n\nfn apply_datetime_offset(dt: NaiveDateTime, offset: \u0026DateOffset) -\u003e NaiveDateTime {\n    match offset {\n        DateOffset::None =\u003e dt,\n        DateOffset::Duration { amount, unit } =\u003e match unit {\n            DurationUnit::Minutes =\u003e dt + Duration::minutes(*amount),\n            DurationUnit::Hours =\u003e dt + Duration::hours(*amount),\n            DurationUnit::Days =\u003e dt + Duration::days(*amount),\n            DurationUnit::Weeks =\u003e dt + Duration::weeks(*amount),\n            DurationUnit::Months =\u003e {\n                let new_date = add_months(dt.date(), *amount);\n                NaiveDateTime::new(new_date, dt.time())\n            }\n            DurationUnit::Years =\u003e {\n                let new_date = add_months(dt.date(), amount * 12);\n                NaiveDateTime::new(new_date, dt.time())\n            }\n        },\n        DateOffset::Weekday { weekday, direction } =\u003e {\n            let new_date = find_relative_weekday(dt.date(), *weekday, *direction);\n            NaiveDateTime::new(new_date, dt.time())\n        }\n    }\n}\n\nfn apply_time_offset(time: NaiveTime, offset: \u0026DateOffset) -\u003e NaiveTime {\n    match offset {\n        DateOffset::None =\u003e time,\n        DateOffset::Duration { amount, unit } =\u003e match unit {\n            DurationUnit::Minutes =\u003e {\n                let secs = time.num_seconds_from_midnight() as i64 + amount * 60;\n                let normalized = secs.rem_euclid(86400) as u32;\n                NaiveTime::from_num_seconds_from_midnight_opt(normalized, 0)\n                    .unwrap_or(time)\n            }\n            DurationUnit::Hours =\u003e {\n                let secs = time.num_seconds_from_midnight() as i64 + amount * 3600;\n                let normalized = secs.rem_euclid(86400) as u32;\n                NaiveTime::from_num_seconds_from_midnight_opt(normalized, 0)\n                    .unwrap_or(time)\n            }\n            _ =\u003e time, // days/weeks/months don't affect time\n        },\n        DateOffset::Weekday { .. } =\u003e time, // weekdays don't affect time\n    }\n}\n\nfn add_months(date: NaiveDate, months: i64) -\u003e NaiveDate {\n    let year = date.year() as i64;\n    let month = date.month() as i64;\n    let day = date.day();\n\n    let total_months = year * 12 + month - 1 + months;\n    let new_year = (total_months / 12) as i32;\n    let new_month = (total_months % 12 + 1) as u32;\n\n    // Handle day overflow (e.g., Jan 31 + 1 month = Feb 28/29)\n    let max_day = days_in_month(new_year, new_month);\n    let new_day = day.min(max_day);\n\n    NaiveDate::from_ymd_opt(new_year, new_month, new_day).unwrap_or(date)\n}\n\nfn days_in_month(year: i32, month: u32) -\u003e u32 {\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 =\u003e 31,\n        4 | 6 | 9 | 11 =\u003e 30,\n        2 =\u003e {\n            if year % 4 == 0 \u0026\u0026 (year % 100 != 0 || year % 400 == 0) {\n                29\n            } else {\n                28\n            }\n        }\n        _ =\u003e 30,\n    }\n}\n\nfn find_relative_weekday(\n    date: NaiveDate,\n    target: Weekday,\n    direction: Direction,\n) -\u003e NaiveDate {\n    let current = date.weekday();\n\n    match direction {\n        Direction::Previous =\u003e {\n            // Find the previous occurrence (or today if it's the target)\n            let days_diff = (current.num_days_from_monday() as i64\n                - target.num_days_from_monday() as i64\n                + 7)\n                % 7;\n            let days_back = if days_diff == 0 { 7 } else { days_diff };\n            date - Duration::days(days_back)\n        }\n        Direction::Next =\u003e {\n            // Find the next occurrence (or today if it's the target)\n            let days_diff = (target.num_days_from_monday() as i64\n                - current.num_days_from_monday() as i64\n                + 7)\n                % 7;\n            let days_forward = if days_diff == 0 { 7 } else { days_diff };\n            date + Duration::days(days_forward)\n        }\n    }\n}\n\nfn format_date(date: NaiveDate, format: Option\u003c\u0026str\u003e) -\u003e String {\n    let fmt = format.unwrap_or(\"%Y-%m-%d\");\n    date.format(fmt).to_string()\n}\n\nfn format_datetime(dt: NaiveDateTime, format: Option\u003c\u0026str\u003e) -\u003e String {\n    let fmt = format.unwrap_or(\"%Y-%m-%dT%H:%M:%S\");\n    dt.format(fmt).to_string()\n}\n\nfn format_time(time: NaiveTime, format: Option\u003c\u0026str\u003e) -\u003e String {\n    let fmt = format.unwrap_or(\"%H:%M\");\n    time.format(fmt).to_string()\n}\n\nfn format_week(week: IsoWeek, format: Option\u003c\u0026str\u003e) -\u003e String {\n    match format {\n        // If a format is provided, apply it to a date in that week\n        // This allows formats like \"%Y-W%V\" to produce \"2025-W51\"\n        Some(fmt) =\u003e {\n            // Get a date in this week (Monday)\n            let date = NaiveDate::from_isoywd_opt(week.year(), week.week(), Weekday::Mon)\n                .unwrap_or_else(|| Local::now().date_naive());\n            date.format(fmt).to_string()\n        }\n        // Default: just the week number\n        None =\u003e week.week().to_string(),\n    }\n}\n\nfn format_year(date: NaiveDate, format: Option\u003c\u0026str\u003e) -\u003e String {\n    let fmt = format.unwrap_or(\"%Y\");\n    date.format(fmt).to_string()\n}\n\n/// Check if a string looks like an ISO 8601 date (YYYY-MM-DD).\nfn looks_like_iso_date(s: \u0026str) -\u003e bool {\n    // Quick check: must be at least 10 chars and match pattern\n    if s.len() \u003c 10 {\n        return false;\n    }\n    let bytes = s.as_bytes();\n    // Check pattern: DDDD-DD-DD where D is digit\n    bytes[0].is_ascii_digit()\n        \u0026\u0026 bytes[1].is_ascii_digit()\n        \u0026\u0026 bytes[2].is_ascii_digit()\n        \u0026\u0026 bytes[3].is_ascii_digit()\n        \u0026\u0026 bytes[4] == b'-'\n        \u0026\u0026 bytes[5].is_ascii_digit()\n        \u0026\u0026 bytes[6].is_ascii_digit()\n        \u0026\u0026 bytes[7] == b'-'\n        \u0026\u0026 bytes[8].is_ascii_digit()\n        \u0026\u0026 bytes[9].is_ascii_digit()\n}\n\n/// Check if a string looks like an ISO week notation (YYYY-Www or YYYY-Ww).\nfn looks_like_iso_week(s: \u0026str) -\u003e bool {\n    // Pattern: YYYY-Wxx or YYYY-Wx (7-8 chars minimum)\n    if s.len() \u003c 7 {\n        return false;\n    }\n    let bytes = s.as_bytes();\n    // Check: 4 digits, hyphen, W/w, 1-2 digits\n    bytes[0].is_ascii_digit()\n        \u0026\u0026 bytes[1].is_ascii_digit()\n        \u0026\u0026 bytes[2].is_ascii_digit()\n        \u0026\u0026 bytes[3].is_ascii_digit()\n        \u0026\u0026 bytes[4] == b'-'\n        \u0026\u0026 (bytes[5] == b'W' || bytes[5] == b'w')\n        \u0026\u0026 bytes[6].is_ascii_digit()\n        \u0026\u0026 (s.len() == 7 || (s.len() \u003e= 8 \u0026\u0026 bytes[7].is_ascii_digit()))\n}\n\n/// Check if a string looks like a date math expression.\n///\n/// Returns true for strings like \"today\", \"now + 1d\", \"time - 2h\", \"week\", \"year\",\n/// \"week_start\", \"week_end\", ISO date literals like \"2025-01-15\",\n/// or ISO week notation like \"2025-W01\".\npub fn is_date_expr(s: \u0026str) -\u003e bool {\n    let s = s.trim();\n    let lower = s.to_lowercase();\n\n    // Check for keyword-based expressions\n    // Note: \"week\" matches week, week_start, week_end\n    if lower.starts_with(\"today\")\n        || lower.starts_with(\"now\")\n        || lower.starts_with(\"time\")\n        || lower.starts_with(\"date\")\n        || lower.starts_with(\"week\")\n        || lower.starts_with(\"year\")\n    {\n        return true;\n    }\n\n    // Extract the base part (before any + or - operator with space, or format specifier)\n    let base_part = if let Some(idx) = s.find(['+', '|']) {\n        s[..idx].trim()\n    } else if let Some(idx) = s.rfind(\" -\") {\n        // Use rfind for \" -\" to avoid matching the hyphens in the date/week\n        s[..idx].trim()\n    } else {\n        s\n    };\n\n    // Check for ISO date literal or ISO week notation\n    looks_like_iso_date(base_part) || looks_like_iso_week(base_part)\n}\n\n/// Evaluate a date expression string if it is one, otherwise return None.\npub fn try_evaluate_date_expr(s: \u0026str) -\u003e Option\u003cString\u003e {\n    if is_date_expr(s) {\n        parse_date_expr(s).ok().map(|e| evaluate_date_expr(\u0026e))\n    } else {\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_simple_today() {\n        let expr = parse_date_expr(\"today\").unwrap();\n        assert_eq!(expr.base, DateBase::Today);\n        assert_eq!(expr.offset, DateOffset::None);\n        assert!(expr.format.is_none());\n    }\n\n    #[test]\n    fn test_parse_today_plus_days() {\n        let expr = parse_date_expr(\"today + 1d\").unwrap();\n        assert_eq!(expr.base, DateBase::Today);\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 1, unit: DurationUnit::Days }\n        );\n    }\n\n    #[test]\n    fn test_parse_today_minus_weeks() {\n        let expr = parse_date_expr(\"today - 2w\").unwrap();\n        assert_eq!(expr.base, DateBase::Today);\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: -2, unit: DurationUnit::Weeks }\n        );\n    }\n\n    #[test]\n    fn test_parse_now_with_format() {\n        let expr = parse_date_expr(\"now | %H:%M\").unwrap();\n        assert_eq!(expr.base, DateBase::Now);\n        assert_eq!(expr.format, Some(\"%H:%M\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_weekday_previous() {\n        let expr = parse_date_expr(\"today - monday\").unwrap();\n        assert_eq!(expr.base, DateBase::Today);\n        assert_eq!(\n            expr.offset,\n            DateOffset::Weekday { weekday: Weekday::Mon, direction: Direction::Previous }\n        );\n    }\n\n    #[test]\n    fn test_parse_weekday_next() {\n        let expr = parse_date_expr(\"today + friday\").unwrap();\n        assert_eq!(expr.base, DateBase::Today);\n        assert_eq!(\n            expr.offset,\n            DateOffset::Weekday { weekday: Weekday::Fri, direction: Direction::Next }\n        );\n    }\n\n    #[test]\n    fn test_parse_months() {\n        let expr = parse_date_expr(\"today + 3M\").unwrap();\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 3, unit: DurationUnit::Months }\n        );\n    }\n\n    #[test]\n    fn test_parse_hours() {\n        let expr = parse_date_expr(\"now + 2h\").unwrap();\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 2, unit: DurationUnit::Hours }\n        );\n    }\n\n    #[test]\n    fn test_evaluate_today() {\n        let expr =\n            DateExpr { base: DateBase::Today, offset: DateOffset::None, format: None };\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be in YYYY-MM-DD format\n        assert!(result.len() == 10);\n        assert!(result.chars().nth(4) == Some('-'));\n    }\n\n    #[test]\n    fn test_evaluate_today_plus_one_day() {\n        let expr = parse_date_expr(\"today + 1d\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n\n        let today = Local::now().date_naive();\n        let tomorrow = today + Duration::days(1);\n        assert_eq!(result, tomorrow.format(\"%Y-%m-%d\").to_string());\n    }\n\n    #[test]\n    fn test_evaluate_with_format() {\n        let expr = parse_date_expr(\"today | %A\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be a day name like \"Monday\", \"Tuesday\", etc.\n        let valid_days = [\n            \"Monday\",\n            \"Tuesday\",\n            \"Wednesday\",\n            \"Thursday\",\n            \"Friday\",\n            \"Saturday\",\n            \"Sunday\",\n        ];\n        assert!(valid_days.contains(\u0026result.as_str()));\n    }\n\n    #[test]\n    fn test_add_months_overflow() {\n        // Jan 31 + 1 month should be Feb 28 (non-leap year)\n        let date = NaiveDate::from_ymd_opt(2023, 1, 31).unwrap();\n        let result = add_months(date, 1);\n        assert_eq!(result, NaiveDate::from_ymd_opt(2023, 2, 28).unwrap());\n    }\n\n    #[test]\n    fn test_add_months_leap_year() {\n        // Jan 31 + 1 month in leap year should be Feb 29\n        let date = NaiveDate::from_ymd_opt(2024, 1, 31).unwrap();\n        let result = add_months(date, 1);\n        assert_eq!(result, NaiveDate::from_ymd_opt(2024, 2, 29).unwrap());\n    }\n\n    #[test]\n    fn test_is_date_expr() {\n        assert!(is_date_expr(\"today\"));\n        assert!(is_date_expr(\"TODAY\"));\n        assert!(is_date_expr(\"today + 1d\"));\n        assert!(is_date_expr(\"now\"));\n        assert!(is_date_expr(\"time - 2h\"));\n        assert!(!is_date_expr(\"some_var\"));\n        assert!(!is_date_expr(\"{{today}}\"));\n    }\n\n    #[test]\n    fn test_try_evaluate() {\n        assert!(try_evaluate_date_expr(\"today\").is_some());\n        assert!(try_evaluate_date_expr(\"not_a_date\").is_none());\n    }\n\n    #[test]\n    fn test_parse_week() {\n        let expr = parse_date_expr(\"week\").unwrap();\n        assert_eq!(expr.base, DateBase::Week);\n        assert_eq!(expr.offset, DateOffset::None);\n    }\n\n    #[test]\n    fn test_evaluate_week() {\n        let expr = parse_date_expr(\"week\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be a number between 1 and 53\n        let week_num: u32 = result.parse().unwrap();\n        assert!((1..=53).contains(\u0026week_num));\n    }\n\n    #[test]\n    fn test_evaluate_week_with_format() {\n        let expr = parse_date_expr(\"week | %Y-W%V\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be like \"2025-W51\"\n        assert!(result.contains(\"-W\"));\n        assert!(result.len() \u003e= 8); // \"YYYY-WNN\"\n    }\n\n    #[test]\n    fn test_week_with_offset() {\n        let expr = parse_date_expr(\"week + 1w\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be a valid week number\n        let week_num: u32 = result.parse().unwrap();\n        assert!((1..=53).contains(\u0026week_num));\n    }\n\n    #[test]\n    fn test_parse_year() {\n        let expr = parse_date_expr(\"year\").unwrap();\n        assert_eq!(expr.base, DateBase::Year);\n    }\n\n    #[test]\n    fn test_evaluate_year() {\n        let expr = parse_date_expr(\"year\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        // Should be a 4-digit year\n        assert_eq!(result.len(), 4);\n        let year: i32 = result.parse().unwrap();\n        assert!((2020..=2100).contains(\u0026year));\n    }\n\n    #[test]\n    fn test_is_date_expr_week_year() {\n        assert!(is_date_expr(\"week\"));\n        assert!(is_date_expr(\"WEEK\"));\n        assert!(is_date_expr(\"week + 1w\"));\n        assert!(is_date_expr(\"year\"));\n        assert!(is_date_expr(\"year - 1y\"));\n    }\n\n    // Tests for ISO date literals\n\n    #[test]\n    fn test_parse_iso_date_literal() {\n        let expr = parse_date_expr(\"2025-01-15\").unwrap();\n        assert_eq!(\n            expr.base,\n            DateBase::Literal(NaiveDate::from_ymd_opt(2025, 1, 15).unwrap())\n        );\n        assert_eq!(expr.offset, DateOffset::None);\n        assert!(expr.format.is_none());\n    }\n\n    #[test]\n    fn test_parse_iso_date_with_offset() {\n        let expr = parse_date_expr(\"2025-01-15 + 7d\").unwrap();\n        assert_eq!(\n            expr.base,\n            DateBase::Literal(NaiveDate::from_ymd_opt(2025, 1, 15).unwrap())\n        );\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 7, unit: DurationUnit::Days }\n        );\n    }\n\n    #[test]\n    fn test_parse_iso_date_minus_offset() {\n        let expr = parse_date_expr(\"2025-01-15 - 3d\").unwrap();\n        assert_eq!(\n            expr.base,\n            DateBase::Literal(NaiveDate::from_ymd_opt(2025, 1, 15).unwrap())\n        );\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: -3, unit: DurationUnit::Days }\n        );\n    }\n\n    #[test]\n    fn test_parse_iso_date_with_weekday() {\n        let expr = parse_date_expr(\"2025-01-15 - monday\").unwrap();\n        assert_eq!(\n            expr.base,\n            DateBase::Literal(NaiveDate::from_ymd_opt(2025, 1, 15).unwrap())\n        );\n        assert_eq!(\n            expr.offset,\n            DateOffset::Weekday { weekday: Weekday::Mon, direction: Direction::Previous }\n        );\n    }\n\n    #[test]\n    fn test_parse_iso_date_with_format() {\n        let expr = parse_date_expr(\"2025-01-15 | %A\").unwrap();\n        assert_eq!(\n            expr.base,\n            DateBase::Literal(NaiveDate::from_ymd_opt(2025, 1, 15).unwrap())\n        );\n        assert_eq!(expr.format, Some(\"%A\".to_string()));\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_literal() {\n        let expr = parse_date_expr(\"2025-01-15\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-15\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_plus_days() {\n        let expr = parse_date_expr(\"2025-01-15 + 7d\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-22\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_minus_days() {\n        let expr = parse_date_expr(\"2025-01-15 - 5d\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-10\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_plus_weeks() {\n        let expr = parse_date_expr(\"2025-01-15 + 2w\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-29\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_plus_months() {\n        let expr = parse_date_expr(\"2025-01-15 + 1M\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-02-15\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_with_format() {\n        let expr = parse_date_expr(\"2025-01-15 | %A\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"Wednesday\"); // 2025-01-15 is a Wednesday\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_weekday_offset() {\n        // 2025-01-15 is Wednesday, previous Monday is 2025-01-13\n        let expr = parse_date_expr(\"2025-01-15 - monday\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-13\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_date_next_weekday() {\n        // 2025-01-15 is Wednesday, next Friday is 2025-01-17\n        let expr = parse_date_expr(\"2025-01-15 + friday\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-17\");\n    }\n\n    #[test]\n    fn test_is_date_expr_iso_literal() {\n        assert!(is_date_expr(\"2025-01-15\"));\n        assert!(is_date_expr(\"2025-01-15 + 7d\"));\n        assert!(is_date_expr(\"2025-01-15 - 3d\"));\n        assert!(is_date_expr(\"2025-01-15 | %A\"));\n        assert!(is_date_expr(\"1999-12-31\"));\n        assert!(!is_date_expr(\"2025-1-15\")); // Invalid format (single digit month)\n        assert!(!is_date_expr(\"25-01-15\")); // Invalid format (2-digit year)\n    }\n\n    #[test]\n    fn test_try_evaluate_iso_date() {\n        assert_eq!(try_evaluate_date_expr(\"2025-01-15\"), Some(\"2025-01-15\".to_string()));\n        assert_eq!(\n            try_evaluate_date_expr(\"2025-01-15 + 1d\"),\n            Some(\"2025-01-16\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_invalid_iso_date() {\n        // Invalid date should fail parsing\n        assert!(parse_date_expr(\"2025-13-45\").is_err());\n        assert!(parse_date_expr(\"not-a-date\").is_err());\n    }\n\n    // Tests for week_start and week_end\n\n    #[test]\n    fn test_parse_week_start() {\n        let expr = parse_date_expr(\"week_start\").unwrap();\n        assert_eq!(expr.base, DateBase::WeekStart);\n        assert_eq!(expr.offset, DateOffset::None);\n    }\n\n    #[test]\n    fn test_parse_week_end() {\n        let expr = parse_date_expr(\"week_end\").unwrap();\n        assert_eq!(expr.base, DateBase::WeekEnd);\n        assert_eq!(expr.offset, DateOffset::None);\n    }\n\n    #[test]\n    fn test_parse_week_start_with_offset() {\n        let expr = parse_date_expr(\"week_start + 1w\").unwrap();\n        assert_eq!(expr.base, DateBase::WeekStart);\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 1, unit: DurationUnit::Weeks }\n        );\n    }\n\n    #[test]\n    fn test_evaluate_week_start() {\n        // Test that week_start returns a Monday\n        let expr = parse_date_expr(\"week_start\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        let date = NaiveDate::parse_from_str(\u0026result, \"%Y-%m-%d\").unwrap();\n        assert_eq!(date.weekday(), Weekday::Mon);\n    }\n\n    #[test]\n    fn test_evaluate_week_end() {\n        // Test that week_end returns a Sunday\n        let expr = parse_date_expr(\"week_end\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        let date = NaiveDate::parse_from_str(\u0026result, \"%Y-%m-%d\").unwrap();\n        assert_eq!(date.weekday(), Weekday::Sun);\n    }\n\n    #[test]\n    fn test_week_start_and_end_same_week() {\n        // week_start and week_end should be 6 days apart\n        let start_expr = parse_date_expr(\"week_start\").unwrap();\n        let end_expr = parse_date_expr(\"week_end\").unwrap();\n        let start =\n            NaiveDate::parse_from_str(\u0026evaluate_date_expr(\u0026start_expr), \"%Y-%m-%d\")\n                .unwrap();\n        let end = NaiveDate::parse_from_str(\u0026evaluate_date_expr(\u0026end_expr), \"%Y-%m-%d\")\n            .unwrap();\n        assert_eq!((end - start).num_days(), 6);\n    }\n\n    #[test]\n    fn test_week_start_next_week() {\n        // week_start + 1w should be 7 days after week_start\n        let this_week = parse_date_expr(\"week_start\").unwrap();\n        let next_week = parse_date_expr(\"week_start + 1w\").unwrap();\n        let this_monday =\n            NaiveDate::parse_from_str(\u0026evaluate_date_expr(\u0026this_week), \"%Y-%m-%d\")\n                .unwrap();\n        let next_monday =\n            NaiveDate::parse_from_str(\u0026evaluate_date_expr(\u0026next_week), \"%Y-%m-%d\")\n                .unwrap();\n        assert_eq!((next_monday - this_monday).num_days(), 7);\n    }\n\n    // Tests for ISO week notation\n\n    #[test]\n    fn test_parse_iso_week_notation() {\n        let expr = parse_date_expr(\"2025-W01\").unwrap();\n        assert_eq!(expr.base, DateBase::IsoWeek { year: 2025, week: 1 });\n        assert_eq!(expr.offset, DateOffset::None);\n    }\n\n    #[test]\n    fn test_parse_iso_week_notation_lowercase() {\n        let expr = parse_date_expr(\"2025-w15\").unwrap();\n        assert_eq!(expr.base, DateBase::IsoWeek { year: 2025, week: 15 });\n    }\n\n    #[test]\n    fn test_parse_iso_week_with_offset() {\n        let expr = parse_date_expr(\"2025-W01 + 6d\").unwrap();\n        assert_eq!(expr.base, DateBase::IsoWeek { year: 2025, week: 1 });\n        assert_eq!(\n            expr.offset,\n            DateOffset::Duration { amount: 6, unit: DurationUnit::Days }\n        );\n    }\n\n    #[test]\n    fn test_evaluate_iso_week_monday() {\n        // 2025-W01 should resolve to Monday of that week\n        let expr = parse_date_expr(\"2025-W01\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        let date = NaiveDate::parse_from_str(\u0026result, \"%Y-%m-%d\").unwrap();\n        assert_eq!(date.weekday(), Weekday::Mon);\n        // Week 1 of 2025 starts on 2024-12-30 (ISO week definition)\n        assert_eq!(result, \"2024-12-30\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_week_sunday() {\n        // 2025-W01 + 6d should give Sunday of that week\n        let expr = parse_date_expr(\"2025-W01 + 6d\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        let date = NaiveDate::parse_from_str(\u0026result, \"%Y-%m-%d\").unwrap();\n        assert_eq!(date.weekday(), Weekday::Sun);\n        assert_eq!(result, \"2025-01-05\");\n    }\n\n    #[test]\n    fn test_evaluate_iso_week_specific() {\n        // 2025-W03 should start on 2025-01-13 (Monday)\n        let expr = parse_date_expr(\"2025-W03\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"2025-01-13\");\n    }\n\n    #[test]\n    fn test_iso_week_all_days() {\n        // Test generating all days of a week\n        let monday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03\").unwrap());\n        let tuesday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 1d\").unwrap());\n        let wednesday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 2d\").unwrap());\n        let thursday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 3d\").unwrap());\n        let friday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 4d\").unwrap());\n        let saturday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 5d\").unwrap());\n        let sunday = evaluate_date_expr(\u0026parse_date_expr(\"2025-W03 + 6d\").unwrap());\n\n        assert_eq!(monday, \"2025-01-13\");\n        assert_eq!(tuesday, \"2025-01-14\");\n        assert_eq!(wednesday, \"2025-01-15\");\n        assert_eq!(thursday, \"2025-01-16\");\n        assert_eq!(friday, \"2025-01-17\");\n        assert_eq!(saturday, \"2025-01-18\");\n        assert_eq!(sunday, \"2025-01-19\");\n    }\n\n    #[test]\n    fn test_iso_week_with_format() {\n        let expr = parse_date_expr(\"2025-W03 | %A\").unwrap();\n        let result = evaluate_date_expr(\u0026expr);\n        assert_eq!(result, \"Monday\");\n    }\n\n    #[test]\n    fn test_is_date_expr_week_start_end() {\n        assert!(is_date_expr(\"week_start\"));\n        assert!(is_date_expr(\"week_end\"));\n        assert!(is_date_expr(\"week_start + 1w\"));\n        assert!(is_date_expr(\"week_end - 1d\"));\n    }\n\n    #[test]\n    fn test_is_date_expr_iso_week() {\n        assert!(is_date_expr(\"2025-W01\"));\n        assert!(is_date_expr(\"2025-w15\"));\n        assert!(is_date_expr(\"2025-W01 + 6d\"));\n        assert!(is_date_expr(\"2025-W52 | %A\"));\n        assert!(!is_date_expr(\"2025-W\")); // incomplete\n        assert!(!is_date_expr(\"W01\")); // missing year\n    }\n\n    #[test]\n    fn test_try_evaluate_iso_week() {\n        assert_eq!(try_evaluate_date_expr(\"2025-W03\"), Some(\"2025-01-13\".to_string()));\n        assert_eq!(\n            try_evaluate_date_expr(\"2025-W03 + 6d\"),\n            Some(\"2025-01-19\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_invalid_iso_week() {\n        // Week 0 is invalid\n        assert!(parse_date_expr(\"2025-W00\").is_err());\n        // Week 54+ is invalid\n        assert!(parse_date_expr(\"2025-W54\").is_err());\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":132}},{"line":103,"address":[],"length":0,"stats":{"Line":396}},{"line":106,"address":[],"length":0,"stats":{"Line":406}},{"line":107,"address":[],"length":0,"stats":{"Line":40}},{"line":108,"address":[],"length":0,"stats":{"Line":30}},{"line":110,"address":[],"length":0,"stats":{"Line":122}},{"line":116,"address":[],"length":0,"stats":{"Line":660}},{"line":118,"address":[],"length":0,"stats":{"Line":396}},{"line":119,"address":[],"length":0,"stats":{"Line":264}},{"line":120,"address":[],"length":0,"stats":{"Line":396}},{"line":122,"address":[],"length":0,"stats":{"Line":707}},{"line":123,"address":[],"length":0,"stats":{"Line":108}},{"line":124,"address":[],"length":0,"stats":{"Line":108}},{"line":125,"address":[],"length":0,"stats":{"Line":108}},{"line":127,"address":[],"length":0,"stats":{"Line":91}},{"line":130,"address":[],"length":0,"stats":{"Line":254}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":132}},{"line":137,"address":[],"length":0,"stats":{"Line":132}},{"line":138,"address":[],"length":0,"stats":{"Line":177}},{"line":139,"address":[],"length":0,"stats":{"Line":113}},{"line":140,"address":[],"length":0,"stats":{"Line":61}},{"line":141,"address":[],"length":0,"stats":{"Line":69}},{"line":142,"address":[],"length":0,"stats":{"Line":58}},{"line":143,"address":[],"length":0,"stats":{"Line":51}},{"line":144,"address":[],"length":0,"stats":{"Line":51}},{"line":145,"address":[],"length":0,"stats":{"Line":42}},{"line":148,"address":[],"length":0,"stats":{"Line":52}},{"line":149,"address":[],"length":0,"stats":{"Line":16}},{"line":152,"address":[],"length":0,"stats":{"Line":55}},{"line":153,"address":[],"length":0,"stats":{"Line":15}},{"line":155,"address":[],"length":0,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":36}},{"line":162,"address":[],"length":0,"stats":{"Line":180}},{"line":163,"address":[],"length":0,"stats":{"Line":90}},{"line":164,"address":[],"length":0,"stats":{"Line":90}},{"line":165,"address":[],"length":0,"stats":{"Line":90}},{"line":167,"address":[],"length":0,"stats":{"Line":54}},{"line":168,"address":[],"length":0,"stats":{"Line":16}},{"line":171,"address":[],"length":0,"stats":{"Line":20}},{"line":174,"address":[],"length":0,"stats":{"Line":36}},{"line":175,"address":[],"length":0,"stats":{"Line":72}},{"line":176,"address":[],"length":0,"stats":{"Line":64}},{"line":177,"address":[],"length":0,"stats":{"Line":16}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":43}},{"line":187,"address":[],"length":0,"stats":{"Line":7}},{"line":191,"address":[],"length":0,"stats":{"Line":145}},{"line":192,"address":[],"length":0,"stats":{"Line":87}},{"line":193,"address":[],"length":0,"stats":{"Line":87}},{"line":195,"address":[],"length":0,"stats":{"Line":29}},{"line":197,"address":[],"length":0,"stats":{"Line":58}},{"line":198,"address":[],"length":0,"stats":{"Line":29}},{"line":199,"address":[],"length":0,"stats":{"Line":30}},{"line":200,"address":[],"length":0,"stats":{"Line":48}},{"line":201,"address":[],"length":0,"stats":{"Line":14}},{"line":202,"address":[],"length":0,"stats":{"Line":4}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":58}},{"line":208,"address":[],"length":0,"stats":{"Line":25}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":29}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":36}},{"line":219,"address":[],"length":0,"stats":{"Line":36}},{"line":220,"address":[],"length":0,"stats":{"Line":72}},{"line":221,"address":[],"length":0,"stats":{"Line":64}},{"line":222,"address":[],"length":0,"stats":{"Line":64}},{"line":223,"address":[],"length":0,"stats":{"Line":64}},{"line":224,"address":[],"length":0,"stats":{"Line":64}},{"line":225,"address":[],"length":0,"stats":{"Line":58}},{"line":226,"address":[],"length":0,"stats":{"Line":58}},{"line":227,"address":[],"length":0,"stats":{"Line":29}},{"line":232,"address":[],"length":0,"stats":{"Line":107}},{"line":233,"address":[],"length":0,"stats":{"Line":214}},{"line":234,"address":[],"length":0,"stats":{"Line":321}},{"line":235,"address":[],"length":0,"stats":{"Line":321}},{"line":237,"address":[],"length":0,"stats":{"Line":107}},{"line":239,"address":[],"length":0,"stats":{"Line":192}},{"line":240,"address":[],"length":0,"stats":{"Line":192}},{"line":243,"address":[],"length":0,"stats":{"Line":120}},{"line":244,"address":[],"length":0,"stats":{"Line":96}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":16}},{"line":252,"address":[],"length":0,"stats":{"Line":20}},{"line":255,"address":[],"length":0,"stats":{"Line":8}},{"line":256,"address":[],"length":0,"stats":{"Line":8}},{"line":258,"address":[],"length":0,"stats":{"Line":10}},{"line":259,"address":[],"length":0,"stats":{"Line":40}},{"line":260,"address":[],"length":0,"stats":{"Line":40}},{"line":263,"address":[],"length":0,"stats":{"Line":12}},{"line":264,"address":[],"length":0,"stats":{"Line":16}},{"line":265,"address":[],"length":0,"stats":{"Line":16}},{"line":268,"address":[],"length":0,"stats":{"Line":6}},{"line":269,"address":[],"length":0,"stats":{"Line":8}},{"line":270,"address":[],"length":0,"stats":{"Line":8}},{"line":272,"address":[],"length":0,"stats":{"Line":26}},{"line":274,"address":[],"length":0,"stats":{"Line":13}},{"line":275,"address":[],"length":0,"stats":{"Line":78}},{"line":276,"address":[],"length":0,"stats":{"Line":52}},{"line":277,"address":[],"length":0,"stats":{"Line":52}},{"line":283,"address":[],"length":0,"stats":{"Line":4}},{"line":284,"address":[],"length":0,"stats":{"Line":8}},{"line":285,"address":[],"length":0,"stats":{"Line":8}},{"line":289,"address":[],"length":0,"stats":{"Line":2}},{"line":290,"address":[],"length":0,"stats":{"Line":4}},{"line":291,"address":[],"length":0,"stats":{"Line":4}},{"line":294,"address":[],"length":0,"stats":{"Line":83}},{"line":295,"address":[],"length":0,"stats":{"Line":83}},{"line":296,"address":[],"length":0,"stats":{"Line":58}},{"line":297,"address":[],"length":0,"stats":{"Line":63}},{"line":298,"address":[],"length":0,"stats":{"Line":32}},{"line":299,"address":[],"length":0,"stats":{"Line":8}},{"line":300,"address":[],"length":0,"stats":{"Line":3}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":8}},{"line":305,"address":[],"length":0,"stats":{"Line":16}},{"line":310,"address":[],"length":0,"stats":{"Line":24}},{"line":311,"address":[],"length":0,"stats":{"Line":24}},{"line":312,"address":[],"length":0,"stats":{"Line":24}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":3}},{"line":357,"address":[],"length":0,"stats":{"Line":6}},{"line":358,"address":[],"length":0,"stats":{"Line":6}},{"line":359,"address":[],"length":0,"stats":{"Line":9}},{"line":361,"address":[],"length":0,"stats":{"Line":6}},{"line":362,"address":[],"length":0,"stats":{"Line":6}},{"line":363,"address":[],"length":0,"stats":{"Line":6}},{"line":366,"address":[],"length":0,"stats":{"Line":12}},{"line":367,"address":[],"length":0,"stats":{"Line":12}},{"line":369,"address":[],"length":0,"stats":{"Line":18}},{"line":372,"address":[],"length":0,"stats":{"Line":3}},{"line":373,"address":[],"length":0,"stats":{"Line":3}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":4}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":380,"address":[],"length":0,"stats":{"Line":2}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":4}},{"line":392,"address":[],"length":0,"stats":{"Line":12}},{"line":394,"address":[],"length":0,"stats":{"Line":4}},{"line":397,"address":[],"length":0,"stats":{"Line":6}},{"line":398,"address":[],"length":0,"stats":{"Line":2}},{"line":399,"address":[],"length":0,"stats":{"Line":2}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":401,"address":[],"length":0,"stats":{"Line":6}},{"line":402,"address":[],"length":0,"stats":{"Line":4}},{"line":406,"address":[],"length":0,"stats":{"Line":6}},{"line":407,"address":[],"length":0,"stats":{"Line":2}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":409,"address":[],"length":0,"stats":{"Line":2}},{"line":410,"address":[],"length":0,"stats":{"Line":6}},{"line":411,"address":[],"length":0,"stats":{"Line":4}},{"line":416,"address":[],"length":0,"stats":{"Line":77}},{"line":417,"address":[],"length":0,"stats":{"Line":308}},{"line":418,"address":[],"length":0,"stats":{"Line":231}},{"line":421,"address":[],"length":0,"stats":{"Line":24}},{"line":422,"address":[],"length":0,"stats":{"Line":96}},{"line":423,"address":[],"length":0,"stats":{"Line":72}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":4}},{"line":432,"address":[],"length":0,"stats":{"Line":4}},{"line":435,"address":[],"length":0,"stats":{"Line":1}},{"line":437,"address":[],"length":0,"stats":{"Line":7}},{"line":438,"address":[],"length":0,"stats":{"Line":1}},{"line":439,"address":[],"length":0,"stats":{"Line":3}},{"line":442,"address":[],"length":0,"stats":{"Line":6}},{"line":446,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":8}},{"line":448,"address":[],"length":0,"stats":{"Line":6}},{"line":452,"address":[],"length":0,"stats":{"Line":111}},{"line":454,"address":[],"length":0,"stats":{"Line":111}},{"line":455,"address":[],"length":0,"stats":{"Line":89}},{"line":457,"address":[],"length":0,"stats":{"Line":66}},{"line":459,"address":[],"length":0,"stats":{"Line":44}},{"line":460,"address":[],"length":0,"stats":{"Line":14}},{"line":461,"address":[],"length":0,"stats":{"Line":14}},{"line":462,"address":[],"length":0,"stats":{"Line":14}},{"line":463,"address":[],"length":0,"stats":{"Line":7}},{"line":464,"address":[],"length":0,"stats":{"Line":14}},{"line":465,"address":[],"length":0,"stats":{"Line":14}},{"line":466,"address":[],"length":0,"stats":{"Line":7}},{"line":467,"address":[],"length":0,"stats":{"Line":14}},{"line":468,"address":[],"length":0,"stats":{"Line":14}},{"line":472,"address":[],"length":0,"stats":{"Line":104}},{"line":474,"address":[],"length":0,"stats":{"Line":104}},{"line":475,"address":[],"length":0,"stats":{"Line":63}},{"line":477,"address":[],"length":0,"stats":{"Line":123}},{"line":479,"address":[],"length":0,"stats":{"Line":82}},{"line":480,"address":[],"length":0,"stats":{"Line":16}},{"line":481,"address":[],"length":0,"stats":{"Line":16}},{"line":482,"address":[],"length":0,"stats":{"Line":14}},{"line":483,"address":[],"length":0,"stats":{"Line":7}},{"line":484,"address":[],"length":0,"stats":{"Line":9}},{"line":485,"address":[],"length":0,"stats":{"Line":12}},{"line":486,"address":[],"length":0,"stats":{"Line":24}},{"line":494,"address":[],"length":0,"stats":{"Line":153}},{"line":495,"address":[],"length":0,"stats":{"Line":459}},{"line":496,"address":[],"length":0,"stats":{"Line":459}},{"line":500,"address":[],"length":0,"stats":{"Line":153}},{"line":501,"address":[],"length":0,"stats":{"Line":131}},{"line":502,"address":[],"length":0,"stats":{"Line":130}},{"line":503,"address":[],"length":0,"stats":{"Line":129}},{"line":504,"address":[],"length":0,"stats":{"Line":121}},{"line":505,"address":[],"length":0,"stats":{"Line":113}},{"line":507,"address":[],"length":0,"stats":{"Line":42}},{"line":511,"address":[],"length":0,"stats":{"Line":353}},{"line":512,"address":[],"length":0,"stats":{"Line":40}},{"line":513,"address":[],"length":0,"stats":{"Line":92}},{"line":515,"address":[],"length":0,"stats":{"Line":2}},{"line":517,"address":[],"length":0,"stats":{"Line":90}},{"line":521,"address":[],"length":0,"stats":{"Line":430}},{"line":525,"address":[],"length":0,"stats":{"Line":10}},{"line":526,"address":[],"length":0,"stats":{"Line":20}},{"line":527,"address":[],"length":0,"stats":{"Line":42}},{"line":529,"address":[],"length":0,"stats":{"Line":3}}],"covered":206,"coverable":248},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vars","mod.rs"],"content":"//! Variable specification and metadata for templates, captures, and macros.\n//!\n//! This module defines the schema for declaring variables with:\n//! - Prompts (human-readable text shown when collecting input)\n//! - Defaults (static or computed with date math)\n//! - Required/optional status\n//!\n//! Variables can be extracted from frontmatter in templates/captures/macros.\n\npub mod datemath;\npub mod types;\n\npub use datemath::{\n    DateBase, DateExpr, DateMathError, DateOffset, Direction, DurationUnit,\n    evaluate_date_expr, is_date_expr, parse_date_expr, try_evaluate_date_expr,\n};\npub use types::{\n    VarMetadata, VarSpec, VarsMap, collect_all_variables, extract_variable_names,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vars","types.rs"],"content":"//! Variable specification types.\n\nuse serde::Deserialize;\nuse std::collections::HashMap;\n\n/// A map of variable names to their specifications.\npub type VarsMap = HashMap\u003cString, VarSpec\u003e;\n\n/// Specification for a single variable.\n///\n/// Variables can be specified in two forms in YAML:\n///\n/// Simple form (just the prompt string):\n/// ```yaml\n/// vars:\n///   title: \"Meeting title\"\n/// ```\n///\n/// Full form (with metadata):\n/// ```yaml\n/// vars:\n///   title:\n///     prompt: \"Meeting title\"\n///     required: true\n///   date:\n///     prompt: \"Meeting date\"\n///     default: \"{{today}}\"\n/// ```\n#[derive(Debug, Clone, Deserialize)]\n#[serde(untagged)]\npub enum VarSpec {\n    /// Simple form: just the prompt string\n    Simple(String),\n    /// Full form: detailed metadata\n    Full(VarMetadata),\n}\n\nimpl VarSpec {\n    /// Get the prompt text for this variable.\n    #[must_use]\n    pub fn prompt(\u0026self) -\u003e \u0026str {\n        match self {\n            VarSpec::Simple(s) =\u003e s,\n            VarSpec::Full(m) =\u003e m.prompt.as_deref().unwrap_or(\"\"),\n        }\n    }\n\n    /// Get the default value, if any.\n    #[must_use]\n    pub fn default(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match self {\n            VarSpec::Simple(_) =\u003e None,\n            VarSpec::Full(m) =\u003e m.default.as_deref(),\n        }\n    }\n\n    /// Check if this variable is required.\n    ///\n    /// A variable is required if:\n    /// - It uses the simple form (no default possible)\n    /// - It uses the full form with `required: true` or no default\n    #[must_use]\n    pub fn is_required(\u0026self) -\u003e bool {\n        match self {\n            VarSpec::Simple(_) =\u003e true,\n            VarSpec::Full(m) =\u003e m.required.unwrap_or_else(|| m.default.is_none()),\n        }\n    }\n\n    /// Get the description, if any.\n    #[must_use]\n    pub fn description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match self {\n            VarSpec::Simple(_) =\u003e None,\n            VarSpec::Full(m) =\u003e m.description.as_deref(),\n        }\n    }\n}\n\n/// Full metadata for a variable specification.\n#[derive(Debug, Clone, Default, Deserialize)]\npub struct VarMetadata {\n    /// Human-readable prompt shown when collecting input.\n    pub prompt: Option\u003cString\u003e,\n\n    /// Longer description for help text.\n    pub description: Option\u003cString\u003e,\n\n    /// Whether this variable is required.\n    /// Default: true if no default is provided.\n    pub required: Option\u003cbool\u003e,\n\n    /// Default value (static string or computed expression like \"{{today}}\").\n    pub default: Option\u003cString\u003e,\n    // Future extensions:\n    // pub options: Option\u003cVec\u003cString\u003e\u003e,  // Selection/dropdown prompt\n    // pub validate: Option\u003cString\u003e,       // Regex validation pattern\n    // pub var_type: Option\u003cVarType\u003e,      // Type hints (string, date, number)\n}\n\n/// Extract variable names from a template string.\n///\n/// Finds all `{{var_name}}` patterns and returns the unique variable names.\n/// Does not include built-in variables like `date`, `time`, `today`, etc.\npub fn extract_variable_names(template: \u0026str) -\u003e Vec\u003cString\u003e {\n    use regex::Regex;\n\n    // Built-in variables that shouldn't be prompted for\n    const BUILTINS: \u0026[\u0026str] = \u0026[\n        \"date\",\n        \"time\",\n        \"datetime\",\n        \"today\",\n        \"now\",\n        \"vault_root\",\n        \"templates_dir\",\n        \"captures_dir\",\n        \"macros_dir\",\n        \"template_name\",\n        \"template_path\",\n        \"output_path\",\n        \"output_filename\",\n        \"output_dir\",\n    ];\n\n    let re = Regex::new(r\"\\{\\{([a-zA-Z_][a-zA-Z0-9_]*)\\}\\}\").expect(\"valid regex\");\n    let mut seen = std::collections::HashSet::new();\n    let mut vars = Vec::new();\n\n    for cap in re.captures_iter(template) {\n        let name = \u0026cap[1];\n        if !BUILTINS.contains(\u0026name) \u0026\u0026 seen.insert(name.to_string()) {\n            vars.push(name.to_string());\n        }\n    }\n\n    vars\n}\n\n/// Collect all variable names needed by a template/capture.\n///\n/// Combines:\n/// - Variables declared in `vars` metadata\n/// - Variables found in template content via `{{var}}` patterns\n///\n/// Returns variable names in order: declared vars first, then extracted vars.\npub fn collect_all_variables(\n    vars_map: Option\u003c\u0026VarsMap\u003e,\n    content: \u0026str,\n) -\u003e Vec\u003c(String, Option\u003cVarSpec\u003e)\u003e {\n    let mut result = Vec::new();\n    let mut seen = std::collections::HashSet::new();\n\n    // First add declared variables (in iteration order)\n    if let Some(vars) = vars_map {\n        for (name, spec) in vars {\n            seen.insert(name.clone());\n            result.push((name.clone(), Some(spec.clone())));\n        }\n    }\n\n    // Then add any variables found in content that weren't declared\n    for name in extract_variable_names(content) {\n        if !seen.contains(\u0026name) {\n            seen.insert(name.clone());\n            result.push((name, None));\n        }\n    }\n\n    result\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_extract_variable_names() {\n        let template = \"# {{title}}\\nDate: {{date}}\\nBy: {{author}}\\n{{title}} again\";\n        let vars = extract_variable_names(template);\n        // date is a builtin, title appears twice but should be unique\n        assert_eq!(vars, vec![\"title\", \"author\"]);\n    }\n\n    #[test]\n    fn test_extract_ignores_builtins() {\n        let template = \"{{today}} {{now}} {{time}} {{custom_var}}\";\n        let vars = extract_variable_names(template);\n        assert_eq!(vars, vec![\"custom_var\"]);\n    }\n\n    #[test]\n    fn test_varspec_simple() {\n        let spec = VarSpec::Simple(\"Enter title\".to_string());\n        assert_eq!(spec.prompt(), \"Enter title\");\n        assert!(spec.default().is_none());\n        assert!(spec.is_required());\n    }\n\n    #[test]\n    fn test_varspec_full_required() {\n        let spec = VarSpec::Full(VarMetadata {\n            prompt: Some(\"Enter title\".to_string()),\n            required: Some(true),\n            ..Default::default()\n        });\n        assert_eq!(spec.prompt(), \"Enter title\");\n        assert!(spec.is_required());\n    }\n\n    #[test]\n    fn test_varspec_full_with_default() {\n        let spec = VarSpec::Full(VarMetadata {\n            prompt: Some(\"Enter date\".to_string()),\n            default: Some(\"{{today}}\".to_string()),\n            ..Default::default()\n        });\n        assert_eq!(spec.prompt(), \"Enter date\");\n        assert_eq!(spec.default(), Some(\"{{today}}\"));\n        assert!(!spec.is_required()); // has default, so not required\n    }\n\n    #[test]\n    fn test_varspec_deserialize_simple() {\n        let yaml = r#\"\"Enter your name\"\"#;\n        let spec: VarSpec = serde_yaml::from_str(yaml).unwrap();\n        assert!(matches!(spec, VarSpec::Simple(_)));\n        assert_eq!(spec.prompt(), \"Enter your name\");\n    }\n\n    #[test]\n    fn test_varspec_deserialize_full() {\n        let yaml = r#\"\nprompt: \"Enter date\"\ndefault: \"{{today}}\"\ndescription: \"The meeting date\"\n\"#;\n        let spec: VarSpec = serde_yaml::from_str(yaml).unwrap();\n        assert!(matches!(spec, VarSpec::Full(_)));\n        assert_eq!(spec.prompt(), \"Enter date\");\n        assert_eq!(spec.default(), Some(\"{{today}}\"));\n        assert_eq!(spec.description(), Some(\"The meeting date\"));\n    }\n\n    #[test]\n    fn test_collect_all_variables() {\n        let mut vars_map = VarsMap::new();\n        vars_map.insert(\"title\".to_string(), VarSpec::Simple(\"Enter title\".to_string()));\n\n        let content = \"# {{title}}\\nBy: {{author}}\";\n        let all = collect_all_variables(Some(\u0026vars_map), content);\n\n        assert_eq!(all.len(), 2);\n        assert_eq!(all[0].0, \"title\");\n        assert!(all[0].1.is_some());\n        assert_eq!(all[1].0, \"author\");\n        assert!(all[1].1.is_none()); // not declared, just extracted\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":5}},{"line":42,"address":[],"length":0,"stats":{"Line":5}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":12}},{"line":50,"address":[],"length":0,"stats":{"Line":11}},{"line":51,"address":[],"length":0,"stats":{"Line":11}},{"line":52,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":18}},{"line":63,"address":[],"length":0,"stats":{"Line":5}},{"line":64,"address":[],"length":0,"stats":{"Line":5}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":18}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":21}},{"line":126,"address":[],"length":0,"stats":{"Line":105}},{"line":127,"address":[],"length":0,"stats":{"Line":42}},{"line":128,"address":[],"length":0,"stats":{"Line":42}},{"line":130,"address":[],"length":0,"stats":{"Line":89}},{"line":131,"address":[],"length":0,"stats":{"Line":52}},{"line":132,"address":[],"length":0,"stats":{"Line":156}},{"line":133,"address":[],"length":0,"stats":{"Line":60}},{"line":137,"address":[],"length":0,"stats":{"Line":21}},{"line":147,"address":[],"length":0,"stats":{"Line":19}},{"line":151,"address":[],"length":0,"stats":{"Line":38}},{"line":152,"address":[],"length":0,"stats":{"Line":38}},{"line":155,"address":[],"length":0,"stats":{"Line":27}},{"line":156,"address":[],"length":0,"stats":{"Line":48}},{"line":157,"address":[],"length":0,"stats":{"Line":50}},{"line":158,"address":[],"length":0,"stats":{"Line":50}},{"line":163,"address":[],"length":0,"stats":{"Line":55}},{"line":164,"address":[],"length":0,"stats":{"Line":41}},{"line":165,"address":[],"length":0,"stats":{"Line":35}},{"line":166,"address":[],"length":0,"stats":{"Line":21}},{"line":170,"address":[],"length":0,"stats":{"Line":19}}],"covered":36,"coverable":37},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vault","extractor.rs"],"content":"//! Note content extraction: links, title, type, frontmatter.\n\nuse std::path::Path;\nuse std::sync::LazyLock;\n\nuse regex::Regex;\n\nuse crate::frontmatter::{self, Frontmatter};\nuse crate::index::types::{LinkType, NoteType};\n\n/// Extracted information from a note file.\n#[derive(Debug, Clone)]\npub struct ExtractedNote {\n    /// Note title (from frontmatter, first heading, or filename).\n    pub title: String,\n    /// Note type from frontmatter `type:` field.\n    pub note_type: NoteType,\n    /// Frontmatter as JSON string (if present).\n    pub frontmatter_json: Option\u003cString\u003e,\n    /// All links found in the document.\n    pub links: Vec\u003cExtractedLink\u003e,\n}\n\n/// A link extracted from a note.\n#[derive(Debug, Clone)]\npub struct ExtractedLink {\n    /// Target path/name (raw, as written in the link).\n    pub target: String,\n    /// Display text (alias for wikilinks, text for markdown links).\n    pub text: Option\u003cString\u003e,\n    /// Type of link.\n    pub link_type: LinkType,\n    /// Line number where link appears (1-based).\n    pub line_number: u32,\n    /// Context text (surrounding content).\n    pub context: Option\u003cString\u003e,\n}\n\n// Regex patterns for link extraction\nstatic WIKILINK_RE: LazyLock\u003cRegex\u003e = LazyLock::new(|| {\n    // Matches [[target]] or [[target|alias]]\n    // Also handles [[target#section]] and [[target#section|alias]]\n    Regex::new(r\"\\[\\[([^\\]|]+)(?:\\|([^\\]]+))?\\]\\]\").unwrap()\n});\n\nstatic MARKDOWN_LINK_RE: LazyLock\u003cRegex\u003e = LazyLock::new(|| {\n    // Matches [text](url) - captures .md files and relative paths\n    // Excludes http:// and https:// URLs\n    Regex::new(r\"\\[([^\\]]+)\\]\\(([^)]+)\\)\").unwrap()\n});\n\n/// Extract note information from file content.\npub fn extract_note(content: \u0026str, file_path: \u0026Path) -\u003e ExtractedNote {\n    // Parse frontmatter\n    let parsed = frontmatter::parse(content).unwrap_or_else(|_| {\n        crate::frontmatter::ParsedDocument {\n            frontmatter: None,\n            body: content.to_string(),\n        }\n    });\n\n    // Extract note type from frontmatter\n    let note_type = parsed\n        .frontmatter\n        .as_ref()\n        .and_then(|fm| fm.fields.get(\"type\"))\n        .and_then(|v| v.as_str())\n        .map(|s| s.parse().unwrap_or_default())\n        .unwrap_or_default();\n\n    // Extract title: frontmatter \u003e first heading \u003e filename\n    let title = extract_title(\u0026parsed.frontmatter, \u0026parsed.body, file_path);\n\n    // Serialize frontmatter to JSON\n    let frontmatter_json = parsed\n        .frontmatter\n        .as_ref()\n        .map(|fm| serde_json::to_string(\u0026fm.fields).unwrap_or_default());\n\n    // Extract links from body\n    let mut links = extract_links(\u0026parsed.body);\n\n    // Extract frontmatter references (project:, parent:, etc.)\n    let fm_links = extract_frontmatter_links(\u0026parsed.frontmatter);\n    links.extend(fm_links);\n\n    ExtractedNote { title, note_type, frontmatter_json, links }\n}\n\nfn extract_title(fm: \u0026Option\u003cFrontmatter\u003e, body: \u0026str, file_path: \u0026Path) -\u003e String {\n    // Try frontmatter title\n    if let Some(fm) = fm\n        \u0026\u0026 let Some(title) = fm.fields.get(\"title\").and_then(|v| v.as_str())\n    {\n        return title.to_string();\n    }\n\n    // Try first heading\n    for line in body.lines() {\n        let trimmed = line.trim();\n        if let Some(heading) = trimmed.strip_prefix('#') {\n            let heading = heading.trim_start_matches('#').trim();\n            if !heading.is_empty() {\n                return heading.to_string();\n            }\n        }\n    }\n\n    // Fall back to filename without extension\n    file_path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"Untitled\").to_string()\n}\n\nfn extract_links(body: \u0026str) -\u003e Vec\u003cExtractedLink\u003e {\n    let mut links = Vec::new();\n\n    for (line_num, line) in body.lines().enumerate() {\n        let line_number = (line_num + 1) as u32;\n\n        // Extract wikilinks\n        for cap in WIKILINK_RE.captures_iter(line) {\n            let target = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n            let alias = cap.get(2).map(|m| m.as_str().to_string());\n\n            links.push(ExtractedLink {\n                target: target.to_string(),\n                text: alias,\n                link_type: LinkType::Wikilink,\n                line_number,\n                context: Some(truncate_context(line, 100)),\n            });\n        }\n\n        // Extract markdown links to local files\n        for cap in MARKDOWN_LINK_RE.captures_iter(line) {\n            let text = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n            let url = cap.get(2).map(|m| m.as_str()).unwrap_or(\"\");\n\n            // Skip external URLs\n            if url.starts_with(\"http://\") || url.starts_with(\"https://\") {\n                continue;\n            }\n\n            // Skip non-markdown links (images, etc.) unless they're relative paths\n            if !url.ends_with(\".md\") \u0026\u0026 !is_likely_note_reference(url) {\n                continue;\n            }\n\n            links.push(ExtractedLink {\n                target: url.to_string(),\n                text: Some(text.to_string()),\n                link_type: LinkType::Markdown,\n                line_number,\n                context: Some(truncate_context(line, 100)),\n            });\n        }\n    }\n\n    links\n}\n\nfn is_likely_note_reference(url: \u0026str) -\u003e bool {\n    // Consider it a note reference if it:\n    // - Doesn't have a file extension (might be a note name)\n    // - Or ends with .md\n    // - And doesn't look like an image or other asset\n    let lower = url.to_lowercase();\n\n    // Skip obvious non-notes\n    if lower.ends_with(\".png\")\n        || lower.ends_with(\".jpg\")\n        || lower.ends_with(\".jpeg\")\n        || lower.ends_with(\".gif\")\n        || lower.ends_with(\".svg\")\n        || lower.ends_with(\".pdf\")\n    {\n        return false;\n    }\n\n    // If no extension, it might be a note reference\n    !url.contains('.')\n}\n\nfn extract_frontmatter_links(fm: \u0026Option\u003cFrontmatter\u003e) -\u003e Vec\u003cExtractedLink\u003e {\n    let mut links = Vec::new();\n\n    let fm = match fm {\n        Some(fm) =\u003e fm,\n        None =\u003e return links,\n    };\n\n    // Known reference fields\n    let ref_fields = [\"project\", \"parent\", \"related\", \"blocks\", \"blocked_by\"];\n\n    for field in \u0026ref_fields {\n        if let Some(value) = fm.fields.get(*field) {\n            // Handle single string value\n            if let Some(s) = value.as_str() {\n                links.push(ExtractedLink {\n                    target: s.to_string(),\n                    text: Some(format!(\"{}: {}\", field, s)),\n                    link_type: LinkType::Frontmatter,\n                    line_number: 0, // Frontmatter doesn't have meaningful line numbers\n                    context: None,\n                });\n            }\n            // Handle array of strings\n            if let Some(arr) = value.as_sequence() {\n                for item in arr {\n                    if let Some(s) = item.as_str() {\n                        links.push(ExtractedLink {\n                            target: s.to_string(),\n                            text: Some(format!(\"{}: {}\", field, s)),\n                            link_type: LinkType::Frontmatter,\n                            line_number: 0,\n                            context: None,\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    links\n}\n\nfn truncate_context(line: \u0026str, max_len: usize) -\u003e String {\n    if line.len() \u003c= max_len {\n        line.to_string()\n    } else {\n        format!(\"{}...\", \u0026line[..max_len])\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_extract_wikilinks() {\n        let content = r#\"---\ntitle: Test Note\n---\n# Heading\n\nThis links to [[other-note]] and [[another|with alias]].\nAlso [[path/to/note]] works.\n\"#;\n        let note = extract_note(content, Path::new(\"test.md\"));\n\n        assert_eq!(note.links.len(), 3);\n        assert_eq!(note.links[0].target, \"other-note\");\n        assert_eq!(note.links[0].text, None);\n        assert_eq!(note.links[0].link_type, LinkType::Wikilink);\n\n        assert_eq!(note.links[1].target, \"another\");\n        assert_eq!(note.links[1].text, Some(\"with alias\".to_string()));\n\n        assert_eq!(note.links[2].target, \"path/to/note\");\n    }\n\n    #[test]\n    fn test_extract_markdown_links() {\n        let content = r#\"# Note\n\nSee [this note](./other.md) for details.\nAlso [external](https://example.com) should be skipped.\nAnd [image](./pic.png) should be skipped too.\n\"#;\n        let note = extract_note(content, Path::new(\"test.md\"));\n\n        assert_eq!(note.links.len(), 1);\n        assert_eq!(note.links[0].target, \"./other.md\");\n        assert_eq!(note.links[0].text, Some(\"this note\".to_string()));\n        assert_eq!(note.links[0].link_type, LinkType::Markdown);\n    }\n\n    #[test]\n    fn test_extract_frontmatter_links() {\n        let content = r#\"---\ntitle: Task\ntype: task\nproject: my-project\nrelated:\n  - note-a\n  - note-b\n---\n# Task content\n\"#;\n        let note = extract_note(content, Path::new(\"task.md\"));\n\n        let fm_links: Vec\u003c_\u003e =\n            note.links.iter().filter(|l| l.link_type == LinkType::Frontmatter).collect();\n\n        assert_eq!(fm_links.len(), 3);\n        assert!(fm_links.iter().any(|l| l.target == \"my-project\"));\n        assert!(fm_links.iter().any(|l| l.target == \"note-a\"));\n        assert!(fm_links.iter().any(|l| l.target == \"note-b\"));\n    }\n\n    #[test]\n    fn test_extract_title_from_frontmatter() {\n        let content = r#\"---\ntitle: My Title\n---\n# Heading\n\"#;\n        let note = extract_note(content, Path::new(\"file.md\"));\n        assert_eq!(note.title, \"My Title\");\n    }\n\n    #[test]\n    fn test_extract_title_from_heading() {\n        let content = \"# First Heading\\n\\nContent here.\";\n        let note = extract_note(content, Path::new(\"file.md\"));\n        assert_eq!(note.title, \"First Heading\");\n    }\n\n    #[test]\n    fn test_extract_title_from_filename() {\n        let content = \"No frontmatter, no heading.\";\n        let note = extract_note(content, Path::new(\"my-note.md\"));\n        assert_eq!(note.title, \"my-note\");\n    }\n\n    #[test]\n    fn test_extract_note_type() {\n        let content = r#\"---\ntype: task\n---\n# Task\n\"#;\n        let note = extract_note(content, Path::new(\"task.md\"));\n        assert_eq!(note.note_type, NoteType::Task);\n    }\n\n    #[test]\n    fn test_extract_note_type_default() {\n        let content = \"# Just a note\";\n        let note = extract_note(content, Path::new(\"note.md\"));\n        assert_eq!(note.note_type, NoteType::None);\n    }\n\n    #[test]\n    fn test_line_numbers() {\n        let content = r#\"Line 1\nLine 2 with [[link1]]\nLine 3\nLine 4 with [[link2]]\n\"#;\n        let note = extract_note(content, Path::new(\"test.md\"));\n\n        assert_eq!(note.links.len(), 2);\n        assert_eq!(note.links[0].line_number, 2);\n        assert_eq!(note.links[1].line_number, 4);\n    }\n\n    #[test]\n    fn test_wikilink_with_section() {\n        let content = \"Link to [[note#section]] here.\";\n        let note = extract_note(content, Path::new(\"test.md\"));\n\n        assert_eq!(note.links.len(), 1);\n        assert_eq!(note.links[0].target, \"note#section\");\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":53}},{"line":55,"address":[],"length":0,"stats":{"Line":212}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":106}},{"line":64,"address":[],"length":0,"stats":{"Line":53}},{"line":66,"address":[],"length":0,"stats":{"Line":143}},{"line":67,"address":[],"length":0,"stats":{"Line":109}},{"line":68,"address":[],"length":0,"stats":{"Line":137}},{"line":72,"address":[],"length":0,"stats":{"Line":265}},{"line":75,"address":[],"length":0,"stats":{"Line":106}},{"line":76,"address":[],"length":0,"stats":{"Line":53}},{"line":78,"address":[],"length":0,"stats":{"Line":143}},{"line":81,"address":[],"length":0,"stats":{"Line":159}},{"line":84,"address":[],"length":0,"stats":{"Line":159}},{"line":85,"address":[],"length":0,"stats":{"Line":159}},{"line":90,"address":[],"length":0,"stats":{"Line":53}},{"line":92,"address":[],"length":0,"stats":{"Line":83}},{"line":93,"address":[],"length":0,"stats":{"Line":207}},{"line":95,"address":[],"length":0,"stats":{"Line":58}},{"line":99,"address":[],"length":0,"stats":{"Line":75}},{"line":100,"address":[],"length":0,"stats":{"Line":81}},{"line":101,"address":[],"length":0,"stats":{"Line":48}},{"line":102,"address":[],"length":0,"stats":{"Line":63}},{"line":103,"address":[],"length":0,"stats":{"Line":21}},{"line":104,"address":[],"length":0,"stats":{"Line":42}},{"line":110,"address":[],"length":0,"stats":{"Line":24}},{"line":113,"address":[],"length":0,"stats":{"Line":53}},{"line":114,"address":[],"length":0,"stats":{"Line":106}},{"line":116,"address":[],"length":0,"stats":{"Line":461}},{"line":117,"address":[],"length":0,"stats":{"Line":302}},{"line":120,"address":[],"length":0,"stats":{"Line":499}},{"line":121,"address":[],"length":0,"stats":{"Line":368}},{"line":122,"address":[],"length":0,"stats":{"Line":186}},{"line":124,"address":[],"length":0,"stats":{"Line":138}},{"line":125,"address":[],"length":0,"stats":{"Line":138}},{"line":126,"address":[],"length":0,"stats":{"Line":92}},{"line":127,"address":[],"length":0,"stats":{"Line":92}},{"line":128,"address":[],"length":0,"stats":{"Line":92}},{"line":129,"address":[],"length":0,"stats":{"Line":46}},{"line":134,"address":[],"length":0,"stats":{"Line":469}},{"line":135,"address":[],"length":0,"stats":{"Line":128}},{"line":136,"address":[],"length":0,"stats":{"Line":128}},{"line":139,"address":[],"length":0,"stats":{"Line":64}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":16}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":42}},{"line":149,"address":[],"length":0,"stats":{"Line":42}},{"line":150,"address":[],"length":0,"stats":{"Line":28}},{"line":151,"address":[],"length":0,"stats":{"Line":28}},{"line":152,"address":[],"length":0,"stats":{"Line":28}},{"line":153,"address":[],"length":0,"stats":{"Line":14}},{"line":158,"address":[],"length":0,"stats":{"Line":53}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":53}},{"line":184,"address":[],"length":0,"stats":{"Line":106}},{"line":186,"address":[],"length":0,"stats":{"Line":83}},{"line":187,"address":[],"length":0,"stats":{"Line":60}},{"line":188,"address":[],"length":0,"stats":{"Line":23}},{"line":192,"address":[],"length":0,"stats":{"Line":120}},{"line":194,"address":[],"length":0,"stats":{"Line":330}},{"line":195,"address":[],"length":0,"stats":{"Line":315}},{"line":197,"address":[],"length":0,"stats":{"Line":43}},{"line":198,"address":[],"length":0,"stats":{"Line":42}},{"line":199,"address":[],"length":0,"stats":{"Line":42}},{"line":200,"address":[],"length":0,"stats":{"Line":28}},{"line":201,"address":[],"length":0,"stats":{"Line":14}},{"line":202,"address":[],"length":0,"stats":{"Line":14}},{"line":203,"address":[],"length":0,"stats":{"Line":14}},{"line":207,"address":[],"length":0,"stats":{"Line":16}},{"line":208,"address":[],"length":0,"stats":{"Line":5}},{"line":209,"address":[],"length":0,"stats":{"Line":6}},{"line":210,"address":[],"length":0,"stats":{"Line":6}},{"line":211,"address":[],"length":0,"stats":{"Line":6}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":30}},{"line":226,"address":[],"length":0,"stats":{"Line":60}},{"line":227,"address":[],"length":0,"stats":{"Line":120}},{"line":228,"address":[],"length":0,"stats":{"Line":120}},{"line":230,"address":[],"length":0,"stats":{"Line":0}}],"covered":88,"coverable":98},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vault","hasher.rs"],"content":"//! Content hashing for change detection.\n\nuse std::fs::File;\nuse std::hash::{DefaultHasher, Hash, Hasher};\nuse std::io::{BufRead, BufReader, Result};\nuse std::path::Path;\n\n/// Compute a hash of file content for change detection.\n/// Uses DefaultHasher for speed (non-cryptographic, fast).\n/// Returns hex-encoded hash string.\npub fn content_hash(path: \u0026Path) -\u003e Result\u003cString\u003e {\n    let file = File::open(path)?;\n    let reader = BufReader::new(file);\n\n    let mut hasher = DefaultHasher::new();\n\n    for line in reader.lines() {\n        let line = line?;\n        line.hash(\u0026mut hasher);\n    }\n\n    Ok(format!(\"{:016x}\", hasher.finish()))\n}\n\n/// Compute hash from content string (for testing).\npub fn content_hash_str(content: \u0026str) -\u003e String {\n    let mut hasher = DefaultHasher::new();\n\n    for line in content.lines() {\n        line.hash(\u0026mut hasher);\n    }\n\n    format!(\"{:016x}\", hasher.finish())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_content_hash_str_consistent() {\n        let content = \"# Hello\\n\\nThis is a test.\";\n        let hash1 = content_hash_str(content);\n        let hash2 = content_hash_str(content);\n        assert_eq!(hash1, hash2);\n    }\n\n    #[test]\n    fn test_content_hash_str_different_content() {\n        let hash1 = content_hash_str(\"# Hello\");\n        let hash2 = content_hash_str(\"# World\");\n        assert_ne!(hash1, hash2);\n    }\n\n    #[test]\n    fn test_content_hash_file() {\n        let dir = TempDir::new().unwrap();\n        let path = dir.path().join(\"test.md\");\n        fs::write(\u0026path, \"# Test\\n\\nContent here.\").unwrap();\n\n        let hash = content_hash(\u0026path).unwrap();\n        assert_eq!(hash.len(), 16); // 64-bit hash as 16 hex chars\n    }\n\n    #[test]\n    fn test_content_hash_file_matches_str() {\n        let content = \"# Test\\n\\nContent here.\";\n        let dir = TempDir::new().unwrap();\n        let path = dir.path().join(\"test.md\");\n        fs::write(\u0026path, content).unwrap();\n\n        let file_hash = content_hash(\u0026path).unwrap();\n        let str_hash = content_hash_str(content);\n        assert_eq!(file_hash, str_hash);\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":62}},{"line":12,"address":[],"length":0,"stats":{"Line":186}},{"line":13,"address":[],"length":0,"stats":{"Line":186}},{"line":15,"address":[],"length":0,"stats":{"Line":124}},{"line":17,"address":[],"length":0,"stats":{"Line":468}},{"line":18,"address":[],"length":0,"stats":{"Line":688}},{"line":19,"address":[],"length":0,"stats":{"Line":1032}},{"line":22,"address":[],"length":0,"stats":{"Line":186}},{"line":26,"address":[],"length":0,"stats":{"Line":5}},{"line":27,"address":[],"length":0,"stats":{"Line":10}},{"line":29,"address":[],"length":0,"stats":{"Line":32}},{"line":30,"address":[],"length":0,"stats":{"Line":22}},{"line":33,"address":[],"length":0,"stats":{"Line":20}}],"covered":13,"coverable":13},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vault","mod.rs"],"content":"//! Vault file discovery and content extraction.\n//!\n//! This module provides utilities for walking vault directories,\n//! extracting metadata from markdown files, and computing content hashes.\n\npub mod extractor;\npub mod hasher;\npub mod walker;\n\npub use extractor::{ExtractedLink, ExtractedNote, extract_note};\npub use hasher::{content_hash, content_hash_str};\npub use walker::{VaultWalker, VaultWalkerError, WalkedFile};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","src","vault","walker.rs"],"content":"//! Recursive vault directory walker.\n\nuse std::path::{Path, PathBuf};\nuse std::time::SystemTime;\nuse thiserror::Error;\nuse walkdir::WalkDir;\n\n#[derive(Debug, Error)]\npub enum VaultWalkerError {\n    #[error(\"vault root does not exist: {0}\")]\n    MissingRoot(String),\n\n    #[error(\"failed to walk vault directory {0}: {1}\")]\n    WalkError(String, #[source] walkdir::Error),\n\n    #[error(\"failed to read file metadata {0}: {1}\")]\n    MetadataError(String, #[source] std::io::Error),\n}\n\n/// Information about a discovered markdown file.\n#[derive(Debug, Clone)]\npub struct WalkedFile {\n    /// Absolute path to the file.\n    pub absolute_path: PathBuf,\n    /// Path relative to vault root.\n    pub relative_path: PathBuf,\n    /// File modification time.\n    pub modified: SystemTime,\n    /// File size in bytes.\n    pub size: u64,\n}\n\n/// Walker for discovering markdown files in a vault.\n#[derive(Debug)]\npub struct VaultWalker {\n    root: PathBuf,\n}\n\nimpl VaultWalker {\n    /// Create a new walker for the given vault root.\n    pub fn new(root: \u0026Path) -\u003e Result\u003cSelf, VaultWalkerError\u003e {\n        let root = root\n            .canonicalize()\n            .map_err(|_| VaultWalkerError::MissingRoot(root.display().to_string()))?;\n\n        if !root.exists() {\n            return Err(VaultWalkerError::MissingRoot(root.display().to_string()));\n        }\n\n        Ok(Self { root })\n    }\n\n    /// Walk the vault and return all markdown files.\n    /// Excludes hidden directories and common non-vault directories.\n    pub fn walk(\u0026self) -\u003e Result\u003cVec\u003cWalkedFile\u003e, VaultWalkerError\u003e {\n        let mut files = Vec::new();\n\n        for entry in WalkDir::new(\u0026self.root)\n            .follow_links(false)\n            .into_iter()\n            .filter_entry(|e| !is_hidden_or_ignored(e))\n        {\n            let entry = entry.map_err(|e| {\n                VaultWalkerError::WalkError(self.root.display().to_string(), e)\n            })?;\n\n            let path = entry.path();\n            if !path.is_file() || !is_markdown_file(path) {\n                continue;\n            }\n\n            let metadata = path.metadata().map_err(|e| {\n                VaultWalkerError::MetadataError(path.display().to_string(), e)\n            })?;\n\n            let relative_path =\n                path.strip_prefix(\u0026self.root).unwrap_or(path).to_path_buf();\n\n            files.push(WalkedFile {\n                absolute_path: path.to_path_buf(),\n                relative_path,\n                modified: metadata.modified().unwrap_or(std::time::UNIX_EPOCH),\n                size: metadata.len(),\n            });\n        }\n\n        files.sort_by(|a, b| a.relative_path.cmp(\u0026b.relative_path));\n        Ok(files)\n    }\n\n    /// Get the vault root path.\n    pub fn root(\u0026self) -\u003e \u0026Path {\n        \u0026self.root\n    }\n}\n\nfn is_markdown_file(path: \u0026Path) -\u003e bool {\n    path.extension().and_then(|e| e.to_str()).is_some_and(|e| e == \"md\")\n}\n\nfn is_hidden_or_ignored(entry: \u0026walkdir::DirEntry) -\u003e bool {\n    // Never filter the root directory (depth 0)\n    if entry.depth() == 0 {\n        return false;\n    }\n\n    let name = entry.file_name().to_string_lossy();\n\n    // Skip hidden files and directories\n    if name.starts_with('.') {\n        return true;\n    }\n\n    // Skip common non-vault directories\n    matches!(name.as_ref(), \"node_modules\" | \"target\" | \"__pycache__\" | \"venv\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    fn create_test_vault() -\u003e TempDir {\n        let dir = TempDir::new().unwrap();\n        let root = dir.path();\n\n        // Create some markdown files\n        fs::write(root.join(\"note1.md\"), \"# Note 1\").unwrap();\n        fs::write(root.join(\"note2.md\"), \"# Note 2\").unwrap();\n\n        // Create subdirectory with notes\n        fs::create_dir(root.join(\"subdir\")).unwrap();\n        fs::write(root.join(\"subdir/note3.md\"), \"# Note 3\").unwrap();\n\n        // Create hidden directory (should be skipped)\n        fs::create_dir(root.join(\".hidden\")).unwrap();\n        fs::write(root.join(\".hidden/secret.md\"), \"# Secret\").unwrap();\n\n        // Create non-markdown file (should be skipped)\n        fs::write(root.join(\"readme.txt\"), \"Not markdown\").unwrap();\n\n        dir\n    }\n\n    #[test]\n    fn test_walk_finds_markdown_files() {\n        let vault = create_test_vault();\n        let walker = VaultWalker::new(vault.path()).unwrap();\n        let files = walker.walk().unwrap();\n\n        assert_eq!(files.len(), 3);\n\n        let paths: Vec\u003c_\u003e = files.iter().map(|f| f.relative_path.clone()).collect();\n        assert!(paths.contains(\u0026PathBuf::from(\"note1.md\")));\n        assert!(paths.contains(\u0026PathBuf::from(\"note2.md\")));\n        assert!(paths.contains(\u0026PathBuf::from(\"subdir/note3.md\")));\n    }\n\n    #[test]\n    fn test_walk_skips_hidden_directories() {\n        let vault = create_test_vault();\n        let walker = VaultWalker::new(vault.path()).unwrap();\n        let files = walker.walk().unwrap();\n\n        let paths: Vec\u003c_\u003e =\n            files.iter().map(|f| f.relative_path.to_string_lossy().to_string()).collect();\n\n        assert!(!paths.iter().any(|p| p.contains(\".hidden\")));\n    }\n\n    #[test]\n    fn test_walk_skips_non_markdown() {\n        let vault = create_test_vault();\n        let walker = VaultWalker::new(vault.path()).unwrap();\n        let files = walker.walk().unwrap();\n\n        let paths: Vec\u003c_\u003e =\n            files.iter().map(|f| f.relative_path.to_string_lossy().to_string()).collect();\n\n        assert!(!paths.iter().any(|p| p.contains(\"readme.txt\")));\n    }\n\n    #[test]\n    fn test_walk_results_sorted() {\n        let vault = create_test_vault();\n        let walker = VaultWalker::new(vault.path()).unwrap();\n        let files = walker.walk().unwrap();\n\n        let paths: Vec\u003c_\u003e = files.iter().map(|f| \u0026f.relative_path).collect();\n        let mut sorted = paths.clone();\n        sorted.sort();\n\n        assert_eq!(paths, sorted);\n    }\n\n    #[test]\n    fn test_missing_root() {\n        let result = VaultWalker::new(Path::new(\"/nonexistent/path\"));\n        assert!(result.is_err());\n        assert!(matches!(result.unwrap_err(), VaultWalkerError::MissingRoot(_)));\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":24}},{"line":42,"address":[],"length":0,"stats":{"Line":47}},{"line":44,"address":[],"length":0,"stats":{"Line":27}},{"line":46,"address":[],"length":0,"stats":{"Line":23}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":23}},{"line":55,"address":[],"length":0,"stats":{"Line":23}},{"line":56,"address":[],"length":0,"stats":{"Line":46}},{"line":58,"address":[],"length":0,"stats":{"Line":166}},{"line":59,"address":[],"length":0,"stats":{"Line":23}},{"line":60,"address":[],"length":0,"stats":{"Line":23}},{"line":61,"address":[],"length":0,"stats":{"Line":271}},{"line":63,"address":[],"length":0,"stats":{"Line":360}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":360}},{"line":68,"address":[],"length":0,"stats":{"Line":194}},{"line":69,"address":[],"length":0,"stats":{"Line":50}},{"line":72,"address":[],"length":0,"stats":{"Line":280}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":70}},{"line":77,"address":[],"length":0,"stats":{"Line":350}},{"line":79,"address":[],"length":0,"stats":{"Line":210}},{"line":80,"address":[],"length":0,"stats":{"Line":210}},{"line":81,"address":[],"length":0,"stats":{"Line":140}},{"line":82,"address":[],"length":0,"stats":{"Line":280}},{"line":83,"address":[],"length":0,"stats":{"Line":70}},{"line":87,"address":[],"length":0,"stats":{"Line":259}},{"line":88,"address":[],"length":0,"stats":{"Line":23}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":74}},{"line":98,"address":[],"length":0,"stats":{"Line":592}},{"line":101,"address":[],"length":0,"stats":{"Line":124}},{"line":103,"address":[],"length":0,"stats":{"Line":124}},{"line":104,"address":[],"length":0,"stats":{"Line":23}},{"line":107,"address":[],"length":0,"stats":{"Line":303}},{"line":110,"address":[],"length":0,"stats":{"Line":101}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":485}}],"covered":34,"coverable":39},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","config_loader_errors.rs"],"content":"use mdvault_core::config::loader::{ConfigError, ConfigLoader};\nuse std::fs;\nuse std::path::PathBuf;\nuse tempfile::tempdir;\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn missing_file_fails() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"nope/config.toml\");\n    let err = ConfigLoader::load(Some(\u0026cfg_path), None).unwrap_err();\n    match err {\n        ConfigError::NotFound(_) =\u003e {}\n        other =\u003e panic!(\"expected NotFound, got {other:?}\"),\n    }\n}\n\n#[test]\nfn bad_version_fails() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"config.toml\");\n    write_file(\u0026cfg_path, \"version = 2\\nprofiles = {}\\n\");\n\n    let err = ConfigLoader::load(Some(\u0026cfg_path), None).unwrap_err();\n    match err {\n        ConfigError::BadVersion(2) =\u003e {}\n        other =\u003e panic!(\"expected BadVersion(2), got {other:?}\"),\n    }\n}\n\n#[test]\nfn no_profiles_fails() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"config.toml\");\n    write_file(\u0026cfg_path, \"version = 1\\nprofiles = {}\\n\");\n\n    let err = ConfigLoader::load(Some(\u0026cfg_path), None).unwrap_err();\n    match err {\n        ConfigError::NoProfiles =\u003e {}\n        other =\u003e panic!(\"expected NoProfiles, got {other:?}\"),\n    }\n}\n\n#[test]\nfn profile_not_found_fails() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"config.toml\");\n    let toml = r#\"\nversion = 1\nprofile = \"default\"\n[profiles.default]\nvault_root = \"/tmp/vault\"\ntemplates_dir = \"{{vault_root}}/tpl\"\ncaptures_dir  = \"{{vault_root}}/cap\"\nmacros_dir    = \"{{vault_root}}/mac\"\n\"#;\n    write_file(\u0026cfg_path, toml);\n\n    let err = ConfigLoader::load(Some(\u0026cfg_path), Some(\"missing\")).unwrap_err();\n    match err {\n        ConfigError::ProfileNotFound(p) if p == \"missing\" =\u003e {}\n        other =\u003e panic!(\"expected ProfileNotFound(\\\"missing\\\"), got {other:?}\"),\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":3}},{"line":7,"address":[],"length":0,"stats":{"Line":9}},{"line":8,"address":[],"length":0,"stats":{"Line":6}},{"line":10,"address":[],"length":0,"stats":{"Line":12}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","config_loader_ok.rs"],"content":"use mdvault_core::config::loader::ConfigLoader;\nuse std::fs;\nuse std::path::PathBuf;\nuse tempfile::tempdir;\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn load_default_profile_ok() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"config.toml\");\n    let toml = r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"/tmp/vault\"\ntemplates_dir = \"{{vault_root}}/.markadd/templates\"\ncaptures_dir  = \"{{vault_root}}/.markadd/captures\"\nmacros_dir    = \"{{vault_root}}/.markadd/macros\"\n\n[security]\nallow_shell = false\nallow_http  = true\n\"#;\n\n    write_file(\u0026cfg_path, toml);\n\n    let rc = ConfigLoader::load(Some(\u0026cfg_path), None).expect(\"should load\");\n    assert_eq!(rc.active_profile, \"default\");\n    assert_eq!(rc.vault_root.display().to_string(), \"/tmp/vault\");\n    assert!(rc.templates_dir.ends_with(\".markadd/templates\"));\n    assert!(rc.captures_dir.ends_with(\".markadd/captures\"));\n    assert!(rc.macros_dir.ends_with(\".markadd/macros\"));\n    assert!(!rc.security.allow_shell);\n    assert!(rc.security.allow_http);\n}\n\n#[test]\nfn load_with_profile_override_ok() {\n    let tmp = tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"markadd/config.toml\");\n    let toml = r#\"\nversion = 1\nprofile = \"default\"\n\n[profiles.default]\nvault_root = \"/tmp/def\"\ntemplates_dir = \"{{vault_root}}/tpl\"\ncaptures_dir  = \"{{vault_root}}/cap\"\nmacros_dir    = \"{{vault_root}}/mac\"\n\n[profiles.work]\nvault_root = \"/tmp/work\"\ntemplates_dir = \"{{vault_root}}/tpl\"\ncaptures_dir  = \"{{vault_root}}/cap\"\nmacros_dir    = \"{{vault_root}}/mac\"\n\"#;\n    write_file(\u0026cfg_path, toml);\n\n    let rc = ConfigLoader::load(Some(\u0026cfg_path), Some(\"work\")).expect(\"should load\");\n    assert_eq!(rc.active_profile, \"work\");\n    assert_eq!(rc.vault_root.display().to_string(), \"/tmp/work\");\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":2}},{"line":7,"address":[],"length":0,"stats":{"Line":6}},{"line":8,"address":[],"length":0,"stats":{"Line":4}},{"line":10,"address":[],"length":0,"stats":{"Line":8}}],"covered":4,"coverable":4},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","doctor_snapshot.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","markdown_ast_golden.rs"],"content":"use insta::assert_snapshot;\nuse mdvault_core::markdown_ast::{InsertPosition, MarkdownEditor, SectionMatch};\n\n#[test]\nfn golden_changelog_insert_unreleased_begin() {\n    let input = include_str!(\"fixtures/changelog_simple.md\");\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Unreleased\"),\n        \"### Added\\n\\n- New feature from test\\n\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    assert_snapshot!(result.content);\n}\n\n#[test]\nfn golden_changelog_insert_added_end() {\n    let input = include_str!(\"fixtures/changelog_simple.md\");\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Added\"),\n        \"- Another new feature\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    assert_snapshot!(result.content);\n}\n\n#[test]\nfn golden_complex_document_preserves_formatting() {\n    let input = include_str!(\"fixtures/changelog_complex.md\");\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Added\"),\n        \"- Complex item with `code` and **bold**\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    assert_snapshot!(result.content);\n}\n\n#[test]\nfn golden_insert_into_changed_with_code_block() {\n    let input = include_str!(\"fixtures/changelog_complex.md\");\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Changed\"),\n        \"- New change entry\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    assert_snapshot!(result.content);\n}\n\n#[test]\nfn golden_find_headings_complex() {\n    let input = include_str!(\"fixtures/changelog_complex.md\");\n\n    let headings = MarkdownEditor::find_headings(input);\n    let headings_str: Vec\u003cString\u003e =\n        headings.iter().map(|h| format!(\"L{}: {}\", h.level, h.title)).collect();\n\n    assert_snapshot!(headings_str.join(\"\\n\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","markdown_ast_insert.rs"],"content":"use mdvault_core::markdown_ast::{\n    InsertPosition, MarkdownAstError, MarkdownEditor, SectionMatch,\n};\n\n// === Basic insertion tests ===\n\n#[test]\nfn insert_at_begin_of_section() {\n    let input = r#\"# Changelog\n\n## Unreleased\n\n### Added\n\n- Feature A\n\n## 1.0.0\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Added\"),\n        \"- Feature B\\n\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    // Feature B should appear before Feature A\n    let feature_b_pos = result.content.find(\"Feature B\").unwrap();\n    let feature_a_pos = result.content.find(\"Feature A\").unwrap();\n    assert!(feature_b_pos \u003c feature_a_pos);\n}\n\n#[test]\nfn insert_at_end_of_section() {\n    let input = r#\"# Inbox\n\n- Task 1\n- Task 2\n\n# Done\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Inbox\"),\n        \"- Task 3\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // Task 3 should appear after Task 2 but before Done\n    let task2_pos = result.content.find(\"Task 2\").unwrap();\n    let task3_pos = result.content.find(\"Task 3\").unwrap();\n    let done_pos = result.content.find(\"# Done\").unwrap();\n    assert!(task2_pos \u003c task3_pos);\n    assert!(task3_pos \u003c done_pos);\n}\n\n// === Section matching tests ===\n\n#[test]\nfn case_insensitive_match_default() {\n    let input = \"# INBOX\\n\\nContent\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"inbox\"),\n        \"New item\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(result.is_ok());\n}\n\n#[test]\nfn case_sensitive_match_fails_when_case_differs() {\n    let input = \"# INBOX\\n\\nContent\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"inbox\").case_sensitive(true),\n        \"New item\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(matches!(result, Err(MarkdownAstError::SectionNotFound(_))));\n}\n\n#[test]\nfn case_sensitive_match_succeeds_when_case_matches() {\n    let input = \"# INBOX\\n\\nContent\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"INBOX\").case_sensitive(true),\n        \"New item\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(result.is_ok());\n}\n\n#[test]\nfn trimmed_title_matching() {\n    let input = \"# Inbox   \\n\\nContent\\n\"; // Trailing spaces in heading\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Inbox\"),\n        \"New\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(result.is_ok());\n}\n\n// === Edge cases ===\n\n#[test]\nfn section_not_found_error() {\n    let input = \"# Existing\\n\\nContent\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"NonExistent\"),\n        \"Fragment\\n\",\n        InsertPosition::Begin,\n    );\n\n    match result {\n        Err(MarkdownAstError::SectionNotFound(s)) =\u003e assert_eq!(s, \"NonExistent\"),\n        _ =\u003e panic!(\"Expected SectionNotFound error\"),\n    }\n}\n\n#[test]\nfn empty_document_error() {\n    let result = MarkdownEditor::insert_into_section(\n        \"\",\n        \u0026SectionMatch::new(\"Any\"),\n        \"Fragment\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(matches!(result, Err(MarkdownAstError::EmptyDocument)));\n}\n\n#[test]\nfn whitespace_only_document_error() {\n    let result = MarkdownEditor::insert_into_section(\n        \"   \\n\\n   \",\n        \u0026SectionMatch::new(\"Any\"),\n        \"Fragment\\n\",\n        InsertPosition::Begin,\n    );\n\n    assert!(matches!(result, Err(MarkdownAstError::EmptyDocument)));\n}\n\n#[test]\nfn empty_fragment_is_noop() {\n    let input = \"# Section\\n\\nOriginal\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Section\"),\n        \"\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    // Content should be unchanged\n    assert!(result.content.contains(\"Original\"));\n}\n\n#[test]\nfn code_block_with_hash_not_matched_as_heading() {\n    let input = r#\"# Real Heading\n\n```bash\n# This is a comment, not a heading\necho \"hello\"\n```\n\n# Another Heading\n\"#;\n\n    let headings = MarkdownEditor::find_headings(input);\n    assert_eq!(headings.len(), 2);\n    assert_eq!(headings[0].title, \"Real Heading\");\n    assert_eq!(headings[1].title, \"Another Heading\");\n}\n\n#[test]\nfn last_section_extends_to_eof() {\n    let input = \"# Only Section\\n\\nLine 1\\n\\nLine 2\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Only Section\"),\n        \"New line\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // New line should appear after Line 2\n    let line2_pos = result.content.find(\"Line 2\").unwrap();\n    let newline_pos = result.content.find(\"New line\").unwrap();\n    assert!(newline_pos \u003e line2_pos);\n}\n\n#[test]\nfn insert_into_empty_section() {\n    let input = \"# Empty Section\\n\\n# Next Section\\n\\nContent\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Empty Section\"),\n        \"New content\\n\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    // New content should appear after Empty Section but before Next Section\n    let empty_section_pos = result.content.find(\"# Empty Section\").unwrap();\n    let new_content_pos = result.content.find(\"New content\").unwrap();\n    let next_section_pos = result.content.find(\"# Next Section\").unwrap();\n    assert!(new_content_pos \u003e empty_section_pos);\n    assert!(new_content_pos \u003c next_section_pos);\n}\n\n#[test]\nfn nested_sections_respects_level() {\n    let input = r#\"# Level 1\n\n## Level 2 A\n\nContent A\n\n### Level 3\n\nDeep content\n\n## Level 2 B\n\nContent B\n\"#;\n\n    // Insert into Level 2 A - should only affect until Level 2 B\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Level 2 A\"),\n        \"New A content\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // Verify insertion is before \"## Level 2 B\"\n    let level2b_pos = result.content.find(\"## Level 2 B\").unwrap();\n    let new_content_pos = result.content.find(\"New A content\").unwrap();\n    assert!(new_content_pos \u003c level2b_pos);\n}\n\n#[test]\nfn multiple_same_name_sections_matches_first() {\n    let input = r#\"# Inbox\n\nFirst inbox content\n\n# Other\n\n# Inbox\n\nSecond inbox content\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Inbox\"),\n        \"New item\\n\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    // Should insert after FIRST \"# Inbox\"\n    let first_inbox = result.content.find(\"# Inbox\").unwrap();\n    let new_item = result.content.find(\"New item\").unwrap();\n\n    // Find second inbox after the first\n    let after_first = \u0026result.content[first_inbox + 7..];\n    let second_inbox = after_first.find(\"# Inbox\").unwrap() + first_inbox + 7;\n\n    assert!(new_item \u003e first_inbox \u0026\u0026 new_item \u003c second_inbox);\n}\n\n// === find_headings tests ===\n\n#[test]\nfn find_headings_returns_all_levels() {\n    let input = r#\"# H1\n\n## H2\n\n### H3\n\n#### H4\n\n##### H5\n\n###### H6\n\"#;\n\n    let headings = MarkdownEditor::find_headings(input);\n    assert_eq!(headings.len(), 6);\n    assert_eq!(headings[0].level, 1);\n    assert_eq!(headings[1].level, 2);\n    assert_eq!(headings[2].level, 3);\n    assert_eq!(headings[3].level, 4);\n    assert_eq!(headings[4].level, 5);\n    assert_eq!(headings[5].level, 6);\n}\n\n#[test]\nfn find_headings_preserves_order() {\n    let input = r#\"# First\n\n## Second\n\n# Third\n\"#;\n\n    let headings = MarkdownEditor::find_headings(input);\n    assert_eq!(headings.len(), 3);\n    assert_eq!(headings[0].title, \"First\");\n    assert_eq!(headings[1].title, \"Second\");\n    assert_eq!(headings[2].title, \"Third\");\n}\n\n// === section_exists tests ===\n\n#[test]\nfn section_exists_returns_true_for_existing() {\n    let input = \"# Existing\\n\\nContent\\n\";\n    assert!(MarkdownEditor::section_exists(input, \u0026SectionMatch::new(\"Existing\")));\n}\n\n#[test]\nfn section_exists_returns_false_for_missing() {\n    let input = \"# Existing\\n\\nContent\\n\";\n    assert!(!MarkdownEditor::section_exists(input, \u0026SectionMatch::new(\"Missing\")));\n}\n\n// === Setext headings ===\n\n#[test]\nfn setext_headings_level_1() {\n    let input = r#\"Main Title\n===========\n\nContent under main.\n\"#;\n\n    let headings = MarkdownEditor::find_headings(input);\n    assert_eq!(headings.len(), 1);\n    assert_eq!(headings[0].title, \"Main Title\");\n    assert_eq!(headings[0].level, 1);\n}\n\n#[test]\nfn setext_headings_level_2() {\n    let input = r#\"Subtitle\n--------\n\nSubtitle content.\n\"#;\n\n    let headings = MarkdownEditor::find_headings(input);\n    assert_eq!(headings.len(), 1);\n    assert_eq!(headings[0].title, \"Subtitle\");\n    assert_eq!(headings[0].level, 2);\n}\n\n#[test]\nfn insert_into_setext_heading() {\n    let input = r#\"My Section\n===========\n\nOriginal content.\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"My Section\"),\n        \"New content\\n\",\n        InsertPosition::Begin,\n    )\n    .unwrap();\n\n    assert!(result.content.contains(\"New content\"));\n}\n\n// === Wikilinks and special character preservation ===\n\n#[test]\nfn preserves_wikilinks_in_existing_content() {\n    let input = r#\"# Notes\n\n- [[wikilink]]\n- [[page#section]]\n- Regular text\n\n# Other\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Notes\"),\n        \"- New item\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // Wikilinks should NOT be escaped\n    assert!(\n        result.content.contains(\"[[wikilink]]\"),\n        \"Wikilinks should be preserved, got: {}\",\n        result.content\n    );\n    assert!(\n        result.content.contains(\"[[page#section]]\"),\n        \"Wikilinks with sections should be preserved, got: {}\",\n        result.content\n    );\n}\n\n#[test]\nfn preserves_wikilinks_in_inserted_content() {\n    let input = r#\"# Notes\n\n- Existing item\n\n# Other\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Notes\"),\n        \"- [[new wikilink]]\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // Inserted wikilinks should NOT be escaped\n    assert!(\n        result.content.contains(\"[[new wikilink]]\"),\n        \"Inserted wikilinks should be preserved, got: {}\",\n        result.content\n    );\n}\n\n// === Blank line handling tests ===\n\n#[test]\nfn insert_at_end_preserves_section_separator() {\n    // This is the exact case from the user report:\n    // When inserting at end of section 1, the new text should appear\n    // after existing content, with the blank line separator maintained\n    // between sections.\n    let input = r#\"# section 1\n- content1\n- other content\n\n# another section\n- more text\n\"#;\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"section 1\"),\n        \"- new text\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // Expected output:\n    // # section 1\n    // - content1\n    // - other content\n    // - new text\n    //\n    // # another section\n    // - more text\n\n    let expected = r#\"# section 1\n- content1\n- other content\n- new text\n\n# another section\n- more text\n\"#;\n\n    assert_eq!(\n        result.content, expected,\n        \"\\nExpected:\\n{}\\n\\nGot:\\n{}\\n\",\n        expected, result.content\n    );\n}\n\n#[test]\nfn insert_at_end_with_multiple_blank_lines() {\n    // Multiple blank lines should be normalized to one\n    let input = \"# Section\\n- item1\\n\\n\\n\\n# Next\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Section\"),\n        \"- item2\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    // New item should be right after item1, with one blank line before Next\n    assert!(result.content.contains(\"- item1\\n- item2\\n\"));\n    assert!(result.content.contains(\"\\n\\n# Next\"));\n}\n\n#[test]\nfn insert_at_end_of_last_section_no_trailing_blank() {\n    // Last section shouldn't add extra blank lines at EOF\n    let input = \"# Only Section\\n- item1\\n\";\n\n    let result = MarkdownEditor::insert_into_section(\n        input,\n        \u0026SectionMatch::new(\"Only Section\"),\n        \"- item2\\n\",\n        InsertPosition::End,\n    )\n    .unwrap();\n\n    assert_eq!(result.content, \"# Only Section\\n- item1\\n- item2\\n\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","template_engine.rs"],"content":"use mdvault_core::templates::engine::{RenderContext, render};\nuse mdvault_core::templates::repository::LoadedTemplate;\nuse std::path::PathBuf;\n\nfn loaded(contents: \u0026str) -\u003e LoadedTemplate {\n    LoadedTemplate {\n        logical_name: \"test\".into(),\n        path: PathBuf::from(\"test.md\"),\n        content: contents.to_string(),\n        frontmatter: None,\n        body: contents.to_string(),\n    }\n}\n\n#[test]\nfn render_replaces_known_variables() {\n    let tpl = loaded(\"Hello {{name}}!\");\n    let mut ctx = RenderContext::new();\n    ctx.insert(\"name\".into(), \"Agustin\".into());\n\n    let out = render(\u0026tpl, \u0026ctx).expect(\"render ok\");\n    assert_eq!(out, \"Hello Agustin!\");\n}\n\n#[test]\nfn render_leaves_unknown_variables_intact() {\n    let tpl = loaded(\"Hello {{name}} and {{unknown}}!\");\n    let mut ctx = RenderContext::new();\n    ctx.insert(\"name\".into(), \"Agustin\".into());\n\n    let out = render(\u0026tpl, \u0026ctx).expect(\"render ok\");\n    assert_eq!(out, \"Hello Agustin and {{unknown}}!\");\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":2}},{"line":7,"address":[],"length":0,"stats":{"Line":6}},{"line":8,"address":[],"length":0,"stats":{"Line":4}},{"line":9,"address":[],"length":0,"stats":{"Line":6}},{"line":11,"address":[],"length":0,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","Users","eaguval","repositories","personal","mdvault","crates","core","tests","templates_discovery.rs"],"content":"use mdvault_core::templates::discovery::discover_templates;\nuse std::fs;\nuse std::path::PathBuf;\nuse tempfile::tempdir;\n\nfn write(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).unwrap();\n    }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn discovers_only_md_templates() {\n    let tmp = tempdir().unwrap();\n    let root = tmp.path().join(\"tpl\");\n\n    let a = root.join(\"daily.md\");\n    let b = root.join(\"blog\").join(\"post.md\");\n    let ignored1 = root.join(\"wiki\").join(\"topic.markdown\");\n    let ignored2 = root.join(\"weird.tpl.md\");\n    let ignored3 = root.join(\"note.txt\");\n\n    write(\u0026a, \"# daily\");\n    write(\u0026b, \"# blog\");\n    write(\u0026ignored1, \"# nope\");\n    write(\u0026ignored2, \"# nope\");\n    write(\u0026ignored3, \"# nope\");\n\n    let got = discover_templates(\u0026root).expect(\"discover ok\");\n    let names: Vec\u003cString\u003e = got.into_iter().map(|t| t.logical_name).collect();\n\n    assert_eq!(names, vec![\"blog/post\".to_string(), \"daily\".to_string(),]);\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":5}},{"line":7,"address":[],"length":0,"stats":{"Line":15}},{"line":8,"address":[],"length":0,"stats":{"Line":10}},{"line":10,"address":[],"length":0,"stats":{"Line":20}}],"covered":4,"coverable":4}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      const nbHit = covered? trace.stats.Line: 0;
      return e(
        'div',
        { className: 'code-text-container' },
        e(
          'code',
          {
            className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          },
          line
        ),
        e(
          'div',
          { className: 'cover-indicator' + (covered? ' check-cover': '') + (uncovered? ' no-cover': '')},
          e(
            'div',
            { className: (covered? 'stat-line-hit': '')},
            covered? nbHit: ""
          )
        )
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>